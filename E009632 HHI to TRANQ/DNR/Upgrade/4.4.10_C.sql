SET NOCOUNT ON
GO

SET DEADLOCK_PRIORITY HIGH
GO


insert into upload_tracking (script, timestamp, upload) values ('UPLOAD_START',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/01_Triggers/tp_facility_medical_attestation_upd.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*
 * Written By:	Jarek Zawojski
 * Reviewed By:
 *
 * Script Type: DDL
 * Target DB Type: client
 * Target Database: BOTH (US/CA)
 *
 * Script creates a trigger to prevent updating records in facility_medical_attestation table, other than active from 1 to 0
 *
 */

CREATE OR ALTER TRIGGER [dbo].[tp_facility_medical_attestation_upd]
    ON [dbo].[facility_medical_attestation]
    AFTER UPDATE
                              AS
BEGIN
    IF NOT EXISTS(
        SELECT null
        FROM Deleted as del
        WHERE del.active = 1
              AND EXISTS (
                  SELECT del.fac_id,
                         del.ctrl_medication_value,
                         del.non_ctrl_medication_value,
                         del.created_by,
                         del.created_date,
                         del.mandate_qty_disp_ctrl_medication
                  INTERSECT
                  SELECT ins.fac_id,
                         ins.ctrl_medication_value,
                         ins.non_ctrl_medication_value,
                         ins.created_by,
                         ins.created_date,
                         ins.mandate_qty_disp_ctrl_medication
                  FROM Inserted as ins
                  WHERE ins.facility_medical_attestation_id = del.facility_medical_attestation_id
            )

        )
BEGIN
        RAISERROR('Updating only allowed on [active] from 1 to 0.', 16, 10);
ROLLBACK;
END
END;

GO

print 'C_Branch/01_Triggers/tp_facility_medical_attestation_upd.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/01_Triggers/tp_facility_medical_attestation_upd.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/01_Triggers/tp_pho_phys_order_new_entry_ins.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*****************************************************************************************************
**  Created By:Maciek Sliwa
**  Created Date: 09/08/2011
**
**  Purpose: This trigger updates the pho_phys_order_new_entry table whenever a new phys order is created a
**           and multiple schedules option is turned on
**           Also for the verbal and telephone orders it will create an order to sign record if the feature is enabled
**
Revision History:
2014-06-04  Mike Gillan  Added order_type_id to pho_order_schedule due to PCC-57494

2018-10-17 Assigned CONTEXT_INFO() changes for Data Service EI Process
		   Code 0xDC1000000 will set Context Infor from Data Service Delete/Insert transaction
*****************************************************************************************************/
if exists (select name from sysobjects where name = 'tp_pho_phys_order_new_entry_ins')
begin
    drop trigger tp_pho_phys_order_new_entry_ins
end
GO
     
CREATE TRIGGER tp_pho_phys_order_new_entry_ins ON dbo.pho_phys_order FOR INSERT NOT FOR REPLICATION
 
AS
BEGIN

	IF CONTEXT_INFO() = 0xDC1000000 RETURN
	   
	SET NOCOUNT ON
 
	declare @facId int;
	declare @communicationMethod int;
	declare @orderSignatureEnabledDate datetime;
	declare @ePrescribeEnabled varchar(50);
	declare @country_id int;
	declare @categoryId int;

	select @facId = i.fac_id, @communicationMethod = i.communication_method, @country_id = f.country_id, @categoryId = order_category_id from inserted i inner join facility f on f.fac_id = i.fac_id;


	IF(1 = dbo.fn_get_new_phys_order_entry_parameter(@facId)) -- means configuration is turned on
	BEGIN
		insert into dbo.pho_phys_order_new_entry (phys_order_id)
		select phys_order_id
		from inserted

		-- IF The order signature is enabled, then check for the order communication method, and create a order to sign record if it is verbal or telephone
		SELECT @orderSignatureEnabledDate=CONVERT(datetime,cp.value) FROM dbo.configuration_parameter cp WHERE cp.name = 'order_sign_enable_date' AND cp.fac_id = @facId;
		SELECT @ePrescribeEnabled=cp.value FROM dbo.configuration_parameter cp WHERE cp.name = 'enable_eprescribe_workflow' AND cp.fac_id = @facId;
		IF @ePrescribeEnabled IS NULL
		BEGIN
		   SET @ePrescribeEnabled = 'N';
		END

		IF (@orderSignatureEnabledDate < getdate())
		BEGIN
			IF ( @communicationMethod in (3025,3026) or (@communicationMethod = 2141 and (@ePrescribeEnabled='N' or @categoryId=3030) ) )
			BEGIN
				insert into dbo.pho_phys_order_to_sign (phys_order_id, client_id)
				select phys_order_id, client_id
				from inserted        ;
			END
		END

		-- if the facility ePrescribe is enabledand the order is eprescribe order create the esignature
		IF (@ePrescribeEnabled='Y' and @communicationMethod = 2141 and @categoryId<>3030)
		BEGIN
			insert into dbo.pho_phys_order_esignature (phys_order_id)
			select phys_order_id
			from inserted        ;
		END
    
	END 
	else
	BEGIN
		--when EOM is not on, we still need a record in order schedule to join to schedules.
		insert into pho_order_schedule(phys_order_id,order_type_id,fac_id,deleted,created_by,created_date,revision_by,revision_date)
		select
			phys_order_id,
			order_type_id,
			fac_id,
			'N',
			created_by,
			created_date,
			revision_by,
			revision_date
		from 
			inserted
	END
END
Go

GO

print 'C_Branch/01_Triggers/tp_pho_phys_order_new_entry_ins.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/01_Triggers/tp_pho_phys_order_new_entry_ins.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/02_Functions/Split.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*****************************************************************************************************
**	Created By: Erwin Brko
**	Created Date: 4/12/09
**
**	Purpose: This function will split a string based on a delimiter passed in and return the
**           results in a temp table with each substring in a separate row.
**
**
**	Parameters:
**				@String - The string to split.
**              @Delimiter - The character to use as a delimiter.
**
**	Return: temp table with rows containing the substrings
**		
** modified by
2011-11-04 Aditi Iyer - Updated the function to hold the max- lengthe string and not to limit to 8000 characters
*****************************************************************************************************/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Split]')) 
DROP FUNCTION [dbo].[Split]
GO

-- Add function to split strings for a specified delimiter
CREATE FUNCTION dbo.Split(@String varchar(max), @Delimiter char(1))       
returns @temptable TABLE (items varchar(max))       
as       
begin       
   declare @idx int       
   declare @slice varchar(8000)       

   select @idx = 1       
      if len(@String)<1 or @String is null  return       

   while @idx!= 0       
       begin       
           set @idx = charindex(@Delimiter,@String)       
           if @idx!=0       
               set @slice = left(@String,@idx - 1)       
           else       
               set @slice = @String       
                
           if(len(@slice)>0)  
              insert into @temptable(Items) values(@slice)       
        
           set @String = right(@String,len(@String) - @idx)       
           if len(@String) = 0 break       
       end   
return       
end

GO

print 'C_Branch/02_Functions/Split.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/02_Functions/Split.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/03_Views/view_diagnosis_codes_clinical_category.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


--======================================================================================================================= 
-- CORE-75071		create view_diagnosis_codes_clinical_category
--					
-- Written By:       Brian Young
-- Modified By:      Sandeep Borkar
-- Reviewed By: 	 Brian Young
-- Script Type:      DDL
-- Target DB Type:   Client
-- Target Database:  Both
--
-- Re-Runnable:      YES
--
-- Staging Recommendations/Warnings: None
--
-- 2022-02-10 - CORE-95672  Revised view to include inactive (old) Clinical Category rows
--=======================================================================================================================

IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[view_diagnosis_codes_clinical_category]'))
	DROP VIEW [dbo].view_diagnosis_codes_clinical_category
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER OFF
GO

-- table view of Categories and Subcategies
CREATE VIEW [dbo].[view_diagnosis_codes_clinical_category] AS
SELECT 
      dcc.[diagnosis_id] 
    , dcc.is_valid_primary_diag
    , COALESCE(dcc.[category_display_text], dcc.[category]) AS clinical_category
    , COALESCE(dcc.[subcategory_display_text], dcc.[subcategory]) AS clinical_subcategory
    , dcc.effective_date AS category_effective_date
    , COALESCE(dcc.ineffective_date, '2079-06-06 23:59') AS category_ineffective_date
FROM dbo.diagnosis_codes_clinical_category dcc
JOIN dbo.diagnosis_codes dc on dc.diagnosis_id=dcc.diagnosis_id
LEFT JOIN dbo.facility f on f.fac_id=dc.fac_id
WHERE dc.diag_lib_id = 4004 and dc.system_flag = 'Y' 
  and (f.country_id is null or f.country_id = 100)
;


GO

print 'C_Branch/03_Views/view_diagnosis_codes_clinical_category.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/03_Views/view_diagnosis_codes_clinical_category.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/03_Views/view_llm_template_org_lookup.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- =============================================================================
-- JIRA:            
--
-- Written By:      Mitch Bilensky
-- Reviewed By:     
--
-- Script Type:     DDL
-- Target DB Type:  CLIENT
-- Target Database: BOTH
-- Rerunable:       YES
--
-- View to list Orgs and template DBs, used for facility creation
--
-- Revision History:
-- 
-- =============================================================================
IF EXISTS(SELECT 1 FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = 'view_llm_template_org_lookup')
   AND EXISTS(SELECT 1 FROM sys.servers WHERE data_source = 'pccsql-use2-nprd-ssv-clg0001.c52ed23d09b0.database.windows.net')
BEGIN
	DROP VIEW [dbo].[view_llm_template_org_lookup]
END
GO

IF EXISTS(SELECT 1 FROM sys.servers WHERE data_source = 'pccsql-use2-nprd-ssv-clg0001.c52ed23d09b0.database.windows.net')
BEGIN
	EXECUTE('CREATE VIEW [dbo].[view_llm_template_org_lookup] AS
		SELECT 
		  server_name as ServerName,
		  database_name as DatabaseName,
		  org_code as OrgCode,
		  org_id as OrgId,
		  org_uuid as OrgUUID, 
		  org_desc as OrgDesc,
		  environment_name as Environment,
		  CASE 
			WHEN enabled = 1 THEN ''N''
			ELSE ''Y''
		  END Deleted, 
		  NULL as OrgdbType,
		  NULL as EnableMPI,
		  NULL as EnableIRM
		FROM 
		  [pccsql-use2-nprd-ssv-clg0001.c52ed23d09b0.database.windows.net].[pcc_org_master_qa].[dbo].[view_local_organization]
	')
END
GO 

IF EXISTS(SELECT 1 FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_NAME = 'view_llm_template_org_lookup')
BEGIN
	GRANT SELECT ON dbo.view_llm_template_org_lookup to PUBLIC
END
GO


GO

print 'C_Branch/03_Views/view_llm_template_org_lookup.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/03_Views/view_llm_template_org_lookup.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_admin_list_getAgingByInvoice_1.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ===========================================================================================
-- Jira #:              CORE-29444       Cash Application: add new application screen
--
-- Written By:
-- Reviewed By:
-- Script Type:         DML
-- Target DB Type:      Client
-- Target ENVIRONMENT:  BOTH (US/CA)
-- Re-Runnable:         YES
--
-- Description of Script Function: Returns a list of the client's aging by invoice/balance forward/unapplied cash
--
-- ============================================================================================
-- Sample execution:
-- by Payer:
-- DECLARE @status_code int,  @status_text varchar(3000)
-- EXEC sproc_admin_list_getAgingByInvoice_1 2, 4, null, 7667967, 123, 0, 2, 'N', @status_code, @status_text
-- by Payer Type:
-- DECLARE @status_code int,  @status_text varchar(3000)
-- EXEC sproc_admin_list_getAgingByInvoice_1 2, null, 'Medicare A', 7667967, 123, 1, 2, 'N', @status_code, @status_text
--
--
-- Params:
--                    @facId
--                    @payerId - gets the resident's invoices by a specific payer
--                    @payerType - gets the resident's invoices by payer type
--                    @clientId
--                    @cashTxId - transaction_id of the edited cash entry; When provided, will be used to return
--                                unposted payments (inc. other tx in the same payment distribution) and shown
--                                as distribute amount. The value is -1 for cash import process.
--                    @payableInvoicesOnly
--                              - value=0 returns (fully/partially paid) invoices/unapplied cash per payer/balance forwards;
--                              - value=1 returns invoices with non-zero balance belonging to a statement with non-credit balance remaining; 
--                                        used for cash imports, pay bills from trust
--                    @returnResults - specify which results to return; value defaults to 2
--                              - value=0 returns list of invoices ONLY
--                              - value=1 returns totals ONLY
--                              - value=2 returns invoices, totals, and unposted payments
--								- value=3 returns invoices(without unbilled transactions), totals, and unposted payments (ONLY works with @payableInvoicesOnly = 1)
-- Return:            List containing: partially paid invoices with balance, fully paid invoices,
--                    balance forward and unapplied cash
-- =============================================================================================

SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO

IF EXISTS (
    SELECT 1
    FROM dbo.sysobjects
    WHERE id = object_id(N'dbo.sproc_admin_list_getAgingByInvoice_1')
        AND objectproperty(id, N'IsProcedure') = 1
    )
BEGIN
    DROP PROCEDURE dbo.sproc_admin_list_getAgingByInvoice_1
END
GO

CREATE PROCEDURE sproc_admin_list_getAgingByInvoice_1
(
  @facId int,
  @payerId int,
  @payerType varchar(100),
  @clientId int,
  @cashTxId int = null,
  @payableInvoicesOnly bit = 0,
  @returnResults tinyint = 2,
  @debug char(1) = 'N',
  @status_code int = 0 out,
  @status_text varchar(3000) out
)
AS


SET NOCOUNT ON

DECLARE @error_msg varchar(255)
       ,@error_code int
       ,@step int
       ,@catdDate datetime
       ,@arStartDate datetime
	   ,@currentPostingDate datetime

CREATE TABLE #payers
(
    payer_id int
   ,[description] varchar(50)
   ,bill_form varchar(10)
   ,payer_type varchar(20)
)

--*****************************************************--

CREATE TABLE #allInvoicesList
(
  id int identity,
  payer_id int,
  invoice_id int,
  total_amount DECIMAL (20,2),
  effective_date DATETIME,
  eff_date_to datetime,
  original_invoice_id int,
  transaction_flag char,
  manual_flag char
  index #allInvoicesList__id clustered (id)
)

CREATE TABLE #allInvoicesPostUnfiltered
(
  payer_id int,
  invoice_id int,
  amount DECIMAL (20,2),
  effDateThru DATETIME,
  claim_type_id tinyint
)

CREATE TABLE #allInvoicesPost
(
    payer_id int,
  invoice_id int,
  amount DECIMAL (20,2),
  balance DECIMAL (20,2) default 0,
  effDateThru DATETIME,
  apply_to_year_month DATETIME,
  fully_paid bit default 1
)

CREATE TABLE #allPostInvoicesTx
(
  transaction_id INT NOT NULL,
  invoice_id INT NOT NULL,
    apply_to_year_month DATETIME,
  payer_id INT NOT NULL,
  paid_status_code char(1),
  amount DECIMAL(20,2) DEFAULT(0.00)
)

CREATE TABLE #outstandingPostBal(
  payer_id INT NOT NULL,
  invoice_id INT NOT NULL,
  apply_to_year_month DATETIME,
  amount DECIMAL(20,2) DEFAULT(0.00)
)

CREATE TABLE #unappliedCash
(
  invoice_id int,
  payer_id int,
  amount DECIMAL(20,2) DEFAULT(0.00),
  apply_to_year_month DATETIME
)

CREATE TABLE #postTransitionPayment(
  payer_id INT NOT NULL,
  invoice_id INT NOT NULL,
  apply_to_year_month DATETIME,
  amount DECIMAL(20,2) DEFAULT(0.00)
)

CREATE TABLE #agingByInvoiceWithBalPost(
  payer_id INT NOT NULL,
  invoice_id INT NOT NULL,
  apply_to_year_month DATETIME,
  amount DECIMAL(20,2) DEFAULT(0.00)
)

CREATE TABLE #chargeAllPre
(
  payer_id int,
  apply_to_year_month DATETIME,
  amount DECIMAL(20,2) DEFAULT(0.00)
)

CREATE TABLE #chargeBucketsPre
(
  payer_id int,
  apply_to_year_month DATETIME,
  amount DECIMAL(20,2) DEFAULT(0.00)
)

CREATE TABLE #paymentAllPre
(
  payer_id int,
  apply_to_year_month DATETIME,
  amount DECIMAL(20,2) DEFAULT(0.00)
)

CREATE TABLE #paymentBucketsPre
(
  payer_id int,
  apply_to_year_month DATETIME,
  amount DECIMAL(20,2) DEFAULT(0.00)
)

CREATE TABLE #preTransitionBucket
(
  payer_id int,
  apply_to_year_month DATETIME,
  amount DECIMAL(20,2) DEFAULT(0.00),
  payment DECIMAL(20,2) DEFAULT(0.00),
  balance DECIMAL(20,2)
)

CREATE TABLE #unpostedPaymentsAll(
  invoice_id INT NOT NULL,
  apply_to_year_month DATETIME,
  payer_id INT NOT NULL,
  amount DECIMAL(20,2) DEFAULT(0.00),
  amount_for_auto_writeoff DECIMAL(10,2) DEFAULT(0.00)
)

CREATE TABLE #results
(
    client_id INT NOT NULL
   ,payer_id INT NOT NULL
   ,[description] VARCHAR(50)
   ,invoice_id INT
   ,apply_to_year_month DATETIME
   ,amount DECIMAL (20,2)
   ,balance DECIMAL (20,2)
   ,distributeAmount DECIMAL (20,2)
   ,[type] VARCHAR(50)
   ,effDateThru DATETIME
   ,amountForAutoWriteoff DECIMAL (20,2)
)

CREATE TABLE #privateInvoices
(
    parent_linked_invoice_id INT
   ,invoice_id INT
   ,client_id INT
   ,payer_id INT
   ,[description] VARCHAR(50)
   ,amount DECIMAL (20,2)
   ,balance DECIMAL (20,2)
   ,distributeAmount DECIMAL (20,2)
   ,[type] VARCHAR(50)
   ,effDateThru DATETIME
   ,amountForAutoWriteoff DECIMAL (20,2)
   ,apply_to_year_month DATETIME
)

CREATE TABLE #resultsFinal
(
    parent_linked_invoice_id INT
   ,apply_to_year_month DATETIME
   ,invoice_id INT
   ,client_id INT
   ,payer_id INT
   ,[description] VARCHAR(50)
   ,amount DECIMAL (20,2)
   ,balance DECIMAL (20,2)
   ,distributeAmount DECIMAL (20,2)
   ,totalStmtBalRemaining DECIMAL (20,2)
   ,[type] VARCHAR(50)
   ,effDateThru DATETIME
   ,generated_date DATE
   ,amountForAutoWriteoff DECIMAL (20,2)
)

CREATE TABLE #allPaymentTxsInDist(
  transaction_id INT NOT NULL
)

CREATE TABLE #unpostedPayments(
  invoice_id INT NOT NULL,
  apply_to_year_month DATETIME,
  client_id INT NOT NULL,
  payer_id INT NOT NULL,
  description varchar(50),
  amount DECIMAL(20,2) DEFAULT(0.00),
  amount_for_auto_writeoff DECIMAL(10,2) DEFAULT(0.00)
)

CREATE TABLE #finalCTE(
    client_id INT NOT NULL,
    payer_id INT NOT NULL,
    description varchar(50),
    invoice_id INT NOT NULL,
    apply_to_year_month DATETIME,
    amount DECIMAL(20,2) DEFAULT(0.00),
    balance DECIMAL(20,2) DEFAULT(0.00),
    distributeAmount DECIMAL(20,2) DEFAULT(0.00),
    type varchar(30),
    effDateThru datetime,
    amountForAutoWriteoff DECIMAL(20,2) DEFAULT(0.00)
)

DECLARE @allUnpostTransactions TABLE
  (
    transaction_id int PRIMARY KEY,
    payer_id int,
    batch_number int,
    entry_number int
  )

  

 DECLARE @postTransitionUnpostAll TABLE
  (
    transaction_id int,
	payer_id int,
    amount DECIMAL(20,2) DEFAULT(0.00),
    apply_to_year_month DATETIME,
    invoice_id int,
	amountForAutoWriteoff decimal (20,2) DEFAULT(0.00)
  )

  DECLARE @unappliedCashUnpostAll TABLE
  (
    transaction_id int,
	payer_id int,
    amount DECIMAL(20,2) DEFAULT(0.00),
    apply_to_year_month DATETIME
  )

  DECLARE @appliedPaymentUnpostAll TABLE
  (
    transaction_id int,
	payer_id int,
    amount DECIMAL(20,2) DEFAULT(0.00), 
    apply_to_year_month DATETIME,
	writeoff_amount decimal (20,2) DEFAULT(0.00)
  )

BEGIN TRY
	SELECT TOP 1 @currentPostingDate=posting_date from ar_configuration WHERE fac_id = @facId

    set @step = 1
    if @debug='Y' Print 'STEP ' +  convert(varchar(20), @step) + '  ' + convert(varchar(26),getdate(),109) + ': get CATD date';

  select @catdDate = value from configuration_parameter where fac_id = -1 and name = 'cash_application_transition_date'
  
  SELECT @arStartDate = ar_start_date  from ar_configuration where fac_id = @facId and deleted = 'N'

  IF @arStartDate is NULL OR @catdDate IS NULL OR @arStartDate > @catdDate
  BEGIN
  SET @catdDate = NULL
  END

    set @step = 2
  if @debug='Y' Print 'STEP ' +  convert(varchar(20), @step) + '  ' + convert(varchar(26),getdate(),109) + ': get payers';

    INSERT INTO #payers(payer_id, [description], bill_form, payer_type)
    SELECT p1.payer_id, p1.[description], p1.bill_form, p1.payer_type
    FROM ar_lib_payers p1
    JOIN ar_payers p2
        ON p1.payer_id = p2.payer_id
    WHERE p1.deleted = 'N'
        AND (
             (@payerType IS NOT NULL AND p1.payer_type = @payerType)
                OR (@payerType IS NULL AND p1.payer_id = @payerId)
            )
        AND p2.fac_id = @facId
    
  IF @payerType = 'private'
  BEGIN
    INSERT INTO #payers(payer_id, [description], bill_form, payer_type)
    SELECT p1.payer_id, p1.[description], p1.bill_form, p1.payer_type
    FROM ar_lib_payers p1
    JOIN ar_payers p2
      ON p1.payer_id = p2.payer_id
    WHERE p1.deleted = 'N'
      AND (@payerType IS NOT NULL AND p1.payer_type = 'Outpatient' AND p1.bill_form='private' AND p1.outpatient_payer_type='private')
      AND p2.fac_id = @facId
  END

  --****************************************************************--
  set @step = 3
  if @debug='Y' Print 'STEP ' +  convert(varchar(20), @step) + '  ' + convert(varchar(26),getdate(),109) + ': retrieve all post transition invoice';

Insert into #allInvoicesList (invoice_id,payer_id, total_amount, effective_date, eff_date_to, original_invoice_id, transaction_flag, manual_flag)
  select i.invoice_id, i.payer_id, i.total_amount, i.effective_date, i.eff_date_to, i.original_invoice_id, i.transaction_flag, i.manual_flag 
  from ar_invoice i
  where i.client_id = @clientId
	and i.fac_id = @facId
	and i.deleted = 'N'
	and i.trial_flag = 'N'

	/*
	claim types
		1 - original
		2 - secondary
		3 - tertiary
		4 - adjusment
		5 - manual
		6 - no pay
		7 - exhaust
		8 - copy
	*/
  INSERT into #allInvoicesPostUnfiltered (payer_id, invoice_id, effDateThru, amount, claim_type_id) 
  SELECT i.payer_id, i.invoice_id 
    , i.effective_date AS effDateThru
    , i.total_amount as amount 
	, null as claim_type_id
  from #allInvoicesList i 
  join ar_lib_payers p on p.payer_id = i.payer_id
  left JOIN ar_invoice_statement s ON i.invoice_id = s.invoice_id
  where
   (p.bill_form = 'Other' OR (p.bill_form = 'private' AND s.generated_date IS NOT NULL)) 
  AND (@catdDate IS NULL OR i.effective_date >= @catdDate)
  UNION ALL
  SELECT 
  -- determine the payer_id
  -- for claims, this is determined by the claim_responsible_payer_code in ar_invoice_claim
  case when c.claim_responsible_payer_code = 'a' then c.pcc_primary_payer_id
			when c.claim_responsible_payer_code = 'b' then c.pcc_secondary_payer_id
			when c.claim_responsible_payer_code = 'c' then c.pcc_tertiary_payer_id
			else i.payer_id
		end as payer_id
  , i.invoice_id 
    , CASE WHEN c.invoice_id IS NULL THEN i.eff_date_to ELSE c.effective_to_date END AS effDateThru
    , i.total_amount  
	,	CASE 
		WHEN i.original_invoice_id is null and i.transaction_flag = 'Y' THEN 1 -- 'Original'
		WHEN i.original_invoice_id is not null and i.transaction_flag='Y' and c.tob_frequency_code = 7 THEN 4 -- 'Adjustment'
		WHEN i.original_invoice_id is null and manual_flag='Y' THEN 5 --'Manual'
		WHEN i.original_invoice_id is not null and i.transaction_flag = 'N' and c.claim_responsible_payer_code = 'b' THEN 2 --'Secondary'
		WHEN i.original_invoice_id is not null and i.transaction_flag = 'N' and c.claim_responsible_payer_code = 'c' THEN 3 --'Tertiary'
		WHEN i.original_invoice_id is null and i.transaction_flag = 'N' and c.tob_frequency_code = 0 THEN 6 --'No Pay'
		WHEN i.original_invoice_id is null and i.transaction_flag = 'N' and c.tob_frequency_code <> 0 THEN 7 --'Exhaust'
		WHEN i.original_invoice_id is not null and i.transaction_flag = 'N' and (c.claim_responsible_payer_code <> 'b' or c.claim_responsible_payer_code <> 'c') THEN 8 --'Copy'
		END as claim_type
  from #allInvoicesList i 
  join ar_lib_payers p on p.payer_id = i.payer_id
  LEFT JOIN ar_invoice_claim c ON c.invoice_id = i.invoice_id
  where 
	p.bill_form LIKE 'UB%' 
  AND (
  (c.invoice_id IS NULL AND (@catdDate IS NULL OR i.eff_date_to >= @catdDate))
  OR
  (c.invoice_id IS NOT NULL AND (@catdDate IS NULL OR c.effective_to_date >= @catdDate))
  )
  
  declare @adjustmentInvoiceTotals table (invoice_id int, amount money)

  -- get adjustment totals from ar_transactions
  insert into @adjustmentInvoiceTotals (invoice_id, amount)
  select a.invoice_id, sum(t.amount)
  from #allInvoicesPostUnfiltered a
	join ar_transactions t
		on t.invoice_id = a.invoice_id
			and t.fac_id = @facId
			and t.client_id = @clientId
			and t.deleted = 'N'
  where a.claim_type_id = 4 -- adjustment
  group by a.invoice_id

  -- update adjustment invoice totals
  update a
  set amount = t.amount
  from #allInvoicesPostUnfiltered a
	join @adjustmentInvoiceTotals t
		on t.invoice_id = a.invoice_id

  -- filter out invoices that don't have any transactions
	INSERT into #allInvoicesPost (payer_id, invoice_id, effDateThru, amount) 
	select i.payer_id, i.invoice_id, i.effDateThru, i.amount
	from #allInvoicesPostUnfiltered i 
		join #payers p
			on p.payer_id = i.payer_id
	cross APPLY
	(
		select top 1 t.transaction_id
		from ar_transactions t
		where i.invoice_id = t.invoice_id
		and t.fac_id = @facId
		and t.client_id = @clientId
		and t.deleted ='N'
	) a

  set @step = 4
  if @debug='Y' Print 'STEP ' +  convert(varchar(20), @step) + '  ' + convert(varchar(26),getdate(),109) + ': retrieve all post transition buckets';

  insert into #allPostInvoicesTx (transaction_id, invoice_id, apply_to_year_month, payer_id, paid_status_code, amount)
  SELECT t.transaction_id AS transaction_id
    , ISNULL(t.invoice_id, -2) AS invoice_id 
    , DATEFROMPARTS(year(t.effective_date), month(t.effective_date),1)
    --, CASE WHEN ISNULL(t.invoice_id, -999) = -999 THEN DATEFROMPARTS(year(t.effective_date), month(t.effective_date),1) ELSE NULL END
    , t.payer_id
    , ISNULL(t.paid_status_code, 'N')
    , t.amount
  from ar_transactions t
  JOIN #payers py ON t.payer_id = py.payer_id
  Left JOIN #allInvoicesPost i on i.invoice_id = t.invoice_id
  where t.fac_id = @facId 
    AND t.client_id = @clientId
    AND t.deleted = 'N' 
    AND t.transaction_date IS NOT NULL 
    AND t.transaction_type <> 'C'
    AND (i.invoice_id IS NOT NULL OR (ISNULL(t.invoice_id, -999) = -999 AND (@catdDate is NULL OR t.effective_date >= @catdDate)))

  -- remove unbilled/mark as billed transactions from post-transition buckets
  IF @returnResults = 3
  BEGIN
	DELETE FROM #allPostInvoicesTx WHERE invoice_id IN (-2, -999)
  END

  INSERT into #allInvoicesPost (payer_id, invoice_id, effDateThru, apply_to_year_month, amount)
  SELECT payer_id
    , invoice_id
    , apply_to_year_month
    , apply_to_year_month
    , SUM(amount) 
  from #allPostInvoicesTx
  WHERE invoice_id < 0 --AND invoice_id <> -999
  GROUP BY payer_id, invoice_id, apply_to_year_month
  UNION ALL
  SELECT payer_id, -1 as invoice_id, NULL, NULL, 0
  FROM #payers 

  /***********************************************************************************************************************************************/
  INSERT into @allUnpostTransactions (transaction_id, payer_id, batch_number, entry_number)
  SELECT t.transaction_id
  , t.payer_id
  , b.batch_number
  , t.entry_number 
  from ar_transactions t
  join #payers p on p.payer_id = t.payer_id
  JOIN ar_batch b on b.batch_id = t.batch_id
  where t.fac_id = @facId and t.client_id = @clientId AND t.deleted = 'N' and t.transaction_type = 'C' and t.transaction_date IS NULL
  AND
  (@cashTxId = -1 OR 
    (t.transaction_id <> @cashTxId AND ISNULL(t.distribution_tx_id,-1) <> @cashTxId) 
  )

	declare @paymentsFromAutoWriteoff table (transaction_id int)
	
	insert into @paymentsFromAutoWriteoff (transaction_id)
	select up.transaction_id 
	from @allUnpostTransactions up
		join ar_transactions_payment p on up.transaction_id = p.payment_transaction_id
	where p.is_created_from_auto_writeoff = 1
	group by up.transaction_id
	
  insert into @postTransitionUnpostAll (invoice_id, transaction_id, payer_id, apply_to_year_month, amount, amountForAutoWriteoff)
  select t.invoice_id
  , up.transaction_id
	, up.payer_id
    , apply_to_year_month 
    , sum(p.amount) AS amount 
	, sum( case when pwrt.transaction_id is not null and (t.invoice_id > 0 or t.invoice_id = -999) then 0 else isnull(p.amount_for_auto_writeoff, 0) end) AS amountForAutoWriteoff  
    from #allPostInvoicesTx t
    join ar_transactions_payment p on t.transaction_id = p.charge_transaction_id 
    join @allUnpostTransactions up on up.transaction_id = p.payment_transaction_id
	left join @paymentsFromAutoWriteoff pwrt
		on pwrt.transaction_id = up.transaction_id
    group by t.invoice_id, up.transaction_id, up.payer_id, apply_to_year_month

	insert into @unappliedCashUnpostAll (transaction_id, payer_id, apply_to_year_month, amount)
   SELECT t.transaction_id
	, t.payer_id
    , DATEFROMPARTS(year(u.effective_date), month(u.effective_date),1) as apply_to_year_month
	, SUM(u.amount) AS amount 
  FROM @allUnpostTransactions t
  join ar_unapplied_cash u on u.transaction_id = t.transaction_id 
  WHERE is_post_transition = 1
  GROUP BY  t.transaction_id, t.payer_id, DATEFROMPARTS(year(u.effective_date), month(u.effective_date),1) 

  insert into @appliedPaymentUnpostAll (transaction_id, payer_id, apply_to_year_month, amount, writeoff_amount)
  SELECT h.transaction_id, h.payer_id,  DATEFROMPARTS(year(h.applied_to_date), month(h.applied_to_date),1) apply_to_year_month, -1 * SUM(h.amount), -1 * sum(ISNULL(writeoff_amount, 0))
    FROM @allUnpostTransactions t 
    join ar_applied_payment_history h on h.transaction_id = t.transaction_id
    WHERE h.deleted = 'N' 
      and h.fac_id = @facId 
      AND h.client_id = @clientId
	  AND h.applied_date IS NULL 
	GROUP BY h.transaction_id, h.payer_id, DATEFROMPARTS(year(h.applied_to_date), month(h.applied_to_date),1)

	declare @unpostedMonthCount table (payer_id int, apply_to_year_month datetime, count int)
	insert into @unpostedMonthCount(payer_id, apply_to_year_month, count)
	select a.payer_id, a.apply_to_year_month, sum(a.count)
	from
	(
		SELECT h.payer_id
		, apply_to_year_month
		, count(*) as count
		FROM @appliedPaymentUnpostAll h
		GROUP BY payer_id, apply_to_year_month
		UNION ALL
		select b.payer_id
		,b.apply_to_year_month
		, -1 * count(*) as count
		from
			(
			SELECT uc.transaction_id, uc.payer_id
			, apply_to_year_month
			FROM @unappliedCashUnpostAll uc
			GROUP BY  transaction_id,payer_id, apply_to_year_month
			UNION
			SELECT transaction_id, payer_id
			, apply_to_year_month
			FROM @postTransitionUnpostAll
			GROUP BY transaction_id,payer_id, apply_to_year_month
		) b
		group by b.payer_id, b.apply_to_year_month
	) a
	group by a.payer_id, a.apply_to_year_month


  /**********************************************************************************************************************************************/

  -- This will be removed from pre-transition bucket later.
  insert into #unappliedCash (payer_id, invoice_id, amount, apply_to_year_month)
  SELECT t.payer_id 
    , -1 as invoice_id 
    , SUM(u.amount) AS amount 
    , DATEFROMPARTS(year(u.effective_date), month(u.effective_date),1) as apply_to_year_month
  FROM ar_unapplied_cash u 
  join ar_transactions t on u.transaction_id = t.transaction_id 
  JOIN #payers py ON t.payer_id = py.payer_id 
  WHERE t.fac_id = @facId 
    AND t.client_id = @clientId 
	and t.deleted = 'N'
    and is_post_transition = 1
    AND (@cashTxId = -1 OR
        (t.transaction_id <> @cashTxId AND ISNULL(t.distribution_tx_id,-1) <> @cashTxId)
    ) 
  GROUP BY  t.payer_id, DATEFROMPARTS(year(u.effective_date), month(u.effective_date),1) 
  HAVING SUM(u.amount) <> 0  

  INSERT INTO #postTransitionPayment (payer_id, invoice_id, amount, apply_to_year_month)  
    SELECT t.payer_id 
    , t.invoice_id 
    , SUM(p.amount) AS amount 
    , apply_to_year_month 
  FROM #allPostInvoicesTx t 
  join ar_transactions_payment p on t.transaction_id = p.charge_transaction_id AND p.posting_date IS NOT NULL 
  WHERE t.paid_status_code = 'P' 
  GROUP BY  t.payer_id, t.invoice_id, apply_to_year_month
  HAVING SUM(p.amount) <> 0 
  union all 
  SELECT u.payer_id 
    , -1 as invoice_id 
    , SUM(u.amount) AS amount 
    , NULL as apply_to_year_month 
  FROM #unappliedCash u 
  GROUP BY u.payer_id 
  HAVING SUM(u.amount) <> 0 
  UNION ALL 
  SELECT p.payer_id 
    , p.invoice_id 
    , sum(p.amount + isnull(p.amountForAutoWriteoff,0)) as amount 
    , apply_to_year_month 
  FROM @postTransitionUnpostAll p 
  GROUP BY p.payer_id, p.invoice_id, apply_to_year_month
  HAVING(sum(p.amount + isnull(p.amountForAutoWriteoff,0))) <> 0

  INSERT INTO #outstandingPostBal (payer_id, invoice_id, amount, apply_to_year_month)  
  SELECT t.payer_id
    , t.invoice_id 
    , SUM(t.amount) AS amount 
    , case WHEN invoice_id > 0 THEN NULL ELSE apply_to_year_month END 
  FROM #allPostInvoicesTx t 
  WHERE t.paid_status_code IN ('P','N') 
  GROUP BY  t.payer_id, t.invoice_id, case WHEN invoice_id > 0 THEN NULL ELSE apply_to_year_month END 
  HAVING SUM(t.amount) <> 0 
  UNION ALL
  SELECT payer_id 
    , invoice_id
    , SUM(amount)
    ,  CASE WHEN invoice_id > 0 THEN NULL ELSE apply_to_year_month END
  from #postTransitionPayment
  GROUP BY payer_id, invoice_id, case WHEN invoice_id > 0 THEN NULL ELSE apply_to_year_month END
  HAVING SUM(amount) <> 0

  INSERT INTO #agingByInvoiceWithBalPost (payer_id, invoice_id, amount, apply_to_year_month) 
  SELECT t.payer_id 
    , t.invoice_id 
    , SUM(t.amount) AS amount 
    , t.apply_to_year_month 
  FROM #outstandingPostBal t
    GROUP BY t.payer_id, t.invoice_id, apply_to_year_month
    HAVING SUM(t.amount) <> 0

  update i SET fully_paid = 0, balance = b.amount 
  from #allInvoicesPost i
  join #agingByInvoiceWithBalPost b 
    on i.invoice_id = b.invoice_id AND (i.invoice_id > -2 OR i.apply_to_year_month = b.apply_to_year_month) 
      and b.payer_id = i.payer_id

  -- remove all zero charge and zero balance unbilled/Mark as Billed row
  -- do not remove if the balance contains unposted payments
  DELETE a 
  FROM #allInvoicesPost a
	left join (
		  select payer_id, invoice_id, apply_to_year_month from @postTransitionUnpostAll
		  where invoice_id < -1
		  group by payer_id, invoice_id, apply_to_year_month
		) p
		on p.payer_id = a.payer_id
			and p.invoice_id = a.invoice_id
			and p.apply_to_year_month = a.apply_to_year_month
  where a.invoice_id < -1 and a.amount = 0 and a.fully_paid = 1
	and p.payer_id is null

  IF @catdDate IS NOT NULL
  BEGIN
  
  set @step = 5
  if @debug='Y' Print 'STEP ' +  convert(varchar(20), @step) + '  ' + convert(varchar(26),getdate(),109) + ': retrieve all pre transition buckets';

    insert into #chargeAllPre (payer_id, apply_to_year_month, amount)
    SELECT rc.payer_id,  DATEFROMPARTS(year(effective_date), month(effective_date),1) e_date, cast(sum(amount) AS MONEY) AS amount
    from ar_transactions_rollup_client rc
    JOIN #payers py ON rc.payer_id = py.payer_id
    where rc.client_id = @clientId and rc.transaction_type <> 'C'
    GROUP BY rc.payer_id, DATEFROMPARTS(year(effective_date), month(effective_date),1)
    UNION ALL
    SELECT t.payer_id,  DATEFROMPARTS(year(effective_date), month(effective_date),1) e_date, cast(sum(amount) AS MONEY) AS amount
    from ar_transactions t
    JOIN #payers py ON t.payer_id = py.payer_id
    where t.client_id = @clientId and t.transaction_type <> 'C' AND t.deleted = 'N' and t.OpenClose_Flag = 'O'
      AND transaction_date IS NOT NULL
    GROUP BY t.payer_id, DATEFROMPARTS(year(effective_date), month(effective_date),1)
    UNION ALL
    select payer_id, apply_to_year_month, -1 * SUM(amount) 
    FROM #allPostInvoicesTx
    GROUP BY payer_id, apply_to_year_month

	-- remove unbilled transactions from pre-transition buckets
	IF @returnResults = 3
	BEGIN
		INSERT INTO #chargeAllPre (payer_id, apply_to_year_month, amount)
		SELECT t.payer_id, DATEFROMPARTS(year(t.effective_date), month(t.effective_date),1), -1 * SUM(t.amount) 
		from ar_transactions t
		JOIN #payers py ON t.payer_id = py.payer_id
		WHERE t.client_id = @clientId and t.transaction_type <> 'C' AND t.deleted = 'N'
		  AND t.transaction_date IS NOT NULL 
		  AND (t.invoice_id IS NULL OR t.invoice_id = -999)
		GROUP BY t.payer_id, DATEFROMPARTS(year(t.effective_date), month(t.effective_date),1)
	END

    insert into #chargeBucketsPre (payer_id, apply_to_year_month, amount)
    SELECT payer_id, apply_to_year_month, sum(amount) 
    from #chargeAllPre
    GROUP BY payer_id, apply_to_year_month

    insert into #paymentAllPre (payer_id, apply_to_year_month, amount)
    SELECT h.payer_id,  DATEFROMPARTS(year(h.applied_to_date), month(h.applied_to_date),1) apply_to_year_month, -1 * SUM(h.amount)  -- posted
    FROM ar_applied_payment_history h
    JOIN #payers py ON h.payer_id = py.payer_id 
    join ar_transactions t on h.transaction_id = t.transaction_id AND t.deleted = 'N'
    WHERE h.deleted = 'N' 
      and h.fac_id = @facId 
      AND h.client_id = @clientId
      AND h.applied_date IS NOT NULL
    GROUP BY h.payer_id,  DATEFROMPARTS(year(h.applied_to_date), month(h.applied_to_date),1) 
	UNION ALL
	SELECT payer_id, apply_to_year_month, SUM(amount) -- unposted
    FROM @appliedPaymentUnpostAll
	GROUP BY payer_id, apply_to_year_month
	UNION ALL
	SELECT payer_id, apply_to_year_month, SUM(isnull(writeoff_amount,0))  -- writeoffs
    FROM @appliedPaymentUnpostAll
	GROUP BY payer_id, apply_to_year_month
	HAVING SUM(ISNULL(writeoff_amount, 0)) <> 0
	UNION ALL
	-- get balance credits
	SELECT h.payer_id,  DATEFROMPARTS(year(h.applied_to_date), month(h.applied_to_date),1) apply_to_year_month, -1 * SUM(h.amount) 
    FROM ar_applied_payment_history h
    JOIN #payers py ON h.payer_id = py.payer_id 
    WHERE h.deleted = 'N' 
      and h.fac_id = @facId 
      AND h.client_id = @clientId
	  and h.transaction_id = -1
	  and h.current_period_date IS NOT NULL 
    GROUP BY h.payer_id,  DATEFROMPARTS(year(h.applied_to_date), month(h.applied_to_date),1)
    UNION ALL
    -- Remove payment is covered by post-transition part
    SELECT payer_id, apply_to_year_month, -1 * SUM(amount)
    FROM #postTransitionPayment 
    WHERE invoice_id <> -1
    GROUP by payer_id, apply_to_year_month, invoice_id
    HAVING sum(amount) <> 0
	UNION ALL
	-- Not include the amount for auto writeoff because it is already included in last part
	SELECT payer_id, apply_to_year_month, SUM(ISNULL(amountForAutoWriteoff,0))
    FROM @postTransitionUnpostAll 
    WHERE invoice_id <> -1
    GROUP by payer_id, apply_to_year_month, invoice_id
    HAVING sum(ISNULL(amountForAutoWriteoff,0)) <> 0
    UNION ALL
    -- Remove payment for all charges with paid_status_code as 'F' in post-transaction part
    SELECT payer_id, apply_to_year_month, sum(amount)
    FROM #allPostInvoicesTx 
    WHERE paid_status_code = 'F'
    GROUP BY payer_id, apply_to_year_month
    HAVING sum(amount) <> 0
    UNION ALL
    SELECT payer_id, apply_to_year_month, -1 * sum(amount)
    FROM #unappliedCash
    GROUP BY payer_id, apply_to_year_month
    HAVING sum(amount) <> 0

    INSERT INTO #paymentBucketsPre (payer_id, apply_to_year_month, amount)
    SELECT payer_id, apply_to_year_month, sum(amount) from #paymentAllPre 
    group by payer_id, apply_to_year_month

    ;WITH temp AS
    (
      SELECT payer_id, apply_to_year_month, amount, 0 as payment, amount as balance
      FROM #chargeBucketsPre
      UNION ALL
      SELECT payer_id, apply_to_year_month, 0 as amount, amount as payment, amount as balance
      FROM #paymentBucketsPre
    )
    INSERT INTO #preTransitionBucket (payer_id, apply_to_year_month, amount, payment, balance)
    SELECT t.payer_id, t.apply_to_year_month, sum(t.amount), sum(payment), sum(balance)
    FROM temp t
	left join @unpostedMonthCount m
		on m.payer_id = t.payer_id
			and m.apply_to_year_month = t.apply_to_year_month
    GROUP BY t.payer_id, t.apply_to_year_month
    HAVING sum(t.amount) <> 0 OR SUM(payment) <> 0 or sum(m.count) > 0

  END

  set @step = 5
  if @debug='Y' Print 'STEP ' +  convert(varchar(20), @step) + '  ' + convert(varchar(26),getdate(),109) + ': retrieve all payment related to this cash transaction';

    INSERT INTO #allPaymentTxsInDist (transaction_id)
        SELECT t.transaction_id AS transaction_id
        FROM ar_transactions t
        WHERE t.fac_id = @facId
            AND t.client_id = @clientId
            AND t.deleted = 'N'
            AND ISNULL(t.distribution_tx_id, t.transaction_id) = @cashTxId
  
  insert into #unpostedPaymentsAll (invoice_id, payer_id, amount, amount_for_auto_writeoff, apply_to_year_month)
  SELECT t.invoice_id
            , t.payer_id
            , SUM(p.amount) AS amount
            , ISNULL(sum(p.amount_for_auto_writeoff), 0) AS amount_for_auto_writeoff
      , t.apply_to_year_month
    FROM #allPostInvoicesTx t
    JOIN ar_transactions_payment p
        ON t.transaction_id = p.charge_transaction_id
    JOIN #allPaymentTxsInDist pTx
        ON p.payment_transaction_id = pTx.transaction_id
    WHERE p.posting_date IS NULL
    GROUP BY t.payer_id, t.invoice_id, t.apply_to_year_month
    HAVING SUM(p.amount) <> 0
    union all
    SELECT -1 AS invoice_id
        , t.payer_id
        , SUM(u.amount) AS amount
        , 0 AS amount_for_auto_writeoff
        , DATEFROMPARTS(year(u.effective_date), month(u.effective_date),1) AS apply_to_year_month
    FROM ar_unapplied_cash u
  join ar_transactions t on u.transaction_id = t.transaction_id
    JOIN #payers py ON t.payer_id = py.payer_id
    JOIN #allPaymentTxsInDist pTx
        ON t.transaction_id = pTx.transaction_id
    WHERE t.fac_id = @facId
        AND t.client_id = @clientId
        AND u.posting_date IS NULL
    AND u.is_post_transition = 1
    GROUP BY  t.payer_id, DATEFROMPARTS(year(u.effective_date), month(u.effective_date),1)
    HAVING SUM(u.amount) <> 0
  UNION ALL
  SELECT -3 AS invoice_id, h.payer_id
  , -1 * SUM(h.amount) as amount, -1 * sum(ISNULL(h.writeoff_amount,0)) as amount_for_auto_writeoff
  , DATEFROMPARTS(year(h.applied_to_date), month(h.applied_to_date),1) AS apply_to_year_month
  FROM ar_applied_payment_history h
  join #allPaymentTxsInDist t on h.transaction_id = t.transaction_id
  where h.deleted = 'N' --and h.applied_date IS NULL
  GROUP BY h.payer_id, DATEFROMPARTS(year(h.applied_to_date), month(h.applied_to_date),1)
  -- Not checking the write off in the having clause because it doesn't make sense for having sum(amount) is 0 but still have write off not as 0.
  HAVING SUM(h.amount) <> 0

  INSERT INTO #unpostedPayments (invoice_id, client_id, payer_id, amount, amount_for_auto_writeoff, apply_to_year_month)
  SELECT invoice_id, @clientId, payer_id, SUM(amount)
    , ISNULL(sum(amount_for_auto_writeoff), 0) AS amount_for_auto_writeoff 
    , CASE WHEN invoice_id >= -1 THEN NULL ELSE apply_to_year_month END AS apply_to_year_month
  FROM #unpostedPaymentsAll
  WHERE invoice_id <> -3
  GROUP BY invoice_id, payer_id, CASE WHEN invoice_id >= -1 THEN NULL ELSE apply_to_year_month END
  HAVING SUM(amount) <> 0
  UNION ALL
  SELECT -3 AS invoice_id, @clientId, payer_id
    , SUM(CASE WHEN invoice_id = -3 THEN amount ELSE (-1 * amount) END)
    , SUM(case when invoice_id = -3 then ISNULL(amount_for_auto_writeoff,0) else 0 end) as amount_for_auto_writeoff, apply_to_year_month 
  FROM #unpostedPaymentsAll
  GROUP BY payer_id, apply_to_year_month
  HAVING SUM(CASE WHEN invoice_id = -3 THEN amount ELSE (-1 * amount) END) <> 0

  set @step = 6
  if @debug='Y' Print 'STEP ' +  convert(varchar(20), @step) + '  ' + convert(varchar(26),getdate(),109) + ': generate final output';

	declare @bucketsAll table ( payer_id int, invoice_id int, amount decimal (20,2), balance decimal(20,2), apply_to_year_month datetime, effDateThru datetime)
	insert into @bucketsAll (payer_id, invoice_id, amount, balance, apply_to_year_month, effDateThru)
    SELECT payer_id
      , invoice_id
      , amount
      , balance AS balance
      , apply_to_year_month
      , effDateThru
    from #allInvoicesPost
    UNION ALL
    SELECT payer_id
      , -3 AS invoice_id
      , amount
      , balance
      , apply_to_year_month
      , apply_to_year_month AS  effDateThru
    from #preTransitionBucket
  
  INSERT INTO #finalCTE (client_id, payer_id, description, invoice_id, amount, balance, distributeAmount
    , type, effDateThru, amountForAutoWriteoff, apply_to_year_month)
  SELECT @clientId
    , b.payer_id
    , p.description
    , b.invoice_id
    , b.amount
    , b.balance
    , -1 * ISNULL(u.amount, 0) as distributeAmount
    , CASE b.invoice_id 
      WHEN -999 THEN 'Marked as Billed' 
      WHEN -3 THEN 'Pre-Transition'
      WHEN -2 THEN 'Unbilled Transactions'
      WHEN -1 THEN 'Unapplied Cash'
      ELSE 
        CASE WHEN payer_type = 'Other' AND bill_form IN ('private','Other') THEN 'Other' ELSE 'Invoice' END 
      END as [type]
    , b.effDateThru
    , ISNULL(u.amount_for_auto_writeoff, 0) AS amountForAutoWriteoff
    , b.apply_to_year_month
  FROM @bucketsAll b
  JOIN #payers p on b.payer_id = p.payer_id
  LEFT JOIN #unpostedPayments u ON u.invoice_id = b.invoice_id AND u.payer_id = b.payer_id 
    AND ISNULL(b.apply_to_year_month,-1) = ISNULL(u.apply_to_year_month,-1)


	-- add an entry for where there are unposted payments but there are no buckets (no charges and no payments)
	INSERT INTO #finalCTE (client_id, payer_id, description, invoice_id, amount, balance, distributeAmount
    , type, effDateThru, amountForAutoWriteoff, apply_to_year_month)
  SELECT @clientId
    , u.payer_id
    , p.description
    , u.invoice_id
    , 0 -- amount
    , 0 -- balance
    , -1 * ISNULL(u.amount, 0) as distributeAmount
    , CASE u.invoice_id 
      WHEN -999 THEN 'Marked as Billed' 
      WHEN -3 THEN 'Pre-Transition'
      WHEN -2 THEN 'Unbilled Transactions'
      WHEN -1 THEN 'Unapplied Cash'
      ELSE 
        CASE WHEN payer_type = 'Other' AND bill_form IN ('private','Other') THEN 'Other' ELSE 'Invoice' END 
      END as [type]
    , u.apply_to_year_month
    , ISNULL(u.amount_for_auto_writeoff, 0) AS amountForAutoWriteoff
    , u.apply_to_year_month
  FROM #unpostedPayments u
  JOIN #payers p on u.payer_id = p.payer_id
  LEFT JOIN @bucketsAll b ON u.invoice_id = b.invoice_id AND u.payer_id = b.payer_id 
    AND ISNULL(b.apply_to_year_month,-1) = ISNULL(u.apply_to_year_month,-1)
	where b.payer_id is null

    INSERT INTO #results
    (
        client_id, payer_id, description, invoice_id, amount, balance, distributeAmount, type, effDateThru, amountForAutoWriteoff, apply_to_year_month
    )
    SELECT f.client_id
        , f.payer_id
        , f.[description]
        , f.invoice_id
        , f.amount     -- original invoice total
        , f.balance    -- invoice total less any payments
        , f.distributeAmount
        , f.[type]
        , f.effDateThru
        , f.amountForAutoWriteoff * -1 AS amountForAutoWriteoff
        , f.apply_to_year_month
    FROM #finalCTE f
    -- create Unapplied Row for all payers. 
    UNION ALL
    SELECT DISTINCT @clientId
        , p.payer_id
        , p.[description]
        , -1 AS invoice_id
        , 0 AS amount
        , 0 AS balance
        , CASE
            WHEN up.invoice_id = -1 THEN up.amount * -1
            ELSE 0
          END AS distributeAmount
        , 'Unapplied Cash' AS [type]
        , NULL as effDateThru
        , 0 AS amountForAutoWriteoff
        , NULL AS apply_to_year_month
    FROM #payers p
    LEFT JOIN #finalCTE pWU
        ON p.payer_id = pWU.payer_id
        AND pWU.[type] = 'Unapplied Cash'
    LEFT JOIN #unpostedPayments up
        ON up.invoice_id = -1 AND up.payer_id = p.payer_id
    WHERE pWU.payer_id IS NULL

  IF @payerType = 'private'
  BEGIN

    INSERT INTO #privateInvoices
    (
      parent_linked_invoice_id, client_id, payer_id, description, invoice_id, amount, balance, distributeAmount, type, effDateThru, amountForAutoWriteoff, apply_to_year_month
    )
    SELECT parent_linked_invoice_id, client_id, payer_id, description, invoice_id, amount, balance, distributeAmount, type, effDateThru, amountForAutoWriteoff, apply_to_year_month
    FROM (
      -- parent: private - billed
      SELECT i.parent_linked_invoice_id, max(r.client_id) as client_id, -99999 as payer_id, 'Private/Outpatient' as description, i.parent_linked_invoice_id as invoice_id, sum(amount) as amount,
      SUM(balance) as balance, SUM(distributeAmount) as distributeAmount, MAX(type) as type, r.effDateThru, SUM(amountForAutoWriteoff) as amountForAutoWriteoff, apply_to_year_month
      FROM #results r
      JOIN ar_invoice i on i.invoice_id = r.invoice_id
      GROUP BY i.parent_linked_invoice_id, effDateThru, apply_to_year_month
      UNION ALL
      -- children: private - billed
      SELECT parent_linked_invoice_id, r.client_id, r.payer_id, description, r.invoice_id, amount,
      balance, distributeAmount, type, r.effDateThru, amountForAutoWriteoff, apply_to_year_month
      FROM #results r
      JOIN ar_invoice i on i.invoice_id = r.invoice_id and i.payer_id = r.payer_id
      UNION ALL
      -- parent: unapplied cash
      SELECT invoice_id as parent_linked_invoice_id, max(r.client_id) as client_id, -99999 as payer_id, 'Private/Outpatient' as description, invoice_id, sum(amount) as amount,
      SUM(balance) as balance, SUM(distributeAmount) as distributeAmount, MAX(type) as type, r.effDateThru, SUM(amountForAutoWriteoff) as amountForAutoWriteoff, apply_to_year_month
      FROM #results r
      WHERE invoice_id = - 1
      GROUP BY invoice_id, effDateThru, apply_to_year_month 
      UNION ALL
      -- children: sum: unapplied cash
      SELECT invoice_id as parent_linked_invoice_id, r.client_id, payer_id, r.description, invoice_id, amount,
      balance, distributeAmount, type, r.effDateThru, amountForAutoWriteoff, apply_to_year_month
      FROM #results r
      WHERE invoice_id = -1
      UNION ALL
      -- parent: private - unbilled/mark as billed/pre-transition
      SELECT r.invoice_id as parent_linked_invoice_id, max(r.client_id) as client_id, -99999 as payer_id, 'Private/Outpatient' as description, r.invoice_id, sum(amount) as amount,
      SUM(balance) as balance, SUM(distributeAmount) as distributeAmount, MAX(type) as type, NULL as effDateThru, SUM(amountForAutoWriteoff) as amountForAutoWriteoff, NULL as apply_to_year_month
      FROM #results r
      WHERE r.invoice_id in (-2, -3, -999)
      GROUP BY r.invoice_id
      UNION ALL
      -- mid-level parent: private/mark as billed/pre-transition
      SELECT r.invoice_id as parent_linked_invoice_id, max(r.client_id) as client_id, -99999 as payer_id, 'Private/Outpatient' as description, r.invoice_id, SUM(amount) as amount,
      SUM(balance) as balance, SUM(distributeAmount) as distributeAmount, type, r.effDateThru, sum(amountForAutoWriteoff) as amountForAutoWriteoff, apply_to_year_month
      FROM #results r
      WHERE r.invoice_id in (-2, -3, -999)
      GROUP BY r.invoice_id, type, r.effDateThru, r.apply_to_year_month
      UNION ALL
      -- children: private/mark as billed - unbilled/pre-transition
        SELECT r.invoice_id as parent_linked_invoice_id, r.client_id, r.payer_id, r.description, r.invoice_id, r.amount,
      r.balance, r.distributeAmount, r.type, r.effDateThru, r.amountForAutoWriteoff, r.apply_to_year_month
      FROM #results r
      WHERE r.invoice_id in (-2, -3, -999)
    ) a
  END

    IF @payableInvoicesOnly = 0
    BEGIN
        -- returns list of Invoices
		IF @returnResults IN (0, 2)
        BEGIN
            IF @payerType = 'private'
			BEGIN

			INSERT INTO #resultsFinal
			(
				parent_linked_invoice_id, invoice_id, client_id, payer_id, description, amount, balance, distributeAmount, type, effDateThru, amountForAutoWriteoff, apply_to_year_month
			)
			SELECT parent_linked_invoice_id, invoice_id, client_id, payer_id, description, amount, balance, distributeAmount, type, effDateThru, amountForAutoWriteoff, apply_to_year_month
			FROM #privateInvoices
                        
			SELECT parent_linked_invoice_id, apply_to_year_month AS unbilled_year_month, invoice_id, client_id, payer_id, [description], amount, 
					balance, distributeAmount, totalStmtBalRemaining, [type], effDateThru, generated_date, amountForAutoWriteoff
					FROM #resultsFinal
			ORDER BY client_id,
				CASE WHEN invoice_id = -3 THEN 0 WHEN invoice_id = -999 THEN 1 WHEN invoice_id > 0 OR invoice_id is NULL THEN 2 WHEN invoice_id = -2 THEN 3 WHEN invoice_id = -1 THEN 4 END,
				CASE WHEN invoice_id > 0 or invoice_id is NULL THEN effDateThru ELSE apply_to_year_month END, parent_linked_invoice_id, CASE WHEN payer_id = -99999 THEN 1 ELSE 2 END, description, invoice_id
			END
		ELSE
		  BEGIN
			INSERT INTO #resultsFinal
			(
			  invoice_id, client_id, payer_id, description, amount, balance, distributeAmount, type, effDateThru, amountForAutoWriteoff, apply_to_year_month
			)
			SELECT invoice_id, client_id, payer_id, description, amount, balance, distributeAmount, type, effDateThru, amountForAutoWriteoff, apply_to_year_month
			FROM #results
			UNION ALL
			SELECT  invoice_id as invoice_id, client_id, payer_id, description, SUM(amount) as amount, SUM(balance) as balance,
					SUM(distributeAmount) as distributeAmount, MAX(type) as type, null as effDateThru,
					SUM(amountForAutoWriteoff) as amountForAutoWriteoff, NULL as apply_to_year_month
			FROM #results
			WHERE invoice_id in (-2, -3, -999)
			GROUP BY client_id, payer_id, description, invoice_id

			SELECT parent_linked_invoice_id, apply_to_year_month AS unbilled_year_month, invoice_id, client_id, payer_id, [description], amount, 
				   balance, distributeAmount, totalStmtBalRemaining, [type], effDateThru, generated_date, amountForAutoWriteoff 
			FROM #resultsFinal
			ORDER BY client_id, payer_id, CASE WHEN invoice_id = -3 THEN 0 WHEN invoice_id = -999 THEN 1 WHEN invoice_id > 0 THEN 2 WHEN invoice_id = -2 THEN 3 WHEN invoice_id = -1 THEN 4 END, 
			CASE WHEN invoice_id > 0 THEN effDateThru ELSE apply_to_year_month END, invoice_id
		  END
      END
    END
    ELSE
    BEGIN
		IF @payerType = 'private'
		BEGIN
		
			;WITH statementWithBalance AS
			(
			  SELECT parent_linked_invoice_id, SUM(balance) AS totalStmtBalRemaining
			  FROM #privateInvoices
			  WHERE payer_id <> -99999
			  GROUP BY parent_linked_invoice_id
			  HAVING SUM(balance) <> 0
			)
			-- return payableInvoices only if they belong to statements with non-credit balance
			INSERT INTO #resultsFinal
			(
			  client_id, payer_id, description, apply_to_year_month, invoice_id, amount, balance, distributeAmount, type, effDateThru, amountForAutoWriteoff, generated_date, parent_linked_invoice_id, totalStmtBalRemaining
			)
				SELECT r.client_id
					, r.payer_id
					, r.[description]
					, r.apply_to_year_month
					, r.invoice_id
					, r.amount     -- original invoice total
					, r.balance    -- invoice total less any payments
					, r.distributeAmount
					, r.[type]
					, r.effDateThru
					, r.amountForAutoWriteoff * -1 AS amountForAutoWriteoff
					, DATEFROMPARTS(YEAR(ais.generated_date),MONTH(ais.generated_date),DAY(ais.generated_date)) AS generated_date
			        , r.parent_linked_invoice_id
					, s.totalStmtBalRemaining
				FROM #privateInvoices r
			JOIN statementWithBalance s
			  ON r.parent_linked_invoice_id = s.parent_linked_invoice_id
			LEFT JOIN ar_invoice_statement ais ON ais.invoice_id = r.invoice_id
			WHERE r.balance <> 0 
			AND (r.invoice_id > 0 
				OR (r.invoice_id = -2 AND apply_to_year_month < @currentPostingDate) -- exclude current & future posting period unbilled transactions
				OR r.invoice_id = -3) 
			AND r.payer_id <> -99999
		END
		ELSE
		BEGIN
		    -- pay from trust: returns only invoices with balance and excludes parent rows
			INSERT INTO #resultsFinal
			(
			  invoice_id, client_id, payer_id, description, amount, balance, distributeAmount, type, effDateThru, amountForAutoWriteoff, apply_to_year_month
			)
			SELECT invoice_id, client_id, payer_id, description, amount, balance, distributeAmount, type, effDateThru, amountForAutoWriteoff, apply_to_year_month
			FROM #results
			WHERE balance <> 0 
				AND (invoice_id > 0 
				OR (invoice_id = -2 AND apply_to_year_month < @currentPostingDate) -- exclude current & future posting period unbilled transactions
				OR invoice_id = -3) 	
		END
		
		IF @returnResults IN (0, 2, 3)
        BEGIN
            SELECT r.client_id, r.payer_id, r.[description], CASE WHEN invoice_id < 0 THEN r.apply_to_year_month ELSE NULL END AS unbilled_year_month, r.invoice_id, r.amount, r.balance, r.distributeAmount, r.[type], r.effDateThru, r.amountForAutoWriteoff, r.generated_date, r.parent_linked_invoice_id, r.totalStmtBalRemaining
            FROM #resultsFinal r
            ORDER BY r.client_id, 
					CASE WHEN r.invoice_id = -3 THEN 1 WHEN r.invoice_id > 0 THEN 2 WHEN r.invoice_id = -2 THEN 3 ElSE 4 END, -- pre-transition -> post-transition -> unbilled
					r.effDateThru, r.generated_date, r.parent_linked_invoice_id, r.totalStmtBalRemaining DESC, CASE WHEN r.balance < 0 THEN 1 ELSE 2 END, r.balance DESC
        END
    END

    -- return totals
    IF @returnResults IN (1, 2, 3)
    BEGIN

        SELECT ISNULL(SUM(amount),0) AS TotalAmount
                , ISNULL(SUM(balance),0) AS TotalBal
                , ISNULL(SUM(distributeAmount),0) AS TotalUnpostedAmount
                , ISNULL(SUM(amountForAutoWriteoff),0) AS TotalAmountForAutoWriteOff
        FROM #resultsFinal
        WHERE 
            (payer_id <> -99999 AND @payerType = 'private')
            OR ((ISNULL(@payerType,'') <> 'private' AND ((invoice_id < -1 AND apply_to_year_month IS NOT NULL) OR invoice_id >= -1)))
    END

    -- return unposted payments
    IF @returnResults IN (2, 3)
    BEGIN

  DECLARE @preTransitionUnpostByTransaction TABLE
  (
    transaction_id int,
    amount DECIMAL(20,2),
    apply_to_year_month DATETIME
  )

  IF @catdDate IS NOT NULL
  BEGIN

    insert into @preTransitionUnpostByTransaction (transaction_id, amount, apply_to_year_month)
    SELECT transaction_id
    , amount
    , apply_to_year_month
    from @appliedPaymentUnpostAll
	where amount <> 0
    UNION ALL
    SELECT transaction_id
    , -1 * sum(amount)
    , apply_to_year_month
    from @unappliedCashUnpostAll
	GROUP BY apply_to_year_month, transaction_id
    HAVING SUM(amount) <> 0
    UNION ALL
    SELECT transaction_id, -1 * SUM(amount), apply_to_year_month
    FROM @postTransitionUnpostAll
    GROUP BY apply_to_year_month, transaction_id
    HAVING SUM(amount) <> 0

  END

    select 
      p.invoice_id
      , CASE WHEN invoice_id > 0 THEN NULL ELSE p.apply_to_year_month END AS unbilled_year_month
      , sum(p.amount) amount
      , up.batch_number
      , up.entry_number 
    from @postTransitionUnpostAll p
  join @allUnpostTransactions up on p.transaction_id = up.transaction_id
    group by p.invoice_id, CASE WHEN p.invoice_id > 0 THEN NULL ELSE p.apply_to_year_month END, up.batch_number, up.entry_number
    HAVING SUM(p.amount) <> 0
    UNION ALL
    SELECT  
      -3 AS invoice_id
      , p.apply_to_year_month AS unbilled_year_month
      , sum(p.amount) amount
      , up.batch_number
      , up.entry_number 
    FROM @preTransitionUnpostByTransaction p
  join @allUnpostTransactions up on p.transaction_id = up.transaction_id    
  GROUP BY p.apply_to_year_month, up.batch_number, up.entry_number
    HAVING SUM(p.amount) <> 0
    ORDER BY batch_number, entry_number

  END

END TRY
BEGIN CATCH
  SELECT @error_code = @@error, @status_text = ERROR_MESSAGE()
  SELECT @status_code = 1
  GOTO PgmAbend
END CATCH

--program success return
PgmSuccess:
BEGIN
  IF @status_code = 0 AND @debug='Y'
    PRINT 'Successful execution of stored procedure'
END

--program failure return
PgmAbend:
BEGIN
  IF @status_code = 1 AND @debug='Y'
  BEGIN
    PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '     ' + convert(varchar(26),getdate())
    PRINT 'Error code: '+convert(varchar(3),@step) + '; Error description:      ' + @status_text
  END
END
GO

GRANT EXECUTE ON dbo.sproc_admin_list_getAgingByInvoice_1 TO PUBLIC
GO

SET ANSI_NULLS OFF
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_admin_list_getAgingByInvoice_1.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_admin_list_getAgingByInvoice_1.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_cash_data_integrity_check.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- =================================================================================
-- Jira #:               CORE-62293
--
-- Written By:           Justin Pitters

-- Reviewed By:          David Bretzlaff
--
-- Script Type:          DML
-- Target DB Type:       CLIENT
-- Target ENVIRONMENT:   BOTH
--
--
-- Re-Runable:           YES
--
-- Where tested:         172.16.10.119,1689 (Optimystic DEV DB)
--						 ORG: agrd
--
-- Staging Recommendations/Warnings:
--
-- Description of Script Function:
-- Run validations against the new open item cash tables to verify integrity of the data.

/*
    SAMPLE EXECUTION:

    STEPS:

    010. Get the change tracking version and run id at the time the job was previously run
    020. Get the current change tracking version
    030. Get list of transactions that have changed since the last job run
    040. Do validation checks
	     041. Validate paid_status_code for changed transactions
		 042. Validate amount in changed cash transaction matches with applied payment history
		 043. Validate cash transaction amount matches applied + unapplied cash
    050. Insert new record into data integrity job run table
    060. Insert invalid charges into error summary table
    070. Insert invalid charges into error detail table
*/


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

IF EXISTS (SELECT 1 FROM sysobjects WHERE id = object_id(N'sproc_ar_cash_data_integrity_check'))
BEGIN
    DROP PROCEDURE sproc_ar_cash_data_integrity_check
END
GO

CREATE PROCEDURE sproc_ar_cash_data_integrity_check
(
      @DebugMe CHAR(1) = 'N'
    , @status_code int  out
    , @status_text varchar(3000) out
)
AS
BEGIN

    SET NOCOUNT ON

    DECLARE @debug bit = 0
    DECLARE @step VARCHAR(5) = '0'

    IF @debugMe = 'Y'
    BEGIN
	    SET @debug = 1
    END

    CREATE TABLE #changedTransactions
    (
      transaction_id INT NOT NULL,
      amount MONEY NOT NULL,
      paid_status_code CHAR(1) NULL,
      change_version BIGINT NOT NULL,
      change_operation NCHAR(1) NOT NULL,
      deleted CHAR NOT NULL,
	  trust_amount MONEY NULL,
	  transaction_type VARCHAR(2) NULL,
	  distribution_tx_id INT NULL,
	  payer_id INT NULL,
	  client_id INT NULL,
      INDEX #changedTransactions__transactionId_CL_IX CLUSTERED (transaction_id)
    )

    CREATE TABLE #changedCashTransactions
    (
      transaction_id INT NOT NULL,
      amount MONEY NOT NULL,
      paid_status_code CHAR(1) NULL,
      change_version BIGINT NOT NULL,
      change_operation NCHAR(1) NOT NULL,
      deleted CHAR NOT NULL,
	  trust_amount MONEY NULL,
	  transaction_type VARCHAR(2) NULL,
	  distribution_tx_id INT NULL,
	  payer_id INT NULL,
	  client_id INT NULL,
	  include_transaction_payment_set bit default 0,
      INDEX #changedCashTransactions__transactionId_CL_IX CLUSTERED (transaction_id)
    )

	CREATE TABLE #appliedPaymentHistoryTemp
    (
	  applied_payment_id INT NOT NULL,
      transaction_id INT NOT NULL,
      deleted CHAR NOT NULL,
	  payer_id INT NULL,
	  client_id INT NULL,
      amount MONEY NOT NULL,
	  include_transaction_payment bit default 0,
	  INDEX #appliedPaymentHistoryTemp__appliedPaymentId_CL_IX CLUSTERED (applied_payment_id)
	)
	
    CREATE TABLE #errorDetails
    (
      transaction_id INT NOT NULL,
      transaction_amount MONEY NOT NULL,
      transaction_payment_total MONEY NULL,
      paid_status_code CHAR(1) NULL,
	  validation_type_id INT NOT NULL,
	  applied_payment_total MONEY NULL,
	  unapplied_cash_total MONEY NULL
    )

    CREATE TABLE #changedCharges
    (
        transaction_id INT,
        transaction_amount MONEY,
        transaction_payment_total MONEY,
        paid_status_code CHAR(1)
    )

	DECLARE @errorIdTable TABLE (error_id INT, validation_type_id INT)

    BEGIN TRY

        --------------------------------------------------
        -- 010. Get the change tracking version and run id at the time the job was previously run
        --------------------------------------------------
        SET @step = '010'

        DECLARE @previousChangeTrackingVersion bigint = null
        DECLARE @currentRunId TABLE (run_id INT)
        SELECT @previousChangeTrackingVersion = change_tracking_version
        FROM
        (
            SELECT top 1 change_tracking_version
            FROM ar_cash_data_integrity_job_run
            ORDER BY change_tracking_version DESC
        ) x

        --------------------------------------------------
        -- 020. Get the current change tracking version
        --------------------------------------------------
        SET @step = '020'

        DECLARE @currentChangeTrackingVersion BIGINT = (SELECT CHANGE_TRACKING_CURRENT_VERSION())

        IF @debug = 1
        BEGIN
            SELECT '@previousChangeTrackingVersion', @previousChangeTrackingVersion
            SELECT '@currentChangeTrackingVersion', @currentChangeTrackingVersion
        END

        --------------------------------------------------
        -- 030. Get list of transactions that have changed since the last job run
        --------------------------------------------------
        SET @step = '030'

        CREATE TABLE #tmpChanged (transaction_id INT, change_version BIGINT, change_operation NCHAR)
        INSERT INTO #tmpChanged (transaction_id, change_version, change_operation)
        SELECT transaction_id, change_version, change_operation
        FROM dbo.fn_ar_getChangedTransactions(@previousChangeTrackingVersion)

        INSERT INTO #changedTransactions (
			transaction_id, amount, paid_status_code, change_version, change_operation, deleted, trust_amount, transaction_type,
			distribution_tx_id, payer_id, client_id
		)
        SELECT 
			ct.transaction_id, t.amount, t.paid_status_code, ct.change_version, ct.change_operation, t.deleted, ISNULL(t.trust_amount, 0), t.transaction_type,
			t.distribution_tx_id, t.payer_id, t.client_id
        FROM #tmpChanged ct
        JOIN ar_transactions t with(NOLOCK) on t.transaction_id = ct.transaction_id
        WHERE t.transaction_date IS NOT NULL
			AND t.deleted = 'N'
			AND t.payer_id IS NOT NULL

        IF @debug = 1
        BEGIN
            SELECT '#changedTransactions', * FROM #changedTransactions
        END

		SET @step = '040'
        
		--------------------------------------------------
        -- 041. Validate paid_status_code for changed transactions
        --------------------------------------------------
		SET @step = '041'
		
		DECLARE @paidStatusTypeId INT = (SELECT validation_type_id FROM ar_cash_data_integrity_validation_type WHERE name='paid_status_code_check')
		
        INSERT INTO #changedCharges (transaction_id, transaction_amount, transaction_payment_total, paid_status_code)
        SELECT charge.transaction_id as transaction_id, max(charge.amount) as transaction_amount,
	            sum(map.amount) as transaction_payment_total, max(charge.paid_status_code) as paid_status_code
        FROM #changedTransactions charge
        LEFT JOIN ar_transactions_payment map with(NOLOCK) on charge.transaction_id = map.charge_transaction_id
        WHERE map.posting_date IS NOT NULL
        GROUP BY charge.transaction_id
        
        ; WITH invalidCharges AS
        (
	            SELECT *, CASE WHEN (#changedCharges.transaction_amount + ISNULL(#changedCharges.transaction_payment_total,0)) = 0  THEN 'F'
	                           WHEN (#changedCharges.transaction_amount + ISNULL(#changedCharges.transaction_payment_total,0)) = #changedCharges.transaction_amount THEN 'N'
                               ELSE 'P' END
		        as recalculated_status
	            FROM #changedCharges
        )
        INSERT INTO #errorDetails (validation_type_id, transaction_id, transaction_amount, transaction_payment_total, paid_status_code)
        SELECT @paidStatusTypeId, transaction_id, transaction_amount, transaction_payment_total, paid_status_code
        FROM invalidCharges
        WHERE ISNULL(paid_status_code,'N') <> invalidCharges.recalculated_status

		-------------------------------------------------------------------------
        -- 042. Validate cash transaction amount matches applied payment history
        -------------------------------------------------------------------------
		SET @step = '042'

		INSERT INTO #changedCashTransactions(
			transaction_id, amount, paid_status_code, change_version, change_operation, deleted, trust_amount, transaction_type,
			distribution_tx_id, payer_id, client_id
		)
        SELECT 
			transaction_id, amount, paid_status_code, change_version, change_operation, deleted, trust_amount, transaction_type,
			distribution_tx_id, payer_id, client_id
		FROM #changedTransactions 
		WHERE transaction_type='C'

		INSERT INTO #appliedPaymentHistoryTemp
			(applied_payment_id, transaction_id, deleted, payer_id, client_id, amount, include_transaction_payment)	
		SELECT h.applied_payment_id,h.transaction_id, h.deleted, h.payer_id, h.client_id, h.amount, include_transaction_payment
		FROM ar_applied_payment_history h with(NOLOCK) 
		JOIN #changedCashTransactions t ON h.transaction_id=t.transaction_id
		WHERE h.deleted='N'
		
		-- remove trust transfer
		DELETE FROM tfer
		FROM #changedCashTransactions tfer
		INNER JOIN dbo.ar_transactions ptx with(NOLOCK)
			ON tfer.distribution_tx_id = ptx.transaction_id	
				AND tfer.transaction_id <> ISNULL(tfer.distribution_tx_id, tfer.transaction_id)
		LEFT JOIN #appliedPaymentHistoryTemp pay with(NOLOCK)
			ON tfer.transaction_id = pay.transaction_id
		WHERE pay.transaction_id IS NULL
			AND ptx.deleted = 'N' 
			AND ptx.payer_id = tfer.payer_id
			AND ptx.client_id = tfer.client_id
			AND ptx.trust_amount<>0

		-- Handle batch created before include_transaction_payment introduced
		UPDATE t set t.include_transaction_payment_set = 1 
		from #changedCashTransactions t
		join #appliedPaymentHistoryTemp h on h.include_transaction_payment = 1 and t.transaction_id = h.transaction_id
		
		DECLARE @txAndAppliedPaymentTypeId INT = (SELECT validation_type_id FROM ar_cash_data_integrity_validation_type WHERE name='cash_transaction_match_applied_payment_history_check')
		
		INSERT INTO #errorDetails (validation_type_id, transaction_id, transaction_amount, applied_payment_total)
		SELECT @txAndAppliedPaymentTypeId, t.transaction_id, (MAX(t.amount) - MAX(t.trust_amount)) AS transaction_amount, isnull(SUM(aph.amount),0) * -1 AS applied_payment_total
		FROM #changedCashTransactions t 
		LEFT JOIN #appliedPaymentHistoryTemp aph
			ON aph.transaction_id = t.transaction_id
		GROUP BY t.transaction_id
		HAVING (MAX(t.amount) - MAX(t.trust_amount)) <> (ISNULL(SUM(aph.amount),0) * -1)
		
        IF @debug = 1
        BEGIN
            SELECT '#errorDetails', * FROM #errorDetails
        END

		-------------------------------------------------------------------------
        -- 043. Validate cash transaction amount matches applied + unapplied cash
        -------------------------------------------------------------------------
		SET @step = '043'
				
		DECLARE @txAndCashPaymentTypeId INT = (SELECT validation_type_id FROM ar_cash_data_integrity_validation_type WHERE name='cash_match_applied_payment_with_unapplied_cash_check')
		
		INSERT INTO #errorDetails (validation_type_id, transaction_id, transaction_amount, applied_payment_total, transaction_payment_total, unapplied_cash_total)
		SELECT @txAndCashPaymentTypeId, transaction_id, 0, SUM(cash_amount) AS applied_payment_total, 
				SUM(payment_amount) AS transaction_payment_total, SUM(unapplied_cash) AS unapplied_cash_total
		FROM (
			-- All payments for open cash
			SELECT t.transaction_id, 0 AS cash_amount, ISNULL(SUM(p.amount),0) * -1 AS payment_amount, 0 AS unapplied_cash
			FROM #changedCashTransactions t
				LEFT JOIN ar_transactions_payment p
						ON t.transaction_id = p.payment_transaction_id AND t.include_transaction_payment_set = 1
			GROUP BY t.transaction_id
			union ALL
			-- All un-applied cash
			SELECT t.transaction_id, 0 AS cash_amount, 0 AS payment_amount, ISNULL(SUM(u.amount),0) * -1 AS unapplied_cash
			FROM #changedCashTransactions t
				JOIN ar_unapplied_cash u
						ON t.transaction_id = u.transaction_id and u.is_post_transition = 1 and t.include_transaction_payment_set = 1
			GROUP BY t.transaction_id
			UNION ALL
			-- All cash for open cash 
			SELECT t.transaction_id, ISNULL(SUM(h.amount), 0)  AS cash_amount, 0 AS payment_amount, 0 AS unapplied_cash
			from #changedCashTransactions t
			left JOIN #appliedPaymentHistoryTemp h 
				on h.transaction_id = t.transaction_id and h.include_transaction_payment = 1 AND t.include_transaction_payment_set = 1
			GROUP by t.transaction_id
		) a
		GROUP BY a.transaction_id
		Having SUM(cash_amount) <> (SUM(a.payment_amount) + SUM(unapplied_cash))
		
        IF @debug = 1
        BEGIN
            SELECT '#errorDetails', * FROM #errorDetails
        END

        BEGIN TRAN
            --------------------------------------------------
            -- 050. Insert new record into data integrity job run table
            --------------------------------------------------
            SET @step = '050'

            INSERT INTO ar_cash_data_integrity_job_run (run_by, run_date, change_tracking_version)
            OUTPUT INSERTED.run_id into @currentRunId
            VALUES ('_system_', getDate(), @currentChangeTrackingVersion)

            IF @debug = 1
            BEGIN
                SELECT 'Updated job runs', * FROM ar_cash_data_integrity_job_run ORDER BY run_id DESC
            END

            IF EXISTS (SELECT 1 FROM #errorDetails)
            BEGIN

                --------------------------------------------------
                -- 060. Insert into error summary table
                --------------------------------------------------
                SET @step = '060'

				DECLARE @maxRunId INT = (SELECT MAX(run_id) FROM @currentRunId)
				
                INSERT INTO ar_cash_data_integrity_error_summary(run_id, validation_type_id, error_count)
                OUTPUT INSERTED.error_id, INSERTED.validation_type_id into @errorIdTable
                SELECT @maxRunId, validation_type_id, count(transaction_id) FROM #errorDetails GROUP BY validation_type_id
				
                --------------------------------------------------
                -- 070. Insert into error detail table
                --------------------------------------------------
                SET @step = '070'

                INSERT INTO ar_cash_data_integrity_error_detail 
					(error_id, transaction_id, transaction_amount, transaction_payment_total, applied_payment_total, unapplied_cash_total, paid_status_code)
                SELECT ei.error_id, transaction_id, transaction_amount, transaction_payment_total, applied_payment_total, unapplied_cash_total, paid_status_code
                FROM #errorDetails ed
				JOIN @errorIdTable ei
					ON ed.validation_type_id = ei.validation_type_id

            END

        IF @debug = 1
        BEGIN
            SELECT 'ar_cash_data_integrity_error_summary', * FROM ar_cash_data_integrity_error_summary ORDER BY error_id DESC
            SELECT 'ar_cash_data_integrity_error_detail', * FROM ar_cash_data_integrity_error_detail ORDER BY error_detail_id DESC
        END

        COMMIT TRAN
    END TRY
    BEGIN CATCH
        IF @@trancount > 0 ROLLBACK TRAN
        SELECT @status_text = IIF(@status_text IS NULL, 'ERROR on step' + @step + '. ', '') + ERROR_MESSAGE()
             , @status_code = 1;
        IF @debug=1
            Print 'Stored procedure failure in step: ' + @step + '; Error description:  ' + @status_text
        ;THROW 50001, @status_text, 1;
    END CATCH

END
GO

GRANT EXECUTE ON sproc_ar_cash_data_integrity_check TO PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_cash_data_integrity_check.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_cash_data_integrity_check.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_dml_createCustomRecurringChargeRateDateRange.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*****************************************************************************************************
  Created By:		Dmitry Strelbytsky
  Created Date:	    October 25, 2016
  
  Reviewed By:

  Target DB Type:       CLIENT
  Target ENVIRONMENT:   BOTH

  Description:          Create new ar_custom_recurring_charge_rates_date_range and related ar_custom_recurring_charge_rates_detail.

					 
*****************************************************************************************************/
IF EXISTS (SELECT 1 FROM sysobjects WHERE name = 'sproc_ar_dml_createCustomRecurringChargeRateDateRange') 
      DROP procedure sproc_ar_dml_createCustomRecurringChargeRateDateRange
GO

CREATE PROCEDURE sproc_ar_dml_createCustomRecurringChargeRateDateRange 
( 
 @facId int,
 @eff_date datetime,
 @chargeCodeIds varchar(4000),
 @user varchar(60),
 @current datetime,
 @byAniversary bit,
 @includeCustomRate bit,
 @includeStdRate bit,
 @debug          char(1)  = 'N',
 @status_code    int  out, 
 @status_text    varchar(3000) out
)
AS
BEGIN

  SET nocount ON
  
  DECLARE @step varchar(4),
          @error_code int
          
  SELECT @status_code = 0
    
  BEGIN TRY  
	DECLARE @recurring_charges_to_change table
	(
		transaction_id INT,
		client_id INT, 
		charge_code_id INT,
		sbb_package_id INT,
		units DECIMAL (8,2),
		prev_rate MONEY,
		prev_amount MONEY,
		frequency CHAR(1),
		new_rate MONEY,
		new_amount MONEY,
		anniversary_date SMALLDATETIME,
		is_cc_active_date_range BIT,
		is_customized BIT,
		service_level_description VARCHAR(100)
	)

	DECLARE @selectedChargeCodes table
	(
		charge_code_id int
	)

	DECLARE @eff_date_nextday datetime
	SET @eff_date_nextday = DATEADD(day, datediff(day, 0, @eff_Date) + 1, 0)
		
	BEGIN TRAN
    
	SET @step = '1'
    IF(@debug='Y') 
    BEGIN 
      PRINT 'BEGIN STEP ' + @step + ': insert all charge codes into temp table ' + CONVERT(varchar(26),getdate(),109) 
    END 

	INSERT INTO @selectedChargeCodes (charge_code_id) 
		SELECT items FROM split(@chargeCodeIds, ',') 
			
    SET @step = '2'
    IF(@debug='Y') 
    BEGIN 
      PRINT 'BEGIN STEP ' + @step + ': get effected regular and additional services recurring charges ' + CONVERT(varchar(26),getdate(),109) 
    END 

	INSERT INTO @recurring_charges_to_change (transaction_id, client_id, charge_code_id, units, prev_rate, prev_amount, 
				frequency, new_rate, new_amount, is_cc_active_date_range, is_customized)
	SELECT rt.transaction_id, rt.client_id, rt.item_type_id, rt.days_amount, rt.daily_rate, rt.amount, rt.charge_frequency, 
		dr.amount as new_rate, dr.amount*rt.days_amount as new_amount,
		CASE WHEN dr.amount IS NULL THEN 0 ELSE 1 END, 0
	FROM ar_recurring_transactions  rt
	JOIN @selectedChargeCodes scc ON scc.charge_code_id = rt.item_type_id
	LEFT JOIN ar_item_date_range dr ON rt.item_type_id = dr.item_type_id AND dr.fac_id = @facId 
		AND (dr.effective_date < @eff_date_nextday) AND DATEADD(day, datediff(day, 0, ISNULL(dr.ineffective_date, '9999-12-31')), 0) >= @eff_date
	LEFT JOIN ar_sbb_client_service_package_detail spd ON rt.transaction_id = spd.recurring_transaction_id
	WHERE   (rt.fac_id = @facId)
	        AND (rt.deleted IS NULL OR rt.deleted = 'N')
			AND DATEADD(day, datediff(day, 0, ISNULL(rt.ineffective_date, '9999-12-31')), 0) >= @eff_date
			AND spd.recurring_transaction_id IS NULL
			
	SET @step = '3'
    IF(@debug='Y') 
    BEGIN 
      PRINT 'BEGIN STEP ' + @step + ': update additional services recurring charges with service package id ' + CONVERT(varchar(26),getdate(),109) 
    END
	
	UPDATE rcc SET rcc.sbb_package_id = adds.sbb_package_id
	FROM @recurring_charges_to_change rcc
	LEFT JOIN ar_sbb_client_additional_service adds ON rcc.transaction_id = adds.recurring_transaction_id 
	WHERE adds.recurring_transaction_id IS NOT NULL

	SET @step = '4'
	IF(@debug='Y') 
	BEGIN 
	  PRINT 'BEGIN STEP ' + @step + ': update customized flag for regular and additional services recurring charges ' + CONVERT(varchar(26),getdate(),109) 
	END
	UPDATE rcc SET is_customized = 1
	FROM @recurring_charges_to_change rcc
	JOIN ar_recurring_transactions  rt ON rt.transaction_id=rcc.transaction_id
	LEFT JOIN ar_item_date_range dr ON rt.item_type_id = dr.item_type_id AND dr.fac_id = @facId 
	WHERE (rt.fac_id = @facId)
			AND (rt.deleted IS NULL OR rt.deleted = 'N')
			AND (dr.effective_date <=rt.effective_date) AND DATEADD(day, datediff(day, 0, ISNULL(dr.ineffective_date, '9999-12-31')), 0) >= rt.effective_date
			AND rt.daily_rate<>dr.amount	
			 
    SET @step = '5'
    IF(@debug='Y') 
    BEGIN 
      PRINT 'BEGIN STEP ' + @step + ': get effected service package (except additional services) created recurring charges ' + CONVERT(varchar(26),getdate(),109) 
    END 

	INSERT INTO @recurring_charges_to_change (transaction_id, client_id, charge_code_id, sbb_package_id, units, prev_rate, prev_amount, 
				frequency, new_rate, new_amount, is_cc_active_date_range, is_customized, service_level_description)
	SELECT rt.transaction_id, rt.client_id, rt.item_type_id, cspd.sbb_package_id,
		cspd.units, cspd.custom_rate, rt.amount, rt.charge_frequency, 
		sldr.amount as new_rate, sldr.amount*cspd.units as new_amount,
		CASE WHEN sldr.amount IS NULL THEN 0 ELSE 1 END,
		cspd.use_custom_rate, sldr.description
	FROM ar_recurring_transactions  rt
	JOIN @selectedChargeCodes scc ON scc.charge_code_id = rt.item_type_id
	JOIN ar_sbb_client_service_package_detail cspd ON rt.transaction_id = cspd.recurring_transaction_id
	JOIN ar_lib_sbb_service_level sl ON cspd.sbb_service_level_id = sl.sbb_service_level_id
	LEFT JOIN ar_sbb_service_category_date_range cdr ON cdr.sbb_service_category_id = sl.sbb_service_category_id AND cdr.fac_id = @facId
		AND (cdr.effective_date < @eff_date_nextday) AND DATEADD(day, datediff(day, 0, ISNULL(cdr.ineffective_date, '9999-12-31')), 0) >= @eff_date
	LEFT JOIN ar_sbb_service_level_date_range sldr ON cdr.sbb_date_range_id = sldr.sbb_date_range_id
	WHERE   (rt.fac_id = @facId)
	         AND (rt.deleted IS NULL OR rt.deleted = 'N')
			 AND DATEADD(day, datediff(day, 0, ISNULL(rt.ineffective_date, '9999-12-31')), 0) >= @eff_date
			 AND  (sldr.sbb_service_level_id is null or sldr.sbb_service_level_id = cspd.sbb_service_level_id)

	IF @includeStdRate <> 1
	BEGIN
	    SET @step = '6'
	    IF(@debug='Y') 
	    BEGIN 
	      PRINT 'BEGIN STEP ' + @step + ': filter out records based on standard rate ' + CONVERT(varchar(26),getdate(),109) 
	    END
		DELETE rcc FROM @recurring_charges_to_change rcc
		WHERE is_customized = 0
	END

	IF @includeCustomRate <> 1
	BEGIN
	    SET @step = '6.1'
	    IF(@debug='Y') 
	    BEGIN 
	      PRINT 'BEGIN STEP ' + @step + ': filter out records based on custom rate ' + CONVERT(varchar(26),getdate(),109) 
	    END
		DELETE rcc FROM @recurring_charges_to_change rcc
		WHERE is_customized = 1
	END

	SET @step = '7'
    IF(@debug='Y') 
    BEGIN 
      PRINT 'BEGIN STEP ' + @step + ': retrieve anniversary date information ' + CONVERT(varchar(26),getdate(),109) 
    END
	
	UPDATE rc SET rc.anniversary_date = rla.anniversary_date
	FROM @recurring_charges_to_change rc
	JOIN rentroll_lease_agreement rla ON rc.client_id = rla.client_id AND rla.anniversary_date IS NOT NULL
	WHERE (rla.lease_start_date <= @eff_date) AND DATEADD(day, datediff(day, 0, ISNULL(rla.lease_end_date, '2079-06-06')), 0) >= @eff_date
    
	IF @byAniversary = 1
	BEGIN
	    SET @step = '7.1'
	    IF(@debug='Y') 
	    BEGIN 
	      PRINT 'BEGIN STEP ' + @step + ': filter out records based on anniversary date ' + CONVERT(varchar(26),getdate(),109) 
	    END
		DELETE FROM @recurring_charges_to_change 
		WHERE anniversary_date IS NULL OR (DATEPART(MONTH, anniversary_date) != DATEPART(MONTH, @eff_date)) OR (DATEPART(DAY, anniversary_date) != DATEPART(DAY, @eff_date))
	END

	SET @step = '8'
	IF(@debug='Y') 
	BEGIN
		PRINT 'BEGIN STEP ' + @step + ': insert into ar_custom_recurring_charge_rates_date_range ' + CONVERT(varchar(26),getdate(),109)
	END 
		
	INSERT INTO ar_custom_recurring_charge_rates_date_range (fac_id, effective_date, applied, deleted, 
	use_anniversary_date_flag, created_by, created_date, revision_by, revision_date)
	VALUES (@facId, @eff_date, 0, 'N', @byAniversary, @user, @current, @user, @current)
	
	SET @step = '9'
	IF(@debug='Y') 
	BEGIN
		PRINT 'BEGIN STEP ' + @step + ': retrieve the primary key of the last step ' + CONVERT(varchar(26),getdate(),109)
	END 
		
	DECLARE @dateRangeId int
	
	SET @dateRangeId = SCOPE_IDENTITY()
	
	SET @step = '10'
	IF(@debug='Y') 
	BEGIN
		PRINT 'BEGIN STEP ' + @step + ': insert the charge code information for the new custom date range ' + CONVERT(varchar(26),getdate(),109)
	END
	    
	INSERT INTO ar_custom_recurring_charge_rates_date_range_charge_code (eff_date_range_id, charge_code_id)
	SELECT @dateRangeId, charge_code_id FROM @selectedChargeCodes 
	
	SET @step = '11'
	IF(@debug='Y') 
	BEGIN
		PRINT 'BEGIN STEP ' + @step + ': insert the new custom recurring charge rate detail ' + CONVERT(varchar(26),getdate(),109)
	END
		
	INSERT INTO ar_custom_recurring_charge_rates_detail (eff_date_range_id, client_id, charge_code_id, transaction_id, sbb_package_id, units, prev_rate, prev_amount, 
	frequency, new_rate, new_amount, client_anniversary_date, charge_code_active_date_range, service_level_description)
	SELECT @dateRangeId, client_id, charge_code_id, transaction_id, sbb_package_id, units, prev_rate, prev_amount,
	frequency, new_rate, new_amount, anniversary_date, is_cc_active_date_range, service_level_description
	FROM @recurring_charges_to_change

    SET @status_code = 0
    SELECT @dateRangeId
    GOTO PgmSuccess
  
  END TRY
  BEGIN CATCH
    SELECT @error_code = @@error, @status_text = ERROR_MESSAGE()
    SELECT @status_code = 1
    GOTO PgmAbend
  END CATCH
      
  --program success return
  PgmSuccess:
  BEGIN
  	IF @@TRANCOUNT > 0 
		COMMIT
    IF @status_code = 0 AND @debug='Y' 
      PRINT 'Successfull execution of stored procedure'	
  END
  
  --program failure return
  PgmAbend:
  BEGIN
	IF @@TRANCOUNT > 0
		ROLLBACK  
    IF @status_code = 1 AND @debug='Y'
    BEGIN
      PRINT 'Stored procedure failure in step: '+ @step + '	' + convert(varchar(26),getdate())
      PRINT 'Error code: '+ cast(@error_code as varchar(30)) + '; Error description: ' +@status_text
    END 
  END  
  
END
GO

GRANT EXECUTE ON sproc_ar_dml_createCustomRecurringChargeRateDateRange TO PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_dml_createCustomRecurringChargeRateDateRange.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_dml_createCustomRecurringChargeRateDateRange.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_get_applied_payment_id_count_to_reserve_for_invoices.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- =================================================================================
-- Jira #:               CORE-99637
--
-- Written By:           Naomi Martel
-- Reviewed By:
--
-- Script Type:          Stored Procedure
-- Target DB Type:       CLIENT
-- Target ENVIRONMENT:   BOTH
--
-- Re-Runable:           YES
--
-- Where tested:         pccsql-use2-nprd-dvsh-cli0003.bbd2b72cba43.database.windows.net,1433
--						 ORG: abhow
--
-- Staging Recommendations/Warnings:
--
-- Description of Script Function:
-- Get count of applied payment ids needed to create applied payment history given a list of invoice ids.
--
-- Sample execution (abhow):
-- DECLARE @status_code int, @status_text varchar(3000)
-- EXEC sproc_ar_get_applied_payment_id_count_to_reserve_for_invoices '2206112,2206113,2206115', 1, 'N', @status_code, @status_text
-- =================================================================================

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

IF EXISTS (SELECT 1 FROM sysobjects WHERE id = object_id(N'sproc_ar_get_applied_payment_id_count_to_reserve_for_invoices'))
BEGIN
    DROP PROCEDURE sproc_ar_get_applied_payment_id_count_to_reserve_for_invoices;
END
GO

CREATE PROCEDURE sproc_ar_get_applied_payment_id_count_to_reserve_for_invoices
	( @invoiceId_CSV varchar(max) 
	, @facId INT
	, @DebugMe CHAR(1) = 'N'
	, @status_code int  out
	, @status_text varchar(3000) out
    )
AS
BEGIN
	DECLARE @error_code INT
		   ,@result_message varchar(200)

	SET NOCOUNT ON

    DECLARE @appliedPaymentId int
	DECLARE @numUniqueEffectiveMonths int
	DECLARE @invoiceIdsTable TABLE (id int identity(1,1), invoice_id int)

	INSERT INTO @invoiceIdsTable(invoice_id) SELECT value FROM pcc__csvToTableOfIntMax(@invoiceId_CSV)

	SELECT @numUniqueEffectiveMonths = count(*) from (
		select t.payer_id
		from @invoiceIdsTable ti 
		join ar_transactions t on t.invoice_id = ti.invoice_id
		where t.fac_id = @facId 
			and t.deleted = 'N'
			and t.transaction_type <> 'C'
		group by t.payer_id, (DATEFROMPARTS(YEAR(t.effective_date),MONTH(t.effective_date),1))
        UNION ALL
        select 1 as payer_id
        from @invoiceIdsTable
        where invoice_id < 0
	) x

	IF @numUniqueEffectiveMonths < 1 
	BEGIN 
		SET @numUniqueEffectiveMonths = 1
	END

	SELECT @numUniqueEffectiveMonths AS 'applied_payment_id_count'

END
GO

GRANT EXECUTE ON dbo.sproc_ar_get_applied_payment_id_count_to_reserve_for_invoices TO PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_get_applied_payment_id_count_to_reserve_for_invoices.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_get_applied_payment_id_count_to_reserve_for_invoices.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_getAgingByBillDate.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


---- =================================================================================
---- Jira #:               core-99299
----
---- Written By:           Justin Pitters
---- Reviewed By:
----
---- Script Type:          Stored Procedure
---- Target DB Type:       CLIENT
---- Target ENVIRONMENT:   BOTH
----
----
---- Re-Runable:           YES
----
---- Where tested:         pccsql-use2-nprd-dvsh-cli0003.bbd2b72cba43.database.windows.net,1433 (Avengers DEV DB)
----                       ORG: agrd
----
---- Staging Recommendations/Warnings:
----
---- Description of Script Function:
---- Get aging by bill date used

---- Execution sample:
---- Org: abhow

----DECLARE @status_code int, @status_text varchar(3000)
----EXEC dbo.sproc_ar_getAgingByBillDate 25735394, 'N', @status_code, @status_text
---- =================================================================================

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF EXISTS (SELECT 1 FROM sysobjects WHERE id = object_id(N'sproc_ar_getAgingByBillDate'))
BEGIN
	DROP PROCEDURE sproc_ar_getAgingByBillDate;
END
GO

CREATE PROCEDURE sproc_ar_getAgingByBillDate
	( @cashTxId INT
	, @DebugMe CHAR(1) = 'N'
	, @status_code int  out
	, @status_text varchar(3000) out
	)
AS
BEGIN

	SET NOCOUNT ON

	CREATE TABLE #invoiceWithAmount
	(
		theOrder int NOT NULL,
		invoice_id int NULL,
		payer_id int NOT NULL,
		amount decimal(20, 2) NOT NULL,
		amount_for_auto_writeoff decimal(20, 2) NOT NULL,
		effDate datetime NULL
	)

	CREATE TABLE #aph
	(
		invoice_id int NULL,
		payer_id int NOT NULL,
		amount decimal(20, 2) NOT NULL,
		writeoff_amount decimal(20, 2) NOT NULL,
		effDate datetime NULL,
		include_transaction_payment bit NULL
	)
	
	CREATE TABLE #tp
	(
		invoice_id int NULL,
		payer_id int NOT NULL,
		amount decimal(20, 2) NOT NULL,
		amount_for_auto_writeoff decimal(20, 2) NOT NULL,
		effDate datetime NULL
	)

	INSERT INTO #aph (invoice_id, payer_id, amount, writeoff_amount, effDate, include_transaction_payment)
	SELECT -3 as invoice_id, payer_id, amount AS amount,  
		ISNULL(writeoff_amount, 0) as amount_for_auto_writeoff,
		DATEADD(MONTH, DATEDIFF(MONTH, 0, applied_to_date), 0) AS effDate ,
		include_transaction_payment
	FROM ar_applied_payment_history aph  
	WHERE deleted='N' 
		AND transaction_id=@cashTxId

	INSERT INTO #tp (invoice_id, payer_id, amount, amount_for_auto_writeoff, effDate)
	SELECT t.invoice_id, t.payer_id, tp.amount * -1 AS amount,  
		ISNULL(tp.amount_for_auto_writeoff*-1, 0) as amount_for_auto_writeoff, 
		DATEADD(MONTH, DATEDIFF(MONTH, 0, t.effective_date), 0) AS effDate  
	FROM ar_transactions t  
		JOIN ar_transactions_payment tp on t.transaction_id = tp.charge_transaction_id  
	WHERE tp.payment_transaction_id = @cashTxId  
		AND t.deleted='N'
		AND t.transaction_type <> 'C'
		and t.transaction_date is not null

	INSERT INTO #invoiceWithAmount (theOrder, invoice_id, payer_id, amount, amount_for_auto_writeoff, effDate)
	-- Payments towards Pre-transition charges
	SELECT 1 AS theOrder, -3 as invoice_id, payer_id, SUM(amount) AS amount,  
		sum(writeoff_amount) as amount_for_auto_writeoff,
	   effDate  
	FROM #aph aph  
	WHERE  (include_transaction_payment=0 OR include_transaction_payment IS NULL)  
	GROUP BY payer_id, effDate 
	UNION ALL
	-- Write-offs from pre-transition 835 imports
	SELECT 1 AS theOrder, -4 as invoice_id, aph.payer_id, 0 as amount,
		sum(writeoff_amount) as amount_for_auto_writeoff,  
		effDate  
	FROM #aph aph  
	WHERE writeoff_amount <> 0
		AND include_transaction_payment=1
	GROUP BY aph.payer_id, effDate
	UNION ALL 
	-- Payments towards Marked As Billed charges
	SELECT 2 AS theOrder, -999 as invoice_id, t.payer_id, SUM(t.amount)  AS amount,  
		sum(t.amount_for_auto_writeoff) as amount_for_auto_writeoff, 
		effDate  
	FROM #tp t
	WHERE t.invoice_id = -999  
	GROUP BY t.payer_id, effDate
	UNION ALL 
	-- Payments towards billed charges
	SELECT 3 AS theOrder, t.invoice_id, t.payer_id, SUM(t.amount)AS amount,  
	sum(t.amount_for_auto_writeoff) as amount_for_auto_writeoff, NULL AS effDate  
	FROM #tp t
	WHERE t.invoice_id >0  
	GROUP BY t.invoice_id, t.payer_id  
	UNION ALL  
	-- Payments towards unbilled transactions
	SELECT 4 AS theOrder, -2 as invoice_id, MIN(t.payer_id), SUM(t.amount) AS amount,  
		sum(t.amount_for_auto_writeoff) as amount_for_auto_writeoff,  
		effDate
	FROM #tp t
	WHERE t.invoice_id IS NULL 
	GROUP BY effDate
	HAVING SUM(t.amount) <> 0  
	UNION ALL  
	-- Payments towards unapplied cash
	SELECT 5 AS theOrder, -1 as invoice_id, t.payer_id, SUM(t.amount) * -1 AS amount,  
		0 AS amount_for_auto_writeoff, NULL AS effDate  
	FROM dbo.view_ar_unapplied_cash t  
	WHERE t.transaction_id = @cashTxId  
	GROUP BY t.payer_id  
	HAVING SUM(t.amount) <> 0  

	-- Merge write-offs from 835 import with the payment
	IF (SELECT COUNT(invoice_id) FROM #invoiceWithAmount WHERE invoice_id = -4) = 1
	AND (SELECT COUNT(invoice_id) FROM #invoiceWithAmount WHERE invoice_id <> -4) = 1
	BEGIN
		UPDATE i
		SET amount_for_auto_writeoff = (SELECT amount_for_auto_writeoff FROM #invoiceWithAmount WHERE invoice_id = -4)
		FROM #invoiceWithAmount i
		WHERE invoice_id <> -4

		DELETE FROM #invoiceWithAmount
		WHERE invoice_id = -4
	END

	SELECT ia.invoice_id, ia.amount,  
	CASE  
		WHEN ia.invoice_id = -3 OR  ia.invoice_id = -999 OR ia.invoice_id = -2 THEN ia.effDate  
		WHEN p.bill_form = 'Other' OR (p.bill_form = 'private' AND s.generated_date IS NOT NULL) THEN i.effective_date  
		WHEN ia.invoice_id = -1 THEN NULL  
		WHEN c.invoice_id IS NULL AND i.invoice_id IS NOT NULL THEN i.eff_date_to  
		ELSE c.effective_to_date  
		END AS billDate  
		, ia.amount_for_auto_writeoff  
	FROM #invoiceWithAmount ia  
		JOIN ar_lib_payers p on p.payer_id = ia.payer_id  
		LEFT JOIN ar_invoice i ON i.invoice_id = ia.invoice_id  
		LEFT JOIN ar_invoice_claim c ON c.invoice_id = i.invoice_id  
		LEFT JOIN ar_invoice_statement s ON i.invoice_id = s.invoice_id  
	ORDER BY theOrder, billDate
END
GO

GRANT EXECUTE ON dbo.sproc_ar_getAgingByBillDate TO PUBLIC
GO

GO

print 'C_Branch/04_StoredProcedures/sproc_ar_getAgingByBillDate.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_getAgingByBillDate.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_getClaimGenerationProcessError.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- Jira #:                CORE-100195             
--                           
-- Written By:            Jimmy Zhang
-- Reviewed By:           
-- 
-- Script Type:           DDL 
-- Target DB Type:        Client
-- Target Environment:    Both
-- 
-- 
-- Re-Runable:            YES 
-- 
-- Description of Script: get claim generation process error by process uuid
-- 
-- Special Instruction:   None
--
-- Sample Execution: 
--
-- EXEC dbo.sproc_ar_getClaimGenerationProcessError
--  @processUuid = ?     
-- =================================================================================
IF EXISTS
(
    SELECT 1
    FROM INFORMATION_SCHEMA.ROUTINES
    WHERE ROUTINE_SCHEMA = 'dbo'
          AND ROUTINE_NAME = 'sproc_ar_getClaimGenerationProcessError'
          AND ROUTINE_TYPE = 'PROCEDURE'
)
BEGIN
    DROP PROCEDURE dbo.sproc_ar_getClaimGenerationProcessError
END
GO


CREATE PROCEDURE dbo.sproc_ar_getClaimGenerationProcessError 
  @processUuid        varchar(40) 
 
AS
BEGIN
    SET NOCOUNT ON
    
    DECLARE @vProcessUuid varchar(40) = @processUuid
    DECLARE @pId uniqueidentifier
    DECLARE @payerIds varchar(512)
    DECLARE @noClients int

    SELECT @pId = process_uuid, 
           @payerIds = payer_ids, 
           @noClients = no_of_clients 
    FROM ar_claim_generation_error
    WHERE process_uuid = @vProcessUuid

--    DELETE FROM ar_claim_generation_error
--    WHERE process_uuid = @vProcessUuid

    SELECT @pId as process_uuid, 
           @noClients as no_of_clients, 
           STUFF((SELECT ', ' + lp.description
                  FROM ar_lib_payers lp
                  INNER JOIN (SELECT DISTINCT value 
                              FROM pcc__csvToTableOfInt(@payerIds)) a
                    ON lp.payer_id = a.value 
                    ORDER BY lp.description
                  FOR XML PATH('')
                ), 1, 1, '') AS payer_names
    WHERE @pId = @vProcessUuid

END
GO

GRANT EXECUTE ON dbo.sproc_ar_getClaimGenerationProcessError TO PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_getClaimGenerationProcessError.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_getClaimGenerationProcessError.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_list_getUnbilledUBClients.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- Jira #:                CORE-94230             
--                           
-- Written By:            Daniel Chen
-- Reviewed By:           Jimmy Zhang
-- 
-- Script Type:           DDL 
-- Target DB Type:        Client
-- Target Environment:    Both
-- 
-- 
-- Re-Runable:            YES 
-- 
-- Description of Script: get unbilled UB clients list
-- 
-- Special Instruction:   None
--
--Sample Execution 
-- DECLARE @TableVar OneColumnOfStringTableType
-- INSERT INTO @TableVar VALUES ('3'),('4')

--DECLARE @status_code int, @status_text varchar(3000)
--EXEC dbo.sproc_ar_list_getUnbilledUBClients
--  @facId = 1       
-- ,@filterType = 1 
-- ,@filterValueTable = @TableVar
-- ,@startDate = '2014-02-28'
-- ,@toDate = '2021-08-01'   
-- ,@excludeTrialFlag = 1
-- ,@debug ='Y'
-- ,@status_code = @status_code
-- ,@status_text = @status_text
-- =================================================================================
IF EXISTS
(
    SELECT 1
    FROM INFORMATION_SCHEMA.ROUTINES
    WHERE ROUTINE_SCHEMA = 'dbo'
          AND ROUTINE_NAME = 'sproc_ar_list_getUnbilledUBClients'
          AND ROUTINE_TYPE = 'PROCEDURE'
)
BEGIN
    DROP PROCEDURE dbo.sproc_ar_list_getUnbilledUBClients;
END;
GO
SET ANSI_NULLS ON;
GO
SET QUOTED_IDENTIFIER ON;
GO
CREATE PROCEDURE dbo.sproc_ar_list_getUnbilledUBClients 

  @facId        INT 
 ,@filterType   INT 
 ,@filterValueTable dbo.OneColumnOfStringTableType ReadOnly
 ,@startDate    DATETIME
 ,@toDate       DATETIME
 ,@excludeTrialFlag BIT
 ,@debug char(1) = 'N'
 ,@status_code int = 0 OUT
 ,@status_text varchar(3000) = '' OUT
 
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @vFacId INT = @facId
    DECLARE @vFilterType INT = @filterType
    DECLARE @vStartDate DATETIME = @startDate
    DECLARE @vToDate DATETIME = @toDate
    DECLARE @vExcludeTrialFlag BIT = @excludeTrialFlag
    DECLARE @errorCode INT
    DECLARE @vStep INT
    
    set @vStep = 1
	  if @debug='Y' Print 'STEP' +  convert(varchar(20), @vStep)  + ' create temp tables ' +  convert(varchar(26),getdate(),109)
           
    CREATE TABLE #temp_unbilled_tx
    (
      transaction_id int,
      effective_date datetime,
      client_id int,
      payer_id int
    )

    CREATE TABLE #temp_qualified_unbilled_tx
    (
      transaction_id int,
      effective_date datetime,
      client_id int,
      payer_id int
    )

    CREATE TABLE #temp_payer_id
    (
      payer_id int
    )
    
    CREATE TABLE #temp_payer_type
    (
      payer_type VARCHAR(20)
    )

    CREATE TABLE #temp_payer_rpt_grp
    (
      payer_reporting_group int
    )
    
    set @vStep = 2
	  if @debug='Y' Print 'STEP' +  convert(varchar(20), @vStep)  + ' prepare parameter to temp table ' +  convert(varchar(26),getdate(),109)
     
    IF(@vFilterType = 1)
    BEGIN
      INSERT INTO #temp_payer_id
      (
        payer_id       
      )
      SELECT DISTINCT CAST(col1 AS INT) FROM @filterValueTable
    END
    
    IF(@vFilterType = 2)
    BEGIN
      INSERT INTO #temp_payer_type
      (
        payer_type       
      )
      SELECT DISTINCT col1 FROM @filterValueTable
    END
    
    IF(@vFilterType = 3)
    BEGIN
      INSERT INTO #temp_payer_rpt_grp
      (
        payer_reporting_group       
      )
      SELECT DISTINCT CAST(col1 AS INT) FROM @filterValueTable
    END
     
    BEGIN TRY     
      set @vStep = 3
      if @debug='Y' Print 'STEP' +  convert(varchar(20), @vStep)  + ' get all unbilled UB clients ' +  convert(varchar(26),getdate(),109)
      
      INSERT INTO #temp_unbilled_tx
      (
        transaction_id,
        effective_date,
        payer_id, 
        client_id
      )
      SELECT
           tx.transaction_Id,
           tx.effective_date,
           tx.payer_id,
           tx.client_id
        FROM AR_TRANSACTIONS tx
             LEFT JOIN AR_INVOICE trialinvoice ON tx.trial_invoice_id = trialinvoice.invoice_id
                                                  AND trialinvoice.deleted = 'N'
             LEFT JOIN AR_PAYERS arpayer ON tx.payer_id = arpayer.payer_id
                                            AND tx.fac_id = arpayer.fac_id
             LEFT JOIN AR_INVOICE invoice ON tx.invoice_id = invoice.invoice_id
             JOIN AR_LIB_PAYERS libpayer ON tx.payer_id = libpayer.payer_id
                                                 AND libpayer.deleted = 'N'
             LEFT JOIN #temp_payer_id pr ON tx.payer_id = pr.payer_id
             LEFT JOIN #temp_payer_type pt ON pt.payer_type = libpayer.payer_type
             LEFT JOIN #temp_payer_rpt_grp pg ON pg.payer_reporting_group = libpayer.payer_reporting_group 
        WHERE (@vExcludeTrialFlag = 0 OR (@vExcludeTrialFlag = 1 and (tx.trial_invoice_id IS NULL
                OR tx.revision_date > trialinvoice.revision_date)))
               AND libpayer.bill_form = 'UB92'
               AND tx.INVOICE_ID IS NULL
               AND tx.transaction_type NOT IN('X', 'C')
        AND (@vFilterType IS NULL 
             OR (@vFilterType = 1 AND pr.payer_id IS NOT NULL)
             OR (@vFilterType = 2 AND pt.payer_type IS NOT NULL)
             OR (@vFilterType = 3 AND pg.payer_reporting_group IS NOT NULL))
        AND tx.TRANSACTION_DATE IS NOT NULL
        AND (tx.distribution_tx_id IS NULL
             OR tx.distribution_tx_id = tx.transaction_id)
        AND tx.REVERSING_TX_ID IS NULL
        AND tx.EFFECTIVE_DATE < @vToDate
        AND tx.EFFECTIVE_DATE > @vStartDate
        AND (CASE
          WHEN EXISTS
          (
              SELECT *
              FROM ar_batch_errors
              WHERE ar_batch_errors.transaction_id = tx.transaction_id
                    AND ((warning_flag = 'N'
                          AND field_code LIKE 'IE%')
                         OR (warning_flag = 'Y'
                             AND field_code LIKE 'IW%'))
          )
               THEN 1
               ELSE 0
               END) = '0'
        AND tx.FAC_ID = @vFacId
             AND tx.DELETED = 'N'
      order by tx.client_id,tx.payer_id,tx.effective_date

      set @vStep = 4
      if @debug='Y' Print 'STEP' +  convert(varchar(20), @vStep)  + ' filter out tx in real bill period ' +  convert(varchar(26),getdate(),109)
      
      INSERT INTO #temp_qualified_unbilled_tx
      (
          transaction_id,
          effective_date,
          client_id,
          payer_id
      )
      SELECT 
          tx.transaction_id,
          tx.effective_date,
          tx.client_id, 
          tx.payer_id
      FROM #temp_unbilled_tx tx
      WHERE NOT EXISTS
       (
          SELECT 1
          FROM ar_invoice
             JOIN ar_invoice_claim ON ar_invoice.invoice_id = ar_invoice_claim.invoice_id
          WHERE ar_invoice.deleted = 'N'
             AND ar_invoice.trial_flag = 'N'
             AND ar_invoice.manual_flag = 'N'
             AND ar_invoice.original_invoice_id IS NULL
             AND ar_invoice.transaction_flag = 'Y'
             and ar_invoice.fac_id = @vFacId
             AND ar_invoice.client_id = tx.client_id
             AND ar_invoice.payer_id = tx.payer_id
             AND tx.effective_date >= ar_invoice_claim.effective_from_date
             AND tx.effective_date < DATEADD(day, 1, ar_invoice_claim.effective_to_date)
       )
      ORDER BY tx.transaction_id  
      
      DROP TABLE  #temp_unbilled_tx

      set @vStep = 5
      if @debug='Y' Print 'STEP' +  convert(varchar(20), @vStep)  + ' get client sum list ' +  convert(varchar(26),getdate(),109)
      
      SELECT SUM(tx.AMOUNT) AS claim_total, 
               MIN(qtx.EFFECTIVE_DATE) AS min_effective_date, 
               MAX(qtx.EFFECTIVE_DATE) AS max_effective_date, 
               billable_flag = CONVERT(BIT, 
               MIN(CASE
                   WHEN ISNULL(parentTransactionAssessmentInfo.pdpm_flag, 0) = 0
                        OR parentTransactionAssessmentInfo.hipps_code = 'ZZZZZ'
                        OR assess.STATUS IN('Accepted', 'Completed')
                   THEN 1
                   ELSE 0
                   END)),            
               mpi.last_name patient_last_name, 
               mpi.first_name patient_first_name, 
               client.client_id_number, 
               qtx.client_id, 
               libpayer.description AS payer_desc, 
               libpayer.payer_code, 
               libpayer.payer_type, 
               pps_flag = CONVERT(BIT, IIF(libpayer.pps_flag = 'Y', 1, 0)),
               libpayer.assessment_notifications_rates_flag, 
               libpayer.enforce_pps_updates_flag, 
               qtx.payer_id, 
               arpayer.bill_unk_flag AS payer_bill_unk_flag,              
               rateSchedule.is_reimbursement_use_hipps, 
               parentTransactionAssessmentInfo.hipps_code,
               tx.care_level,
               tx.transaction_type
        FROM AR_TRANSACTIONS tx
         JOIN #temp_qualified_unbilled_tx qtx on tx.transaction_id = qtx.transaction_id
             JOIN CLIENTS client ON qtx.client_id = client.client_id
             LEFT JOIN AR_PAYERS arpayer ON qtx.payer_id = arpayer.payer_id
                                            AND tx.fac_id = arpayer.fac_id
             LEFT JOIN MPI mpi ON client.mpi_id = mpi.mpi_id
                                  AND (mpi.deleted = 'N')
             JOIN AR_LIB_PAYERS libpayer ON qtx.payer_id = libpayer.payer_id
                                                 AND (libpayer.deleted = 'N')
             LEFT JOIN AR_TRANSACTION_ASSESSMENT_INFO transactionAssessmentInfo ON tx.transaction_id = transactionAssessmentInfo.transaction_id
             LEFT JOIN AR_TRANSACTION_ASSESSMENT_INFO parentTransactionAssessmentInfo ON tx.distribution_tx_id = parentTransactionAssessmentInfo.transaction_id
             LEFT JOIN AS_ASSESSMENT assess ON parentTransactionAssessmentInfo.pps_assessment_id = assess.assess_id
                                               AND (assess.deleted = 'N')
             LEFT JOIN ar_eff_rate_schedule rateSchedule ON tx.eff_schedule_id = rateSchedule.eff_schedule_id                                    
        GROUP BY libpayer.DESCRIPTION, 
                libpayer.payer_code, 
                mpi.last_name, 
                mpi.first_name, 
                client.client_id_number, 
                qtx.client_id, 
                libpayer.payer_type, 
                libpayer.pps_flag, 
                libpayer.assessment_notifications_rates_flag, 
                libpayer.enforce_pps_updates_flag, 
                qtx.PAYER_ID, 
                arpayer.bill_unk_flag, 
                rateSchedule.is_reimbursement_use_hipps, 
                parentTransactionAssessmentInfo.hipps_code,
                tx.care_level,
                tx.transaction_type
        ORDER BY  libpayer.description,
                 libpayer.payer_code,         
                 mpi.last_name, 
                 mpi.first_name, 
                 client.client_id_number, 
                 qtx.client_id, 
                 qtx.PAYER_ID
  END TRY
	BEGIN CATCH
	  SELECT @errorCode = @@error, @status_text = ERROR_MESSAGE()
	  SELECT @status_code = 1
	  GOTO PgmAbend
	END CATCH

	SET @status_code = 0
	
	PgmSuccess:
	BEGIN
	  IF @status_code = 0 AND @debug='Y' 
		PRINT 'Successfull execution of stored procedure'    
	END
	  
	PgmAbend:
	BEGIN
	  IF @status_code = 1 AND @debug='Y'
	  BEGIN
		PRINT 'Stored procedure failure. ' + convert(varchar(26),getdate())
		PRINT 'Error code: '+ CAST(@errorCode AS VARCHAR) + '; Error description:    ' + @status_text
	  END 
	END	       
END
GO
GRANT EXECUTE ON dbo.sproc_ar_list_getUnbilledUBClients TO PUBLIC;
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_list_getUnbilledUBClients.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_list_getUnbilledUBClients.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_list_getUnbilledUBClients_oldLayout.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- Jira #:                CORE-94230             
--                           
-- Written By:            Daniel Chen
-- Reviewed By:           Jimmy Zhang
-- 
-- Script Type:           DDL 
-- Target DB Type:        Client
-- Target Environment:    Both
-- 
-- 
-- Re-Runable:            YES 
-- 
-- Description of Script: get unbilled UB clients list
-- 
-- Special Instruction:   None
-- This sp is for old layout of unbilled client list when the Optimizely flag is off,
-- will be removed when the Optimizely flag is on
--Sample Execution 
-- DECLARE @TableVar OneColumnOfStringTableType
-- INSERT INTO @TableVar VALUES ('3'),('4')

--DECLARE @status_code int, @status_text varchar(3000)
--EXEC dbo.sproc_ar_list_getUnbilledUBClients_oldLayout
--  @facId = 1       
-- ,@filterType = 1 
-- ,@filterValueTable = @TableVar
-- ,@startDate = '2014-02-28'
-- ,@toDate = '2021-08-01'   
-- ,@excludeTrialFlag = 1
-- ,@debug ='Y'
-- ,@status_code = @status_code
-- ,@status_text = @status_text
-- =================================================================================
IF EXISTS
(
    SELECT 1
    FROM INFORMATION_SCHEMA.ROUTINES
    WHERE ROUTINE_SCHEMA = 'dbo'
          AND ROUTINE_NAME = 'sproc_ar_list_getUnbilledUBClients_oldLayout'
          AND ROUTINE_TYPE = 'PROCEDURE'
)
BEGIN
    DROP PROCEDURE dbo.sproc_ar_list_getUnbilledUBClients_oldLayout;
END;
GO
SET ANSI_NULLS ON;
GO
SET QUOTED_IDENTIFIER ON;
GO
CREATE PROCEDURE dbo.sproc_ar_list_getUnbilledUBClients_oldLayout 

  @facId        INT 
 ,@filterType   INT 
 ,@filterValueTable dbo.OneColumnOfStringTableType ReadOnly
 ,@startDate    DATETIME
 ,@toDate       DATETIME
 ,@excludeTrialFlag BIT
 ,@debug char(1) = 'N'
 ,@status_code int = 0 OUT
 ,@status_text varchar(3000) = '' OUT
 
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @vFacId INT = @facId
    DECLARE @vFilterType INT = @filterType
    DECLARE @vStartDate DATETIME = @startDate
    DECLARE @vToDate DATETIME = @toDate
    DECLARE @vExcludeTrialFlag BIT = @excludeTrialFlag
    DECLARE @errorCode INT
    DECLARE @vStep INT
    
    set @vStep = 1
	  if @debug='Y' Print 'STEP' +  convert(varchar(20), @vStep)  + ' create temp tables ' +  convert(varchar(26),getdate(),109)
           
    CREATE TABLE #temp_unbilled_tx
    (
      transaction_id int,
      effective_date datetime,
      client_id int,
      payer_id int
    )

    CREATE TABLE #temp_qualified_unbilled_tx
    (
      transaction_id int,
      effective_date datetime,
      client_id int,
      payer_id int
    )

    CREATE TABLE #temp_payer_id
    (
      payer_id int
    )
    
    CREATE TABLE #temp_payer_type
    (
      payer_type VARCHAR(20)
    )

    CREATE TABLE #temp_payer_rpt_grp
    (
      payer_reporting_group int
    )
    
    set @vStep = 2
	  if @debug='Y' Print 'STEP' +  convert(varchar(20), @vStep)  + ' prepare parameter to temp table ' +  convert(varchar(26),getdate(),109)
     
    IF(@vFilterType = 1)
    BEGIN
      INSERT INTO #temp_payer_id
      (
        payer_id       
      )
      SELECT DISTINCT CAST(col1 AS INT) FROM @filterValueTable
    END
    
    IF(@vFilterType = 2)
    BEGIN
      INSERT INTO #temp_payer_type
      (
        payer_type       
      )
      SELECT DISTINCT col1 FROM @filterValueTable
    END
    
    IF(@vFilterType = 3)
    BEGIN
      INSERT INTO #temp_payer_rpt_grp
      (
        payer_reporting_group       
      )
      SELECT DISTINCT CAST(col1 AS INT) FROM @filterValueTable
    END
     
    BEGIN TRY     
      set @vStep = 3
      if @debug='Y' Print 'STEP' +  convert(varchar(20), @vStep)  + ' get all unbilled UB clients ' +  convert(varchar(26),getdate(),109)
      
      INSERT INTO #temp_unbilled_tx
      (
        transaction_id,
        effective_date,
        payer_id, 
        client_id
      )
      SELECT
           tx.transaction_Id,
           tx.effective_date,
           tx.payer_id,
           tx.client_id
        FROM AR_TRANSACTIONS tx
             LEFT JOIN AR_INVOICE trialinvoice ON tx.trial_invoice_id = trialinvoice.invoice_id
                                                  AND trialinvoice.deleted = 'N'
             LEFT JOIN AR_PAYERS arpayer ON tx.payer_id = arpayer.payer_id
                                            AND tx.fac_id = arpayer.fac_id
             LEFT JOIN AR_INVOICE invoice ON tx.invoice_id = invoice.invoice_id
             JOIN AR_LIB_PAYERS libpayer ON tx.payer_id = libpayer.payer_id
                                                 AND libpayer.deleted = 'N'
             LEFT JOIN #temp_payer_id pr ON tx.payer_id = pr.payer_id
             LEFT JOIN #temp_payer_type pt ON pt.payer_type = libpayer.payer_type
             LEFT JOIN #temp_payer_rpt_grp pg ON pg.payer_reporting_group = libpayer.payer_reporting_group 
        WHERE (@vExcludeTrialFlag = 0 OR (@vExcludeTrialFlag = 1 and (tx.trial_invoice_id IS NULL
                OR tx.revision_date > trialinvoice.revision_date)))
               AND libpayer.bill_form = 'UB92'
               AND tx.INVOICE_ID IS NULL
               AND tx.transaction_type NOT IN('X', 'C')
        AND (@vFilterType IS NULL 
             OR (@vFilterType = 1 AND pr.payer_id IS NOT NULL)
             OR (@vFilterType = 2 AND pt.payer_type IS NOT NULL)
             OR (@vFilterType = 3 AND pg.payer_reporting_group IS NOT NULL))
        AND tx.TRANSACTION_DATE IS NOT NULL
        AND (tx.distribution_tx_id IS NULL
             OR tx.distribution_tx_id = tx.transaction_id)
        AND tx.REVERSING_TX_ID IS NULL
        AND tx.EFFECTIVE_DATE < @vToDate
        AND tx.EFFECTIVE_DATE > @vStartDate
        AND (CASE
          WHEN EXISTS
          (
              SELECT *
              FROM ar_batch_errors
              WHERE ar_batch_errors.transaction_id = tx.transaction_id
                    AND ((warning_flag = 'N'
                          AND field_code LIKE 'IE%')
                         OR (warning_flag = 'Y'
                             AND field_code LIKE 'IW%'))
          )
               THEN 1
               ELSE 0
               END) = '0'
        AND tx.FAC_ID = @vFacId
             AND tx.DELETED = 'N'
      order by tx.client_id,tx.payer_id,tx.effective_date

      set @vStep = 4
      if @debug='Y' Print 'STEP' +  convert(varchar(20), @vStep)  + ' filter out tx in real bill period ' +  convert(varchar(26),getdate(),109)
      
      INSERT INTO #temp_qualified_unbilled_tx
      (
          transaction_id,
          effective_date,
          client_id,
          payer_id
      )
      SELECT 
          tx.transaction_id,
          tx.effective_date,
          tx.client_id, 
          tx.payer_id
      FROM #temp_unbilled_tx tx
      WHERE NOT EXISTS
       (
          SELECT 1
          FROM ar_invoice
             JOIN ar_invoice_claim ON ar_invoice.invoice_id = ar_invoice_claim.invoice_id
          WHERE ar_invoice.deleted = 'N'
             AND ar_invoice.trial_flag = 'N'
             AND ar_invoice.manual_flag = 'N'
             AND ar_invoice.original_invoice_id IS NULL
             AND ar_invoice.transaction_flag = 'Y'
             and ar_invoice.fac_id = @vFacId
             AND ar_invoice.client_id = tx.client_id
             AND ar_invoice.payer_id = tx.payer_id
             AND tx.effective_date >= ar_invoice_claim.effective_from_date
             AND tx.effective_date < DATEADD(day, 1, ar_invoice_claim.effective_to_date)
       )
      ORDER BY tx.transaction_id  
      
      DROP TABLE  #temp_unbilled_tx

      set @vStep = 5
      if @debug='Y' Print 'STEP' +  convert(varchar(20), @vStep)  + ' get client sum list ' +  convert(varchar(26),getdate(),109)
      
      SELECT SUM(tx.AMOUNT) AS claim_total, 
               MIN(qtx.EFFECTIVE_DATE) AS min_effective_date, 
               MAX(qtx.EFFECTIVE_DATE) AS max_effective_date, 
               billable_flag = CONVERT(BIT, 
               MIN(CASE
                   WHEN ISNULL(parentTransactionAssessmentInfo.pdpm_flag, 0) = 0
                        OR parentTransactionAssessmentInfo.hipps_code = 'ZZZZZ'
                        OR assess.STATUS IN('Accepted', 'Completed')
                   THEN 1
                   ELSE 0
                   END)),            
               mpi.last_name patient_last_name, 
               mpi.first_name patient_first_name, 
               client.client_id_number, 
               qtx.client_id, 
               libpayer.description AS payer_desc, 
               libpayer.payer_code, 
               libpayer.payer_type, 
               pps_flag = CONVERT(BIT, IIF(libpayer.pps_flag = 'Y', 1, 0)),
               libpayer.assessment_notifications_rates_flag, 
               libpayer.enforce_pps_updates_flag, 
               qtx.payer_id, 
               arpayer.bill_unk_flag AS payer_bill_unk_flag,              
               rateSchedule.is_reimbursement_use_hipps, 
               parentTransactionAssessmentInfo.hipps_code,
               tx.care_level,
               tx.transaction_type
        FROM AR_TRANSACTIONS tx
         JOIN #temp_qualified_unbilled_tx qtx on tx.transaction_id = qtx.transaction_id
             JOIN CLIENTS client ON qtx.client_id = client.client_id
             LEFT JOIN AR_PAYERS arpayer ON qtx.payer_id = arpayer.payer_id
                                            AND tx.fac_id = arpayer.fac_id
             LEFT JOIN MPI mpi ON client.mpi_id = mpi.mpi_id
                                  AND (mpi.deleted = 'N')
             JOIN AR_LIB_PAYERS libpayer ON qtx.payer_id = libpayer.payer_id
                                                 AND (libpayer.deleted = 'N')
             LEFT JOIN AR_TRANSACTION_ASSESSMENT_INFO transactionAssessmentInfo ON tx.transaction_id = transactionAssessmentInfo.transaction_id
             LEFT JOIN AR_TRANSACTION_ASSESSMENT_INFO parentTransactionAssessmentInfo ON tx.distribution_tx_id = parentTransactionAssessmentInfo.transaction_id
             LEFT JOIN AS_ASSESSMENT assess ON parentTransactionAssessmentInfo.pps_assessment_id = assess.assess_id
                                               AND (assess.deleted = 'N')
             LEFT JOIN ar_eff_rate_schedule rateSchedule ON tx.eff_schedule_id = rateSchedule.eff_schedule_id                                    
        GROUP BY mpi.last_name, 
                mpi.first_name, 
                client.client_id_number, 
                qtx.client_id, 
                libpayer.DESCRIPTION,
                libpayer.payer_code, 
                libpayer.payer_type, 
                libpayer.pps_flag, 
                libpayer.assessment_notifications_rates_flag, 
                libpayer.enforce_pps_updates_flag, 
                qtx.PAYER_ID, 
                arpayer.bill_unk_flag, 
                rateSchedule.is_reimbursement_use_hipps, 
                parentTransactionAssessmentInfo.hipps_code,
                tx.care_level,
                tx.transaction_type
        ORDER BY  mpi.last_name, 
                 mpi.first_name, 
                 client.client_id_number, 
                 qtx.client_id, 
                 libpayer.description,
                 libpayer.payer_code, 
                 libpayer.payer_type, 
                 libpayer.pps_flag, 
                 libpayer.assessment_notifications_rates_flag, 
                 libpayer.enforce_pps_updates_flag, 
                 qtx.PAYER_ID, 
                 arpayer.bill_unk_flag,
                 rateSchedule.is_reimbursement_use_hipps, 
                 parentTransactionAssessmentInfo.hipps_code,               
                 tx.care_level, 
                 tx.transaction_type
  END TRY
	BEGIN CATCH
	  SELECT @errorCode = @@error, @status_text = ERROR_MESSAGE()
	  SELECT @status_code = 1
	  GOTO PgmAbend
	END CATCH

	SET @status_code = 0
	
	PgmSuccess:
	BEGIN
	  IF @status_code = 0 AND @debug='Y' 
		PRINT 'Successfull execution of stored procedure'    
	END
	  
	PgmAbend:
	BEGIN
	  IF @status_code = 1 AND @debug='Y'
	  BEGIN
		PRINT 'Stored procedure failure. ' + convert(varchar(26),getdate())
		PRINT 'Error code: '+ CAST(@errorCode AS VARCHAR) + '; Error description:    ' + @status_text
	  END 
	END	       
END
GO
GRANT EXECUTE ON dbo.sproc_ar_list_getUnbilledUBClients_oldLayout TO PUBLIC;
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_list_getUnbilledUBClients_oldLayout.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_list_getUnbilledUBClients_oldLayout.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_as_list_getAuditReportHistory.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- =========================================================================================================================
--
--  Written By: Brian Young
--  Reviewed By:
--
--  Script Type: User defined store procedure
--  Target DB Type: Client
--  Target Database: Both
--
--  Re-Runable: Yes
--
--  Description: Used to get list of assessment history responses.
--
--	Parameters:
--			@assess_id	- Assess_Id for reporting 
--			@visual		- Include "Visible" Question Key Responses Only or "All" assessment responses
--			@debug		- Debug flag
--			@statusCode	- Return value if the procedure ran correctly, 1 if error, 0 if success.
--			@statusText	- Error message if statusCode is 1.
--
--  Revision History:
--  2021-07-30		CORE-81819   Initial creation of this stored proc.
--  2021-09-01  Yevgen Voroshylov CORE-94316
--                  added with (nolock),
--                  bdy/ebdy/gbdy control types have more than one question_key with prefix so we can't rely on equal condition for them
--  2022-01-25  Anthony Yuan CORE-96521
--                  For CMS Interaction, order results by question_text; otherwise by question_key 
--                  Include question_text in the search result
--  Notes:
-- =========================================================================================================================

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_as_list_getAuditReportHistory' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE [dbo].[sproc_as_list_getAuditReportHistory]
END
GO

SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON  --- SET QUOTED_IDENTIFIER ON because we have used reserved words such as status, floor, etc...
GO

CREATE PROCEDURE  [dbo].[sproc_as_list_getAuditReportHistory]
	  @assess_id int   
	, @visual char(1)
	, @debug char(1) = 'N'
	, @status_code int out 
	, @status_text varchar(3000) out
AS
BEGIN 
	SET NOCOUNT ON;

	DECLARE
		  @vAssess_id	int
		, @vVisual		char(1)
		, @error_code 	int

	SET @vAssess_id = @assess_id;
	SET @vVisual = @visual;
	SET @status_code = 0;
	SET @status_text = '';

	IF @debug='Y' PRINT 'BEGIN - sproc_as_list_getAuditReportHistory - ' + convert(varchar(26),getdate(),109);
			
	BEGIN TRY
		SELECT assess.std_assess_id, assess.assess_id, hist.question_key, ques.question_text, hist.created_date, 
			hist.acknowledged, ques.control_type, ques.control_type_id, picklist.item_description, hist.item_value,
			hist.long_username, hist.revision_by, hist.position_desc, 
			hist.revision_date, hist.collection_date, ques.visual
		FROM dbo.AS_ASSESSMENT assess with (nolock)
		LEFT JOIN dbo.VIEW_AS_RESPONSE_COLLECTION_AUDIT hist with (nolock) ON hist.assess_id = assess.assess_id
		LEFT JOIN dbo.mirror_AS_STD_QUESTION ques with (nolock) ON assess.std_assess_id = ques.std_assess_id AND hist.question_key like '%' + ques.question_key
		LEFT JOIN dbo.mirror_AS_STD_PICK_LIST_ITEM picklist with (nolock)ON ques.pick_list_id = picklist.pick_list_id AND hist.item_value = picklist.item_value
		LEFT JOIN dbo.as_std_assessment_cms_template_mapping cmsMapping with (nolock) ON assess.std_assess_id = cmsMapping.std_assess_id 
		WHERE assess.assess_id  = @vAssess_id
		  AND (ques.visual  = @vVisual or @vVisual = 'N') 
		  AND (picklist.pick_list_id is null or 
                (picklist.effective_date <= assess.assess_date and 
			      (picklist.ineffective_date is null or assess.assess_date <= picklist.ineffective_date)
			    )
			  )
	  ORDER BY (CASE WHEN cmsMapping.cms_uuid IS NULL THEN hist.question_key ELSE ques.question_text END), hist.revision_date DESC
		;
	END TRY
	
	BEGIN CATCH
		SET @error_code  = ERROR_NUMBER();
		SET @status_text = ERROR_MESSAGE();
		SET @status_code = 1;

		GOTO PgmAbend;
	END CATCH
	
	IF @debug='Y' PRINT 'END - sproc_as_list_getAuditReportHistory - ' + convert(varchar(26),getdate(),109);

	PgmSuccess:
	IF @status_code = 0
	BEGIN
		IF @debug = 'Y' PRINT 'Successful execution of stored procedure.';
		RETURN @status_code;
	END
	    
	PgmAbend:
	IF @debug = 'Y'
	BEGIN
		PRINT 'Stored procedure failure: ' + convert(varchar(26),getdate(),109);
		PRINT 'Error code: ' + convert(varchar(3),@error_code) + '; Error description:  ' + @status_text;
	END
	RAISERROR (@status_text, 16, 1);
	
	RETURN @status_code;
END
GO

GRANT EXECUTE ON dbo.sproc_as_list_getAuditReportHistory TO PUBLIC
GO

SET ANSI_NULLS OFF 
GO

SET QUOTED_IDENTIFIER OFF
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_as_list_getAuditReportHistory.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_as_list_getAuditReportHistory.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_dml_care_pho_strikeoutPhysOrder_del.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO



if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[sproc_dml_care_pho_strikeoutPhysOrder_del]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
   drop procedure [dbo].[sproc_dml_care_pho_strikeoutPhysOrder_del]

go
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sproc_dml_care_pho_strikeoutPhysOrder_del]
	@phys_order_id int,
	@strikeout_reason_code int,
	@strikeout_by varchar(60),
	@strikeout_by_position varchar(60),
	@strikeout_date smalldatetime,
	@audit smallint,	-- tells us if an audit record should be created
	@audit_id INT OUTPUT,
	@debug char(1) = 'N' -- optional


/********************************************************************************
Purpose:


Revision History:
2008-11-26  Jacek Jakubiak     Initial creation of this stored proc
2010-06-18  Kuldip Shah		   PCC-15411 If phys order is a draft order,
							   delete pharmacy and associated records
2012-05-25  Duksun Choi 		Update admin order(s) in the PHO_ADMIN_ORDER_AUDIT table when order is striked out
2012-11-21  Alireza Mandegar   Moved deletion of pho_order_sliding_scale_range before pho_order_schedule due to PCC-30715
2012-12-20  Alireza Mandegar   PCC-32537  delete pho_schedule_details_supplementary_info before pho_schedule_details
2013-02-04  Alireza Mandegar   PCC-32537  reverted changes for pho_schedule_details_supplementary_info
2014-07-23	Mustafa Behrainwala	PCC-59209	OM: Provide the Ability to Discontinue, Hold & Resume Orders that Were Created as Part of an Order Sets
2015-04-23  Ramin Shojaei		PCC-73785 Remove Order By From Resident Profile If Order By Was Added By Application During Order Entry
2015-12-16  Gleb Gadyatskiy		PCC-85220 Provide ability to Strikeout a Discharge Order in Pending Signature Status
2019-3-07  Dom Christie		CORE-35349 delete from the drug change request tables
**********************************************************************************/
AS

SET NOCOUNT ON;
--
-- Declare variables
--
DECLARE  @step         float
        ,@status_text  varchar(3000)
        ,@error_msg    varchar(255)
		,@returnCode   int
		,@created_date DATETIME
		,@scheduleID   int
		,@isDraft      int
		,@rowCount     int
		,@isEnhanced   varchar
        ,@facId        int
		,@isQueued	   bit
		,@physicianId int
		,@relatedPhysicianId int,
		@relatedAdminOrderId int,
		@first_documented datetime

DECLARE @TempAuditId TABLE
(
    audit_id INT
)

DECLARE @linkedSetId TABLE
(
	linked_set_id INT
)

DECLARE @labOrderExtraInfo TABLE
(
	device_id INT
)

BEGIN TRY
	/****************************************************************/
	set @step = 1.0
	set @status_text = 'Step ' + convert(varchar,@step) +
        ' check facility configuration ' + CONVERT(CHAR(8), getdate(), 114)
    if  @debug='Y' print @status_text

	-- Check to see if the New Physician Order Option is turned on
	-- If it is then we also delete from pho_order_schedule
	select @facId = fac_id, @first_documented=first_documented from dbo.pho_phys_order where phys_order_id = @phys_order_id
	select @isEnhanced=dbo.fn_get_new_phys_order_entry_parameter(@facId)

	if  @debug='Y' print 'FacilityID is: ' + convert(varchar, @facId)
	if  @debug='Y' print 'isEnhanced ? : ' + @isEnhanced
	/****************************************************************/

	/****************************************************************/
	set @step = 1.1
	set @status_text = 'Step ' + convert(varchar,@step) +
        ' strikeout - process draft ' + CONVERT(CHAR(8), getdate(), 114)
	if  @debug='Y' print @status_text
	/****************************************************************/
    
    if (@first_documented is not null)
    begin
        RAISERROR('Order is documented', 11,1)
    end
	-- Check if this phys order is a DRAFT order
	SELECT @isDraft = p.draft FROM view_pho_phys_order p WHERE p.phys_order_id = @phys_order_id
	
	-- Check if this phys order is a QUEUED order
	if (EXISTS (select 1 from pho_order_queue where phys_order_id=@phys_order_id and promoted_date is null))
		set @isQueued = 1
	else
		set @isQueued = 0

	-- delete from the ti tables too
	DELETE FROM pho_phys_order_ti WHERE phys_order_id=@phys_order_id

	-- delete phys_order overdose warning messages
    DELETE FROM pho_phys_order_dose_check_warning WHERE phys_order_id=@phys_order_id

    -- delete phys_order overdose warning acknowledgements
    DELETE FROM pho_phys_order_dose_check_acknowledgement WHERE phys_order_id=@phys_order_id

	--DECLARE @linkedSetId int
	--set @linkedSetId = (select linked_set_id FROM pho_linked_set_item where phys_order_id=@phys_order_id)
	-- delete from the linked set item table
	DELETE FROM pho_linked_set_item 
	OUTPUT DELETED.linked_set_id into @linkedSetId
	WHERE phys_order_id=@phys_order_id

	DECLARE @countLinkedItems int
	set @countLinkedItems = (select count(lsi.linked_set_id) from pho_linked_set_item lsi join @linkedSetId si on si.linked_set_id=lsi.linked_set_id group by lsi.linked_set_id)
	
	
	IF @countLinkedItems<2 -- if count is less than 2 we only have one item in the set, and so the set can be deleted.
	BEGIN
		-- delete another item from linked set item if it is the only one.
		DELETE FROM pho_linked_set_item WHERE linked_set_id = (select linked_set_id from @linkedSetId)

		-- delete the linked_set if no more items exist in it. Check count to be 1
		DELETE FROM pho_linked_set WHERE linked_set_id = (select linked_set_id from @linkedSetId)
	END


	-- delete pho_schedule referencing tables
    DELETE pho_mar_std_time_report_options FROM dbo.pho_mar_std_time_report_options stdro
	WHERE  stdro.phys_order_id=@phys_order_id

	DELETE pho_schedule_details_strikeout_followup_useraudit
	FROM dbo.pho_schedule_details_strikeout_followup_useraudit strikeoutfollowupuseraudit,
		(SELECT followupstrk.followup_strikeout_id FROM dbo.pho_followup_strikeout followupstrk, dbo.view_pho_schedule ps
		WHERE ps.phys_order_id = @phys_order_id and followupstrk.schedule_id = ps.schedule_id ) followup_strike_det
	WHERE strikeoutfollowupuseraudit.followupby_strikeout_id = followup_strike_det.followup_strikeout_id

	DELETE pho_followup_strikeout FROM dbo.pho_followup_strikeout fustrk, dbo.view_pho_schedule ps
	WHERE  ps.phys_order_id = @phys_order_id and fustrk.schedule_id = ps.schedule_id

	DELETE pho_schedule_details_strikeout_performby_useraudit
	FROM dbo.pho_schedule_details_strikeout_performby_useraudit strikeoutuseraudit,
		( SELECT admstrk.admin_strikeout_id FROM dbo.pho_admin_strikeout admstrk, dbo.view_pho_schedule ps
		WHERE ps.phys_order_id = @phys_order_id and admstrk.schedule_id = ps.schedule_id ) admin_strike_det
	WHERE strikeoutuseraudit.admin_strikeout_id = admin_strike_det.admin_strikeout_id


	DELETE pho_admin_strikeout FROM dbo.pho_admin_strikeout admstrk, dbo.view_pho_schedule ps
	WHERE  ps.phys_order_id = @phys_order_id and admstrk.schedule_id = ps.schedule_id

    --For CAD Med Mgmt orders, delete entry from attestation table if it exists
	DELETE from pho_phys_order_attestation where phys_order_id=@phys_order_id

	--delete extended dose table entry (if exists)
	delete pho_phys_order_extended_schedule where phys_order_id=@phys_order_id
	/****************************************************************/
	set @step = 1.2
	set @status_text = 'Step ' + convert(varchar,@step) +
        ' strikeout - process schedules ' + CONVERT(CHAR(8), getdate(), 114)
	if  @debug='Y' print @status_text
	/****************************************************************/
	-- delete all schedule details for order

	DELETE pho_schedule_details_followup_useraudit
	FROM pho_schedule_details_followup_useraudit followupuseraudit,
		( select psd.pho_schedule_detail_id from  dbo.pho_schedule_details psd, dbo.view_pho_schedule ps
			WHERE  ps.phys_order_id = @phys_order_id and psd.pho_schedule_id = ps.schedule_id) sched_details
	WHERE followupuseraudit.schedule_detail_id =  sched_details.pho_schedule_detail_id

	DELETE pho_schedule_details_performby_useraudit
	FROM pho_schedule_details_performby_useraudit docuseraudit,
		( select psd.pho_schedule_detail_id from  dbo.pho_schedule_details psd, dbo.view_pho_schedule ps
			WHERE  ps.phys_order_id = @phys_order_id and psd.pho_schedule_id = ps.schedule_id) sched_details
	WHERE docuseraudit.schedule_detail_id =  sched_details.pho_schedule_detail_id

    DELETE pho_schedule_details from dbo.pho_schedule_details psd, dbo.view_pho_schedule ps
	WHERE  ps.phys_order_id = @phys_order_id and psd.pho_schedule_id = ps.schedule_id

	DELETE PHO_ORDER_RELATED_VALUE
	FROM PHO_ORDER_RELATED_VALUE val,
	PHO_ORDER_RELATED_PROMPT prompt,
	view_pho_schedule sched
	WHERE sched.phys_order_id = @phys_order_id
	AND sched.schedule_id = prompt.schedule_id
	AND prompt.prompt_id = val.prompt_id

	--
	-- delete PHO_ORDER_RELATED_PROMPT before deleting pho_schedule
	--
	DELETE PHO_ORDER_RELATED_PROMPT
	FROM PHO_ORDER_RELATED_PROMPT prompt,
	VIEW_PHO_SCHEDULE	sched
	WHERE sched.phys_order_id = @phys_order_id
	AND sched.schedule_id = prompt.schedule_id

	-- delete schedules themselves, must first delete last_event...
	DELETE pho_schedule_last_event
    FROM pho_schedule_last_event le
    INNER JOIN
    view_pho_schedule del on del.schedule_id = le.schedule_id and del.phys_order_id = @phys_order_id

    -- PCC-30715 : Delete pho_order_sliding_scale_range before pho_order_schedule as it is now linked to order schedules
	DELETE pho_order_sliding_scale_range WHERE phys_order_id = @phys_order_id
	
	DELETE FROM pho_order_schedule_related_diagnoses 
	WHERE order_schedule_id in (SELECT order_schedule_id FROM pho_order_schedule WHERE phys_order_id=@phys_order_id)

  --non-processed actions from offline emar
  DELETE pho_disconnected_emar_admin_site_detail
  FROM pho_phys_order ppo
  JOIN pho_schedule ps ON ps.phys_order_id=ppo.phys_order_id
  JOIN pho_disconnected_emar_admin_action act ON act.schedule_id=ps.schedule_id
  JOIN pho_disconnected_emar_admin_site_detail pde_site ON pde_site.disconnected_emar_admin_action_id=act.disconnected_emar_admin_action_id
  WHERE ppo.phys_order_id = @phys_order_id;

  DELETE pho_disconnected_emar_admin_related_prompt
  FROM pho_phys_order ppo
  JOIN pho_schedule ps ON ps.phys_order_id=ppo.phys_order_id
  JOIN pho_disconnected_emar_admin_action act ON act.schedule_id=ps.schedule_id
  JOIN pho_disconnected_emar_admin_related_prompt pde_prompt ON pde_prompt.disconnected_emar_admin_action_id=act.disconnected_emar_admin_action_id
  WHERE ppo.phys_order_id = @phys_order_id;

  DELETE pho_disconnected_emar_admin_vital
  FROM pho_phys_order ppo
  JOIN pho_schedule ps ON ps.phys_order_id=ppo.phys_order_id
  JOIN pho_disconnected_emar_admin_action act ON act.schedule_id=ps.schedule_id
  JOIN pho_disconnected_emar_admin_vital pde_vital ON pde_vital.disconnected_emar_admin_action_id=act.disconnected_emar_admin_action_id
  WHERE ppo.phys_order_id = @phys_order_id;

  DELETE pho_disconnected_emar_admin_progress_note
  FROM pho_phys_order ppo
  JOIN pho_schedule ps ON ps.phys_order_id=ppo.phys_order_id
  JOIN pho_disconnected_emar_admin_action act ON act.schedule_id=ps.schedule_id
  JOIN pho_disconnected_emar_admin_progress_note pde_note ON pde_note.disconnected_emar_admin_action_id=act.disconnected_emar_admin_action_id
  WHERE ppo.phys_order_id = @phys_order_id;

  DELETE pho_disconnected_emar_admin_action
  FROM pho_phys_order ppo
  JOIN pho_schedule ps ON ps.phys_order_id=ppo.phys_order_id
  JOIN pho_disconnected_emar_admin_action act ON act.schedule_id=ps.schedule_id
  WHERE ppo.phys_order_id = @phys_order_id;

  -- delete pho_schedule first
  DELETE FROM DBO.PHO_SCHEDULE WHERE  PHYS_ORDER_ID = @phys_order_id

	if @isQueued = 1
		delete from pho_schedule_audit where phys_order_id = @phys_order_id

	DELETE FROM pho_order_schedule_self_admin_history 
	WHERE order_schedule_id in (SELECT order_schedule_id FROM pho_order_schedule WHERE phys_order_id=@phys_order_id);
		
	DELETE FROM DBO.PHO_ORDER_SCHEDULE
	WHERE  PHYS_ORDER_ID IN (SELECT PHYS_ORDER_ID
                         FROM   PHO_RELATED_ORDER
                         WHERE  RELATED_PHYS_ORDER_ID = @phys_order_id)

	DELETE FROM DBO.PHO_ORDER_SCHEDULE WHERE  PHYS_ORDER_ID = @phys_order_id
	
	if @isQueued = 1		
		delete from pho_order_schedule_audit where phys_order_id = @phys_order_id


	/****************************************************************/
	set @step = 1.3
	set @status_text = 'Step ' + convert(varchar,@step) +
        ' strikeout - process drug records ' + CONVERT(CHAR(8), getdate(), 114)
	if  @debug='Y' print @status_text
	/****************************************************************/
	--
	-- delete from drug record tables
	--

	DELETE FROM dbo.PHO_DRUG_RECORD WHERE PHYS_ORDER_ID=@phys_order_id
	DELETE FROM dbo.PHO_DRUG_RECORD_ORDERED WHERE PHYS_ORDER_ID=@phys_order_id
	DELETE FROM dbo.PHO_DRUG_RECORD_FILLED WHERE PHYS_ORDER_ID=@phys_order_id
	DELETE FROM dbo.PHO_DRUG_RECORD_RECEIVED WHERE PHYS_ORDER_ID=@phys_order_id

	---delete from drug change request tables
	DELETE FROM dbo.pho_phys_med_change_detail WHERE phys_order_id=@phys_order_id
	DELETE FROM dbo.pho_phys_med_change WHERE phys_order_id=@phys_order_id

	---delete from renewal request tables
	DELETE FROM dbo.pho_phys_renewal WHERE phys_order_id=@phys_order_id

	--
	-- PCC-11586 delete records from medispan class table
	--
	delete dbo.pho_order_ext_lib_cls from
	pho_order_ext_lib_cls class, pho_order_ext_lib_med_ref refr
	where refr.phys_order_id=@phys_order_id and
	class.phys_order_ext_lib_rec_id = refr.phys_order_ext_lib_rec_id

	----------
	-- PCC-73785 - Remove Order By From Resident Profile If Order By Was Added By Application During Order Entry  
	----------
	set @step = 1.31
	set @status_text = 'Step ' + convert(varchar,@step) +
        ' remove order by from resident' + CONVERT(CHAR(8), getdate(), 114) + ' physorderid: ' + CONVERT(VARCHAR, @phys_order_id)
	if  @debug='Y' print @status_text

	EXEC sproc_pho_remove_order_by_from_resident @phys_order_id

	--
    -- PCC-594 delete from pho_order_ext_lib_med_ref, all external library references
    --
    DELETE FROM dbo.PHO_ORDER_EXT_LIB_MED_REF WHERE PHYS_ORDER_ID=@phys_order_id


	/****************************************************************/
	set @step = 1.4
	set @status_text = 'Step ' + convert(varchar,@step) +
        ' strikeout - process admin orders ' + CONVERT(CHAR(8), getdate(), 114) + ' physorderid: ' + CONVERT(VARCHAR, @phys_order_id)
	if  @debug='Y' print @status_text
	/****************************************************************/

	-- Deprecated table
--    DELETE pho_phys_order_med_professional WHERE PHYS_ORDER_ID IN
--     ( SELECT PHYS_ORDER_ID FROM PHO_RELATED_ORDER WHERE RELATED_PHYS_ORDER_ID = @phys_order_id );

    DELETE FROM pho_phys_order_review WHERE PHYS_ORDER_ID IN
     ( SELECT PHYS_ORDER_ID FROM PHO_RELATED_ORDER WHERE RELATED_PHYS_ORDER_ID = @phys_order_id );


	--
	-- delete related orders references
	--
	-- *** PCC-15759 Should delete also the related admin order to this physician order medication
	-- *** Should be done here before PHO_RELATED_ORDER record is deleted
	-- *** Deletion in sequence to satisfy DB constraints
	DELETE PHO_ADMIN_ORDER_USERAUDIT
	WHERE  ADMIN_ORDER_ID IN (SELECT ADMIN_ORDER_ID
							  FROM   PHO_ADMIN_ORDER
							  WHERE  PHYS_ORDER_ID IN (SELECT PHYS_ORDER_ID
													   FROM   PHO_RELATED_ORDER
													   WHERE
									 RELATED_PHYS_ORDER_ID = @phys_order_id))

    -- *** TODO: See sproc_dml_care_pho_strikeoutAdministrativeOrder_del.sql
    -- *** Refactor similar ADMIN_ORDER SQL - out...
	DELETE PHO_ADMIN_ORDER WHERE PHYS_ORDER_ID IN
     ( SELECT PHYS_ORDER_ID FROM PHO_RELATED_ORDER WHERE RELATED_PHYS_ORDER_ID = @phys_order_id )

	DELETE PHO_PHYS_ORDER_LAST_EVENT WHERE PHYS_ORDER_ID IN
     ( SELECT PHYS_ORDER_ID FROM PHO_RELATED_ORDER WHERE RELATED_PHYS_ORDER_ID = @phys_order_id )

    DELETE FROM pho_phys_order_drug_acknowledgement
 	WHERE phys_order_id = @phys_order_id or phys_order_id2 = @phys_order_id

    DELETE FROM pho_phys_order_blackbox_acknowledgement
 	WHERE phys_order_id = @phys_order_id

    DELETE FROM pho_phys_order_allergy_acknowledgement
 	WHERE phys_order_id = @phys_order_id

    DELETE sa FROM pho_order_supply_allergy sa
    INNER JOIN pho_order_supply pos ON sa.order_supply_id = pos.order_supply_id
 	WHERE pos.phys_order_id = @phys_order_id

	DELETE PHO_PHYS_ORDER_STD_ORDER WHERE PHYS_ORDER_ID=@phys_order_id

	DELETE PHO_PHYS_ORDER
	WHERE PHYS_ORDER_ID IN
     ( SELECT PHYS_ORDER_ID FROM PHO_RELATED_ORDER WHERE RELATED_PHYS_ORDER_ID = @phys_order_id )
	-- ***
    DELETE FROM pho_phys_order_advanced_directive
 	WHERE phys_order_id = @phys_order_id

	--Delete upload file attributes
	DELETE un FROM upload_files_notes un JOIN  pho_phys_order_upload_file puf ON un.file_id = puf.uploaded_file_id
	WHERE puf.phys_order_id = @phys_order_id

	DELETE FROM pho_phys_order_upload_file WHERE phys_order_id = @phys_order_id
	-- Deprecated table
--	DELETE FROM pho_phys_order_med_professional WHERE phys_order_id = @phys_order_id;
    DELETE FROM pho_phys_order_review WHERE PHYS_ORDER_ID = @phys_order_id;

	DELETE PHO_ADMIN_ORDER WHERE PHYS_ORDER_ID=@phys_order_id

  DELETE PHO_PHYS_ORDER_REQUIRE_WITNESS WHERE PHYS_ORDER_ID = @phys_order_id


	/****************************************************************/
	set @step = 1.5
	set @status_text = 'Step ' + convert(varchar,@step) +
        ' strikeout - draft pharmacy tables ' + CONVERT(CHAR(8), getdate(), 114)
	if  @debug='Y' print @status_text
	/****************************************************************/
	-------------------------------------------------
	--If this order is draft, delete pharmacy tables
	-------------------------------------------------
	if @isDraft = 1
	begin

		DELETE FROM pho_pharmacy_note_detail
			WHERE EXISTS
			(	SELECT pharamcy.pharmacy_order_id
					FROM view_pho_phys_order p, pho_pharmacy_order pharamcy
						WHERE p.phys_order_id = pharamcy.phys_order_id
							AND pharamcy.pharmacy_order_id = pho_pharmacy_note_detail.pharmacy_order_id
							AND p.phys_order_id = @phys_order_id
			)

		DELETE FROM pho_pharmacy_schedule
			WHERE EXISTS
			(	SELECT pharamcy.pharmacy_order_id
					FROM view_pho_phys_order p, pho_pharmacy_order pharamcy
						WHERE p.phys_order_id = pharamcy.phys_order_id
							AND pharamcy.pharmacy_order_id = pho_pharmacy_schedule.pharmacy_order_id
							AND p.phys_order_id = @phys_order_id
			)


		DELETE FROM pho_pharmacy_order WHERE PHYS_ORDER_ID=@phys_order_id

	end

	--
	-- delete order supply records
	--

    DELETE PHO_SUPPLY_DISPENSE FROM pho_supply_dispense dispense, pho_order_supply supply
		   WHERE supply.phys_order_id=@phys_order_id AND
				 dispense.order_supply_id=supply.order_supply_id

	DELETE PHO_ORDER_SUPPLY WHERE PHYS_ORDER_ID=@phys_order_id

	/****************************************************************/
	set @step = 1.6
	set @status_text = 'Step ' + convert(varchar,@step) +
        ' strikeout - process queues ' + CONVERT(CHAR(8), getdate(), 114)
	if  @debug='Y' print @status_text
	/****************************************************************/
	--
	-- PCC-23799 delete from queue if any records,
	--

	DELETE PHO_ORDER_QUEUE WHERE PHYS_ORDER_ID=@phys_order_id;
	DELETE pho_order_queue_drug_protocol_action  WHERE phys_order_id=@phys_order_id;
	--
	-- do the actual phys_order delete and audit table update here
	--

	DELETE PHO_PHYS_ORDER_LAST_EVENT WHERE PHYS_ORDER_ID=@phys_order_id

  -- delete useraudit info within pho_phys_order trigger to preserve info
	-- DELETE PHO_PHYS_ORDER_USERAUDIT WHERE  PHYS_ORDER_ID = @phys_order_id

	DELETE PHO_PHYS_VENDOR WHERE PHYS_ORDER_ID=@phys_order_id

	DELETE PHO_PHYS_ORDER_STD_ORDER WHERE PHYS_ORDER_ID=@phys_order_id
	
	DELETE PHO_PHYS_ORDER_NURSE_INSTRUCTION WHERE PHYS_ORDER_ID=@phys_order_id;
	
	if @isQueued = 1
	begin
		delete ua from pho_phys_order_audit_useraudit ua inner join pho_phys_order_audit a on ua.audit_id=a.audit_id
			where a.phys_order_id = @phys_order_id
		delete la from pho_phys_order_lab_audit la inner join pho_phys_order_audit a on la.audit_id=a.audit_id
			where a.phys_order_id = @phys_order_id	
		delete from pho_phys_order_audit where phys_order_id = @phys_order_id
	end
	
	DELETE pho_phys_order_new_ctrlsubstancecode WHERE PHYS_ORDER_ID=@phys_order_id;
	
	DELETE pho_phys_order_quantity_info WHERE PHYS_ORDER_ID=@phys_order_id;

	DELETE pho_order_pending_reason where phys_order_id = @phys_order_id;

	DELETE pho_phys_order_discharge_snapshot WHERE PHYS_ORDER_ID=@phys_order_id;

	DELETE pho_phys_order_outbound_message_control where phys_order_id=@phys_order_id;
	
	DELETE ts
	FROM 
	pho_phys_order_to_sign ts 
	LEFT JOIN pho_phys_order_sign s on s.phys_order_id =ts.phys_order_id
	WHERE s.phys_order_id is null AND ts.phys_order_id=@phys_order_id;
	
	-- delete extra lab order info
	INSERT INTO @labOrderExtraInfo (device_id)
		SELECT device_id FROM pho_phys_order_lab WHERE phys_order_id=@phys_order_id;
	DELETE pho_phys_order_lab WHERE phys_order_id=@phys_order_id;

	DELETE PHO_PHYS_ORDER WHERE PHYS_ORDER_ID=@phys_order_id	-- TRIGGER FIRED

	--
	-- PCC-23799 if this is a strikeout of a queued order then no audit necessary
	--

	if @audit=1

	BEGIN

		/****************************************************************/
		set @step = 1.7
		set @status_text = 'Step ' + convert(varchar,@step) +
        	' strikeout - updating PHO_PHYS_ORDER_AUDIT table ' + CONVERT(CHAR(8), getdate(), 114)
		if  @debug='Y' print @status_text
		/****************************************************************/
		UPDATE PHO_PHYS_ORDER_AUDIT SET STRIKEOUT_BY=@strikeout_by,
										STRIKEOUT_DATE=@strikeout_date,
										STRIKEOUT_REASON_CODE=@strikeout_reason_code,
										STRIKEOUT_BY_POSITION=@strikeout_by_position
										OUTPUT INSERTED.AUDIT_ID INTO @TempAuditId
								WHERE	PHYS_ORDER_ID=@phys_order_id AND EVENT_TYPE='S'
		select @rowCount = @@rowcount

		-- check if exactly 1 row was updated

		if(@rowCount <>1)
			RAISERROR('Audit table update error', 11,1)

		SELECT @audit_id = AUDIT_ID from @TempAuditId
		
		-- create audit for extra lab order info
		INSERT INTO pho_phys_order_lab_audit
		(
			audit_id,
			device_id
		)
		SELECT
		  @audit_id,
		  device_id
		FROM
		  @labOrderExtraInfo

		/****************************************************************/
		set @step = 1.8
		set @status_text = 'Step ' + convert(varchar,@step) +
        	' strikeout - updating PHO_PHYS_ORDER_AUDIT table for admin order(s)' + CONVERT(CHAR(8), getdate(), 114)
		if  @debug='Y' print @status_text
		/****************************************************************/
		UPDATE PHO_PHYS_ORDER_AUDIT SET STRIKEOUT_BY=@strikeout_by,
										STRIKEOUT_DATE=@strikeout_date,
										STRIKEOUT_REASON_CODE=@strikeout_reason_code,
										STRIKEOUT_BY_POSITION=@strikeout_by_position
										OUTPUT INSERTED.AUDIT_ID INTO @TempAuditId
								WHERE	PHYS_ORDER_ID IN (SELECT PHYS_ORDER_ID FROM PHO_RELATED_ORDER WHERE RELATED_PHYS_ORDER_ID = @phys_order_id)
								  AND EVENT_TYPE='S'


		/****************************************************************/
		set @step = 1.9
		set @status_text = 'Step ' + convert(varchar,@step) +
        	' strikeout - updating PHO_ADMIN_ORDER_AUDIT table ' + CONVERT(CHAR(8), getdate(), 114)
		if  @debug='Y' print @status_text
		/****************************************************************/
		UPDATE PHO_ADMIN_ORDER_AUDIT SET STRIKEOUT_BY=@strikeout_by,
										STRIKEOUT_DATE=@strikeout_date,
										STRIKEOUT_REASON_CODE=@strikeout_reason_code,
										STRIKEOUT_BY_POSITION=@strikeout_by_position
								WHERE	PHYS_ORDER_ID IN (SELECT PHYS_ORDER_ID FROM PHO_RELATED_ORDER WHERE RELATED_PHYS_ORDER_ID = @phys_order_id)
								  AND EVENT_TYPE='S'


	END

	--It is better to be deleted later since PHO_RELATED_ORDER is referenced a lot
	DELETE PHO_RELATED_ORDER WHERE PHYS_ORDER_ID=@phys_order_id OR RELATED_PHYS_ORDER_ID=@phys_order_id;
	
END TRY
	BEGIN CATCH
		SELECT @returnCode = @@ERROR
		SELECT @error_msg = 'Error attempting to strikeout order:'+ERROR_MESSAGE()
		GOTO ERROR_EXIT
END CATCH
return

ERROR_EXIT:
	BEGIN
		RAISERROR (@error_msg, 10, 1)
		return @returnCode
	END


GO

grant execute on dbo.sproc_dml_care_pho_strikeoutPhysOrder_del to public
go
--


GO

print 'C_Branch/04_StoredProcedures/sproc_dml_care_pho_strikeoutPhysOrder_del.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_dml_care_pho_strikeoutPhysOrder_del.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_dso2_balance_client_payer.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*
============================================================================================== 
Purpose:             DSO Balance for specified facility, clients, payer, Year/Month

Target ENVIRONMENT:  BOTH
Target DB Type:      Client Database
Re-Runable:          YES 

CORE-17243:          DSO Updates: Update data nightly
Written By:          Andrei Medvedev
Reviewed By:         

Description:         See for details https://confluence.pointclickcare.com/confluence/x/si0ZBw

Sample executions:
DECLARE @status_code int,  @status_text varchar(3000), @ClientIdTable TableOfInt
INSERT @ClientIdTable SELECT TOP 10 client_id FROM clients WHERE fac_id = 1 ORDER BY client_id DESC
EXEC dbo.sproc_dso2_balance_client_payer 1, @ClientIdTable, 1, '2018-08-01', 'Y', @status_code, @status_text
==============================================================================================
*/

IF EXISTS (
    SELECT 1
    FROM dbo.sysobjects
    WHERE id = object_id(N'dbo.sproc_dso2_balance_client_payer')
        AND objectproperty(id, N'IsProcedure') = 1
    ) 
BEGIN 
	DROP PROCEDURE dbo.sproc_dso2_balance_client_payer
END
GO

CREATE PROCEDURE dbo.sproc_dso2_balance_client_payer
	  @facId INT
	, @ClientIdTable TableOfInt READONLY
	, @payerId INT
	, @yearMonth DATE

	, @debug_me CHAR(1) = 'N'
	, @status_code INT OUT
	, @status_text VARCHAR(3000) OUT
AS
BEGIN

	IF @debug_me <> 'Y'
		SET NOCOUNT ON;
	SET @status_code = 0;

	DECLARE @vFacId INT = @facId
		, @vPayerId INT = @payerId
		, @fromDate DATE = DATEFROMPARTS(YEAR(@yearMonth), MONTH(@yearMonth), 1);
	DECLARE @nextMonthFromDate DATE = DATEADD(MONTH, 1, @fromDate)
		, @yearMonthTrans DATE = DATEFROMPARTS(YEAR(@fromDate), MONTH(@fromDate), 15);

	DECLARE @start DATETIME = GETDATE()
		, @startMain DATETIME = GETDATE()
		, @error_code INT
		, @vgs_program_name VARCHAR(200) = Object_name(@@ProcID)  ---Current Store Proc Name
		;

	IF @debug_me = 'Y'
	BEGIN
		IF @vgs_program_name IS NULL
			SET @vgs_program_name = 'SprocCodeTest';
		PRINT 'Executing store proc :  ' + @vgs_program_name + ' ' + CONVERT(VARCHAR(26), @start, 109);
		PRINT '  @fromDate = ' + CONVERT(VARCHAR(30), @fromDate);
	END

	BEGIN TRY

        WITH Rollup_CTE AS (
			SELECT roll.client_id
				, balance = SUM(roll.amount)
			FROM @ClientIdTable cli
				JOIN dbo.ar_transactions_rollup_client roll
					ON roll.fac_id = @vFacId
						AND roll.payer_id = @vPayerId
						AND roll.transaction_date < @nextMonthFromDate
						AND roll.amount IS NOT NULL
						AND roll.client_id = cli.id
			GROUP BY roll.client_id
		)
		, Tran_CTE AS (
			SELECT t.client_id
				, balance = SUM(t.amount)
			FROM @ClientIdTable cli
				JOIN dbo.ar_transactions AS t
					ON t.deleted = 'N'
						AND t.fac_id = @vFacId
						AND t.payer_id = @vPayerId
						AND t.transaction_date < @nextMonthFromDate
						AND t.OpenClose_Flag = 'O'
						AND t.amount IS NOT NULL
						AND t.client_id = cli.id
			GROUP BY t.client_id
		)
		, Union_CTE AS (
			SELECT client_id
				, balance
			FROM Rollup_CTE
			UNION ALL
			SELECT client_id
				, balance
			FROM Tran_CTE
		)
		, Balance_CTE AS (
			SELECT client_id
				, balance = SUM(balance)
			FROM Union_CTE
			GROUP BY client_id
		)
        SELECT client_id
            , balance
        INTO #balance
        FROM Balance_CTE
        ;

        DELETE cliBal
        FROM dbo.ar_dso_client_balance cliBal
        INNER JOIN #balance b
        ON cliBal.client_id = b.client_id
        WHERE cliBal.fac_id = @vFacId
          AND cliBal.payer_id = @vPayerId
        ;

        INSERT dbo.ar_dso_client_balance
            ( fac_id
            , payer_id
            , client_id
            , balance_date
            , balance
            )
        SELECT @vFacId
             , @vPayerId
             , b.client_id
             , @startMain
             , balance = ISNULL(b.balance, 0)
        FROM #balance b
        ;

		IF @debug_me = 'Y'
			PRINT 'Duration 1: ' + CONVERT(varchar(20), DATEDIFF(millisecond, @start, GETDATE())) + ' ms - updated ar_dso_client_balance';
		SET @start = GETDATE();

        DELETE
        FROM dbo.ar_dso_balance
        WHERE fac_id = @vFacId
          AND payer_id = @vPayerId
          AND transaction_date >= @fromDate
        ;

        INSERT dbo.ar_dso_balance
            ( fac_id
            , payer_id
            , transaction_date
            , balance
            , balance_no_negatives
            )
        SELECT @vFacId
             , @vPayerId
             , @yearMonthTrans
             , balance = ISNULL(SUM(b.balance), 0)
             , balance_no_negatives = ISNULL(SUM(IIF(b.balance > 0, b.balance, 0)) ,0)
        FROM dbo.ar_dso_client_balance b
        WHERE b.fac_id = @vFacId
          AND b.payer_id = @vPayerId
        ;

		IF @debug_me = 'Y'
			PRINT 'Duration 2: ' + CONVERT(varchar(20), DATEDIFF(millisecond, @start, GETDATE())) + ' ms - updated ar_dso_balance';
		SET @start = GETDATE();

        DROP TABLE #balance

	END TRY

	BEGIN CATCH
		SET @error_code = @@error;
		SET @status_text = ERROR_MESSAGE();
		SET @status_code = 1;

		GOTO PgmAbend;
	END CATCH

	IF @debug_me = 'Y'
		PRINT 'Total Duration: ' + CONVERT(varchar(20), DATEDIFF(millisecond, @startMain, GETDATE())) + ' ms';

	PgmSuccess:
	IF @status_code = 0
	BEGIN
		IF @debug_me = 'Y'
			PRINT 'Successful execution of stored procedure';

		RETURN;
	END
	    
	PgmAbend:
	IF @debug_me = 'Y'
	BEGIN
		PRINT 'Stored procedure failure: ' + convert(varchar(26),getdate(),109);
		PRINT 'Error code: ' + convert(varchar(3),@error_code) + '; Error description:  ' + @status_text;
	END
	RAISERROR (@status_text, 16, 1);

END 
GO


GRANT EXECUTE ON dbo.sproc_dso2_balance_client_payer TO PUBLIC
GO



GO

print 'C_Branch/04_StoredProcedures/sproc_dso2_balance_client_payer.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_dso2_balance_client_payer.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_dso2_balance_fac_payer.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*
============================================================================================== 
Purpose:             DSO Balance migration for specified facility, payer, Year/Month

Target ENVIRONMENT:  BOTH
Target DB Type:      Client Database
Re-Runable:          YES 

CORE-17243:          DSO Updates: Update data nightly
Written By:          Andrei Medvedev
Reviewed By:         

Description:         See for details https://confluence.pointclickcare.com/confluence/x/si0ZBw

Sample executions:
DECLARE @status_code int,  @status_text varchar(3000)
EXEC dbo.sproc_dso2_balance_fac_payer 1, 1, '2017-02-24', 'Y', @status_code, @status_text
==============================================================================================
*/

IF EXISTS (
    SELECT 1
    FROM dbo.sysobjects
    WHERE id = object_id(N'dbo.sproc_dso2_balance_fac_payer')
        AND objectproperty(id, N'IsProcedure') = 1
    ) 
BEGIN 
	DROP PROCEDURE dbo.sproc_dso2_balance_fac_payer
END
GO

CREATE PROCEDURE dbo.sproc_dso2_balance_fac_payer
	  @facId INT
	, @payerId INT
	, @fromYearMonth DATE

	, @debug_me CHAR(1) = 'N'
	, @status_code INT OUT
	, @status_text VARCHAR(3000) OUT
AS
BEGIN

	IF @debug_me <> 'Y'
		SET NOCOUNT ON;
	SET @status_code = 0;

	DECLARE @vFacId INT = @facId
		, @vPayerId INT = @payerId
		, @fromDate DATE = DATEFROMPARTS(YEAR(@fromYearMonth), MONTH(@fromYearMonth), 1);
	DECLARE @nextMonthFromDate DATE = DATEADD(MONTH, 1, @fromDate);

	DECLARE @start DATETIME = GETDATE()
		, @startMain DATETIME = GETDATE()
		, @error_code INT
		, @vgs_program_name VARCHAR(200) = Object_name(@@ProcID)  ---Current Store Proc Name
		;

	IF @debug_me = 'Y'
	BEGIN
		IF @vgs_program_name IS NULL
			SET @vgs_program_name = 'SprocCodeTest';
		PRINT 'Executing store proc :  ' + @vgs_program_name + ' ' + CONVERT(VARCHAR(26), @start, 109);
		PRINT '  @fromDate = ' + CONVERT(VARCHAR(30), @fromDate);
	END

	BEGIN TRY

		CREATE TABLE #clientMonthlyTransactions
			( client_id INT NOT NULL
			, transaction_date DATE NOT NULL
			, isTrans BIT NOT NULL
				DEFAULT (0)
			, balance DECIMAL(19, 2) NOT NULL
			, PRIMARY KEY NONCLUSTERED 
				( client_id
				, transaction_date
				, isTrans
				)
			, UNIQUE CLUSTERED 
				( transaction_date
				, client_id
				, isTrans
				)
			);

		-- INSERT Initial Balance - Sum of the ALL years by @fromYearMonth
		INSERT #clientMonthlyTransactions
			( client_id
			, transaction_date
			, balance
			, isTrans
			)
		SELECT roll.client_id
			, transaction_date = DATEFROMPARTS(YEAR(@fromDate), MONTH(@fromDate), 15)
			, balance = SUM(roll.amount)
			, isTrans = 0
		FROM dbo.ar_transactions_rollup_client roll
		WHERE roll.fac_id = @vFacId
			AND roll.payer_id = @vPayerId
			AND roll.transaction_date < @nextMonthFromDate
			AND roll.amount IS NOT NULL
			AND roll.client_id > 0
		GROUP BY roll.client_id
		HAVING SUM(roll.amount) <> 0
		;

		IF @debug_me = 'Y'
			PRINT 'Duration 1-1: ' + CONVERT(varchar(20), DATEDIFF(millisecond, @start, GETDATE())) + ' ms - All prior years from Rollup';
		SET @start = GETDATE();

		INSERT #clientMonthlyTransactions
			( client_id
			, transaction_date
			, balance
			, isTrans
			)
		SELECT t.client_id
			, transaction_date = DATEFROMPARTS(YEAR(@fromDate), MONTH(@fromDate), 15)
			, balance = SUM(t.amount)
			, isTrans = 1
		FROM dbo.ar_transactions AS t 
		WHERE t.deleted = 'N'
			AND t.fac_id = @vFacId
			AND t.payer_id = @vPayerId
			AND t.transaction_date < @nextMonthFromDate
			AND t.OpenClose_Flag = 'O'
			AND t.amount IS NOT NULL
			AND t.client_id > 0
		GROUP BY t.client_id
		HAVING SUM(t.amount) <> 0
		;

		IF @debug_me = 'Y'
			PRINT 'Duration 1-2: ' + CONVERT(varchar(20), DATEDIFF(millisecond, @start, GETDATE())) + ' ms - All prior years from unrolled Transactions';
		SET @start = GETDATE();

		-- INSERT Sum of monthly amounts per client/payer
		INSERT #clientMonthlyTransactions
			( client_id
			, transaction_date
			, balance
			, isTrans
			)
		SELECT roll.client_id
			, transaction_date = DATEFROMPARTS(YEAR(roll.transaction_date), MONTH(roll.transaction_date), 15)
			, balance = SUM(roll.amount)
			, isTrans = 0
		FROM dbo.ar_transactions_rollup_client roll
		WHERE roll.fac_id = @vFacId
			AND roll.payer_id = @vPayerId
			AND roll.transaction_date >= @nextMonthFromDate
			AND roll.amount IS NOT NULL
			AND roll.client_id > 0
		GROUP BY roll.client_id
			, YEAR(roll.transaction_date)
			, MONTH(roll.transaction_date)
		HAVING SUM(roll.amount) <> 0
		;

		IF @debug_me = 'Y'
			PRINT 'Duration 2-1: ' + CONVERT(varchar(20), DATEDIFF(millisecond, @start, GETDATE())) + ' ms - Monthly from Rollup';
		SET @start = GETDATE();

		INSERT #clientMonthlyTransactions
			( client_id
			, transaction_date
			, balance
			, isTrans
			)
		SELECT t.client_id
			, transaction_date = DATEFROMPARTS(YEAR(t.transaction_date), MONTH(t.transaction_date), 15)
			, balance = SUM(t.amount)
			, isTrans = 1
		FROM dbo.ar_transactions AS t 
		WHERE t.deleted = 'N'
			AND t.fac_id = @vFacId
			AND t.payer_id = @vPayerId
			AND t.transaction_date >= @nextMonthFromDate
			AND t.OpenClose_Flag = 'O'
			AND t.amount IS NOT NULL
			AND t.client_id > 0
		GROUP BY t.client_id
			, YEAR(t.transaction_date)
			, MONTH(t.transaction_date)
		HAVING SUM(t.amount) <> 0
		;

		IF @debug_me = 'Y'
			PRINT 'Duration 2-2: ' + CONVERT(varchar(20), DATEDIFF(millisecond, @start, GETDATE())) + ' ms - Monthly from unrolled Transactions';
		SET @start = GETDATE();

        WITH ClientMonthlyTransactions_CTE AS (
			SELECT b.client_id
				, b.transaction_date
				, balance = SUM(b.balance)
			FROM #clientMonthlyTransactions b
			GROUP BY b.client_id
				, b.transaction_date
		)
		, ClientBalance_CTE AS (
			SELECT b.client_id
				, b.transaction_date
				, balance = SUM(bb.balance)
			FROM ClientMonthlyTransactions_CTE b
				JOIN ClientMonthlyTransactions_CTE bb
					ON bb.client_id = b.client_id
						AND bb.transaction_date <= b.transaction_date
			GROUP BY b.client_id
				, b.transaction_date
		)
		, FacClientBalance_CTE AS (
			SELECT b.client_id
				, b.transaction_date
				, b.balance
			FROM ClientBalance_CTE b
				JOIN clients cli
					ON cli.client_id = b.client_id
						AND cli.deleted = 'N'
		)
		, FacPayerDate_CTE AS (
			SELECT DISTINCT b.transaction_date
			FROM FacClientBalance_CTE b
		)
		, FacPayerBalOrdered_CTE AS (
			SELECT fpd.transaction_date
				, b.balance
				, balance_no_negatives = IIF(b.balance > 0, b.balance, 0)
				, rn = ROW_NUMBER() OVER (PARTITION BY b.client_id, fpd.transaction_date ORDER BY b.transaction_date DESC)
			FROM FacPayerDate_CTE fpd
				JOIN FacClientBalance_CTE b
					ON b.transaction_date <= fpd.transaction_date
		)
		, Balance_CTE AS (
			SELECT b.transaction_date
				, balance = SUM(b.balance)
				, balance_no_negatives = SUM(b.balance_no_negatives)
			FROM FacPayerBalOrdered_CTE b
			WHERE b.rn = 1
			GROUP BY b.transaction_date
		)
        SELECT transaction_date
            , balance
            , balance_no_negatives
        INTO #balance
        FROM Balance_CTE
        ;

        DELETE
        FROM dbo.ar_dso_balance
        WHERE fac_id = @vFacId
          AND payer_id = @vPayerId
          AND transaction_date >= @fromDate
        ;

        INSERT dbo.ar_dso_balance
            ( fac_id
            , payer_id
            , transaction_date
            , balance
            , balance_no_negatives
			)
        SELECT @vFacId
             , @vPayerId
             , b.transaction_date
             , balance = ISNULL(b.balance, 0)
             , balance_no_negatives = ISNULL(b.balance_no_negatives, 0)
        FROM #balance b
        ;

		IF @debug_me = 'Y'
			PRINT 'Duration 3: ' + CONVERT(varchar(20), DATEDIFF(millisecond, @start, GETDATE())) + ' ms - Final calculation';
		SET @start = GETDATE();
		
		DECLARE @CurrMonth CHAR(6) = CONVERT(CHAR(6), GETDATE(), 112);

        DELETE
        FROM dbo.ar_dso_client_balance
        WHERE fac_id = @vFacId
            AND payer_id = @vPayerId
        ;

        INSERT dbo.ar_dso_client_balance
            ( fac_id
            , payer_id
            , client_id
            , balance_date
            , balance
            )
        SELECT @vFacId
             , @vPayerId
             , b.client_id
             , @startMain
             , balance = ISNULL(SUM(b.balance), 0)
        FROM #clientMonthlyTransactions b
        WHERE CONVERT(CHAR(6), b.transaction_date, 112) <= @CurrMonth
        GROUP BY b.client_id
        ;

        IF @debug_me = 'Y'
			PRINT 'Duration 4: ' + CONVERT(varchar(20), DATEDIFF(millisecond, @start, GETDATE())) + ' ms - updated ar_dso_client_balance';

		DROP TABLE #clientMonthlyTransactions
        DROP TABLE #balance

	END TRY

	BEGIN CATCH
		SET @error_code = @@error;
		SET @status_text = ERROR_MESSAGE();
		SET @status_code = 1;

		GOTO PgmAbend;
	END CATCH

	IF @debug_me = 'Y'
		PRINT 'Total Duration: ' + CONVERT(varchar(20), DATEDIFF(millisecond, @startMain, GETDATE())) + ' ms';

	PgmSuccess:
	IF @status_code = 0
	BEGIN
		IF @debug_me = 'Y'
			PRINT 'Successful execution of stored procedure';

		RETURN;
	END
	    
	PgmAbend:
	IF @debug_me = 'Y'
	BEGIN
		PRINT 'Stored procedure failure: ' + convert(varchar(26),getdate(),109);
		PRINT 'Error code: ' + convert(varchar(3),@error_code) + '; Error description:  ' + @status_text;
	END
	RAISERROR (@status_text, 16, 1);

END 
GO


GRANT EXECUTE ON dbo.sproc_dso2_balance_fac_payer TO PUBLIC
GO



GO

print 'C_Branch/04_StoredProcedures/sproc_dso2_balance_fac_payer.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_dso2_balance_fac_payer.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_dso2_revenue_fac_payer.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*
============================================================================================== 
Purpose:             DSO Revenue migration for specified facility, payer, adj.code, Year/Month

Target ENVIRONMENT:  BOTH
Target DB Type:      Client Database
Re-Runable:          YES 

CORE-17243:          DSO Updates: Update data nightly
Written By:          Andrei Medvedev
Reviewed By:         

Description:         See for details https://confluence.pointclickcare.com/confluence/x/si0ZBw

Sample executions:
DECLARE @status_code int,  @status_text varchar(3000)
EXEC dbo.sproc_dso2_revenue_fac_payer 1, 1, 23, '2016-10-15', 'Y', @status_code, @status_text
==============================================================================================
*/

IF EXISTS (
    SELECT 1
    FROM dbo.sysobjects
    WHERE id = object_id(N'dbo.sproc_dso2_revenue_fac_payer')
        AND objectproperty(id, N'IsProcedure') = 1
    ) 
BEGIN 
	DROP PROCEDURE dbo.sproc_dso2_revenue_fac_payer
END
GO

CREATE PROCEDURE dbo.sproc_dso2_revenue_fac_payer
	  @facId INT
	, @payerId INT
	, @adjustmentCode INT
	, @yearMonth DATE

	, @debug_me CHAR(1) = 'N'
	, @status_code INT OUT
	, @status_text VARCHAR(3000) OUT
AS
BEGIN

	IF @debug_me <> 'Y'
		SET NOCOUNT ON;
	SET @status_code = 0;

	DECLARE @fromDate DATE = DATEFROMPARTS(YEAR(@yearMonth), MONTH(@yearMonth), 1)
		, @vFacId INT = @facId
		, @vPayerId INT = @payerId
		, @vAdjustmentCode INT = @adjustmentCode
		, @adjustmentWithCodeNull INT = -9999
		;

	DECLARE @upToExclDate DATE = DATEADD(MONTH, 1, @fromDate);

	DECLARE @start DATETIME = GETDATE()
		, @startMain DATETIME = GETDATE()
		, @error_code INT
		, @vgs_program_name VARCHAR(200) = Object_name(@@ProcID)  ---Current Store Proc Name
		;

	IF @debug_me = 'Y'
	BEGIN
		IF @vgs_program_name IS NULL
			SET @vgs_program_name = 'SprocCodeTest';

		PRINT 'Executing store proc :  ' + @vgs_program_name + ' ' + CONVERT(VARCHAR(26), @start, 109);
		PRINT '  @facId = ' + CONVERT(VARCHAR(30), @facId)
			+ '  @payerId = ' + CONVERT(VARCHAR(30), @payerId)
			+ '  @adjustmentCode = ' + CONVERT(VARCHAR(30), ISNULL(@adjustmentCode, 0))
			+ '  @fromDate = ' + CONVERT(VARCHAR(26), @fromDate, 109);
	END

	BEGIN TRY

        DELETE FROM dbo.ar_dso_revenue
        WHERE fac_id = @vFacId
          AND payer_id = @vPayerId
          AND transaction_date >= @fromDate
          AND transaction_date < @upToExclDate
          AND ISNULL(adjustment_code, 0) = ISNULL(@vAdjustmentCode, 0)
        ;

        INSERT dbo.ar_dso_revenue
            ( fac_id
            , payer_id
            , transaction_date
            , adjustment_code
            , revenue
			)
        SELECT @vFacId
           , @vPayerId
           , transaction_date = DATEFROMPARTS(YEAR(t.transaction_date), MONTH(t.transaction_date), 15)
           , @vAdjustmentCode
           , revenue = ISNULL(SUM(t.amount), 0)
        FROM dbo.ar_transactions t
                 JOIN dbo.ar_lib_payers p
                      ON p.payer_id = t.payer_id
                          AND p.deleted = 'N'
        WHERE t.transaction_type <> 'C'
          AND t.fac_id = @vFacId
          AND t.payer_id = @vPayerId
          AND (IIF(t.transaction_type = 'X', ISNULL(t.item_type_id, @adjustmentWithCodeNull), 0) = ISNULL(@vAdjustmentCode, 0))  -- if Adjustment Code is NULL we also need to compare it (without OR is NULL)
          AND t.transaction_date >= @fromDate
          AND t.transaction_date < @upToExclDate
          AND t.amount IS NOT NULL
          AND t.deleted = 'N'
        GROUP BY t.fac_id
               , t.payer_id
               , YEAR(t.transaction_date)
               , MONTH(t.transaction_date)
               , IIF(t.transaction_type = 'X', ISNULL(t.item_type_id, @adjustmentWithCodeNull), NULL)
        HAVING SUM(t.amount) <> 0
        ;

	END TRY

	BEGIN CATCH
		SET @error_code = @@error;
		SET @status_text = ERROR_MESSAGE();
		SET @status_code = 1;

		GOTO PgmAbend;
	END CATCH

	IF @debug_me = 'Y'
		PRINT 'Total Duration: ' + CONVERT(varchar(20), DATEDIFF(millisecond, @startMain, GETDATE())) + ' ms';

	RETURN

	PgmSuccess:
	IF @status_code = 0
	BEGIN
		IF @debug_me = 'Y'
			PRINT 'Successful execution of stored procedure';

		RETURN;
	END
	    
	PgmAbend:
	IF @debug_me = 'Y'
	BEGIN
		PRINT 'Stored procedure failure: ' + convert(varchar(26),getdate(),109);
		PRINT 'Error code: ' + convert(varchar(3),@error_code) + '; Error description:  ' + @status_text;
	END
	RAISERROR (@status_text, 16, 1);

END 
GO


GRANT EXECUTE ON dbo.sproc_dso2_revenue_fac_payer TO PUBLIC
GO



GO

print 'C_Branch/04_StoredProcedures/sproc_dso2_revenue_fac_payer.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_dso2_revenue_fac_payer.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_dso2_updateJob.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*
============================================================================================== 
Purpose:             Nightly job that updates ar_dso_balance, ar_dso_revenue tables

Target ENVIRONMENT:  BOTH
Target DB Type:      Client Database
Re-Runable:          YES 

CORE-17243:          DSO Updates: Update data nightly
Written By:          Andrei Medvedev
Reviewed By:         

Description:         See for details https://confluence.pointclickcare.com/confluence/x/si0ZBw

Sample executions:
DECLARE @status_code int,  @status_text varchar(3000)
EXEC dbo.sproc_dso2_updateJob 'Y', @status_code, @status_text
==============================================================================================
*/

IF EXISTS (
    SELECT 1
    FROM dbo.sysobjects
    WHERE id = object_id(N'dbo.sproc_dso2_updateJob')
        AND objectproperty(id, N'IsProcedure') = 1
    ) 
BEGIN 
	DROP PROCEDURE dbo.sproc_dso2_updateJob
END
GO

CREATE PROCEDURE dbo.sproc_dso2_updateJob
	  @debug_me CHAR(1) = 'N'
	, @status_code INT OUT
	, @status_text VARCHAR(3000) OUT
AS
BEGIN

	IF @debug_me <> 'Y'
		SET NOCOUNT ON;
	SET @status_code = 0;

	DECLARE 
		  @changeTrackingLastVersionParam VARCHAR(100)  = 'DSO_DASHBOARD__CHANGE_TRACKING_LAST_VERSION'
		, @changeTrackingLastVersion BIGINT
		, @changeTrackingCurrentVersion BIGINT
		, @tablesLastUpdateDateTimeParam VARCHAR(100)   = 'DSO_DASHBOARD__TABLES_LAST_UPDATE_DATETIME'
		, @tablesLastUpdateDateTime DATETIME
		, @balanceByClientMaxClientsParam VARCHAR(100)   = 'DSO_DASHBOARD__BALANCE_BY_CLIENT_MAX_CLIENTS'
		, @balanceByClientMaxClients INT
		, @balanceByClientMaxClientsDefault INT = 20
		, @adjustmentWithCodeNull INT = -9999
		, @trunkateTable CHAR(1) = 'N'
		, @error_code INT
		, @vgsStepStartTime DATETIME
		, @vgsTotalStartTime DATETIME = GETDATE()
		, @vgs_program_name VARCHAR(200) = Object_name(@@ProcID)  ---Current Store Proc Name
		;

	DECLARE @monthsPerYear INT = 12
		, @newMonth CHAR(1) = 'N'
		, @thisMonth DATE = DATEFROMPARTS(YEAR(GETDATE()), MONTH(GETDATE()), 1)
--		, @upToMonth DATE
--		, @upToPreviousMonth DATE
		;
	DECLARE @from3YrBackDate DATE = DATEADD(MONTH, -((3 * @monthsPerYear) + 1), @thisMonth)
		, @from2YrBackDate DATE = DATEADD(MONTH, -((2 * @monthsPerYear) + 1), @thisMonth);

	CREATE TABLE #changes
		( fac_id INT NOT NULL
		, payer_id INT NOT NULL
		, client_id INT NOT NULL
		, transactionYearMonth DATE NOT NULL
		, adjustmentCodeId INT
		, UNIQUE CLUSTERED 
			( transactionYearMonth
			, fac_id
			, payer_id
			, client_id
			, adjustmentCodeId
			)
		);

	DECLARE @fac_id INT
		, @payer_id INT
		, @transactionYearMonth DATE
		, @adjustmentCodeId INT;

	IF @debug_me = 'Y'
	BEGIN
		SET @vgsStepStartTime = GETDATE();
		IF @vgs_program_name IS NULL
			SET @vgs_program_name = 'SprocCodeTest';
		PRINT 'Executing store proc :  ' + @vgs_program_name + ' ' + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);
	END

	BEGIN TRY
		
		-- Load parameters
		SET @balanceByClientMaxClients = (
				SELECT TOP 1 CONVERT(INT, IIF(ISNUMERIC([value]) = 1, [value], NULL))
				FROM configuration_parameter
				WHERE fac_id = -1
					AND [name] = @balanceByClientMaxClientsParam
			);
		IF @balanceByClientMaxClients IS NULL
			SET @balanceByClientMaxClients = @balanceByClientMaxClientsDefault;

		SET @tablesLastUpdateDateTime = (
				SELECT TOP 1 CONVERT(DATETIME, IIF(ISDATE([value]) = 1, [value], NULL))
				FROM configuration_parameter
				WHERE fac_id = -1
					AND [name] = @tablesLastUpdateDateTimeParam
			);

		-- no saved date - take from table - next month
		IF @tablesLastUpdateDateTime IS NULL
		BEGIN
			SELECT @tablesLastUpdateDateTime = MAX(transaction_date)
			FROM ar_dso_balance;

			IF @tablesLastUpdateDateTime IS NOT NULL
			BEGIN
				SET @tablesLastUpdateDateTime = DATEADD(MONTH, 1, @tablesLastUpdateDateTime);
				SET @tablesLastUpdateDateTime = DATEFROMPARTS(YEAR(@tablesLastUpdateDateTime), MONTH(@tablesLastUpdateDateTime), 1);
			END
		END

		SET @changeTrackingLastVersion = (
				SELECT TOP 1 CONVERT(BIGINT, IIF(ISNUMERIC([value]) = 1, [value], NULL))
				FROM configuration_parameter
				WHERE fac_id = -1
					AND [name] = @changeTrackingLastVersionParam
			);

		SET @changeTrackingCurrentVersion = CHANGE_TRACKING_CURRENT_VERSION();

		IF @debug_me = 'Y'
			SELECT changeTrackingLastVersion = @changeTrackingLastVersion
				, changeTrackingCurrentVersion = @changeTrackingCurrentVersion
				, MIN_VALID_VERSION_ar_transactions = CHANGE_TRACKING_MIN_VALID_VERSION(OBJECT_ID('dbo.ar_transactions'))
				, tablesLastUpdateDateTime = @tablesLastUpdateDateTime;

		IF @tablesLastUpdateDateTime IS NULL
			OR @changeTrackingLastVersion IS NULL
			OR @changeTrackingLastVersion < CHANGE_TRACKING_MIN_VALID_VERSION(OBJECT_ID('dbo.ar_transactions'))
		BEGIN
			IF @debug_me = 'Y'
			BEGIN
				PRINT '!!! Outdated - recalculate for the all facilities - data migration!!!';
				SELECT from2YrBackDate = @from2YrBackDate, from3YrBackDate = @from3YrBackDate;
			END
			
			SET @changeTrackingLastVersion = NULL;
			SET @trunkateTable = 'Y';

			EXEC dbo.sproc_dso2_balance_migration @from2YrBackDate, @trunkateTable, @debug_me, @status_code, @status_text;
			EXEC dbo.sproc_dso2_revenue_migration @from3YrBackDate, @trunkateTable, @debug_me, @status_code, @status_text;
		END
		ELSE
		BEGIN
			
			SET @newMonth = IIF(CONVERT(CHAR(6), @tablesLastUpdateDateTime, 112) < CONVERT(CHAR(6), @thisMonth, 112), 'Y', 'N');

			IF @debug_me = 'Y'
			BEGIN
				SET @vgsStepStartTime = GETDATE();
				SELECT newMonth = @newMonth;
			END

			-- load changes
			INSERT #changes
				( fac_id
				, payer_id
				, client_id
				, transactionYearMonth
				, adjustmentCodeId
				)
			SELECT DISTINCT tr.fac_id
				, tr.payer_id
				, tr.client_id
				, transactionYearMonth = DATEFROMPARTS(YEAR(tr.transaction_date), MONTH(tr.transaction_date), 15)
				, adjustmentCodeId = IIF(tr.transaction_type = 'X', ISNULL(tr.item_type_id, @adjustmentWithCodeNull), NULL)
			FROM CHANGETABLE(CHANGES ar_transactions, @changeTrackingLastVersion) ct
				JOIN ar_transactions tr
					ON tr.transaction_id = ct.transaction_id
			WHERE tr.fac_id IS NOT NULL
				AND tr.payer_id IS NOT NULL
				AND tr.client_id IS NOT NULL
				AND tr.transaction_date IS NOT NULL
			;

			IF @debug_me = 'Y'
				SELECT * FROM #changes;

			IF EXISTS (
					SELECT TOP 1 1
					FROM #changes
				)
			BEGIN

				-- loop through balances
				BEGIN
				
					DECLARE @CurrMonth CHAR(6) = CONVERT(CHAR(6), GETDATE(), 112)
						, @maxYearMonth DATE
						, @ClientIdCount INT
						, @FutureTrans CHAR(1) = 'N';
					DECLARE @ClientIdTable TableOfInt;

					DECLARE BalCursor CURSOR FOR
						SELECT fac_id
							, payer_id
							, fromYearMonth = 
								IIF(CONVERT(CHAR(6), MIN(transactionYearMonth), 112) < CONVERT(CHAR(6), @from2YrBackDate, 112)
											, @from2YrBackDate
											, MIN(transactionYearMonth)
										)
							, maxYearMonth = MAX(transactionYearMonth)
						FROM #changes
						GROUP BY fac_id
							, payer_id
					;

					OPEN BalCursor;
					FETCH NEXT FROM BalCursor INTO @fac_id, @payer_id, @transactionYearMonth, @maxYearMonth;

					WHILE @@FETCH_STATUS = 0
					BEGIN
						DELETE
						FROM @ClientIdTable;

						INSERT @ClientIdTable
						SELECT DISTINCT client_id
						FROM #changes
						WHERE fac_id = @fac_id
							AND payer_id = @payer_id
							AND (CONVERT(CHAR(6), @transactionYearMonth, 112) = @CurrMonth);

						SET @ClientIdCount = (
								SELECT COUNT(*)
								FROM @ClientIdTable
							);
						SET @FutureTrans = IIF(EXISTS(
								SELECT 1
								FROM dbo.ar_dso_balance
								WHERE fac_id = @fac_id
									AND payer_id = @payer_id
									AND CONVERT(CHAR(6), transaction_date, 112) > @CurrMonth
							), 'Y', 'N');

						IF @debug_me = 'Y' 
							PRINT '  @transactionYearMonth = ' + CONVERT(CHAR(6), @transactionYearMonth, 112)
								+ '  @maxYearMonth = ' + CONVERT(CHAR(6), @maxYearMonth, 112)
								+ '  @balanceByClientMaxClients = ' + CONVERT(VARCHAR(20), @balanceByClientMaxClients)
								+ '  @ClientIdCount = ' + CONVERT(VARCHAR(20), @ClientIdCount)
								+ '  @FutureTrans = ' + @FutureTrans;

						IF CONVERT(CHAR(6), @transactionYearMonth, 112) <> @CurrMonth
								OR CONVERT(CHAR(6), @maxYearMonth, 112) <> @CurrMonth
								OR @ClientIdCount > @balanceByClientMaxClients
								OR @FutureTrans = 'Y'
							-- transactions not for current month or too many clients
							EXEC dbo.sproc_dso2_balance_fac_payer @fac_id, @payer_id, @transactionYearMonth, @debug_me, @status_code, @status_text;
						ELSE
							EXEC dbo.sproc_dso2_balance_client_payer @fac_id, @ClientIdTable, @payer_id, @transactionYearMonth, @debug_me, @status_code, @status_text;

						FETCH NEXT FROM BalCursor INTO @fac_id, @payer_id, @transactionYearMonth, @maxYearMonth;
					END

					CLOSE BalCursor;
					DEALLOCATE BalCursor;
				END

				-- loop through revenues
				BEGIN
					DECLARE RevCursor CURSOR FOR
						SELECT DISTINCT fac_id
							, payer_id
							, transactionYearMonth
							, adjustmentCodeId
						FROM #changes
						WHERE CONVERT(CHAR(6), transactionYearMonth, 112) >= CONVERT(CHAR(6), @from3YrBackDate, 112)
					;

					OPEN RevCursor;
					FETCH NEXT FROM RevCursor INTO @fac_id, @payer_id, @transactionYearMonth, @adjustmentCodeId;

					WHILE @@FETCH_STATUS = 0
					BEGIN
						EXEC dbo.sproc_dso2_revenue_fac_payer @fac_id, @payer_id, @adjustmentCodeId, @transactionYearMonth, @debug_me, @status_code, @status_text;

						FETCH NEXT FROM RevCursor INTO @fac_id, @payer_id, @transactionYearMonth, @adjustmentCodeId;
					END

					CLOSE RevCursor;
					DEALLOCATE RevCursor;
				END
			END

			-- new month processing
			IF @newMonth = 'Y'
			BEGIN
				IF @debug_me = 'Y' 
					SET @vgsStepStartTime = GETDATE();

				DELETE
				FROM dbo.ar_dso_balance
				WHERE CONVERT(CHAR(6), transaction_date, 112) < CONVERT(CHAR(6), @from2YrBackDate, 112);

				DELETE
				FROM dbo.ar_dso_revenue
				WHERE CONVERT(CHAR(6), transaction_date, 112) < CONVERT(CHAR(6), @from3YrBackDate, 112);

				IF @debug_me = 'Y' 
					PRINT 'Duration clean-up: ' + LTRIM(RTRIM(STR(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';
			END
		END

		-- save parameters
        UPDATE configuration_parameter
        SET value = CONVERT(VARCHAR(30), @changeTrackingCurrentVersion)
        WHERE fac_id = -1 and name = @changeTrackingLastVersionParam
		;

		IF @@ROWCOUNT = 0
        INSERT INTO configuration_parameter (fac_id, name, value)
        VALUES (-1, @changeTrackingLastVersionParam, CONVERT(VARCHAR(30), @changeTrackingCurrentVersion))
        ;

        UPDATE configuration_parameter
        SET value = CONVERT(VARCHAR(30), @vgsTotalStartTime)
        WHERE fac_id = -1 and name = @tablesLastUpdateDateTimeParam
		;

        IF @@ROWCOUNT = 0
        INSERT INTO configuration_parameter (fac_id, name, value)
        VALUES (-1, @tablesLastUpdateDateTimeParam, CONVERT(VARCHAR(30), @vgsTotalStartTime))
        ;

	END TRY

	BEGIN CATCH
		SET @error_code = @@error;
		SET @status_text = ERROR_MESSAGE();
		SET @status_code = 1;

		GOTO PgmAbend;
	END CATCH

	IF @debug_me = 'Y' 
		PRINT 'Total execution time: ' + LTRIM(RTRIM(STR(DATEDIFF(ms, @vgsTotalStartTime, GETDATE()))))+ ' ms';

	PgmSuccess:
	IF @status_code = 0
	BEGIN
		IF @debug_me = 'Y'
			PRINT 'Successful execution of stored procedure';

		RETURN;
	END
	    
	PgmAbend:
	IF @debug_me = 'Y'
	BEGIN
		PRINT 'Stored procedure failure: ' + convert(varchar(26),getdate(),109);
		PRINT 'Error code: ' + convert(varchar(3),@error_code) + '; Error description:  ' + @status_text;
	END
	RAISERROR (@status_text, 16, 1);

END 
GO


GRANT EXECUTE ON dbo.sproc_dso2_updateJob TO PUBLIC
GO



GO

print 'C_Branch/04_StoredProcedures/sproc_dso2_updateJob.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_dso2_updateJob.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_empi_list_extractFacilityInfo_v2.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- =========================================================================================================================
-- Jira #:               CORE-26032
--
-- Written By:           Pedja Topalov
--  
-- Script Type:          User defined stored procedure 
-- Target DB Type:       CLIENT
-- Target ENVIRONMENT:   BOTH
--              
--  Re-Runable:          Yes
--
--  Description :        Extracts facility data within client DB required for eMPI synchronization. 
--                       Criteria for facilities to be picked up for sync:
--                        - Not HHC
--                        - Not Home office nor IRM fac
--                        - Active (not deleted nor inactivated)
--                       Script runs in 2 modes depending on the input param lastSyncedVersion value:
--                       1. if value is null, 'initial' facility record set that matches criteria is returned without checking 
--                          db change tracking
--                       2. if value is not null, facilities records are being returned only if there were any changes in  
--                          columns of interest on records that are matching criteria based on passed DB Change tracking 
--                          version number. Columns of interest are: (facility table) name, health_type, address1, address2,  
--                          city, prov, pc, deleted, inactive
--                       In case sync hasn't been done for period longer than retention time of DB Change tracking and 
--                       lastSyncedVersion became invalid, 'initial' facility record set is returned in order to RE-initialize
--
--  Parameters:
--          @lastSyncedVersion       - Last successfully synced DB Change tracking version number. If null is passed then 
--                                     the 'initial' facility record set is retrieved without checking db change tracking.
--          @currentSyncVersion(OUT) - DB Change tracking version number that should be used next time changes (delta) are
--                                     requested.
--
-- =========================================================================================================================
/*
Sample executions:
- Initial load
DECLARE @lastSyncedVersion BIGINT = null
		, @currentSyncVersion BIGINT
		, @status_code INT
		, @status_text VARCHAR(3000)
EXEC dbo.sproc_empi_list_extractFacilityInfo_v2 @lastSyncedVersion, @currentSyncVersion OUTPUT, 'Y', @status_code OUTPUT, @status_text OUTPUT
SELECT @currentSyncVersion
- Changes load
DECLARE @lastSyncedVersion BIGINT = 1
		, @currentSyncVersion BIGINT
		, @status_code INT
		, @status_text VARCHAR(3000)
EXEC dbo.sproc_empi_list_extractFacilityInfo_v2 @lastSyncedVersion, @currentSyncVersion OUTPUT, 'Y', @status_code OUTPUT, @status_text OUTPUT
SELECT @currentSyncVersion
*/

IF EXISTS (
    SELECT 1
    FROM dbo.sysobjects
    WHERE id = object_id(N'dbo.sproc_empi_list_extractFacilityInfo_v2')
        AND objectproperty(id, N'IsProcedure') = 1
    ) 
BEGIN 
    DROP PROCEDURE dbo.sproc_empi_list_extractFacilityInfo_v2
END
GO


CREATE PROCEDURE [dbo].[sproc_empi_list_extractFacilityInfo_v2]
	  @lastSyncedVersion BIGINT
	, @currentSyncVersion BIGINT OUT
	, @DebugMe CHAR(1) = 'N'
	, @status_code INT OUT
	, @status_text VARCHAR(3000) OUT
AS
BEGIN

	SET NOCOUNT ON;
	SET @status_code = 0;
	DECLARE @error_code INT;
	DECLARE @minimumValidVersion BIGINT;

	DECLARE @facility_objectId INT            = OBJECT_ID('facility');
	DECLARE @fac_name_columnId INT            = COLUMNPROPERTY(@facility_objectId, 'name', 'ColumnId');
	DECLARE @fac_health_type_columnId INT     = COLUMNPROPERTY(@facility_objectId, 'health_type', 'ColumnId');
	DECLARE @fac_address1_columnId INT        = COLUMNPROPERTY(@facility_objectId, 'address1', 'ColumnId');
	DECLARE @fac_address2_columnId INT        = COLUMNPROPERTY(@facility_objectId, 'address2', 'ColumnId');
	DECLARE @fac_city_columnId INT            = COLUMNPROPERTY(@facility_objectId, 'city', 'ColumnId');
	DECLARE @fac_prov_columnId INT            = COLUMNPROPERTY(@facility_objectId, 'prov', 'ColumnId');
	DECLARE @fac_pc_columnId INT              = COLUMNPROPERTY(@facility_objectId, 'pc', 'ColumnId');
	DECLARE @fac_deleted_columnId INT         = COLUMNPROPERTY(@facility_objectId, 'deleted', 'ColumnId');
	DECLARE @fac_inactive_columnId INT        = COLUMNPROPERTY(@facility_objectId, 'inactive', 'ColumnId');
	DECLARE @fac_location_status_columnId INT = COLUMNPROPERTY(@facility_objectId, 'location_status_id', 'ColumnId');


	
	BEGIN TRY
    
    -- Create Temporary tables
    -- stores facility ids for records that got changed (inserted or updated)
	IF OBJECT_ID(N'tempdb..#changedRecords') IS NOT NULL
	DROP TABLE #changedRecords;
    
	CREATE TABLE #changedRecords
    (
        fac_id INT,
		is_reindex BIT
    );
	
	SET TRANSACTION ISOLATION LEVEL SNAPSHOT;  
	BEGIN TRAN 
	
		-- get current Change tracking version and minimal valid version
		SET @currentSyncVersion = CHANGE_TRACKING_CURRENT_VERSION();
		SET @minimumValidVersion = CHANGE_TRACKING_MIN_VALID_VERSION(@facility_objectId);
		
		
		IF @lastSyncedVersion IS NOT NULL AND @lastSyncedVersion >= @minimumValidVersion
		BEGIN
			/* This branch should execute in case sync was previously successfully completed
			 * and Last synchronized version is valid, so we need to fetch only changes (delta)
			 * that happen since last check.
			 */
			IF @DebugMe='Y' PRINT 'Fetch changed records since version ' + convert(varchar(20),@lastSyncedVersion);
	

			INSERT INTO #changedRecords
			SELECT 
				fac.fac_id,
				0 AS is_reindex
			FROM facility fac
				INNER JOIN CHANGETABLE(CHANGES facility, @lastSyncedVersion) AS CT ON fac.fac_id = ct.fac_id
			WHERE 
				(
					CHANGE_TRACKING_IS_COLUMN_IN_MASK(@fac_name_columnId, CT.SYS_CHANGE_COLUMNS) = 1
					OR CHANGE_TRACKING_IS_COLUMN_IN_MASK(@fac_health_type_columnId, CT.SYS_CHANGE_COLUMNS) = 1
					OR CHANGE_TRACKING_IS_COLUMN_IN_MASK(@fac_address1_columnId, CT.SYS_CHANGE_COLUMNS) = 1
					OR CHANGE_TRACKING_IS_COLUMN_IN_MASK(@fac_address2_columnId, CT.SYS_CHANGE_COLUMNS) = 1
					OR CHANGE_TRACKING_IS_COLUMN_IN_MASK(@fac_city_columnId, CT.SYS_CHANGE_COLUMNS) = 1
					OR CHANGE_TRACKING_IS_COLUMN_IN_MASK(@fac_prov_columnId, CT.SYS_CHANGE_COLUMNS) = 1
					OR CHANGE_TRACKING_IS_COLUMN_IN_MASK(@fac_pc_columnId, CT.SYS_CHANGE_COLUMNS) = 1
					OR CHANGE_TRACKING_IS_COLUMN_IN_MASK(@fac_location_status_columnId, CT.SYS_CHANGE_COLUMNS) = 1
				)
				OR
				( -- if fac_uuid was not null (i.e. facility was already indexed), then get the facility when deleted or inactive field changed to any value
				  -- OR if fac_uuid was null (i.e. facility was not indexed), then get the faciity only when changes in deleted or inactive field caused the facility status to remain or change to active 
					(
						CHANGE_TRACKING_IS_COLUMN_IN_MASK(@fac_deleted_columnId, CT.SYS_CHANGE_COLUMNS) = 1
						OR CHANGE_TRACKING_IS_COLUMN_IN_MASK(@fac_inactive_columnId, CT.SYS_CHANGE_COLUMNS) = 1
					)
					AND (fac.fac_uuid IS NOT NULL OR (ISNULL(fac.deleted, 'N') = 'N' AND ISNULL(fac.inactive, 'N') = 'N'))
				)
			UNION
			SELECT 
				fac.fac_id,
				0 AS is_reindex
			FROM facility fac
				INNER JOIN CHANGETABLE(CHANGES configuration_parameter, @lastSyncedVersion) AS CT ON (ct.fac_id = fac.fac_id AND ct.name = 'mds3_ccn')
			UNION
			SELECT 
				reindex.entity_id,
				1 AS is_reindex
			FROM empi_data_sync_reindex reindex
			WHERE entity_type = 'fac' AND only_entity = 1
                
			SELECT 
				fac.fac_uuid
				, fac.fac_id
				, fac.name
				, fac.health_type
				, fac.address1
				, fac.address2
				, fac.city
				, fac.prov
				, fac.pc
				, fac.deleted
				, fac.inactive
				, CASE WHEN fac.fac_uuid IS NULL THEN 'I' ELSE 'U' END AS change_operation
				, COALESCE(NULLIF(cp.[value],''), NULLIF(ac.medicare_prov_no,'')) AS ccn
				, cr.is_reindex
				, ls.code AS location_status_code
			FROM #changedRecords cr
				INNER JOIN facility fac on cr.fac_id = fac.fac_id 
				LEFT JOIN configuration_parameter cp ON cp.fac_id = cr.fac_id  AND cp.[name] = 'mds3_ccn'
				LEFT JOIN as_configuration ac ON fac.fac_id = ac.fac_id
				LEFT JOIN location_status ls ON fac.location_status_id = ls.location_status_id
			WHERE 				
				ISNULL(fac.is_live,'Y') = 'Y'
				AND fac.health_type != 'HHC'
				AND fac.fac_id NOT IN (9999, 9001)
				AND ISNULL(fac.deleted, 'N') = 'N' AND ISNULL(fac.inactive, 'N') = 'N'
					
		END    
		ELSE
		BEGIN
			/* Query is returning all facilities that are meeting criteria:
			 *  - Ignore HHC
			 *  - Ignore Home office (9999) and IRM (9001) facilities
			 *  - if facility has never been synced it must not be deleted or inactivated 
			 *  - if facility has been synced (fac_uuid exists) we are not checking if it's active
			 * This branch should execute in two scenarios
			 *  1. Sync is being done for the first time and we need to initialize
			 *  2. Last synchronized version is smaller than minimum valid synchronization version and RE-initialize is required
			 */
			IF @DebugMe='Y' PRINT 'Initial load';

			SELECT
				fac.fac_uuid
				, fac.fac_id
				, fac.name
				, fac.health_type
				, fac.address1
				, fac.address2
				, fac.city
				, fac.prov
				, fac.pc
				, ISNULL(fac.deleted, 'N') deleted
				, ISNULL(fac.inactive, 'N') inactive
				, CASE WHEN fac.fac_uuid IS NULL THEN 'I' ELSE 'U' END AS change_operation
                , COALESCE(NULLIF(cp.[value],''), NULLIF(ac.medicare_prov_no,''), NULL) AS ccn
				-- facilities that need to be re-processed themselves, not ones that are indexed and need patients processed
				, CASE WHEN r.only_entity IS NULL THEN 0 ELSE 1 END AS is_reindex
				, ls.code AS location_status_code
			FROM facility fac
                LEFT JOIN configuration_parameter cp ON fac.fac_id = cp.fac_id AND cp.[name] = 'mds3_ccn'
                LEFT JOIN as_configuration ac ON fac.fac_id = ac.fac_id
				LEFT JOIN empi_data_sync_reindex r ON fac.fac_id = r.entity_id AND r.entity_type = 'fac' AND r.only_entity = 1
				LEFT JOIN location_status ls ON fac.location_status_id = ls.location_status_id
			WHERE
				-- only check for deleted and inactive flag if the facility was never synced (i.e. fac_uuid is null)
				(fac.fac_uuid IS NOT NULL OR (ISNULL(fac.deleted, 'N') = 'N' AND ISNULL(fac.inactive, 'N') = 'N'))
				AND ISNULL(fac.is_live,'Y') = 'Y'
                -- Ignore HHC
				AND fac.health_type != 'HHC'
                -- Ignore Home office (9999) and IRM (9001) facilities
				AND fac.fac_id NOT IN (9999, 9001);
			
		END
	
    IF @@TRANCOUNT > 0
        COMMIT TRAN 
	IF @DebugMe='Y' PRINT 'Current sync version ' + convert(varchar(20),@currentSyncVersion);
	
	END TRY

	BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRAN
        
		SET @error_code = @@error
		SET @status_text = ERROR_MESSAGE()
		SET @status_code = 1
	 
		GOTO PgmAbend
	END CATCH

	PgmSuccess:
	IF @status_code = 0
	BEGIN
		IF @DebugMe='Y' 
			PRINT 'Successful execution of stored procedure'
		RETURN
	END
	    
	PgmAbend:
	IF @DebugMe='Y'
	BEGIN
		PRINT 'Stored procedure failure: ' + convert(varchar(26),getdate(),109)
		PRINT 'Error code: ' + convert(varchar(3),@error_code) + '; Error description:  ' + @status_text
	END
	RAISERROR(@status_text, 16, 1)
END
GO

GRANT EXECUTE ON dbo.sproc_empi_list_extractFacilityInfo_v2 TO PUBLIC
GO

GO

print 'C_Branch/04_StoredProcedures/sproc_empi_list_extractFacilityInfo_v2.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_empi_list_extractFacilityInfo_v2.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_getEnhancedOrder.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


 -- ===============================================================================================================================
 -- ---------------
 -- Deprecated
 --	---------------
 -- 
 -- Purpose: The purpose of this procedure is to load a phys order with all it's schedule information
 --
 -- Target ENVIRONMENT: BOTH 
 --
 --  Special Instructions: 
 --
 --	Params:
 --			
 --			@physOrderId    - phys order id
 --			@facId			- Facility Id 
 --			@includeAdministrativeOrder - Flag to include Administrative Orders, 'Y' or 'N'
 --			@includeSupplyInfo - Flag to include Supply Info, 'Y' or 'N'
 --			@debug          - Debug param, 'Y' or 'N'
 --			@status_code    - SP execution flag, 0 for success.
 --			@status_text    - SP error text if error occurs.
 --
 -- Change History:
 --   Author			Date		Comment
 -- ------------------------------------------------------------------------------------------------------------------------------- 
 --	  Joel Pelletier    08/11/2011	Created.
 --   Alireza Mandegar	10/15/2012	Updated due to PCC-33677 and Replaced the usage of fn_pho_getOrderStatus with sproc_pho_getOrderStatus
 --									Also modified the file maintenance box to be in sql comment format rather than java format
 --									and added the Change History section to it to keep track of changes.
 --  Alireza Mandegar	 11/12/2012	Added pho_ext_lib_generic_desc/id for PCC-34329
 --  Alireza Mandegar	 11/22/2012	Added schedule_sliding_scale_id due to PCC-30715
 --  Alireza Mandegar	 11/29/2012	Added schedule_dose_duration due to PCC-32538
 --  Feng Xia			 12/15/2012	Added xxMonths
 --  Alireza Mandegar	 12/20/2012	Added apply_remove_flag due to PCC-32537
 --  Alireza Mandegar	 01/25/2013	Added remove_time due to PCC-32537
 --  Alireza Mandegar	 01/31/2013	Added remove_duration due to PCC-32537
 --  Aarti Malhotra      09/24/2013  Added pho_ext_lib_rxnorm for PCC-47251 (main JIRA PCC-46704)
 --  Mustafa Behrainwala 04/28/2014  Added table to handle Therapeutic Interchange sliding scale PCC-52492 
 --  Mustafa Behrainwala 07/31/2014  Added Linked Set Id and Description for PCC-59209
 --	 Mustafa Behrainwala 10/29/2015	 Added order_class_id
 --  Willie Wong		 05/11/2016	 Added schedule_directions for dietary orders for PCC-94151
 --	 Nooshin Hayeri		 06/29/2016	Added snapshot_schedule_start_date for PCC-96359
 --  Melvin Parinas      07/16/2016  Removed snapshot_schedule_start_date and replaced with earliest_prescriber_start_date date PCC-96359
 --  Melvin Parinas      07/25/2016  Added prescriber_schedule_start_date due to PCC-98059	
 --	 Devika Bapat		 02/24/2017	Added 2 optional parameters to include administrative orders and supply info PCC-108894
 --	 Mustafa Behrainwala 10/12/2018 Modified due to CORE-23367 to add dose_low for dose ranging.
 --	 Elias Ghanem 		 12/21/2018 	Added last_pharmacy_end_date due to CORE-28433.
 --  Mustafa Behrainwala 01/29/2019 Modified due to CORE-29190 return behavior lookup
 --  Elias Ghanem 		 01/29/2019 Added schedule_revision_date due to CORE-85435
 --  Sree Naghasundharam 11/18/2021 This Stored Procedure 'sproc_pho_list_getEnhancedOrder' is herebry deprecated(CORE-97119).
 --									New stored procedure 'sproc_pho_list_getEnhancedOrder_v2' created to remove 'mmdb' references.
 --									Any further changes to 'sproc_pho_list_getEnhancedOrder' should also be made in the new stored procedure.
 --  Jarek Zawojski      01/18/2022 Added prescription_dispense_interval prescription_total_authorized_quantity (CORE-99218)
 --  Elias Ghanem 		 01/26/2022 use temp table to enhance performance CORE-94344
 -- ===============================================================================================================================

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[sproc_pho_list_getEnhancedOrder]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
   drop procedure [dbo].[sproc_pho_list_getEnhancedOrder]
GO

create 
proc sproc_pho_list_getEnhancedOrder
(
	@physOrderId	int,
	@facId			int,
	@includeAdministrativeOrder	char(1) = 'N',
	@includeSupplyInfo char(1) = 'N',
	@debug char(1)  = 'N',
	@status_code int out, 
	@status_text varchar(3000) out
)
as 
begin

SET NOCOUNT ON

DECLARE @step			int,
		@error_code		int

	   

BEGIN TRY

    -- PCC-33677
    ----Localize input Variables
    DECLARE  @vFacId int
            ,@vClientId int
            ,@vPhysOrderId int
            ,@vDateTime datetime
			,@vOrderCategory int
        
    -- Set the local variables
    select 
        @vFacId         = @facId 
       ,@vClientId      = null 
	   ,@vPhysOrderId   = @physOrderId
       ,@vDateTime      = dbo.fn_facility_getCurrentTime(@facId)
	   ,@status_code 	= 0
        
    -- Table variable to store the result of sproc_pho_getOrderStatus
    declare @TMP_PhoOrderStatus table (phys_order_id    int
                                    ,fac_id             int
                                    ,order_status       smallint
                                    ,order_relationship int
                                    ,status_reason      varchar(75));
    
	set @vOrderCategory = (select order_category_id from pho_phys_order where phys_order_id=@vPhysOrderId)
	
	-- Check exist in pho_phys_order table, struck out order does not has record in pho_phys_order table, if not exit, there is no need to execute sproc_pho_getOrderStatus
	if @vOrderCategory > 0
	begin
		-- Fill the table variable
		insert into @TMP_PhoOrderStatus
		exec sproc_pho_getOrderStatus 
				@facId          = @vFacId
				,@clientId      = @vClientId
				,@physOrderId   = @vPhysOrderId
				,@date          = @vDateTime
				,@debug         = 'N'
				,@status_code   = @status_code
				,@status_text   = @status_text
	end

	if @debug = 'Y'  select * From @TMP_PhoOrderStatus

	if isnull(@status_code,0) <> 0
		  begin
				set @status_text = 'sproc_pho_getOrderStatus returned the following error: ' + isnull(@status_text,'')
				Raiserror( @status_text, 11, 1 );
		  end

	
	if(@debug='Y') begin Print 'BEGIN STEP select enhanced phys order	' + ' ' + convert(varchar(26),getdate(),109) end

SELECT 
o.phys_order_id
, o.order_type_id
, o.physician_id
, o.pharmacy_id
, o.fac_id
, o.client_id
, o.drug_code
, o.created_by
, o.created_date
, o.revision_by
, o.revision_date
, o.reorder
, o.date_ordered
, o.start_date
, o.end_date
, o.strength
, o.form
, o.route_of_admin
, o.diagnoses
, o.description
, o.directions
, o.related_generic
, o.supplementary_notes
, o.communication_method
, o.diet_type
, diettype.item_description AS diet_type_description
, o.diet_texture
, diettexture.item_description AS diet_texture_description
, o.stat
, o.packaging
, o.disc_with_pharm
, o.quantity_to_administer
, o.std_order_id
, o.discontinued_date
, o.fluid_consistency
, fluidcon.item_description AS fluid_consistency_description
, o.diet_supplement
, dietsup.item_description AS diet_supplement_description
, o.hold_date
, o.nurse_admin_notes
, o.nurse_pharm_notes
, o.delivery_notes
, o.delivery_type
, o.self_admin
, o.administered_by_id
, o.prn_flag
, o.label_name
, o.reorder_count
, o.last_reorder_date
, o.quantity_received
, o.tran_id
, o.prescription
, o.start_date_type
, o.end_date_type
, o.end_date_duration_type
, o.end_date_duration
, o.schedule_dose_duration -- PCC-32538
, o.alter_med_src
, o.alter_med_src_name
, o.sent_date
, vpos.order_status
, o.status_change_by
, o.status_change_date
, o.hold_physician_id
, o.discontinue_physician_id
, o.pharm_nurse_notes
, o.first_admin
, o.drug_manufacturer
, o.drug_class_number
, o.resume_physician_id
, o.event_driven_flag
, o.auto_fill_flag
, o.controlled_substance_code
, o.related_phys_order_id
, o.relationship
, o.auto_created_flag
, o.active_flag
, o.new_supply_flag
, o.resume_date
, o.last_received_date
, o.orig_phys_order_id
, o.disp_package_identifier
, o.hold_date_end
, o.vendor_phys_order_id
, o.order_date
, o.sliding_scale_id
, o.order_verified
, o.dispense_as_written
, o.next_refill_date
, o.do_not_fill
, o.cur_supply_id
, o.first_documented
, o.substitution_indicator
, o.reassessment_required
, o.completed_date
, o.completed_by
, o.verify_copied_order
, o.original_route_of_admin
, o.indications_for_use
, o.draft
, o.origin_id
, o.order_category_id
, o.order_revision_date
, o.order_revision_by
, o.drug_strength
, o.drug_strength_uom
, o.drug_name
, o.is_new_order
, o.order_schedule_id
, o.start_date as schedule_start_date
, o.end_date as schedule_end_date
, o.last_pharmacy_end_date
, o.physician_name_in_msg
, s.schedule_id
, s.schedule_type
, s.pho_std_time_id
, s.xxdays as xx_days
, s.sun
, s.mon
, s.tues as tue
, s.wed
, s.thurs as thu
, s.fri
, s.sat
, s.days_on
, s.days_off
, s.std_freq_id
, s.dose AS dose_value
, s.dose_low
, s.alternate_dose
, s.start_time
, s.end_time
, s.nurse_action_notes
, s.date_start
, s.date_stop
, s.repeat_week
, s.apply_to
, s.prn_admin
, s.prn_admin_value
, s.prn_admin_units
, s.std_freq_time_label
, s.until_finished
, s.quantity_uom_id
, s.dose_uom_id
, case 
       -- diet orders do not populate the view_pho_schedule need to get directly from the pho_order_schedule table
       when  s.schedule_directions is null and o.order_category_id = 3031 then o.schedule_directions 
       else s.schedule_directions
end as schedule_directions
, o.order_directions as order_directions
, s.schedule_template
, s.xxMonths
, s.date_of_month
, s.std_shift_id
, s.schedule_sliding_scale_id
, s.apply_remove_flag
, s.remove_time
, s.remove_duration
, s.behavior_lookback
, o.schedule_revision_date
, c.first_name AS physician_first_name
, c.last_name AS physician_last_name
, c.title + ' ' + c.first_name + ' ' + c.last_name AS physician_fullname
, cb.long_username AS created_by_long
, rb.long_username AS revision_by_long
, poua.edited_by_audit_id
, poua.edited_date
, poua.created_by_audit_id
, edituser.long_username AS edited_by_long
, edituser.position_description AS edited_by_position
, edituser.designation_desc AS edited_by_designation
, createuser.long_username AS created_by_audit_long
, createuser.position_description AS created_by_position
, createuser.designation_desc AS created_by_designation
, poua.confirmed_by_audit_id
, poua.confirmed_date
, confuser.long_username AS confirmed_by_long
, confuser.position_description AS confirmed_by_position
, confuser.designation_desc AS confirmed_by_designation
, lib.pho_ext_lib_id
, lib.pho_ext_lib_med_id
, lib.pho_ext_lib_med_ddid
, lib.pho_ext_lib_generic_id
, lib.pho_ext_lib_generic_desc
, lib.ext_lib_rxnorm_id
, o.min_start_date
, o.max_end_date
, o.emergency_pharmacy_flag
, o.need_location_of_admin
, so.advanced_directive as order_advanced_directive
, poad.advanced_dir_status
, pspo.advanced_directive as advanced_directive
, signuser.long_username as signed_by_long
, ppos.signature_date
, o.extended_end_date
, o.extended_count
, custmed.cust_med_id
, ti.orig_phys_order_id as original_ti_phys_order_id
, lsi.linked_set_id as linked_set_id
, ls.set_description as linked_set_description
, nctrlsc.new_controlled_substance_code as new_controlled_substance_code
, esign.marked_to_sign_user_id
, case when marked_to_sign_user_id is not null then dbo.fn_get_username(marked_to_sign_user_id) else null end as marked_to_sign_user_longname
, esign.marked_to_sign_date
, esign.marked_to_sign_contact_id
, esign.marked_to_sign_authentication_type_id
, esign.marked_to_sign_source_type_id
, rstype.description as marked_to_sign_source_type_description
, esign.sign_user_id
, case when sign_user_id is not null then dbo.fn_get_username(sign_user_id) else null end as sign_user_longname
, esign.sign_date
, esign.sign_contact_id
, esign.sign_authentication_type_id
, atype.description as sign_authentication_type_description
, esign.sign_source_type_id
, stype.description as sign_source_type_description
, popr.reason_binary_code
, clinrev.reviewed_date
, clinrev.phys_order_id as review_order_id
, clinrev.reviewed_by
, oq.quantity as prescription_quantity
, oq.unit_of_measure as prescription_quantity_uom
, oq.no_of_refills as prescription_no_of_refills
, oq.dispense_interval as prescription_dispense_interval
, oq.total_authorized_quantity as prescription_total_authorized_quantity
, o.order_class_id
, o.prescriber_schedule_start_date as earliest_prescriber_start_date
, o.prescriber_schedule_start_date
, o.linked_order_id
, o.linked_reason_id
into #temp
FROM
	view_pho_phys_order o
	LEFT JOIN @TMP_PhoOrderStatus vpos
		ON o.phys_order_id = vpos.phys_order_id
	LEFT JOIN view_pho_schedule s
		ON o.order_schedule_id = s.order_schedule_id AND o.phys_order_id = s.phys_order_id
		AND s.deleted = 'N'
	LEFT JOIN COMMON_CODE diettype
        ON @vOrderCategory=3031 and o.diet_type = diettype.item_id and diettype.item_code = 'phodyt' -- only need for diet order
    LEFT JOIN COMMON_CODE diettexture
        ON @vOrderCategory=3031 and o.diet_texture = diettexture.item_id and diettexture.item_code = 'phodtx' -- only need for diet order
    LEFT JOIN COMMON_CODE dietsup
        ON @vOrderCategory=3032 and o.diet_supplement = dietsup.item_id and dietsup.item_code = 'phosup' -- only need for diet supplement order
    LEFT JOIN COMMON_CODE fluidcon
    	ON @vOrderCategory=3031 and o.fluid_consistency = fluidcon.item_id and fluidcon.item_code = 'phocst' -- only need for diet order
	LEFT JOIN contact c
		ON c.contact_id = o.physician_id
	LEFT JOIN sec_user cb
		ON cb.loginname = o.created_by
	LEFT JOIN sec_user rb
		ON rb.loginname = o.revision_by
	LEFT JOIN pho_phys_order_useraudit poua
		ON poua.phys_order_id = o.phys_order_id
	LEFT JOIN cp_sec_user_audit createuser
	  ON createuser.cp_sec_user_audit_id = poua.created_by_audit_id
	LEFT JOIN cp_sec_user_audit edituser
	  ON edituser.cp_sec_user_audit_id = poua.edited_by_audit_id
	LEFT JOIN cp_sec_user_audit confuser
	  ON confuser.cp_sec_user_audit_id = poua.confirmed_by_audit_id
	LEFT JOIN pho_order_ext_lib_med_ref lib
	  ON @vOrderCategory=3022 and lib.phys_order_id = o.phys_order_id -- only need for pharmacy order
	LEFT JOIN pho_phys_order_std_order templateorder
	  ON @vOrderCategory=3029 and templateorder.phys_order_id = o.phys_order_id -- only need for other category order
	LEFT JOIN  pho_std_order so 
	  ON @vOrderCategory=3029 and templateorder.std_order_id = so.std_order_id -- only need for other category order
	LEFT JOIN pho_std_phys_order pspo
	  ON @vOrderCategory=3029 and o.std_order_id = pspo.std_phys_order_id -- only need for other category order
	LEFT JOIN pho_phys_order_advanced_directive poad
	  ON @vOrderCategory=3029 and o.phys_order_id = poad.phys_order_id -- only need for other category order
	LEFT JOIN pho_phys_order_sign ppos
	  ON o.phys_order_id = ppos.phys_order_id
	LEFT JOIN cp_sec_user_audit signuser
	  ON signuser.cp_sec_user_audit_id = ppos.cp_sec_user_audit_id
	LEFT JOIN pho_phys_order_cust_med custmed
	  ON @vOrderCategory=3022 and custmed.phys_order_id = o.phys_order_id -- only need for pharmacy order
	LEFT JOIN pho_phys_order_ti ti
	  ON ti.phys_order_id = o.phys_order_id
	LEFT JOIN pho_linked_set_item lsi
	  ON lsi.phys_order_id = o.phys_order_id
	LEFT JOIN pho_linked_set ls on ls.linked_set_id = lsi.linked_set_id
	LEFT JOIN pho_phys_order_new_ctrlsubstancecode nctrlsc ON @vOrderCategory=3022 and nctrlsc.phys_order_id=o.phys_order_id -- only need for pharmacy order
	LEFT JOIN pho_phys_order_esignature esign  ON o.phys_order_id = esign.phys_order_id
	LEFT JOIN order_sign_source_type stype ON esign.sign_source_type_id = stype.source_type_id
	LEFT JOIN order_sign_source_type rstype ON esign.marked_to_sign_source_type_id = rstype.source_type_id
	LEFT JOIN order_sign_authentication_type atype ON esign.sign_authentication_type_id = atype.authentication_type_id
	LEFT JOIN pho_order_pending_reason popr ON popr.phys_order_id = o.phys_order_id
    LEFT JOIN pho_order_clinical_review clinrev ON clinrev.phys_order_id=o.phys_order_id 
    LEFT JOIN pho_phys_order_quantity_info oq on @vOrderCategory=3022 and oq.phys_order_id=o.phys_order_id -- only need for pharmacy order

WHERE
	o.phys_order_id = @physOrderId


SELECT
t.phys_order_id
, t.order_type_id
, t.physician_id
, t.pharmacy_id
, t.fac_id
, t.std_freq_id
, t.client_id
, t.drug_code
, t.created_by
, t.created_date
, t.revision_by
, t.revision_date
, t.reorder
, t.date_ordered
, t.start_date
, t.end_date
, t.strength
, t.form
, t.route_of_admin
, t.diagnoses
, t.description
, t.directions
, t.related_generic
, t.supplementary_notes
, t.communication_method
, t.diet_type
, t.diet_type_description
, t.diet_texture
, t.diet_texture_description
, t.stat
, t.packaging
, t.disc_with_pharm
, t.quantity_to_administer
, t.std_order_id
, t.discontinued_date
, t.fluid_consistency
, t.fluid_consistency_description
, t.diet_supplement
, t.diet_supplement_description
, t.hold_date
, t.nurse_admin_notes
, t.nurse_pharm_notes
, t.delivery_notes
, t.delivery_type
, t.self_admin
, t.administered_by_id
, t.prn_flag
, t.label_name
, t.reorder_count
, t.last_reorder_date
, t.quantity_received
, t.tran_id
, t.prescription
, t.start_date_type
, t.end_date_type
, t.end_date_duration_type
, t.end_date_duration
, t.schedule_dose_duration -- PCC-32538
, t.alter_med_src
, t.alter_med_src_name
, t.sent_date
, t.order_status
, t.status_change_by
, t.status_change_date
, t.hold_physician_id
, t.discontinue_physician_id
, t.pharm_nurse_notes
, t.first_admin
, t.drug_manufacturer
, t.drug_class_number
, t.resume_physician_id
, t.event_driven_flag
, t.auto_fill_flag
, t.controlled_substance_code
, t.related_phys_order_id
, t.relationship
, t.auto_created_flag
, t.active_flag
, t.new_supply_flag
, t.resume_date
, t.last_received_date
, t.orig_phys_order_id
, t.disp_package_identifier
, t.hold_date_end
, t.vendor_phys_order_id
, t.order_date
, t.sliding_scale_id
, t.order_verified
, t.dispense_as_written
, t.next_refill_date
, t.do_not_fill
, t.cur_supply_id
, t.first_documented
, t.substitution_indicator
, t.reassessment_required
, t.completed_date
, t.completed_by
, t.verify_copied_order
, t.original_route_of_admin
, t.indications_for_use
, t.draft
, t.origin_id
, t.order_category_id
, t.order_revision_date
, t.order_revision_by
, t.drug_strength
, t.drug_strength_uom
, t.drug_name
, t.is_new_order
, t.order_schedule_id
, t.schedule_start_date
, t.schedule_end_date
, t.last_pharmacy_end_date
, t.physician_name_in_msg
, t.schedule_id
, t.schedule_type
, t.pho_std_time_id
, t.xx_days
, t.sun
, t.mon
, t.tue
, t.wed
, t.thu
, t.fri
, t.sat
, t.days_on
, t.days_off
, t.dose_value
, t.dose_low
, t.alternate_dose
, t.start_time
, t.end_time
, t.nurse_action_notes
, t.date_start
, t.date_stop
, t.repeat_week
, t.apply_to
, t.prn_admin
, t.prn_admin_value
, t.prn_admin_units
, t.std_freq_time_label
, t.until_finished
, t.quantity_uom_id
, t.dose_uom_id
, t.schedule_directions
, t.order_directions
, t.schedule_template
, t.xxMonths
, t.date_of_month
, t.std_shift_id
, t.schedule_sliding_scale_id
, t.apply_remove_flag
, t.remove_time
, t.remove_duration
, t.behavior_lookback
, t.schedule_revision_date
, v.vital
, p.prompt_id
, p.value_type
, p.description as prompt_description
, p.long_description
, p.notes
, p.no_of_values
, p.current_value2
, p.current_value
, p.specify_initial_value
, p.value_data_type
, p.prompt_frequency_type
, p.prompt_frequency
, p.value_date
, pt.short_desc
, t.physician_first_name
, t.physician_last_name
, t.physician_fullname
, t.created_by_long
, t.revision_by_long
, t.edited_by_audit_id
, t.edited_date
, t.created_by_audit_id
, t.edited_by_long
, t.edited_by_position
, t.edited_by_designation
, t.created_by_audit_long
, t.created_by_position
, t.created_by_designation
, t.confirmed_by_audit_id
, t.confirmed_date
, t.confirmed_by_long
, t.confirmed_by_position
, t.confirmed_by_designation
, t.pho_ext_lib_id
, t.pho_ext_lib_med_id
, t.pho_ext_lib_med_ddid
, t.pho_ext_lib_generic_id
, t.pho_ext_lib_generic_desc
, t.ext_lib_rxnorm_id
, t.min_start_date
, t.max_end_date
, t.emergency_pharmacy_flag
, t.need_location_of_admin
, t.order_advanced_directive
, t.advanced_dir_status
, t.advanced_directive
, t.signed_by_long
, t.signature_date
, t.extended_end_date
, t.extended_count
, t.cust_med_id
, t.original_ti_phys_order_id
, t.linked_set_id
, t.linked_set_description
, t.new_controlled_substance_code
, t.marked_to_sign_user_id
, t.marked_to_sign_user_longname
, t.marked_to_sign_date
, t.marked_to_sign_contact_id
, t.marked_to_sign_authentication_type_id
, t.marked_to_sign_source_type_id
, t.marked_to_sign_source_type_description
, t.sign_user_id
, t.sign_user_longname
, t.sign_date
, t.sign_contact_id
, t.sign_authentication_type_id
, t.sign_authentication_type_description
, t.sign_source_type_id
, t.sign_source_type_description
, t.reason_binary_code
, t.reviewed_date
, t.review_order_id
, t.reviewed_by
, t.prescription_quantity
, t.prescription_quantity_uom
, t.prescription_no_of_refills
, t.prescription_dispense_interval
, t.prescription_total_authorized_quantity
, t.order_class_id
, t.earliest_prescriber_start_date
, t.prescriber_schedule_start_date
, t.linked_order_id
, t.linked_reason_id
, poa.facility_medical_attestation_id
from
#temp t
LEFT JOIN pho_order_related_prompt p
ON t.schedule_id = p.schedule_id and p.deleted ='N'
LEFT JOIN pho_order_related_value_type pt
ON p.value_type = pt.type_id
LEFT JOIN pho_schedule_vitals v
ON t.schedule_id = v.schedule_id and v.deleted = 'N'
LEFT JOIN pho_phys_order_attestation poa ON @vOrderCategory=3022 and poa.phys_order_id = t.phys_order_id -- only need for pharmacy order
ORDER BY t.order_schedule_id, t.schedule_id


-- select administrative orders
if @includeAdministrativeOrder='Y'
	select vpao.admin_created_date,
	vpao.admin_order_verified,
	vpao.order_related_id,
	vpao.phys_order_id,
	vpao.standard_phys_order_id,
	vpao.created_by,
	vpao.created_date,
	vpao.revision_by,
	vpao.revision_date,
	vpao.deleted_by,
	vpao.deleted_date,
	vpao.deleted,
	vpao.fac_id,
	vpao.order_relationship_id,
	vpao.admin_communication_method,
	vpao.admin_effective_date,
	vpao.admin_ineffective_date,
	vpao.admin_physician_id,
	vpao.admin_reason,
	vpao.admin_noted_by,
	vpao.admin_physician_first_name,
	vpao.admin_physician_last_name,
	vpao.strikeout_by,
	vpao.strikeout_date,
	vpao.strikeout_reason_code,
	vpao.strikeout_reason_description,
	vpao.strikeout_by_long,
	vpao.admin_order_id,
	vpao.admin_origin_id,
	secuser.long_username 'created_by_long' , secuser.designation_desc as created_by_designation, ccc.item_description as created_by_position
	,csua.long_username confirmed_by_username, csua.position_description as confirmed_by_position, csua.designation_desc as confirmed_by_designation, ua.confirmed_date as confirmed_date
	FROM view_pho_administrative_order vpao
	left join SEC_USER secuser on secuser.loginname = vpao.created_by
	left join common_code ccc on ccc.item_id = secuser.position_id
	left join pho_admin_order_useraudit ua ON ua.admin_order_id = vpao.admin_order_id
	left join cp_sec_user_audit csua on csua.cp_sec_user_audit_id = ua.confirmed_by_audit_id
	WHERE vpao.standard_phys_order_id = @physOrderId
	ORDER BY vpao.revision_date  DESC

IF @includeSupplyInfo='Y'
BEGIN
	DECLARE @integratedPharmacies TABLE
    (
        pharmacy_id int not null
    )
	INSERT INTO @integratedPharmacies (pharmacy_id)
	select distinct extFacId from (
		SELECT mp.ext_fac_id as extFacId
			FROM message_profile mp WITH (NOLOCK)
			INNER JOIN lib_message_profile lmp WITH (NOLOCK)
				ON lmp.message_profile_id = mp.message_profile_id
			       AND lmp.deleted = 'N' and lmp.is_enabled='Y'
			WHERE mp.is_enabled = 'Y' and mp.is_integrated_pharmacy='Y'
			AND mp.fac_id = @facId
			AND mp.message_protocol_id = 12
			GROUP BY mp.ext_fac_id
		UNION
		SELECT distinct mi.internal_id as extFacId
			FROM map_identifier mi WITH (NOLOCK)
			INNER JOIN lib_message_profile libmp WITH (NOLOCK)
			ON libmp.vendor_code = mi.vendor_code
			AND libmp.deleted = 'N'
			INNER JOIN message_profile mp WITH (NOLOCK)
			ON libmp.message_profile_id = mp.message_profile_id
			WHERE mi.map_type_id = 3 and mp.fac_id = @facId and  mi.fac_id = @facId
	) a where extFacId is not null

select pos.phys_order_id,
        pos.order_supply_id,
        pos.description as supply_description,
        pos.directions as supply_directions,
        pos.date_dispensed as date_dispensed,
        pos.last_received_date as supply_received_date,
        pos.med_src_type_id as supply_med_src_type_id,
        pos.pharmacy_id as supply_pharmacy_id,
        eef.name as supply_pharmacy_name,
        pos.reordering as supply_reordering,
        pos.status AS supply_status,
        pos.new_supply_flag as supply_new_supply_flag,
        pos.last_reorder_date as supply_last_reorder_date,
        pos.disp_code as supply_disp_code,
        pos.pharm_nurse_notes as pharm_nurse_notes,
        pos.nurse_pharm_notes as nurse_pharm_notes,
        pos.disp_package_identifier as supply_disp_package_identifier,
        pos.controlled_substance_code as supply_controlled_substance_code,
        pos.prescription as supply_prescription,
        pos.do_not_fill as supply_do_not_fill,
        pos.inventory_on_hand as inventory_on_hand,
        pos.next_refill_date as next_refill_date,
        psd.pharmacy_order_id as pharmacy_order_id,
        CASE  WHEN ip.pharmacy_id IS NULL THEN 'N' ELSE 'Y' END 'integrated_pharmacy',
        pos.active as supply_active,
        mmdb.dbo.fn_pho_getImageFilenameByNDC(pos.drug_code) as imageFileName, 
        pos.drug_code as drug_code
    FROM pho_order_supply pos
        
        LEFT JOIN emc_ext_facilities eef ON eef.ext_fac_id = pos.pharmacy_id
        left join pho_supply_dispense psd on psd.order_supply_id = pos.order_supply_id and psd.deleted='N'
        LEFT JOIN @integratedPharmacies ip
                    ON ip.pharmacy_id = pos.pharmacy_id
    WHERE (pos.active = 'Y' or pos.active = 'N') AND pos.deleted = 'N' and pos.phys_order_id = @physOrderId
    ORDER BY pos.created_date DESC
END

	if(@debug='Y') begin Print 'END STEP select enhanced phys order		' + ' ' + convert(varchar(26),getdate(),109) end

END TRY
 
--error trapping
BEGIN CATCH

SELECT @error_code = @@error
	 , @status_text = ERROR_MESSAGE()
 
	SET @status_code = 1

	GOTO PgmAbend
 
END CATCH

--program success return
PgmSuccess:
IF @status_code = 0
BEGIN
	IF @debug='Y' PRINT 'Successfull execution of stored procedure'
	RETURN @status_code
END

--program failure return
PgmAbend:
IF @debug='Y' PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '	' + convert(varchar(26),getdate())
IF @debug='Y' PRINT 'Error code: '+convert(varchar(3),@step) + '; Error description:	' +@status_text
RETURN @status_code

END
GO

GRANT EXECUTE ON sproc_pho_list_getEnhancedOrder TO PUBLIC
GO



GO

print 'C_Branch/04_StoredProcedures/sproc_pho_list_getEnhancedOrder.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_getEnhancedOrder.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_getEnhancedOrder_v2.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


 -- ===============================================================================================================================
 -- 
 -- Purpose: The purpose of this procedure is to load a phys order with all it's schedule information.
 --			 Please note that this stored procedure is a copy of 'sproc_pho_list_getEnhancedOrder' but has all MMDB references removed.
 --
 --
 -- Target ENVIRONMENT: BOTH 
 --
 --  Special Instructions: 
 --
 --	Params:
 --			
 --			@physOrderId    - phys order id
 --			@facId			- Facility Id 
 --			@includeAdministrativeOrder - Flag to include Administrative Orders, 'Y' or 'N'
 --			@includeSupplyInfo - Flag to include Supply Info, 'Y' or 'N'
 --			@debug          - Debug param, 'Y' or 'N'
 --			@status_code    - SP execution flag, 0 for success.
 --			@status_text    - SP error text if error occurs.
 --
 -- Change History:
 --   Author			Date		Comment
 -- ------------------------------------------------------------------------------------------------------------------------------- 
 --	  Joel Pelletier    08/11/2011	Created.
 --   Alireza Mandegar	10/15/2012	Updated due to PCC-33677 and Replaced the usage of fn_pho_getOrderStatus with sproc_pho_getOrderStatus
 --									Also modified the file maintenance box to be in sql comment format rather than java format
 --									and added the Change History section to it to keep track of changes.
 --  Alireza Mandegar	 11/12/2012	Added pho_ext_lib_generic_desc/id for PCC-34329
 --  Alireza Mandegar	 11/22/2012	Added schedule_sliding_scale_id due to PCC-30715
 --  Alireza Mandegar	 11/29/2012	Added schedule_dose_duration due to PCC-32538
 --  Feng Xia			 12/15/2012	Added xxMonths
 --  Alireza Mandegar	 12/20/2012	Added apply_remove_flag due to PCC-32537
 --  Alireza Mandegar	 01/25/2013	Added remove_time due to PCC-32537
 --  Alireza Mandegar	 01/31/2013	Added remove_duration due to PCC-32537
 --  Aarti Malhotra      09/24/2013  Added pho_ext_lib_rxnorm for PCC-47251 (main JIRA PCC-46704)
 --  Mustafa Behrainwala 04/28/2014  Added table to handle Therapeutic Interchange sliding scale PCC-52492 
 --  Mustafa Behrainwala 07/31/2014  Added Linked Set Id and Description for PCC-59209
 --	 Mustafa Behrainwala 10/29/2015	 Added order_class_id
 --  Willie Wong		 05/11/2016	 Added schedule_directions for dietary orders for PCC-94151
 --	 Nooshin Hayeri		 06/29/2016	Added snapshot_schedule_start_date for PCC-96359
 --  Melvin Parinas      07/16/2016  Removed snapshot_schedule_start_date and replaced with earliest_prescriber_start_date date PCC-96359
 --  Melvin Parinas      07/25/2016  Added prescriber_schedule_start_date due to PCC-98059	
 --	 Devika Bapat		 02/24/2017	Added 2 optional parameters to include administrative orders and supply info PCC-108894
 --	 Mustafa Behrainwala 10/12/2018 Modified due to CORE-23367 to add dose_low for dose ranging.
 --	 Elias Ghanem 		 12/21/2018 	Added last_pharmacy_end_date due to CORE-28433.
 --  Mustafa Behrainwala 01/29/2019 Modified due to CORE-29190 return behavior lookup
 --  Elias Ghanem 		 01/29/2019 Added schedule_revision_date due to CORE-85435
 --  Sree Naghasundharam 11/18/2021 Created this new stored procedure 'sproc_pho_list_getEnhancedOrder_v2' and Removed MMDB references (CORE-97119)
 --  Jarek Zawojski      01/18/2022 Added prescription_dispense_interval prescription_total_authorized_quantity (CORE-99218)
 --  Elias Ghanem 		 01/26/2022 use temp table to enhance performance CORE-94344
 -- ===============================================================================================================================

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[sproc_pho_list_getEnhancedOrder_v2]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
   drop procedure [dbo].[sproc_pho_list_getEnhancedOrder_v2]
GO

create 
proc sproc_pho_list_getEnhancedOrder_v2
(
	@physOrderId	int,
	@facId			int,
	@includeAdministrativeOrder	char(1) = 'N',
	@includeSupplyInfo char(1) = 'N',
	@debug char(1)  = 'N',
	@status_code int out, 
	@status_text varchar(3000) out
)
as 
begin

SET NOCOUNT ON

DECLARE @step			int,
		@error_code		int

	   

BEGIN TRY

    -- PCC-33677
    ----Localize input Variables
    DECLARE  @vFacId int
            ,@vClientId int
            ,@vPhysOrderId int
            ,@vDateTime datetime
			,@vOrderCategory int
        
    -- Set the local variables
    select 
        @vFacId         = @facId 
       ,@vClientId      = null 
	   ,@vPhysOrderId   = @physOrderId
       ,@vDateTime      = dbo.fn_facility_getCurrentTime(@facId)
	   ,@status_code 	= 0
        
    -- Table variable to store the result of sproc_pho_getOrderStatus
    declare @TMP_PhoOrderStatus table (phys_order_id    int
                                    ,fac_id             int
                                    ,order_status       smallint
                                    ,order_relationship int
                                    ,status_reason      varchar(75));
    
	set @vOrderCategory = (select order_category_id from pho_phys_order where phys_order_id=@vPhysOrderId)
	
	-- Check exist in pho_phys_order table, struck out order does not has record in pho_phys_order table, if not exit, there is no need to execute sproc_pho_getOrderStatus
	if @vOrderCategory > 0
	begin
		-- Fill the table variable
		insert into @TMP_PhoOrderStatus
		exec sproc_pho_getOrderStatus 
				@facId          = @vFacId
				,@clientId      = @vClientId
				,@physOrderId   = @vPhysOrderId
				,@date          = @vDateTime
				,@debug         = 'N'
				,@status_code   = @status_code
				,@status_text   = @status_text
	end

	if @debug = 'Y'  select * From @TMP_PhoOrderStatus

	if isnull(@status_code,0) <> 0
		  begin
				set @status_text = 'sproc_pho_getOrderStatus returned the following error: ' + isnull(@status_text,'')
				Raiserror( @status_text, 11, 1 );
		  end

	
	if(@debug='Y') begin Print 'BEGIN STEP select enhanced phys order	' + ' ' + convert(varchar(26),getdate(),109) end

SELECT 
o.phys_order_id
, o.order_type_id
, o.physician_id
, o.pharmacy_id
, o.fac_id
, o.client_id
, o.drug_code
, o.created_by
, o.created_date
, o.revision_by
, o.revision_date
, o.reorder
, o.date_ordered
, o.start_date
, o.end_date
, o.strength
, o.form
, o.route_of_admin
, o.diagnoses
, o.description
, o.directions
, o.related_generic
, o.supplementary_notes
, o.communication_method
, o.diet_type
, diettype.item_description AS diet_type_description
, o.diet_texture
, diettexture.item_description AS diet_texture_description
, o.stat
, o.packaging
, o.disc_with_pharm
, o.quantity_to_administer
, o.std_order_id
, o.discontinued_date
, o.fluid_consistency
, fluidcon.item_description AS fluid_consistency_description
, o.diet_supplement
, dietsup.item_description AS diet_supplement_description
, o.hold_date
, o.nurse_admin_notes
, o.nurse_pharm_notes
, o.delivery_notes
, o.delivery_type
, o.self_admin
, o.administered_by_id
, o.prn_flag
, o.label_name
, o.reorder_count
, o.last_reorder_date
, o.quantity_received
, o.tran_id
, o.prescription
, o.start_date_type
, o.end_date_type
, o.end_date_duration_type
, o.end_date_duration
, o.schedule_dose_duration -- PCC-32538
, o.alter_med_src
, o.alter_med_src_name
, o.sent_date
, vpos.order_status
, o.status_change_by
, o.status_change_date
, o.hold_physician_id
, o.discontinue_physician_id
, o.pharm_nurse_notes
, o.first_admin
, o.drug_manufacturer
, o.drug_class_number
, o.resume_physician_id
, o.event_driven_flag
, o.auto_fill_flag
, o.controlled_substance_code
, o.related_phys_order_id
, o.relationship
, o.auto_created_flag
, o.active_flag
, o.new_supply_flag
, o.resume_date
, o.last_received_date
, o.orig_phys_order_id
, o.disp_package_identifier
, o.hold_date_end
, o.vendor_phys_order_id
, o.order_date
, o.sliding_scale_id
, o.order_verified
, o.dispense_as_written
, o.next_refill_date
, o.do_not_fill
, o.cur_supply_id
, o.first_documented
, o.substitution_indicator
, o.reassessment_required
, o.completed_date
, o.completed_by
, o.verify_copied_order
, o.original_route_of_admin
, o.indications_for_use
, o.draft
, o.origin_id
, o.order_category_id
, o.order_revision_date
, o.order_revision_by
, o.drug_strength
, o.drug_strength_uom
, o.drug_name
, o.is_new_order
, o.order_schedule_id
, o.start_date as schedule_start_date
, o.end_date as schedule_end_date
, o.last_pharmacy_end_date
, o.physician_name_in_msg
, s.schedule_id
, s.schedule_type
, s.pho_std_time_id
, s.xxdays as xx_days
, s.sun
, s.mon
, s.tues as tue
, s.wed
, s.thurs as thu
, s.fri
, s.sat
, s.days_on
, s.days_off
, s.std_freq_id
, s.dose AS dose_value
, s.dose_low
, s.alternate_dose
, s.start_time
, s.end_time
, s.nurse_action_notes
, s.date_start
, s.date_stop
, s.repeat_week
, s.apply_to
, s.prn_admin
, s.prn_admin_value
, s.prn_admin_units
, s.std_freq_time_label
, s.until_finished
, s.quantity_uom_id
, s.dose_uom_id
, case 
       -- diet orders do not populate the view_pho_schedule need to get directly from the pho_order_schedule table
       when  s.schedule_directions is null and o.order_category_id = 3031 then o.schedule_directions 
       else s.schedule_directions
end as schedule_directions
, o.order_directions as order_directions
, s.schedule_template
, s.xxMonths
, s.date_of_month
, s.std_shift_id
, s.schedule_sliding_scale_id
, s.apply_remove_flag
, s.remove_time
, s.remove_duration
, s.behavior_lookback
, o.schedule_revision_date
, c.first_name AS physician_first_name
, c.last_name AS physician_last_name
, c.title + ' ' + c.first_name + ' ' + c.last_name AS physician_fullname
, cb.long_username AS created_by_long
, rb.long_username AS revision_by_long
, poua.edited_by_audit_id
, poua.edited_date
, poua.created_by_audit_id
, edituser.long_username AS edited_by_long
, edituser.position_description AS edited_by_position
, edituser.designation_desc AS edited_by_designation
, createuser.long_username AS created_by_audit_long
, createuser.position_description AS created_by_position
, createuser.designation_desc AS created_by_designation
, poua.confirmed_by_audit_id
, poua.confirmed_date
, confuser.long_username AS confirmed_by_long
, confuser.position_description AS confirmed_by_position
, confuser.designation_desc AS confirmed_by_designation
, lib.pho_ext_lib_id
, lib.pho_ext_lib_med_id
, lib.pho_ext_lib_med_ddid
, lib.pho_ext_lib_generic_id
, lib.pho_ext_lib_generic_desc
, lib.ext_lib_rxnorm_id
, o.min_start_date
, o.max_end_date
, o.emergency_pharmacy_flag
, o.need_location_of_admin
, so.advanced_directive as order_advanced_directive
, poad.advanced_dir_status
, pspo.advanced_directive as advanced_directive
, signuser.long_username as signed_by_long
, ppos.signature_date
, o.extended_end_date
, o.extended_count
, custmed.cust_med_id
, ti.orig_phys_order_id as original_ti_phys_order_id
, lsi.linked_set_id as linked_set_id
, ls.set_description as linked_set_description
, nctrlsc.new_controlled_substance_code as new_controlled_substance_code
, esign.marked_to_sign_user_id
, case when marked_to_sign_user_id is not null then dbo.fn_get_username(marked_to_sign_user_id) else null end as marked_to_sign_user_longname
, esign.marked_to_sign_date
, esign.marked_to_sign_contact_id
, esign.marked_to_sign_authentication_type_id
, esign.marked_to_sign_source_type_id
, rstype.description as marked_to_sign_source_type_description
, esign.sign_user_id
, case when sign_user_id is not null then dbo.fn_get_username(sign_user_id) else null end as sign_user_longname
, esign.sign_date
, esign.sign_contact_id
, esign.sign_authentication_type_id
, atype.description as sign_authentication_type_description
, esign.sign_source_type_id
, stype.description as sign_source_type_description
, popr.reason_binary_code
, clinrev.reviewed_date
, clinrev.phys_order_id as review_order_id
, clinrev.reviewed_by
, oq.quantity as prescription_quantity
, oq.unit_of_measure as prescription_quantity_uom
, oq.no_of_refills as prescription_no_of_refills
, oq.dispense_interval as prescription_dispense_interval
, oq.total_authorized_quantity as prescription_total_authorized_quantity
, o.order_class_id
, o.prescriber_schedule_start_date as earliest_prescriber_start_date
, o.prescriber_schedule_start_date
, o.linked_order_id
, o.linked_reason_id
into #temp
FROM
	view_pho_phys_order o
	LEFT JOIN @TMP_PhoOrderStatus vpos
		ON o.phys_order_id = vpos.phys_order_id
	LEFT JOIN view_pho_schedule s
		ON o.order_schedule_id = s.order_schedule_id AND o.phys_order_id = s.phys_order_id
		AND s.deleted = 'N'
	LEFT JOIN COMMON_CODE diettype
        ON @vOrderCategory=3031 and o.diet_type = diettype.item_id and diettype.item_code = 'phodyt' -- only need for diet order
    LEFT JOIN COMMON_CODE diettexture
        ON @vOrderCategory=3031 and o.diet_texture = diettexture.item_id and diettexture.item_code = 'phodtx' -- only need for diet order
    LEFT JOIN COMMON_CODE dietsup
        ON @vOrderCategory=3032 and o.diet_supplement = dietsup.item_id and dietsup.item_code = 'phosup' -- only need for diet supplement order
    LEFT JOIN COMMON_CODE fluidcon
    	ON @vOrderCategory=3031 and o.fluid_consistency = fluidcon.item_id and fluidcon.item_code = 'phocst' -- only need for diet order
	LEFT JOIN contact c
		ON c.contact_id = o.physician_id
	LEFT JOIN sec_user cb
		ON cb.loginname = o.created_by
	LEFT JOIN sec_user rb
		ON rb.loginname = o.revision_by
	LEFT JOIN pho_phys_order_useraudit poua
		ON poua.phys_order_id = o.phys_order_id
	LEFT JOIN cp_sec_user_audit createuser
	  ON createuser.cp_sec_user_audit_id = poua.created_by_audit_id
	LEFT JOIN cp_sec_user_audit edituser
	  ON edituser.cp_sec_user_audit_id = poua.edited_by_audit_id
	LEFT JOIN cp_sec_user_audit confuser
	  ON confuser.cp_sec_user_audit_id = poua.confirmed_by_audit_id
	LEFT JOIN pho_order_ext_lib_med_ref lib
	  ON @vOrderCategory=3022 and lib.phys_order_id = o.phys_order_id -- only need for pharmacy order
	LEFT JOIN pho_phys_order_std_order templateorder
	  ON @vOrderCategory=3029 and templateorder.phys_order_id = o.phys_order_id -- only need for other category order
	LEFT JOIN  pho_std_order so 
	  ON @vOrderCategory=3029 and templateorder.std_order_id = so.std_order_id -- only need for other category order
	LEFT JOIN pho_std_phys_order pspo
	  ON @vOrderCategory=3029 and o.std_order_id = pspo.std_phys_order_id -- only need for other category order
	LEFT JOIN pho_phys_order_advanced_directive poad
	  ON @vOrderCategory=3029 and o.phys_order_id = poad.phys_order_id -- only need for other category order
	LEFT JOIN pho_phys_order_sign ppos
	  ON o.phys_order_id = ppos.phys_order_id
	LEFT JOIN cp_sec_user_audit signuser
	  ON signuser.cp_sec_user_audit_id = ppos.cp_sec_user_audit_id
	LEFT JOIN pho_phys_order_cust_med custmed
	  ON @vOrderCategory=3022 and custmed.phys_order_id = o.phys_order_id -- only need for pharmacy order
	LEFT JOIN pho_phys_order_ti ti
	  ON ti.phys_order_id = o.phys_order_id
	LEFT JOIN pho_linked_set_item lsi
	  ON lsi.phys_order_id = o.phys_order_id
	LEFT JOIN pho_linked_set ls on ls.linked_set_id = lsi.linked_set_id
	LEFT JOIN pho_phys_order_new_ctrlsubstancecode nctrlsc ON @vOrderCategory=3022 and nctrlsc.phys_order_id=o.phys_order_id -- only need for pharmacy order
	LEFT JOIN pho_phys_order_esignature esign  ON o.phys_order_id = esign.phys_order_id
	LEFT JOIN order_sign_source_type stype ON esign.sign_source_type_id = stype.source_type_id
	LEFT JOIN order_sign_source_type rstype ON esign.marked_to_sign_source_type_id = rstype.source_type_id
	LEFT JOIN order_sign_authentication_type atype ON esign.sign_authentication_type_id = atype.authentication_type_id
	LEFT JOIN pho_order_pending_reason popr ON popr.phys_order_id = o.phys_order_id
    LEFT JOIN pho_order_clinical_review clinrev ON clinrev.phys_order_id=o.phys_order_id 
    LEFT JOIN pho_phys_order_quantity_info oq on @vOrderCategory=3022 and oq.phys_order_id=o.phys_order_id -- only need for pharmacy order

WHERE
	o.phys_order_id = @physOrderId


SELECT
t.phys_order_id
, t.order_type_id
, t.physician_id
, t.pharmacy_id
, t.fac_id
, t.std_freq_id
, t.client_id
, t.drug_code
, t.created_by
, t.created_date
, t.revision_by
, t.revision_date
, t.reorder
, t.date_ordered
, t.start_date
, t.end_date
, t.strength
, t.form
, t.route_of_admin
, t.diagnoses
, t.description
, t.directions
, t.related_generic
, t.supplementary_notes
, t.communication_method
, t.diet_type
, t.diet_type_description
, t.diet_texture
, t.diet_texture_description
, t.stat
, t.packaging
, t.disc_with_pharm
, t.quantity_to_administer
, t.std_order_id
, t.discontinued_date
, t.fluid_consistency
, t.fluid_consistency_description
, t.diet_supplement
, t.diet_supplement_description
, t.hold_date
, t.nurse_admin_notes
, t.nurse_pharm_notes
, t.delivery_notes
, t.delivery_type
, t.self_admin
, t.administered_by_id
, t.prn_flag
, t.label_name
, t.reorder_count
, t.last_reorder_date
, t.quantity_received
, t.tran_id
, t.prescription
, t.start_date_type
, t.end_date_type
, t.end_date_duration_type
, t.end_date_duration
, t.schedule_dose_duration -- PCC-32538
, t.alter_med_src
, t.alter_med_src_name
, t.sent_date
, t.order_status
, t.status_change_by
, t.status_change_date
, t.hold_physician_id
, t.discontinue_physician_id
, t.pharm_nurse_notes
, t.first_admin
, t.drug_manufacturer
, t.drug_class_number
, t.resume_physician_id
, t.event_driven_flag
, t.auto_fill_flag
, t.controlled_substance_code
, t.related_phys_order_id
, t.relationship
, t.auto_created_flag
, t.active_flag
, t.new_supply_flag
, t.resume_date
, t.last_received_date
, t.orig_phys_order_id
, t.disp_package_identifier
, t.hold_date_end
, t.vendor_phys_order_id
, t.order_date
, t.sliding_scale_id
, t.order_verified
, t.dispense_as_written
, t.next_refill_date
, t.do_not_fill
, t.cur_supply_id
, t.first_documented
, t.substitution_indicator
, t.reassessment_required
, t.completed_date
, t.completed_by
, t.verify_copied_order
, t.original_route_of_admin
, t.indications_for_use
, t.draft
, t.origin_id
, t.order_category_id
, t.order_revision_date
, t.order_revision_by
, t.drug_strength
, t.drug_strength_uom
, t.drug_name
, t.is_new_order
, t.order_schedule_id
, t.schedule_start_date
, t.schedule_end_date
, t.last_pharmacy_end_date
, t.physician_name_in_msg
, t.schedule_id
, t.schedule_type
, t.pho_std_time_id
, t.xx_days
, t.sun
, t.mon
, t.tue
, t.wed
, t.thu
, t.fri
, t.sat
, t.days_on
, t.days_off
, t.dose_value
, t.dose_low
, t.alternate_dose
, t.start_time
, t.end_time
, t.nurse_action_notes
, t.date_start
, t.date_stop
, t.repeat_week
, t.apply_to
, t.prn_admin
, t.prn_admin_value
, t.prn_admin_units
, t.std_freq_time_label
, t.until_finished
, t.quantity_uom_id
, t.dose_uom_id
, t.schedule_directions
, t.order_directions
, t.schedule_template
, t.xxMonths
, t.date_of_month
, t.std_shift_id
, t.schedule_sliding_scale_id
, t.apply_remove_flag
, t.remove_time
, t.remove_duration
, t.behavior_lookback
, t.schedule_revision_date
, v.vital
, p.prompt_id
, p.value_type
, p.description as prompt_description
, p.long_description
, p.notes
, p.no_of_values
, p.current_value2
, p.current_value
, p.specify_initial_value
, p.value_data_type
, p.prompt_frequency_type
, p.prompt_frequency
, p.value_date
, pt.short_desc
, t.physician_first_name
, t.physician_last_name
, t.physician_fullname
, t.created_by_long
, t.revision_by_long
, t.edited_by_audit_id
, t.edited_date
, t.created_by_audit_id
, t.edited_by_long
, t.edited_by_position
, t.edited_by_designation
, t.created_by_audit_long
, t.created_by_position
, t.created_by_designation
, t.confirmed_by_audit_id
, t.confirmed_date
, t.confirmed_by_long
, t.confirmed_by_position
, t.confirmed_by_designation
, t.pho_ext_lib_id
, t.pho_ext_lib_med_id
, t.pho_ext_lib_med_ddid
, t.pho_ext_lib_generic_id
, t.pho_ext_lib_generic_desc
, t.ext_lib_rxnorm_id
, t.min_start_date
, t.max_end_date
, t.emergency_pharmacy_flag
, t.need_location_of_admin
, t.order_advanced_directive
, t.advanced_dir_status
, t.advanced_directive
, t.signed_by_long
, t.signature_date
, t.extended_end_date
, t.extended_count
, t.cust_med_id
, t.original_ti_phys_order_id
, t.linked_set_id
, t.linked_set_description
, t.new_controlled_substance_code
, t.marked_to_sign_user_id
, t.marked_to_sign_user_longname
, t.marked_to_sign_date
, t.marked_to_sign_contact_id
, t.marked_to_sign_authentication_type_id
, t.marked_to_sign_source_type_id
, t.marked_to_sign_source_type_description
, t.sign_user_id
, t.sign_user_longname
, t.sign_date
, t.sign_contact_id
, t.sign_authentication_type_id
, t.sign_authentication_type_description
, t.sign_source_type_id
, t.sign_source_type_description
, t.reason_binary_code
, t.reviewed_date
, t.review_order_id
, t.reviewed_by
, t.prescription_quantity
, t.prescription_quantity_uom
, t.prescription_no_of_refills
, t.prescription_dispense_interval
, t.prescription_total_authorized_quantity
, t.order_class_id
, t.earliest_prescriber_start_date
, t.prescriber_schedule_start_date
, t.linked_order_id
, t.linked_reason_id
, poa.facility_medical_attestation_id
from
#temp t
LEFT JOIN pho_order_related_prompt p
ON t.schedule_id = p.schedule_id and p.deleted ='N'
LEFT JOIN pho_order_related_value_type pt
ON p.value_type = pt.type_id
LEFT JOIN pho_schedule_vitals v
ON t.schedule_id = v.schedule_id and v.deleted = 'N'
LEFT JOIN pho_phys_order_attestation poa ON @vOrderCategory=3022 and poa.phys_order_id = t.phys_order_id -- only need for pharmacy order
ORDER BY t.order_schedule_id, t.schedule_id


-- select administrative orders
if @includeAdministrativeOrder='Y'
	select vpao.admin_created_date,
	vpao.admin_order_verified,
	vpao.order_related_id,
	vpao.phys_order_id,
	vpao.standard_phys_order_id,
	vpao.created_by,
	vpao.created_date,
	vpao.revision_by,
	vpao.revision_date,
	vpao.deleted_by,
	vpao.deleted_date,
	vpao.deleted,
	vpao.fac_id,
	vpao.order_relationship_id,
	vpao.admin_communication_method,
	vpao.admin_effective_date,
	vpao.admin_ineffective_date,
	vpao.admin_physician_id,
	vpao.admin_reason,
	vpao.admin_noted_by,
	vpao.admin_physician_first_name,
	vpao.admin_physician_last_name,
	vpao.strikeout_by,
	vpao.strikeout_date,
	vpao.strikeout_reason_code,
	vpao.strikeout_reason_description,
	vpao.strikeout_by_long,
	vpao.admin_order_id,
	vpao.admin_origin_id,
	secuser.long_username 'created_by_long' , secuser.designation_desc as created_by_designation, ccc.item_description as created_by_position
	,csua.long_username confirmed_by_username, csua.position_description as confirmed_by_position, csua.designation_desc as confirmed_by_designation, ua.confirmed_date as confirmed_date
	FROM view_pho_administrative_order vpao
	left join SEC_USER secuser on secuser.loginname = vpao.created_by
	left join common_code ccc on ccc.item_id = secuser.position_id
	left join pho_admin_order_useraudit ua ON ua.admin_order_id = vpao.admin_order_id
	left join cp_sec_user_audit csua on csua.cp_sec_user_audit_id = ua.confirmed_by_audit_id
	WHERE vpao.standard_phys_order_id = @physOrderId
	ORDER BY vpao.revision_date  DESC

IF @includeSupplyInfo='Y'
BEGIN
	DECLARE @integratedPharmacies TABLE
    (
        pharmacy_id int not null
    )
	INSERT INTO @integratedPharmacies (pharmacy_id)
	select distinct extFacId from (
		SELECT mp.ext_fac_id as extFacId
			FROM message_profile mp WITH (NOLOCK)
			INNER JOIN lib_message_profile lmp WITH (NOLOCK)
				ON lmp.message_profile_id = mp.message_profile_id
			       AND lmp.deleted = 'N' and lmp.is_enabled='Y'
			WHERE mp.is_enabled = 'Y' and mp.is_integrated_pharmacy='Y'
			AND mp.fac_id = @facId
			AND mp.message_protocol_id = 12
			GROUP BY mp.ext_fac_id
		UNION
		SELECT distinct mi.internal_id as extFacId
			FROM map_identifier mi WITH (NOLOCK)
			INNER JOIN lib_message_profile libmp WITH (NOLOCK)
			ON libmp.vendor_code = mi.vendor_code
			AND libmp.deleted = 'N'
			INNER JOIN message_profile mp WITH (NOLOCK)
			ON libmp.message_profile_id = mp.message_profile_id
			WHERE mi.map_type_id = 3 and mp.fac_id = @facId and  mi.fac_id = @facId
	) a where extFacId is not null

select pos.phys_order_id,
        pos.order_supply_id,
        pos.description as supply_description,
        pos.directions as supply_directions,
        pos.date_dispensed as date_dispensed,
        pos.last_received_date as supply_received_date,
        pos.med_src_type_id as supply_med_src_type_id,
        pos.pharmacy_id as supply_pharmacy_id,
        eef.name as supply_pharmacy_name,
        pos.reordering as supply_reordering,
        pos.status AS supply_status,
        pos.new_supply_flag as supply_new_supply_flag,
        pos.last_reorder_date as supply_last_reorder_date,
        pos.disp_code as supply_disp_code,
        pos.pharm_nurse_notes as pharm_nurse_notes,
        pos.nurse_pharm_notes as nurse_pharm_notes,
        pos.disp_package_identifier as supply_disp_package_identifier,
        pos.controlled_substance_code as supply_controlled_substance_code,
        pos.prescription as supply_prescription,
        pos.do_not_fill as supply_do_not_fill,
        pos.inventory_on_hand as inventory_on_hand,
        pos.next_refill_date as next_refill_date,
        psd.pharmacy_order_id as pharmacy_order_id,
        CASE  WHEN ip.pharmacy_id IS NULL THEN 'N' ELSE 'Y' END 'integrated_pharmacy',
        pos.active as supply_active,
        '' as imageFileName, 
        pos.drug_code as drug_code
    FROM pho_order_supply pos
        
        LEFT JOIN emc_ext_facilities eef ON eef.ext_fac_id = pos.pharmacy_id
        left join pho_supply_dispense psd on psd.order_supply_id = pos.order_supply_id and psd.deleted='N'
        LEFT JOIN @integratedPharmacies ip
                    ON ip.pharmacy_id = pos.pharmacy_id
    WHERE (pos.active = 'Y' or pos.active = 'N') AND pos.deleted = 'N' and pos.phys_order_id = @physOrderId
    ORDER BY pos.created_date DESC
END

	if(@debug='Y') begin Print 'END STEP select enhanced phys order		' + ' ' + convert(varchar(26),getdate(),109) end

END TRY
 
--error trapping
BEGIN CATCH

SELECT @error_code = @@error
	 , @status_text = ERROR_MESSAGE()
 
	SET @status_code = 1

	GOTO PgmAbend
 
END CATCH

--program success return
PgmSuccess:
IF @status_code = 0
BEGIN
	IF @debug='Y' PRINT 'Successfull execution of stored procedure'
	RETURN @status_code
END

--program failure return
PgmAbend:
IF @debug='Y' PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '	' + convert(varchar(26),getdate())
IF @debug='Y' PRINT 'Error code: '+convert(varchar(3),@step) + '; Error description:	' +@status_text
RETURN @status_code

END
GO

GRANT EXECUTE ON sproc_pho_list_getEnhancedOrder_v2 TO PUBLIC
GO



GO

print 'C_Branch/04_StoredProcedures/sproc_pho_list_getEnhancedOrder_v2.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_getEnhancedOrder_v2.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_getEnhancedOrderByVendorOrderId.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


 -- ===============================================================================================================================
 -- 
 -- Purpose: The purpose of this procedure is to load a phys order with all it's schedule information
 --
 -- Target ENVIRONMENT: BOTH 
 --
 --  Special Instructions: 
 --
 --	Params:
 --			
 --			@vendorPhysOrderId  - vendor phys order id
 --			@facId			    - Facility Id 
 --         @clientId           - Client Id
 --			@debug              - Debug param, 'Y' or 'N'
 --			@status_code        - SP execution flag, 0 for success.
 --			@status_text        - SP error text if error occurs.
 --
 -- Change History:
 --   Author			Date		Comment
 -- ------------------------------------------------------------------------------------------------------------------------------- 
 --	  Patryk Golabek    01/25/2012	Created.
 --   Arshad Ali        06/06/2012  ???
 --   Alireza Mandegar	10/15/2012	Updated due to PCC-33677 and Replaced the usage of fn_pho_getOrderStatus with sproc_pho_getOrderStatus
 --									Also modified the file maintenance box to be in sql comment format rather than java format
 --									and added the Change History section to it to keep track of changes.
 --   Alireza Mandegar	11/22/2012	Added schedule_sliding_scale_id due to PCC-30715
 --   Alireza Mandegar	11/29/2012	Added schedule_dose_duration due to PCC-32538
 --	  Elias Ghanem      12/21/2018  Added last_pharmacy_end_date due to CORE-28433.
 --   Mustafa Behrainwala   02/08/2019  Added behavior_lookback flag to be returned due to CORE-29190
 -- ===============================================================================================================================

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[sproc_pho_list_getEnhancedOrderByVendorOrderId]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
   drop procedure [dbo].[sproc_pho_list_getEnhancedOrderByVendorOrderId]
GO

create 
proc [dbo].[sproc_pho_list_getEnhancedOrderByVendorOrderId]
(
	@vendorPhysOrderId varchar(30),
	@facId int,
	@clientId int,
	@debug char(1)  = 'N',
	@status_code int  out, 
	@status_text varchar(3000) out
)
as 
begin

SET NOCOUNT ON

DECLARE @step			int,
	@error_code		int

	   

BEGIN TRY	

    -- PCC-33677
    ----Localize input Variables
    DECLARE  @vFacId int
            ,@vClientId int
            ,@vPhysOrderId int
            ,@vDateTime datetime
        
    -- Set the local variables
    select 
        @vFacId         = @facId, 
		@vClientId  = (
        case when (@clientId <= 0)
        then	null
        else @clientId
	    end)
	   ,@vPhysOrderId   = null
       ,@vDateTime      = getdate()
        
    -- Temp table to store the result of sproc_pho_getOrderStatus
    CREATE TABLE #TMP_PhoOrderStatus(phys_order_id      int
                                    ,fac_id             int
                                    ,order_status       smallint
                                    ,order_relationship int
                                    ,status_reason      varchar(75));
    -- Fill the temp table
	insert into #TMP_PhoOrderStatus
	exec sproc_pho_getOrderStatus 
			@facId          = @vFacId
			,@clientId      = @vClientId
			,@physOrderId   = @vPhysOrderId
			,@date          = @vDateTime
			,@debug         = 'N'
			,@status_code   = @status_code
			,@status_text   = @status_text

	if @debug = 'Y'  select * From #TMP_PhoOrderStatus

	if isnull(@status_code,0) <> 0
		  begin
				set @status_text = 'sproc_pho_getOrderStatus returned the following error: ' + isnull(@status_text,'')
				Raiserror( @status_text, 11, 1 );
		  end

	Create Clustered Index _temp_TMP_PhoOrderStatus_idx on #TMP_PhoOrderStatus( phys_order_id ) ;

    -- /PCC-33677

	if(@debug='Y') begin Print 'BEGIN STEP select enhanced phys order	' + ' ' + convert(varchar(26),getdate(),109) end

--declare @vendorPhysOrderId varchar(20); set @vendorPhysOrderId = 'R31261283'
SELECT 
o.phys_order_id
, o.order_type_id
, o.physician_id
, o.pharmacy_id
, o.fac_id
, o.std_freq_id
, o.client_id
, o.drug_code
, o.created_by
, o.created_date
, o.revision_by
, o.revision_date
, o.reorder
, o.date_ordered
, o.start_date
, o.end_date
, o.strength
, o.form
, o.route_of_admin
, o.diagnoses
, o.description
, o.directions
, o.order_directions as order_directions
, o.related_generic
, o.supplementary_notes
, o.communication_method
, o.diet_type
, diettype.item_description AS diet_type_description
, o.diet_texture
, diettexture.item_description AS diet_texture_description
, o.stat
, o.packaging
, o.disc_with_pharm
, o.quantity_to_administer
, o.std_order_id
, o.discontinued_date
, o.fluid_consistency
, fluidcon.item_description AS fluid_consistency_description
, o.diet_supplement
, dietsup.item_description AS diet_supplement_description
, o.hold_date
, o.nurse_admin_notes
, o.nurse_pharm_notes
, o.delivery_notes
, o.delivery_type
, o.self_admin
, o.administered_by_id
, o.prn_flag
, o.label_name
, o.reorder_count
, o.last_reorder_date
, o.quantity_received
, o.tran_id
, o.prescription
, o.start_date_type
, o.end_date_type
, o.end_date_duration_type
, o.end_date_duration
, o.schedule_dose_duration -- PCC-32538
, o.alter_med_src
, o.alter_med_src_name
, o.sent_date
, vpos.order_status
, o.status_change_by
, o.status_change_date
, o.hold_physician_id
, o.discontinue_physician_id
, o.pharm_nurse_notes
, o.first_admin
, o.drug_manufacturer
, o.drug_class_number
, o.resume_physician_id
, o.event_driven_flag
, o.auto_fill_flag
, o.controlled_substance_code
, o.related_phys_order_id
, o.relationship
, o.auto_created_flag
, o.active_flag
, o.new_supply_flag
, o.resume_date
, o.last_received_date
, o.orig_phys_order_id
, o.disp_package_identifier
, o.hold_date_end
, o.vendor_phys_order_id
, o.order_date
, o.sliding_scale_id
, o.order_verified
, o.dispense_as_written
, o.next_refill_date
, o.do_not_fill
, o.cur_supply_id
, o.first_documented
, o.substitution_indicator
, o.reassessment_required
, o.completed_date
, o.completed_by
, o.verify_copied_order
, o.original_route_of_admin
, o.indications_for_use
, o.draft
, o.origin_id
, o.order_category_id
, o.order_revision_date
, o.order_revision_by
, o.drug_strength
, o.drug_strength_uom
, o.drug_name
, o.is_new_order
, o.order_schedule_id
, o.start_date as schedule_start_date
, o.end_date as schedule_end_date
, o.last_pharmacy_end_date
, s.schedule_id
, s.schedule_type
, s.pho_std_time_id
, s.xxdays as xx_days
, s.sun
, s.mon
, s.tues as tue
, s.wed
, s.thurs as thu
, s.fri
, s.sat
, s.days_on
, s.days_off
, s.std_freq_id
, s.dose AS dose_value
, s.alternate_dose
, s.start_time
, s.nurse_action_notes
, s.date_start
, s.date_stop
, s.repeat_week
, s.apply_to
, s.prn_admin
, s.prn_admin_value
, s.prn_admin_units
, s.std_freq_time_label
, s.until_finished
, s.quantity_uom_id
, s.dose_uom_id
, s.schedule_directions
, s.schedule_template
, s.schedule_sliding_scale_id
, s.apply_remove_flag
, s.remove_time
, s.remove_duration
, s.behavior_lookback
, v.vital
, p.prompt_id
, p.value_type
, p.description as prompt_description
, p.notes
, p.no_of_values
, p.current_value2
, p.current_value
, p.specify_initial_value
, p.value_data_type
, p.prompt_frequency_type
, p.prompt_frequency
, p.value_date
, pt.short_desc
, c.first_name AS physician_first_name
, c.last_name AS physician_last_name
, c.title + ' ' + c.first_name + ' ' + c.last_name AS physician_fullname
, cb.long_username AS created_by_long
, rb.long_username AS revision_by_long
, poua.edited_by_audit_id
, poua.edited_date
, poua.created_by_audit_id
, edituser.long_username AS edited_by_long
, edituser.position_description AS edited_by_position
, edituser.designation_desc AS edited_by_designation
, createuser.long_username AS created_by_audit_long
, createuser.position_description AS created_by_position
, createuser.designation_desc AS created_by_designation
, poua.confirmed_by_audit_id
, poua.confirmed_date
, confuser.long_username AS confirmed_by_long
, confuser.position_description AS confirmed_by_position
, confuser.designation_desc AS confirmed_by_designation
, lib.pho_ext_lib_id
, lib.pho_ext_lib_med_id
, o.min_start_date
, o.max_end_date
, ti.orig_phys_order_id as original_ti_phys_order_id
, nctrlsc.new_controlled_substance_code as new_controlled_substance_code
, esign.marked_to_sign_user_id
, dbo.fn_get_username(esign.marked_to_sign_user_id) as marked_to_sign_user_longname
, esign.marked_to_sign_date
, esign.marked_to_sign_contact_id
, esign.marked_to_sign_authentication_type_id
, esign.marked_to_sign_source_type_id
, rstype.description as marked_to_sign_source_type_description
, esign.sign_user_id
, dbo.fn_get_username(esign.sign_user_id) as sign_user_longname
, esign.sign_date
, esign.sign_contact_id
, esign.sign_authentication_type_id
, atype.description as sign_authentication_type_description
, esign.sign_source_type_id
, stype.description as sign_source_type_description
, clinrev.reviewed_date
, clinrev.phys_order_id as review_order_id
, clinrev.reviewed_by
, oq.quantity as prescription_quantity
, oq.unit_of_measure as prescription_quantity_uom
, oq.no_of_refills as prescription_no_of_refills
, o.order_class_id
, poa.facility_medical_attestation_id
, oq.dispense_interval as prescription_dispense_interval
, oq.total_authorized_quantity as prescription_total_authorized_quantity

FROM
	view_pho_phys_order o
	LEFT JOIN #TMP_PhoOrderStatus vpos with (nolock)
		ON o.phys_order_id = vpos.phys_order_id
	LEFT JOIN view_pho_schedule s
		ON o.order_schedule_id = s.order_schedule_id AND o.phys_order_id = s.phys_order_id
	LEFT JOIN COMMON_CODE diettype
        ON o.diet_type = diettype.item_id and diettype.item_code = 'phodyt'
    LEFT JOIN COMMON_CODE diettexture
        ON o.diet_texture = diettexture.item_id and diettexture.item_code = 'phodtx'
    LEFT JOIN COMMON_CODE dietsup
        ON o.diet_supplement = dietsup.item_id and dietsup.item_code = 'phosup'
    LEFT JOIN COMMON_CODE fluidcon
    	ON o.fluid_consistency = fluidcon.item_id and fluidcon.item_code = 'phocst'
	LEFT JOIN pho_schedule_vitals v
		ON s.schedule_id = v.schedule_id and v.deleted = 'N'
	LEFT JOIN pho_order_related_prompt p
		ON s.schedule_id = p.schedule_id and p.deleted ='N'
	LEFT JOIN pho_order_related_value_type pt
		ON p.value_type = pt.type_id
	LEFT JOIN contact c
		ON c.contact_id = o.physician_id
	LEFT JOIN sec_user cb
		ON cb.loginname = o.created_by
	LEFT JOIN sec_user rb
		ON rb.loginname = o.revision_by
	LEFT JOIN pho_phys_order_useraudit poua
		ON poua.phys_order_id = o.phys_order_id
	LEFT JOIN cp_sec_user_audit createuser
	  ON createuser.cp_sec_user_audit_id = poua.created_by_audit_id
	LEFT JOIN cp_sec_user_audit edituser
	  ON edituser.cp_sec_user_audit_id = poua.edited_by_audit_id
	LEFT JOIN cp_sec_user_audit confuser
	  ON confuser.cp_sec_user_audit_id = poua.confirmed_by_audit_id
	LEFT JOIN pho_order_ext_lib_med_ref lib
	  ON lib.phys_order_id = o.phys_order_id
	LEFT JOIN pho_phys_order_ti ti
	  ON ti.phys_order_id = o.phys_order_id
	LEFT JOIN pho_phys_order_new_ctrlsubstancecode nctrlsc ON nctrlsc.phys_order_id=o.phys_order_id
	LEFT JOIN pho_phys_order_esignature esign  ON o.phys_order_id = esign.phys_order_id
    LEFT JOIN pho_phys_order_quantity_info oq on oq.phys_order_id=o.phys_order_id
    LEFT JOIN order_sign_source_type rstype ON esign.marked_to_sign_source_type_id = rstype.source_type_id
	LEFT JOIN order_sign_authentication_type atype ON esign.sign_authentication_type_id = atype.authentication_type_id
	LEFT JOIN order_sign_source_type stype ON esign.sign_source_type_id = stype.source_type_id
    LEFT JOIN pho_order_clinical_review clinrev ON clinrev.phys_order_id=o.phys_order_id
    LEFT JOIN pho_phys_order_attestation poa ON poa.phys_order_id = o.phys_order_id

WHERE o.vendor_phys_order_id = @vendorPhysOrderId
      AND (@clientId IS NULL OR @clientId <= 0 OR o.client_id = @clientId)
      AND o.fac_id=@facId
ORDER BY o.client_id, o.revision_date desc, o.phys_order_id desc

	if(@debug='Y') begin Print 'END STEP select enhanced phys order		' + ' ' + convert(varchar(26),getdate(),109) end			
END TRY
 
--error trapping
BEGIN CATCH

SELECT @error_code = @@error
	 , @status_text = ERROR_MESSAGE()
 
	SET @status_code = 1

	GOTO PgmAbend
 
END CATCH

--program success return
PgmSuccess:
IF @status_code = 0
BEGIN
	IF @debug='Y' PRINT 'Successfull execution of stored procedure'
	RETURN @status_code
END

--program failure return
PgmAbend:
IF @debug='Y' PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '	' + convert(varchar(26),getdate())
IF @debug='Y' PRINT 'Error code: '+convert(varchar(3),@step) + '; Error description:	' +@status_text
RETURN @status_code

END
GO

Grant execute on sproc_pho_list_getEnhancedOrderByVendorOrderId to public
GO
--


GO

print 'C_Branch/04_StoredProcedures/sproc_pho_list_getEnhancedOrderByVendorOrderId.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_getEnhancedOrderByVendorOrderId.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_ordersToSignDetailsEnhanced.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*****************************************************************************************************
**  Created By: Vitaly Lomov / Pedja Topalov
**  Created Date: 15-Sep-2016
**
**  Script Type: user defined store procedure
**  Target DB Type:  Client
**  Target Database:  Both
**
**  Re-Runable:  Yes
**
**  Special Instructions:  None
**
**
**	Purpose:  Returns a list of Physician Orders that need signature together with clients and
**            facility information. The orders include Telephone/Verbal and ePrescribe.
**
**
**	Params:
**			@userId                       - Required, the logged-in user making the request. If the user is a medical
**			                                professional, then only clients for those med professionals are considered.
**			                                The case when the user is not a med prof does not happen when calling from mobile
**			                                device. It only happens for the web app, in which case, the client id is given.
**			                                If the user is a med prof, only orders ordered by the user's med professional are
**			                                retrieved; otherwise, all orders are considered.
**			                                In case params @clientIdsToIncludeOrdersFrom or @staffIdsToIncludeOrdersFrom are
**			                                supplied in addition to stated above orders from other MPs that 
**			                                given user can sign are included (see params @clientIdsToIncludeOrdersFrom and
**			                                @staffIdsToIncludeOrdersFrom)
**			@clientId                     - Client whose orders to consider, null for all clients. The list of all clients
**			                                depends on whether the user is a med prof or not (see @userId param) and on
**			                                additional params @clientIdsToIncludeOrdersFrom and @staffIdsToIncludeOrdersFrom.
**			                                Clients are	retrieved only for facilities where eSignature, eSignature 
**			                                configuration, and Pract Portal are enabled.
**			@facilityDateTime             - Time 'now', which is used to filter out discharged clients.
**			@calledFrom                   - Flag to specify who's caller: 0 - Web, 1 - Mobile
**			@includeDischargedOrder       - If 1, results include discharged orders. Otherwise this should be 0
**			@clientIdsToIncludeOrdersFrom - List of Client ids for which orders from "other" MPs should be included in 
**			                                addition to orders 'ordered by' userId's MPs. Only orders that given user can sign are 
**			                                retrieved. User's MPs must have "right relationship" with clients. Also, only 
**			                                facilities with enabled features enhanced_signing_enable are considered.
**			@staffIdsToIncludeOrdersFrom  - List of MP ids for which orders should be included in addition to orders 
**			                                'ordered by' userId's MPs. Only orders that given user can sign are 
**			                                retrieved. User's MPs must have "right relationship" with clients. Also, only
**			                                facilities with enabled features enhanced_signing_enable are considered.
**			@includeOrderStatusForMobile  - If 'Y' result has appropriate status information of the orders. @calledFrom has to be '1'.
**			@debug                        - Debug param, 'Y' or 'N'
**			@status_code                  - SP execution flag, 0 for success.
**			@status_text                  - SP error text if error occurs.
**
**
**  Change History:
**
**		Author					Date			Comment
** ------------------------------------------------------------------------------------------------------------------------------- 
**		Pedja Topalov			09/15/2016		Copied sproc_pho_list_ordersToSignDetails and added new features and optimizations.
**		Pedja Topalov			11/30/2016		PCC-96861 Web - added feature to return Orders my other MPs that user can sign
**      Devika Bapat			05/24/2017		PCC-114171 - Added logic to return appropriate status when called from mobile
**		Devika Bapat			06/02/2017		PCC-117106 - Optimized the stored proc
**		Devika Bapat			09/07/2017		PCC-121408 - Added logic to support multiple clientIds instead of only one clientId
**      Daniela El Masery		04/20/2021      PCC-7153 Mobile - when calledFrom=1 (from mobile), and clientsIds are NULL, limit
**                                              the search to only user's clients and clientIdsToIncludeOrdersFrom or/and
**                                              staffIdsToIncludeOrdersFromlist if any provided.
**      Daniela El Masery		07/27/2021      CORE-70589 - when calledFrom=1 (from mobile) append needed parameters to compute
**                                              the flag mobile compatible.
**********************************************************************************************************************************/


SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO

IF EXISTS (
	SELECT 1 FROM dbo.sysobjects 
	WHERE id = OBJECT_ID(N'[dbo].[sproc_pho_list_ordersToSignDetailsEnhanced]')
	AND OBJECTPROPERTY(id, N'IsProcedure') = 1
)
BEGIN
	DROP PROCEDURE [dbo].[sproc_pho_list_ordersToSignDetailsEnhanced]
END
GO

CREATE PROCEDURE [dbo].[sproc_pho_list_ordersToSignDetailsEnhanced]
	@userId INT,	--required
	@clientIds varchar(1000) = NULL, --optional
	@facilityDateTime DATETIME,	--required
	@calledFrom INT, --required, 1 = Mobile and 0 = Web
	@includeDischargedOrder INT = 1,
	@clientIdsToIncludeOrdersFrom varchar(1000) = NULL, --optional
	@staffIdsToIncludeOrdersFrom varchar(1000) = NULL, --optional
	@includeOrderStatusForMobile char(1) = 'N', --optional
	@debug CHAR(1) = 'N',
	@status_code INT = 0 out,
	@status_text VARCHAR(3000) out

AS
BEGIN TRY
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

	DECLARE @step float;
	SET @step = 0;
	DECLARE @numOfAdditionalIds  int;
	SET @numOfAdditionalIds = 0;

	DECLARE @numOfSuppliedIds  int;
	SET @numOfSuppliedIds = 0;

	--DECLARE @clientsUserCanAccess table(
	create table #clientsUserCanAccess (
		client_id int primary key
		,fac_id int
		,admission_date datetime
		,enhanced_signing_enabled bit		-- enhanced siging enabled
		,staff_has_npi_required bit			-- NPI required
		,care_provider_access bit			-- care provider
		,staff_can_sign_other_mp_orders bit	-- relationship
		,requested_client bit				-- requested orders from other MPs
	);
	
	DECLARE @suppliedClientIds table(
		client_id int
	);
	
	DECLARE @additionalClientIds table(
		client_id int
	);

	DECLARE @additionalStaffIds table(
		staff_id int
	);

	CREATE TABLE #unsignedOrderIds
	(
		phys_order_id int primary key
		,related_phys_order_id int
		,sign_source_type tinyint	--1 for Telephone/Verbal Orders (TVO), 2 for ePrescribe orders (eRx)
	);
  
  CREATE TABLE #latestAdminOrderIds
	(
		phys_order_id int
	);

	declare @tblMedProfs table(
		staff_id int
	);

	create table #clientsOTSD
	(
    	fac_id int not null
		,client_id int not null
		,client_id_number varchar(35)
		,first_name varchar(50)
		,last_name varchar(50)
		,middle_name varchar(35)
		,date_of_birth datetime
		,photo varchar(50)
		,photo_small varchar(55)
		,sex char(1)
		,reg_id int
		,facility_name varchar(75)
		,location varchar(125)
		,physician_first_name varchar(50)
		,physician_last_name varchar(50)
		,physician_designation varchar(20)
		,admission_date datetime
	)

	create table #resultOTSD
	(
		phys_order_id int not null PRIMARY KEY
		,related_phys_order_id int
		,status int
		,fac_id int NOT NULL
		,client_id int NOT NULL
		,diet_type int
		,diet_texture int
		,diet_supplement int
		,fluid_consistency int
		,created_by varchar(60)
		,created_date datetime
		,description varchar(500)
		,related_generic varchar(250)
		,dispense_as_written varchar(1)
		,directions varchar(1000)
		,end_date datetime
		,order_category_id int
		,order_class_id int
		,order_date datetime
		,physician_id int
		,revision_by varchar(60)
		,revision_date datetime
		,start_date datetime
		,controlled_substance_code varchar(50)
		,communication_method int
		,eom_order bit
		,sign_source_type tinyint
		,signed bit
		,needs_signing bit
		,orderedByThisUser bit
		,markedtosign bit
		,needs_marking bit
		,order_verified varchar(1)
		,review_order_id int
    ,first_documented datetime
	)


    DECLARE @physOrderAllergies TABLE
    (
      phys_order_id int  NOT NULL
    )

    DECLARE @physOrderRelatedDrugs TABLE
    (
      phys_order_id int  NOT NULL ,
      severity_code varchar(1)
    )

    DECLARE @physOrderBlackbox TABLE
    (
      phys_order_id int  NOT NULL
    )

    DECLARE @physOrderDoseCheck TABLE
    (
      phys_order_id int  NOT NULL,
      over_dose varchar(1)
    )

	-- declare @poStatus table (
	create table #poStatus (
		[phys_order_id] [int] NOT NULL primary key
		,[fac_id] [int] NOT NULL
		,[order_status] [int] NOT NULL
		,[order_relationship] [int] NULL
		,[status_reason] int NULL
	)
	
	DECLARE @tempWebClientIds TABLE(
		client_id int
		,fac_id int
		,admission_date datetime
	);
	
	IF @clientIds IS NOT NULL AND len(@clientIds) > 0 BEGIN
		INSERT INTO @suppliedClientIds
			SELECT value FROM pcc__csvToTableOfInt(@clientIds);
		SET @numOfSuppliedIds = @@ROWCOUNT
		
		IF @debug='Y' BEGIN
			SELECT * FROM @suppliedClientIds;
		END
	END
	--Parse input param lists clientIdsToIncludeOrdersFrom and staffIdsToIncludeOrdersFrom
	IF @clientIdsToIncludeOrdersFrom IS NOT NULL AND len(@clientIdsToIncludeOrdersFrom) > 0 BEGIN
		INSERT INTO @additionalClientIds
			SELECT value FROM pcc__csvToTableOfInt(@clientIdsToIncludeOrdersFrom);
		SET @numOfAdditionalIds = @@ROWCOUNT
		
		IF @debug='Y' BEGIN
			SELECT * FROM @additionalClientIds;
		END
	END

	IF @staffIdsToIncludeOrdersFrom IS NOT NULL AND len(@staffIdsToIncludeOrdersFrom) > 0 BEGIN
		INSERT INTO @additionalStaffIds
			SELECT value FROM pcc__csvToTableOfInt(@staffIdsToIncludeOrdersFrom);
		SET @numOfAdditionalIds = @numOfAdditionalIds+@@ROWCOUNT
		
		IF @debug='Y' BEGIN
			SELECT * FROM @additionalStaffIds;
		END
	END

	
	SET @step=1;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Get client ids';

	IF @calledFrom = 1 -- From Mobile
	BEGIN
		INSERT INTO @tblMedProfs SELECT staff_id FROM [dbo].[fn_isUserMedProf](@userId);

		IF @clientIds IS NULL
		BEGIN
			-- Select only clients where the user is MP if no additional clients or additional staff to include is specified.
			IF  @numOfAdditionalIds = 0
			BEGIN
				INSERT INTO #clientsUserCanAccess
				SELECT cli.client_id
					,cli.fac_id
					,c.admission_date
					,fac_conf.enhanced_signing_enabled
					,null
					,null
					,null
					,0 AS 'requested_client'
				FROM fn_clinical_list_clientsForUser(@userId, null, 1) cli
				INNER JOIN view_pho_facility_sign_configuration fac_conf ON fac_conf.fac_id = cli.fac_id --facilities with configuration for signing
				INNER JOIN dbo.CLIENTS c WITH (NOLOCK) ON cli.client_id = c.client_id AND c.deleted = 'N'
			END
			ELSE
			BEGIN
				-- Get the clients where the user is MP and add to suppliedClientIds table.
				INSERT INTO @suppliedClientIds
				SELECT cli.client_id
				FROM [dbo].[fn_clinical_list_clientsForUser](@userId, null, 1) cli
				INNER JOIN view_pho_facility_sign_configuration fac_conf ON fac_conf.fac_id = cli.fac_id --facilities with configuration for signing
				INNER JOIN dbo.CLIENTS c WITH (NOLOCK) ON cli.client_id = c.client_id AND c.deleted = 'N'

				IF @clientIdsToIncludeOrdersFrom is NOT NULL AND len(@clientIdsToIncludeOrdersFrom) > 0
				BEGIN
					-- Add to supplied clients the additional clients from others MP.
					INSERT INTO @suppliedClientIds
					SELECT client_id
					FROM  @additionalClientIds
				END

				IF @staffIdsToIncludeOrdersFrom IS NOT NULL AND len(@staffIdsToIncludeOrdersFrom) > 0
				BEGIN
					-- Add the clients user can access for signing for staffIds provided only.
					INSERT INTO @suppliedClientIds
					SELECT cli.client_id
					FROM fn_clinical_list_clientsUserCanAccess(@userId, NULL) cli
					INNER JOIN view_pho_facility_sign_configuration fac_conf ON fac_conf.fac_id = cli.fac_id --facilities with configuration for signing
					INNER JOIN dbo.CLIENTS c WITH (NOLOCK) ON cli.client_id = c.client_id AND c.deleted = 'N'
					WHERE
						cli.staff_id in (select staff_id from @additionalStaffIds)
				END

				-- Filter data for the clients that qualified for sign order only that are on the supplied client lists
				INSERT INTO #clientsUserCanAccess
				SELECT cli.client_id
					,cli.fac_id
					,c.admission_date
					,fac_conf.enhanced_signing_enabled
					,cli.staff_has_npi_required
					,cli.care_provider_access
					,cli.staff_can_sign_other_mp_orders
					,CASE WHEN aci.client_id IS NULL THEN 0 ELSE 1 END AS 'requested_client'
				FROM fn_clinical_list_clientsUserCanAccess(@userId, NULL) cli --all clients associated with MPs associated with user
				INNER JOIN view_pho_facility_sign_configuration fac_conf ON fac_conf.fac_id = cli.fac_id --facilities with configuration for signing
				INNER JOIN dbo.CLIENTS c WITH (NOLOCK) ON cli.client_id = c.client_id AND c.deleted = 'N'
				LEFT JOIN @additionalClientIds aci ON aci.client_id = cli.client_id
				WHERE
					cli.client_id in (select client_id from @suppliedClientIds)
			END
		END
		ELSE
		BEGIN -- clientIds not null
			INSERT INTO #clientsUserCanAccess
			SELECT cli.client_id
				,cli.fac_id
				,c.admission_date
				,fac_conf.enhanced_signing_enabled
				,cli.staff_has_npi_required
				,cli.care_provider_access
				,cli.staff_can_sign_other_mp_orders
				,CASE WHEN aci.client_id IS NULL THEN 0 ELSE 1 END AS 'requested_client'
				FROM fn_clinical_list_clientsUserCanAccess(@userId, NULL) cli --all clients associated with MPs associated with user
				INNER JOIN view_pho_facility_sign_configuration fac_conf ON fac_conf.fac_id = cli.fac_id --facilities with configuration for signing
				INNER JOIN dbo.CLIENTS c WITH (NOLOCK) ON cli.client_id = c.client_id AND c.deleted = 'N'
				LEFT JOIN @additionalClientIds aci ON aci.client_id = cli.client_id	
			WHERE
				@clientIds IS NULL OR cli.client_id in (select client_id from @suppliedClientIds);
		END
	END
	ELSE
	BEGIN -- From Web
		DECLARE @clientId int
		SELECT @clientId = client_id from @suppliedClientIds; -- web call will have only 1 client id.
		INSERT INTO @tempWebClientIds
		SELECT TOP 1 @clientId, fac_id, clients.admission_date
			FROM clients WHERE client_id=@clientId  AND deleted = 'N';

		DECLARE @facIdLocal int;
		SELECT @facIdLocal = fac_id FROM @tempWebClientIds;

		IF(EXISTS(select * from configuration_parameter where fac_id = -1 and name = 'medical_professional_enabled' and value = 'Y'))
			INSERT INTO @tblMedProfs SELECT contact_id AS staff_id FROM staff WHERE userid=@userId and deleted='N' and on_staff='N' and fac_id=-1; --New medical professional implementation: only one staff record with fac_id = -1
		ELSE
			INSERT INTO @tblMedProfs SELECT contact_id AS staff_id FROM staff WHERE userid=@userId and deleted='N' and on_staff='N' and fac_id=@facIdLocal;

		IF exists(select * from @tblMedProfs)	--med professional
		BEGIN
			INSERT INTO #clientsUserCanAccess
			SELECT cli.client_id
				,cli.fac_id
				,c.admission_date
				,fac_conf.enhanced_signing_enabled
				,cli.staff_has_npi_required
				,cli.care_provider_access
				,cli.staff_can_sign_other_mp_orders
				,CASE WHEN aci.client_id IS NULL THEN 0 ELSE 1 END AS 'requested_client'
				FROM fn_clinical_list_clientsUserCanAccess(@userId, @facIdLocal) cli --all clients associated with MPs associated with user
					INNER JOIN view_pho_facility_sign_configuration fac_conf ON fac_conf.fac_id = cli.fac_id --facilities with configuration for signing
					INNER JOIN @tempWebClientIds c ON cli.client_id = c.client_id
					LEFT JOIN @additionalClientIds aci ON aci.client_id = cli.client_id	
				WHERE
					(@clientId IS NULL OR cli.client_id = @clientId)
		END
		ELSE -- non-med proffesional
		BEGIN
			INSERT INTO #clientsUserCanAccess
			SELECT cli.client_id ,cli.fac_id ,cli.admission_date, NULL, NULL, NULL, NULL, 0
			FROM @tempWebClientIds cli
		END
		
	END

	IF @debug='Y' BEGIN
		SELECT * FROM #clientsUserCanAccess;
	END

	SET @step=2;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Get unsigned TV order candidates';

	INSERT INTO #unsignedOrderIds
    SELECT ppots.phys_order_id,
		  pro.related_phys_order_id		, --id of the parent (admin's main order)
		  1 AS sign_source_type
    --FROM pho_phys_order_to_sign ppots
    --	LEFT JOIN pho_phys_order_sign ppos on ppots.phys_order_id=ppos.phys_order_id
    --	LEFT JOIN pho_related_order pro ON pro.phys_order_id=ppots.phys_order_id	--link to admin orders
    --WHERE ppos.phys_order_id IS NULL	--not signed
    FROM pho_phys_order ppo
		  JOIN pho_phys_order_to_sign ppots ON(ppo.phys_order_id = ppots.phys_order_id)
		  JOIN #clientsUserCanAccess c ON(ppo.client_id = c.client_id)
		  LEFT JOIN pho_phys_order_sign ppos ON ppots.phys_order_id = ppos.phys_order_id
		  LEFT JOIN pho_related_order pro ON pro.phys_order_id = ppots.phys_order_id and pro.deleted = 'N' --link to admin orders
		  LEFT JOIN pho_order_clinical_review pcr ON pcr.phys_order_id = ppos.phys_order_id AND pcr.reviewed_date IS NULL
    WHERE ppos.phys_order_id IS NULL
    and pcr.phys_order_id IS NULL
		  AND ppo.order_verified = 'Y';
  
  SET @step=2.1;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Get latest admin id of parent order';
  
  WITH sao AS (
    SELECT pro.phys_order_id, ROW_NUMBER() OVER (PARTITION BY pro.related_phys_order_id ORDER BY pro.revision_date DESC) AS rn
    FROM pho_related_order pro
      INNER JOIN #unsignedOrderIds ON [#unsignedOrderIds].related_phys_order_id=pro.related_phys_order_id
      INNER JOIN pho_admin_order pao ON pao.phys_order_id=pro.phys_order_id
      WHERE pro.deleted = 'N'
  )
  INSERT INTO #latestAdminOrderIds
    SELECT phys_order_id FROM sao WHERE sao.rn=1
       

	SET @step=2.2;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Get unsigned eRx order candidates';

	INSERT INTO #unsignedOrderIds
	--SELECT
	--	esign.phys_order_id
	--	,null
	--	,2 as sign_source_type
	--FROM pho_phys_order_esignature esign
	--WHERE sign_contact_id IS NULL 	--not signed

    SELECT esign.phys_order_id,
		 NULL,
		 2 AS sign_source_type
    FROM pho_phys_order ppo
	    JOIN pho_phys_order_esignature esign ON(ppo.phys_order_id = esign.phys_order_id)
	    JOIN #clientsUserCanAccess c ON(ppo.client_id = c.client_id)
    WHERE sign_contact_id IS NULL
    AND (ppo.active_flag IS NULL OR ppo.active_flag = 'Y');    --not signed

	-- create index on #unsignedOrderIds on sign_source_type

	--create index idx01 on #unsignedOrderIds(sign_source_type) include (related_phys_order_id)
	;
	IF @debug='Y' BEGIN
		SELECT 'Order Candidates', * FROM #unsignedOrderIds;
		DECLARE @tOrdIds VARCHAR(100);
		SET @tOrdIds = (SELECT CAST(a.phys_order_id AS VARCHAR) + ',' FROM (SELECT phys_order_id, related_phys_order_id, COUNT(*) AS cnt FROM #unsignedOrderIds GROUP BY phys_order_id, related_phys_order_id HAVING COUNT(*) > 1) AS A FOR XML PATH(''));
		IF @tOrdIds IS NOT NULL RAISERROR('Orders need signature as both TV and eRx: %s',16,1, @tOrdIds);
	END

	
	SET @step=3;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Insert non struckout orders into cache';

	IF exists(select * from @tblMedProfs)	--med professional - Web and Mobile
	BEGIN
		SET @step=3.1;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Unsigned Orders for med professional';
		INSERT INTO #resultOTSD
		SELECT
			ppo.phys_order_id 'phys_order_id'
			,[#unsignedOrderIds].related_phys_order_id 'related_phys_order_id'
			,7 AS status	--unverified
			,ppo.fac_id
			,ppo.client_id
			,ppo.diet_type
			,ppo.diet_texture
			,ppo.diet_supplement
			,ppo.fluid_consistency
			,ppo.created_by
			,ppo.created_date
			,ppo.description
			,ppo.related_generic 'related_generic'
			,ppo.dispense_as_written 'dispense_as_written'
			,ppo.directions
			,ppo.end_date 'end_date'
			,ppo.order_category_id 'order_category_id'
			,ppo.order_class_id 'order_class_id'
			,ppo.order_date 'order_date'
			,ppo.physician_id 'physician_id'
			,ppo.revision_by 'revision_by'
			,ppo.revision_date 'revision_date'
			,ppo.start_date 'start_date'
			,ppo.controlled_substance_code 'controlled_substance_code'
			,ppo.communication_method 'communication_method'
			,CASE WHEN ppone.phys_order_id is null THEN 0 ELSE 1 END AS 'eom_order'
			,[#unsignedOrderIds].sign_source_type
			,0 AS 'signed'
			,1 AS needs_signing --Only Orders ordered by user's MPs or Other Orders that user can sign are returned
			,CASE WHEN [@tblMedProfs].staff_id IS NULL then 0 ELSE 1 END AS orderedByThisUser
			,CASE WHEN esign.marked_to_sign_contact_id IS NULL THEN 0 ELSE 1 END AS markedtosign
			,CASE WHEN (ppo.controlled_substance_code IS NOT NULL AND ppo.controlled_substance_code IN ('2','3','4','5','6')) AND esign.marked_to_sign_contact_id IS NULL THEN 1 ELSE 0 END AS needs_marking
			,ppo.order_verified
			,pcr.phys_order_id 'review_order_id'
      ,ppo.first_documented
		FROM
			#unsignedOrderIds
			INNER JOIN pho_phys_order ppo WITH(nolock) ON [#unsignedOrderIds].phys_order_id=ppo.phys_order_id
			INNER JOIN #clientsUserCanAccess c ON c.client_id = ppo.client_id
			LEFT JOIN pho_order_clinical_review pcr ON pcr.phys_order_id=[#unsignedOrderIds].phys_order_id AND pcr.reviewed_date is NULL
			LEFT JOIN @tblMedProfs ON ppo.physician_id=[@tblMedProfs].staff_id
			LEFT JOIN @additionalStaffIds asi ON ppo.physician_id=asi.staff_id
			LEFT JOIN pho_phys_order_new_entry ppone ON ppone.phys_order_id = ppo.phys_order_id
			LEFT JOIN pho_phys_order_esignature esign ON esign.phys_order_id=[#unsignedOrderIds].phys_order_id AND [#unsignedOrderIds].sign_source_type = 2
		WHERE 
			([#unsignedOrderIds].sign_source_type=1	--TVO
				AND (ppo.order_verified='Y' 
					AND pcr.phys_order_id is NULL
					AND ([@tblMedProfs].staff_id IS NOT NULL --order is ordered by user's MP
						OR (c.enhanced_signing_enabled = 1 
							AND (c.requested_client = 1 OR asi.staff_id IS NOT NULL)
							AND c.staff_has_npi_required = 1 
							AND (c.care_provider_access = 0 OR c.staff_can_sign_other_mp_orders = 1)
						)
					) 
				)
			)
			OR([#unsignedOrderIds].sign_source_type=2	--eRx
				AND ((ppo.active_flag IS NULL OR ppo.active_flag = 'Y') --taken from orderStatus
					AND ([@tblMedProfs].staff_id IS NOT NULL --order is ordered by user's MP
						OR (c.enhanced_signing_enabled = 1 
							AND (c.requested_client = 1 OR asi.staff_id IS NOT NULL) 
							AND c.staff_has_npi_required = 1 
							AND (c.care_provider_access = 0 OR c.staff_can_sign_other_mp_orders = 1)
							AND (ppo.controlled_substance_code NOT IN ('2','3','4','5','6') OR ppo.controlled_substance_code IS NULL) 
						) 
					)
				)
			)
			AND (ppo.order_class_id=1 
				OR (@includeDischargedOrder = 1 AND ppo.created_date > c.admission_date))
	END
	ELSE	--not med professional
	BEGIN
		SET @step=3.1;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Unsigned Orders for non-med professional';
		insert into #resultOTSD
		select distinct 
			ppo.phys_order_id 'phys_order_id'
			,[#unsignedOrderIds].related_phys_order_id 'related_phys_order_id'
			,7 AS status	--unverified
			,ppo.fac_id
			,ppo.client_id
			,ppo.diet_type
			,ppo.diet_texture
			,ppo.diet_supplement
			,ppo.fluid_consistency
			,ppo.created_by
			,ppo.created_date
			,ppo.description
			,ppo.related_generic 'related_generic'
			,ppo.dispense_as_written 'dispense_as_written'
			,ppo.directions
			,ppo.end_date 'end_date'
			,ppo.order_category_id 'order_category_id'
			,ppo.order_class_id 'order_class_id'
			,ppo.order_date 'order_date'
			,ppo.physician_id 'physician_id'
			,ppo.revision_by 'revision_by'
			,ppo.revision_date 'revision_date'
			,ppo.start_date 'start_date'
			,ppo.controlled_substance_code 'controlled_substance_code'
			,ppo.communication_method 'communication_method'
			,CASE WHEN ppone.phys_order_id is null THEN 0 ELSE 1 END AS 'eom_order'
			,[#unsignedOrderIds].sign_source_type
			,0 'signed'
			,1 AS needs_signing
			,0 AS orderedByThisUser
			,0 as markedtosign
			,0 as needs_marking
			,ppo.order_verified
			,pcr.phys_order_id 'review_order_id'
      ,ppo.first_documented
		from
			#unsignedOrderIds
			INNER JOIN pho_phys_order ppo WITH(nolock) ON [#unsignedOrderIds].phys_order_id=ppo.phys_order_id
			LEFT JOIN pho_order_clinical_review pcr ON pcr.phys_order_id=[#unsignedOrderIds].phys_order_id AND pcr.reviewed_date is NULL
			INNER JOIN #clientsUserCanAccess c ON c.client_id = ppo.client_id
			LEFT JOIN pho_phys_order_new_entry ppone ON ppone.phys_order_id = ppo.phys_order_id
		WHERE 
			([#unsignedOrderIds].sign_source_type=1	--TVO
				AND ppo.order_verified='Y'
				AND pcr.phys_order_id is NULL	--no pending clinical review
			)
			OR([#unsignedOrderIds].sign_source_type=2	--eRx
				AND (ppo.active_flag IS NULL OR ppo.active_flag = 'Y')	--taken from orderStatus
			)
			and (ppo.order_class_id=1 
					or (@includeDischargedOrder = 1 AND ppo.created_date > c.admission_date))
	END

	CREATE INDEX idx1 ON #resultOTSD(related_phys_order_id);

	IF @debug='Y' BEGIN
		SELECT * FROM #resultOTSD;
	END

	
	SET @step=4;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Insert main Orders for unsigned admin Orders into cache';
		INSERT INTO #resultOTSD
		SELECT
			ppo.phys_order_id 'phys_order_id'
			,NULL 'related_phys_order_id'
			,7 AS status	--unverified
			,ppo.fac_id
			,ppo.client_id
			,ppo.diet_type
			,ppo.diet_texture
			,ppo.diet_supplement
			,ppo.fluid_consistency
			,ppo.created_by
			,ppo.created_date
			,ppo.description
			,ppo.related_generic 'related_generic'
			,ppo.dispense_as_written 'dispense_as_written'
			,ppo.directions
			,ppo.end_date 'end_date'
			,ppo.order_category_id 'order_category_id'
			,ppo.order_class_id 'order_class_id'
			,ppo.order_date 'order_date'
			,ppo.physician_id 'physician_id'
			,ppo.revision_by 'revision_by'
			,ppo.revision_date 'revision_date'
			,ppo.start_date 'start_date'
			,ppo.controlled_substance_code 'controlled_substance_code'
			,ppo.communication_method 'communication_method'
			,CASE WHEN ppone.phys_order_id is null THEN 0 ELSE 1 END AS 'eom_order'
			-- in case record exists in pho_phys_order_to_sign it's 1 otherwise it's 2
			,CASE WHEN ppots.phys_order_id IS NULL THEN 2 ELSE 1 END AS 'sign_source_type'
			,1 AS 'signed'
			,0 needs_signing
			,CASE WHEN [@tblMedProfs].staff_id IS NULL then 0 ELSE 1 END AS orderedByThisUser
			,0 markedtosign
			,0 needs_marking
			,ppo.order_verified
			,NULL 'review_order_id' -- review for admin order
      ,ppo.first_documented
		FROM pho_phys_order ppo WITH(nolock)
			INNER JOIN (
				-- We want to fetch only main orders that are NOT already in resultOTSD
				SELECT DISTINCT adminOrd.related_phys_order_id
				FROM #resultOTSD adminOrd
					LEFT JOIN #resultOTSD mainOrd ON adminOrd.related_phys_order_id = mainOrd.phys_order_id
				WHERE adminOrd.related_phys_order_id IS NOT NULL AND mainOrd.phys_order_id IS NULL
				) AS mainForAdmin ON mainForAdmin.related_phys_order_id = ppo.phys_order_id
			LEFT JOIN pho_phys_order_to_sign ppots on ppots.phys_order_id=ppo.phys_order_id
			LEFT JOIN @tblMedProfs ON ppo.physician_id=[@tblMedProfs].staff_id
			LEFT JOIN pho_phys_order_new_entry ppone ON ppone.phys_order_id = ppo.phys_order_id

	CREATE INDEX idx2 ON #resultOTSD(client_id);
	CREATE INDEX idx3 ON #resultOTSD(fac_id);
	CREATE INDEX idx4 ON #resultOTSD(physician_id);
		
	IF @debug='Y' BEGIN
		SELECT * FROM #resultOTSD;
	END
	
	
	SET @step=5;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Insert client data';

	INSERT INTO #clientsOTSD
	SELECT
		c.fac_id
		,c.client_id
		,c.client_id_number
		,m.first_name
		,m.last_name
		,m.middle_name
		,m.date_of_birth
		,c.photo
		,c.photo_small
		,m.sex
		,f.regional_id
		,f.name
		,CASE WHEN (ci.census_id IS NULL OR ci.bed_id IS NULL OR ci.bed_id = -1) THEN NULL ELSE unit.unit_desc + ' ' + room.room_desc + '-' + bed.bed_desc END AS location
		,ct.first_name AS physician_first_name
		,ct.last_name AS physician_last_name
		,staff.designation AS physician_designation
		,c.admission_date
	FROM
		dbo.CLIENTS c WITH (NOLOCK)
		INNER JOIN (SELECT DISTINCT(#resultOTSD.client_id) FROM #resultOTSD) AS resOrd ON resOrd.client_id = c.client_id
		INNER JOIN dbo.mpi m WITH (NOLOCK) ON m.mpi_id=c.mpi_id
		INNER JOIN dbo.facility f WITH (NOLOCK) ON f.fac_id = c.fac_id
		LEFT JOIN census_item ci WITH (NOLOCK) ON ci.census_id = c.current_census_id
		LEFT JOIN dbo.BED bed WITH (NOLOCK) ON ci.fac_id = bed.fac_id AND ci.bed_id = bed.bed_id
		LEFT JOIN dbo.ROOM room WITH (NOLOCK) ON bed.fac_id = room.fac_id AND bed.room_id = room.room_id
		LEFT JOIN dbo.UNIT unit WITH (NOLOCK) ON room.fac_id = unit.fac_id AND room.unit_id = unit.unit_id
		LEFT JOIN dbo.floor ufloor WITH (NOLOCK) on ufloor.floor_id = room.floor_id
		LEFT JOIN contact ct WITH (NOLOCK) ON c.primary_physician_id = ct.contact_id
		LEFT JOIN staff WITH (NOLOCK) on staff.contact_id=ct.contact_id

	
	SET @step=6;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Check allergies (if applicable)';

	--Do this near the end so we can avoid having to join onto the pho_phys_order table directly
	INSERT INTO @physOrderAllergies
	SELECT DISTINCT r.phys_order_id
	FROM #resultOTSD r
		INNER JOIN configuration_parameter conf ON conf.fac_id = r.fac_id
		LEFT JOIN pho_order_supply pos on pos.phys_order_id=r.phys_order_id AND (pos.active = 'Y' and (pos.status=4 or pos.status=8)) AND pos.deleted = 'N' -- Only consider active and "on hand" supplies
		LEFT JOIN pho_phys_order_allergy_acknowledgement pa on pa.phys_order_id = r.phys_order_id
		LEFT JOIN pho_order_supply_allergy posa on posa.order_supply_id = pos.order_supply_id
		INNER JOIN allergy a on (a.allergy_id = pa.allergy_id or a.allergy_id=posa.allergy_id)
	WHERE conf.name='enable_drug_allergy_check' AND conf.value='Y'
		AND (a.status_id=1 or a.status_id=3) AND (a.resolved_date is null OR a.resolved_date > @facilityDateTime)

	SET @step=7;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Check Related Drugs (if applicable)';

	--Do this near the end so we can avoid having to join onto the pho_phys_order table directly
	INSERT INTO @physOrderRelatedDrugs
	SELECT DISTINCT r.phys_order_id , pda.severity_code
	FROM #resultOTSD r
		INNER JOIN configuration_parameter conf ON conf.fac_id = r.fac_id
		--must be reviewed whether it's unnecessary (should remove it) or should be fixed
		LEFT JOIN pho_order_supply pos on pos.phys_order_id=r.phys_order_id AND (pos.active = 'Y' and (pos.status=4 or pos.status=8)) AND pos.deleted = 'N' -- Only consider active and "on hand" supplies
		INNER JOIN pho_phys_order_drug_acknowledgement pda on pda.phys_order_id = r.phys_order_id
	WHERE conf.name='enable_drug_interaction' AND conf.value='Y'

	INSERT INTO @physOrderBlackbox
	SELECT DISTINCT r.phys_order_id
	FROM #resultOTSD r
		INNER JOIN configuration_parameter conf ON conf.fac_id = r.fac_id
		--must be reviewed whether it's unnecessary (should remove it) or should be fixed
		LEFT JOIN pho_order_supply pos on pos.phys_order_id=r.phys_order_id AND (pos.active = 'Y' and (pos.status=4 or pos.status=8)) AND pos.deleted = 'N' -- Only consider active and "on hand" supplies
		INNER JOIN pho_phys_order_blackbox_acknowledgement pba on pba.phys_order_id = r.phys_order_id
	WHERE conf.name='enable_black_box' AND conf.value='Y'

	INSERT INTO @physOrderDoseCheck
	SELECT DISTINCT r.phys_order_id,pba.over_dose
	FROM #resultOTSD r
		INNER JOIN configuration_parameter conf ON conf.fac_id = r.fac_id
		INNER JOIN pho_phys_order_dose_check_acknowledgement pba on pba.phys_order_id = r.phys_order_id
	WHERE conf.name='enable_dose_check' AND conf.value='Y'

	IF @calledFrom = 0 OR (@includeOrderStatusForMobile = 'Y' and @calledFrom = 1)
	BEGIN
  
  create table #clientIds
	(
		client_id int,
	)
	
	insert into #clientIds
	SELECT client_id
	FROM #clientsOTSD
	
	declare @numClients int
	set @numClients = (select count(*) from #clientsOTSD)
	DECLARE @Iterator INT
	SET @Iterator = 0	
 
	WHILE (@Iterator < @numClients)
	BEGIN
		declare @tmpFacId int, @tmpClientId int
    set @tmpClientId = (select top 1 client_id from #clientIds)
    set @tmpFacId = (select fac_id from #clientsOTSD where client_id=@tmpClientId)
    
		-- now get the current time for that facility
		DECLARE @now datetime
		SET @now = (select dbo.fn_adjust_time_fac_time_zone_base_on_date(@tmpFacId, GetDate()))
	  
		-- call getOrderStatus stored proc with the current facility and current facility datetime
		INSERT INTO #poStatus
		EXEC sproc_pho_getOrderStatus  @tmpFacId,@tmpClientId,NULL,@now,'N',@debug,@status_code out,@status_text out
		IF @debug='Y' SELECT 'orderStatus', * FROM #poStatus;
	  
		-- we are done with this facility
		delete from #clientIds where client_id = @tmpClientId
  
		Set @Iterator = @Iterator + 1 -- lets's move on to next facility
	  END
      
  drop table #clientIds
  END
    /****************************************
    return final result
    ****************************************/
	SET @step=8;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Return clients';
	SELECT
		fac_id
		,client_id
		,client_id_number
		,first_name
		,last_name
		,middle_name
		,date_of_birth
		,photo
		,photo_small
		,sex
		,reg_id
		,location
		,physician_first_name
		,physician_last_name
		,physician_designation
		,admission_date
	FROM #clientsOTSD
	ORDER BY last_name, first_name, middle_name, facility_name;

	SET @step=9;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Return orders';

    SELECT
		physorder.phys_order_id
		,ISNULL([#poStatus].order_status, 7) AS status	--unverified
		,physorder.fac_id
		,physorder.client_id
		,physorder.created_date
		,physorder.description
		,physorder.related_generic
		,physorder.dispense_as_written
		,physorder.directions
		,physorder.end_date
		,physorder.order_category_id
		,physorder.order_class_id
		,physorder.order_date
		,physorder.revision_by
		,physorder.revision_date
		,physorder.start_date
		,physorder.controlled_substance_code
		,physorder.communication_method
		,physorder.eom_order
		,physorder.physician_id
		,ordercat.category_desc 'order_category_description'
		,physcon.first_name AS physician_first_name
		,physcon.last_name AS physician_last_name
		,staff.designation AS physician_designation
		,dietsup.item_description AS diet_supplement_description
		,diettexture.item_description AS diet_texture_description
		,diettype.item_description AS diet_type_description
		,fluidcon.item_description AS fluid_consistency_description
		,isnull(createdBySu.long_username, physorder.created_by) 'created_by_longname'
		,isnull(revisionBySu.long_username, physorder.created_by) 'revision_by_longname'
		,useraudit.edited_date
		,createuser.long_username AS created_by_audit_long
		,createuser.position_description AS created_by_position
		,createuser.designation_desc AS created_by_designation
		,useraudit.confirmed_date
		,confuser.long_username AS confirmed_by_long
		,confuser.position_description AS confirmed_by_position
		,confuser.designation_desc AS confirmed_by_designation
		,poa.phys_order_id AS allergy_phys_order_id
		,pob.phys_order_id AS blackbox_phys_order_id
		,pdc.phys_order_id AS dose_check_phys_order_id
		,pdc.over_dose AS over_dose_value
		,physorder.sign_source_type
		,physorder.signed
		,physorder.needs_signing
		,physorder.orderedByThisUser
		,physorder.markedtosign
		,physorder.needs_marking
		,oq.quantity as prescription_quantity
 	 	,oq.unit_of_measure as prescription_quantity_uom
 	 	,oq.no_of_refills as prescription_no_of_refills
		,physorder.order_verified
		,physorder.review_order_id
    ,physorder.first_documented
	,CASE WHEN ppoa.is_controlled_medication = 0 THEN fma.non_ctrl_medication_value ELSE fma.ctrl_medication_value END medication_attestation
	FROM
		#resultOTSD physorder
		LEFT JOIN CONTACT physcon ON physorder.physician_id = physcon.contact_id
		LEFT JOIN staff ON staff.contact_id=physcon.contact_id
		LEFT JOIN PHO_ORDER_CATEGORY ordercat ON physorder.order_category_id = ordercat.order_category_id
		LEFT JOIN COMMON_CODE diettype ON physorder.diet_type = diettype.item_id
		LEFT JOIN COMMON_CODE diettexture ON physorder.diet_texture = diettexture.item_id
		LEFT JOIN COMMON_CODE dietsup ON physorder.diet_supplement = dietsup.item_id
		LEFT JOIN COMMON_CODE fluidcon ON physorder.fluid_consistency = fluidcon.item_id
		LEFT JOIN sec_user createdBySu ON createdBySu.loginname = physorder.created_by
		LEFT JOIN sec_user revisionBySu ON revisionBySu.loginname = physorder.revision_by
		LEFT JOIN pho_phys_order_useraudit useraudit ON useraudit.phys_order_id = physorder.phys_order_id
		LEFT JOIN cp_sec_user_audit createuser ON createuser.cp_sec_user_audit_id = useraudit.created_by_audit_id
		LEFT JOIN cp_sec_user_audit confuser ON confuser.cp_sec_user_audit_id = useraudit.confirmed_by_audit_id
		LEFT JOIN @physOrderAllergies poa ON poa.phys_order_id= physorder.phys_order_id
		LEFT JOIN @physOrderBlackbox pob ON pob.phys_order_id= physorder.phys_order_id
		LEFT JOIN @physOrderDoseCheck pdc ON pdc.phys_order_id = physorder.phys_order_id
		LEFT JOIN pho_phys_order_quantity_info oq on oq.phys_order_id=physorder.phys_order_id
		LEFT JOIN #poStatus ON [#poStatus].phys_order_id=physorder.phys_order_id
		LEFT JOIN pho_phys_order_attestation ppoa on ppoa.phys_order_id = physorder.phys_order_id 
        LEFT JOIN facility_medical_attestation fma on fma.facility_medical_attestation_id = ppoa.facility_medical_attestation_id 
	WHERE physorder.order_category_id <> 3030;

	SET @step=10;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Return administrative orders';

	SELECT
		physorder.phys_order_id
		,dbo.pho_related_order.related_phys_order_id AS 'standard_phys_order_id'
		,dbo.pho_related_order.order_relationship_id
		,physorder.order_date
		,administrative.effective_date
		,administrative.ineffective_date
		,physorder.communication_method
		,administrative.reason AS admin_reason
		,physician_contact.first_name AS physician_first_name
		,physician_contact.last_name AS physician_last_name
		,staff.designation AS physician_designation
		,administrative.created_date
		,CASE WHEN createuser.long_username IS NULL THEN sec_user.long_username ELSE createuser.long_username END AS created_by_audit_long
		,createuser.position_description AS created_by_position
		,createuser.designation_desc AS created_by_designation
		,useraudit.confirmed_date
		,confuser.long_username AS confirmed_by_audit_long
		,confuser.position_description AS confirmed_by_position
		,confuser.designation_desc AS confirmed_by_designation
		,NULL AS 'strikeout_by'
		,physorder.sign_source_type
		,0 as signed
		,physorder.orderedByThisUser
		,physorder.order_verified
		,physorder.review_order_id
    ,CASE WHEN [#latestAdminOrderIds].phys_order_id IS NOT NULL THEN 'Y' ELSE 'N' END AS latest
	FROM 
		#resultOTSD AS physorder
		INNER JOIN dbo.pho_related_order ON dbo.pho_related_order.phys_order_id = physorder.phys_order_id 
		INNER JOIN dbo.pho_admin_order AS administrative ON administrative.phys_order_id = physorder.phys_order_id
		LEFT JOIN sec_user ON sec_user.loginname=administrative.created_by
		LEFT JOIN pho_admin_order_useraudit useraudit ON useraudit.admin_order_id = administrative.admin_order_id
		LEFT JOIN cp_sec_user_audit createuser ON createuser.cp_sec_user_audit_id = useraudit.created_by_audit_id
		LEFT JOIN cp_sec_user_audit confuser ON confuser.cp_sec_user_audit_id = useraudit.confirmed_by_audit_id
		LEFT JOIN dbo.contact AS physician_contact ON administrative.physician_id = physician_contact.contact_id
		LEFT JOIN staff ON staff.contact_id=physician_contact.contact_id
    LEFT JOIN #latestAdminOrderIds ON [#latestAdminOrderIds].phys_order_id=physorder.phys_order_id
	WHERE physorder.order_category_id=3030 AND (dbo.pho_related_order.deleted = 'N')

	SET @step=11;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Return the related drugs with severity';

	SELECT r.phys_order_id, poda.severity_code
	FROM #resultOTSD r
	INNER JOIN @physOrderRelatedDrugs poda ON poda.phys_order_id= r.phys_order_id

	SET @step=12;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Return client facilities';

	SELECT fac_id
		,name
		,dbo.fn_core_facTZToAbbr(time_zone) AS time_zone
	FROM facility WHERE fac_id IN(SELECT DISTINCT fac_id FROM #clientsOTSD)
	ORDER BY name;

	SET @step=13;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Return order schedules';

	IF @calledFrom = 1 -- From Mobile
	BEGIN
		SELECT DISTINCT
			cpo.phys_order_id
			,cpo.directions
			,vps.schedule_directions
			,cpo.supplementary_notes 'additional_directions'
			,vps.schedule_template
			,vps.end_date_type
			,vps.end_date_duration_type
			,vps.alternate_dose
			,vps.schedule_sliding_scale_id
			,CASE WHEN oss.order_schedule_id is not null  THEN 1 ELSE 0 END as custom_sliding_scale_exists
		FROM #resultOTSD r
		INNER JOIN view_pho_phys_order cpo  ON r.phys_order_id = cpo.phys_order_id
		LEFT JOIN view_pho_schedule vps ON cpo.order_schedule_id = vps.order_schedule_id
		LEFT OUTER JOIN dw_pho_order_schedule psd ON psd.order_schedule_id = vps.order_schedule_id
		LEFT JOIN pho_order_sliding_scale_range oss ON oss.order_schedule_id = vps.order_schedule_id
	END
	ELSE BEGIN
		SELECT DISTINCT
			cpo.phys_order_id
			,cpo.directions
			,vps.schedule_directions
			,cpo.supplementary_notes 'additional_directions'
			,vps.schedule_template
		FROM #resultOTSD r
			INNER JOIN view_pho_phys_order cpo  ON r.phys_order_id = cpo.phys_order_id
		LEFT JOIN view_pho_schedule vps ON cpo.order_schedule_id = vps.order_schedule_id
		LEFT OUTER JOIN dw_pho_order_schedule psd ON psd.order_schedule_id = vps.order_schedule_id
	END

	SET @step=14;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Return staff info';

    -- return whether the user id medical professional or not
    select * from @tblMedProfs;
	
	IF (@calledFrom = 1 AND @clientIds IS NOT NULL)
    BEGIN -- For the mobile call
		SET @step=15;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Return pharmacy info for discharged order';

		SELECT dop.phys_order_id, dop.ncpdp_identifier, dop.organization_name, dop.address, dop.city, dop.zip, dop.state, dop.phone, dop.epcs, dop.specialty_type_codes
		FROM #resultOTSD r
		INNER JOIN pho_phys_order_discharge_snapshot dop ON dop.phys_order_id= r.phys_order_id
		WHERE r.order_class_id = 2
	END
    

	DROP TABLE #unsignedOrderIds;
	DROP TABLE #clientsOTSD;
	DROP TABLE #resultOTSD;

	SET @step=14;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Done';
    SET @status_code = 0
    GOTO PgmSuccess
END TRY
--error trapping
BEGIN CATCH
    SELECT @status_code = @@error, @status_text = 'Error at step:'+convert(varchar(3),@step)+', '+ERROR_MESSAGE()

    GOTO PgmAbend

END CATCH

--program success return
PgmSuccess:

IF @status_code = 0
BEGIN
    IF @debug='Y' PRINT 'Successful execution of stored procedure'
    RETURN @status_code
END

--program failure return
PgmAbend:

IF @debug='Y' PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '   ' + convert(varchar(26),getdate())
    IF @debug='Y' PRINT 'Error code: '+convert(varchar(3),@status_code) + '; Error description:    ' +@status_text
    RETURN @status_code

GO
GRANT EXECUTE ON sproc_pho_list_ordersToSignDetailsEnhanced TO public
GO



GO

print 'C_Branch/04_StoredProcedures/sproc_pho_list_ordersToSignDetailsEnhanced.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_ordersToSignDetailsEnhanced.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_resident_queued_orders.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*****************************************************************************************************
**  Created By: hliu
**  Created Date: 2013-04-01
**
**	Purpose:  To return a list of Queued Physician Orders for specific client.
**
**	Params:
**			@facId
**			@clientId
**			@facilityDateTime
**          @standardUOMValues
**          @queuedOrderIds - CSV list of Queued Order IDs to return. If null, then all Queued Orders for client are returned.
**          @drugInteractionEnabled
**                          - If 'enable_drug_interaction' is enabled for facility in configuration_parameter, then 1, otherwise 0 
**			@debug          - Debug param, 'Y' or 'N'
**			@status_code    - SP execution flag, 0 for success.
**			@status_text    - SP error text if error occurs.
**
**
**  Revision History:
** 10/10/2017	CORE-49		Mustafa Behrainwala
** 12/12/10/2017	CORE-405 CORE-405 Remove Medispan tables joins.
*****************************************************************************************************/
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'[dbo].[sproc_pho_list_resident_queued_orders]') AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
    DROP PROCEDURE [dbo].[sproc_pho_list_resident_queued_orders]

SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[sproc_pho_list_resident_queued_orders]
	@facId                      INT, --required
	@clientId                   INT, --required
	@facilityDateTime           DATETIME, --required
	@standardUOMValues			xml, --required
	@queuedOrderIds             varchar(1000) = NULL, --optional
	@drugInteractionEnabled     bit, -- required
	@debug              char(1)  = 'N',
	@status_code        int  = 0 out,
	@status_text        varchar(3000) out
	--useful when debugging within sqlserver studio



/***********************************************************************************************

Purpose:
This procedure provides queued orders for the given resident

*************************************************************************************************/

AS
BEGIN TRY
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

DECLARE @step                       int,
        @error_code                 int,
        @facIdLocal					int,
		@clientIdLocal				int,
		@numOfQueuedOrderIds        int

set @clientIdLocal = @clientId
set @facIdLocal = @facId
SET @step = 0
SET @error_code = 0
set @numOfQueuedOrderIds = 0;

    declare @result table
    (
        phys_order_id int not null PRIMARY KEY
        ,status int
        ,relationship int
		,status_reason varchar(50)
        ,fac_id int NOT NULL
        ,client_id int NOT NULL
        ,diet_type int
        ,diet_texture int
        ,diet_supplement int
        ,fluid_consistency int
        ,alter_med_src int
        ,created_by varchar(60)
        ,created_by_longname varchar(100)
        ,created_date datetime
        ,date_ordered datetime
        ,calculated_description varchar(500)
        ,related_generic varchar(250)
        ,drug_name varchar(500)
        ,dispense_as_written varchar(1)
        ,directions varchar(1000)
        ,discontinued_date datetime
        ,end_date datetime
        ,hold_date datetime
        ,hold_date_end datetime
        ,last_reorder_date datetime
        ,order_type_id int
        ,order_category_id int
        ,order_category_description varchar(250)
        ,order_date datetime
        ,order_status int
        ,physician_id int
        ,reorder varchar(1)
        ,revision_by varchar(60)
        ,revision_date datetime
        ,edited_date datetime
        ,route_of_admin int
        ,start_date datetime
        ,order_verified varchar(1)
        ,next_refill_date datetime
        ,do_not_fill varchar(1)
        ,first_documented datetime
        ,origin_id int
        ,controlled_substance_code varchar(50)
        ,pharmacy_id int
        ,communication_method int
        ,legacy_order varchar(1)
        ,discharge_date datetime
        ,client_id_number varchar(35)
        ,floor_id int
        ,floor_description varchar(256)
        ,unit_id int
        ,unit_description varchar(35)
        ,resident_last_name varchar(50)
        ,resident_first_name varchar(50)
        ,orig_phys_order_id int
        ,pho_ext_lib_id int
        ,pho_ext_lib_med_id int
        ,pho_ext_lib_med_ddid int
        ,pho_ext_lib_generic_id varchar(14)
		,vendor_phys_order_id varchar(30)
		,advanced_directive varchar(1)
		, confirmed_by_audit_id int
       , ppone_phys_order_id int
		,description varchar(500)
		,queue_item_complete varchar(1)
		,queue_item_created_by varchar(60)
		,queue_item_created_by_longname varchar(100)
		,queue_item_created_date datetime
		,physician_first_name varchar(200)
		,physician_last_name varchar(200)
		,created_by_designation varchar(200)
		,physician_designation varchar(200)
		,linked_set_id int
		,linked_set_description varchar(100)
    )

   	declare @vpos table (
	[phys_order_id] [int] NOT NULL,
	[fac_id] [int] NOT NULL,
	[order_status] [int] NOT NULL,
	[order_relationship] [int] NULL,
	[status_reason] [varchar](50) NULL
	)



  CREATE TABLE #tempResult
  (
    phys_order_id int not NULL
    ,fac_id int NOT NULL
    ,client_id int NOT NULL
    ,ddid int
    ,order_supply_id int
    ,order_verified varchar(1)
    ,active_flag char(1)
    ,draft bit
    ,hold_date datetime
    ,hold_date_end datetime
    ,end_date datetime
    ,discontinued_date datetime
    ,order_category_id int
    ,controlled_substance_code int
  )

  	CREATE TABLE #orderStatusTable
  (
      [phys_order_id] [int] NOT NULL,
      [fac_id] [int] NOT NULL,
      [order_status] [int] NOT NULL,
      [order_relationship] [int] NULL,
      [status_reason] [varchar](50) NULL
  )

  declare @tpmStandardUOM table(
		uomId int,
		uomDescription varchar(100),
		uomType varchar(25)
	)

	declare @filterQueuedOrderIds table
  (
	phys_order_id int
  );
	
--Parse input param lists queuedOrderIds
	IF LEN(@queuedOrderIds) > 0 
	BEGIN
		INSERT INTO @filterQueuedOrderIds
			SELECT value FROM pcc__csvToTableOfInt(@queuedOrderIds);
		SET @numOfQueuedOrderIds = @@ROWCOUNT
		
		IF @debug='Y' BEGIN
			SELECT '@filterQueuedOrderIds', * FROM @filterQueuedOrderIds;
		END
	END


	insert into @tpmStandardUOM
	select uomId, uomDescription, uomType from fn_xmlToUOM(@standardUOMValues)

DECLARE @now datetime
set @now = dbo.fn_facility_getCurrentTime(@facIdLocal)

SET @step = 1
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Function call'
IF @debug='Y' PRINT @status_text

insert into @vpos
exec sproc_pho_getOrderStatus  @facIdLocal,@clientIdLocal,null,@now,'N',@debug,@status_code out,@status_text out



SET @step = 2
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert orders/client/mpi data.'
IF @debug='Y' PRINT @status_text

	CREATE TABLE #clients
	(
	    client_id int,
	    date_of_birth   datetime,
	    sex char,
	    bed_id int,
	    fac_id int,
	    discharge_date datetime,
		client_id_number varchar(35),
		floor_id	int,
		floor	varchar(256),
		unit_id		int,
		unit	varchar(35),
		first_name	varchar(50),
		last_name	varchar(50)
	)


	SET @step = 1.0
	SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert client data'
    IF @debug='Y'
    PRINT @status_text

  INSERT INTO #clients
  SELECT
    c.client_id
    , m.date_of_birth 'date_of_birth'
    , m.sex 'sex'
    , ci.bed_id 'bed_id'
    , c.fac_id
    , c.discharge_date
    , c.client_id_number
    , abv.floor_id
    , abvv.Floor
    , abv.unit_id
    , abvv.Unit
    , m.first_name
    , m.last_name



  FROM clients c
    INNER JOIN mpi m ON m.mpi_id = c.mpi_id
    LEFT JOIN census_item ci ON ci.census_id = c.current_census_id
    LEFT JOIN view_materialize_bed_room_unit_floor abv ON abv.bed_id = ci.bed_id
    LEFT JOIN all_beds_view abvv WITH (NOLOCK) ON abvv.bed_id = ci.bed_id
  WHERE c.client_id=@clientId



SET @step = 3
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Get common data for queries.'
IF @debug='Y' PRINT @status_text

IF(@drugInteractionEnabled = 1)
BEGIN

  INSERT INTO #tempResult
  SELECT
    DISTINCT ppo.phys_order_id , ppo.fac_id , ppo.client_id , medref.pho_ext_lib_med_ddid,null,
    ppo.order_verified,ppo.active_flag,ppo.draft,ppo.hold_date,ppo.hold_date_end,ppo.end_date,ppo.discontinued_date,ppo.order_category_id, ppo.controlled_substance_code
  FROM pho_phys_order ppo WITH (NOLOCK)
    INNER JOIN #clients c ON c.client_id= ppo.client_id
    INNER JOIN pho_order_ext_lib_med_ref medref ON medref.phys_order_id=ppo.phys_order_id AND pho_ext_lib_id=2 --only get medispan orders
    --LEFT JOIN pho_order_ext_lib_cls medrefcls ON medref.phys_order_ext_lib_rec_id=medrefcls.phys_order_ext_lib_rec_id
  WHERE
    ppo.fac_id = @facId AND  order_verified = 'Y' AND (isNULL(active_flag, 'Y') = 'Y')
    --AND (isNULL(active_flag, 'Y') = 'Y')
    AND order_category_id=3022 -- only pharmacy orders to be considered
    AND ppo.client_id=@clientId


	set @now = getdate()
	
  INSERT INTO #orderStatusTable
  EXEC sproc_pho_getOrderStatus  @facId,NULL,NULL,@now,'Y',@debug,@status_code out,@status_text out
END


insert into @result
select
	distinct ppo.phys_order_id
             ,vpos.order_status
             ,vpos.order_relationship
			 ,vpos.status_reason
             , ppo.fac_id
             , ppo.client_id
             , ppo.diet_type
             , ppo.diet_texture
             , ppo.diet_supplement
             , ppo.fluid_consistency
             , ppo.alter_med_src
             , ppo.created_by
             , createdBySu.long_username
             , ppo.created_date
             , ppo.date_ordered
			 , case when ppo.order_category_id=3031 then diettype.item_description
					     when ppo.order_category_id=3032 then dietsup.item_description
					     when ppo.order_category_id=3023 then diettype.item_description
					     when ppo.order_category_id=3033 then 'Enteral Feed'
					     else ppo.description
					end 'calculated_description'
			 , ppo.related_generic
             , ppo.drug_name
             , ppo.dispense_as_written
             , ppo.directions
             , ppo.discontinued_date
             , ppo.end_date
             , ppo.hold_date
             , ppo.hold_date_end
             , ppo.last_reorder_date
             , ppo.order_type_id
             , ppo.order_category_id
             , ordercat.category_desc
             , ppo.order_date
             , ppo.order_status
             , ppo.physician_id
             , ppo.reorder
             , ppo.revision_by
             , ppo.revision_date
             , CASE WHEN useraudit.edited_date is null THEN ppo.revision_date ELSE useraudit.edited_date END  'useraudit.edited_date'
             , ppo.route_of_admin
             , ppo.start_date
             , isnull(ppo.order_verified, 'Y') 'order_verified'
             , ppo.next_refill_date
             , ppo.do_not_fill
             , ppo.first_documented
             , ppo.origin_id
             , ppo.controlled_substance_code
             , ppo.pharmacy_id
             , ppo.communication_method
             , CASE WHEN ppone.phys_order_id is null THEN 'Y' ELSE 'N' END  'ppone.phys_order_id'
             , c.discharge_date
             , c.client_id_number
             , c.floor_id
             , c.Floor
             , c.unit_id
             , c.Unit
             , c.last_name
             , c.first_name
             , ppo.orig_phys_order_id
             , lib.pho_ext_lib_id
             , lib.pho_ext_lib_med_id
             , lib.pho_ext_lib_med_ddid
             , lib.pho_ext_lib_generic_id
             , ppo.vendor_phys_order_id
			 , isnull(pstd.advanced_directive, 'N') 'advanced_directive'
			, confirmed_by_audit_id
			, ppone.phys_order_id
			,ppo.description
			,poq.complete
			,poq.created_by AS 'queue_item_created_by'
			,queuedBySu.long_username AS 'queue_item_created_by_longname'
			,poq.created_date
			,cont.first_name
            ,cont.last_name
            , createuser.designation_desc AS created_by_designation
            , staff.designation AS physician_designation
			, lsi.linked_set_id as linked_set_id
			, ls.set_description as linked_set_description
from
	#clients c
	INNER JOIN pho_order_queue poq WITH (NOLOCK)
		ON c.client_id = poq.client_id
	INNER JOIN pho_phys_order ppo WITH (NOLOCK)
		ON poq.phys_order_id = ppo.phys_order_id
	INNER JOIN @vpos vpos
		ON vpos.phys_order_id = ppo.phys_order_id
	LEFT JOIN pho_phys_order_new_entry ppone WITH (NOLOCK)
		ON ppone.phys_order_id = ppo.phys_order_id
	LEFT JOIN pho_order_ext_lib_med_ref lib WITH (NOLOCK)
		ON lib.phys_order_id = ppo.phys_order_id

	LEFT JOIN contact cont WITH (NOLOCK)
        ON cont.contact_id = ppo.physician_id

    LEFT JOIN staff staff WITH (NOLOCK)
        ON staff.contact_id = cont.contact_id and (staff.fac_id = ppo.fac_id or staff.fac_id=-1)


	LEFT JOIN pho_std_phys_order pstd WITH (NOLOCK)
		ON pstd.std_phys_order_id = ppo.std_order_id


	LEFT JOIN pho_phys_order_useraudit useraudit WITH (NOLOCK)
		ON useraudit.phys_order_id = ppo.phys_order_id

    LEFT JOIN cp_sec_user_audit createuser
      ON createuser.cp_sec_user_audit_id = useraudit.created_by_audit_id
    LEFT JOIN cp_sec_user_audit edituser
      ON edituser.cp_sec_user_audit_id = useraudit.edited_by_audit_id


	LEFT JOIN PHO_ORDER_CATEGORY ordercat WITH (NOLOCK)
     	ON ppo.order_category_id = ordercat.order_category_id
    LEFT JOIN sec_user createdBySu  WITH (NOLOCK)
     	ON createdBySu.loginname = ppo.created_by
	LEFT JOIN sec_user queuedBySu WITH (NOLOCK)
	    ON queuedBySu.loginname = poq.created_by
	LEFT JOIN COMMON_CODE diettype WITH (NOLOCK)
		ON ppo.diet_type = diettype.item_id
    LEFT JOIN COMMON_CODE dietsup WITH (NOLOCK)
		ON ppo.diet_supplement = dietsup.item_id
	LEFT JOIN pho_linked_set_item lsi
		ON lsi.phys_order_id = poq.phys_order_id
	LEFT JOIN pho_linked_set ls
		ON ls.linked_set_id = lsi.linked_set_id
	LEFT JOIN @filterQueuedOrderIds qo
		ON qo.phys_order_id = ppo.phys_order_id
where poq.promoted_date is null and poq.deleted <> 'Y'
and (@numOfQueuedOrderIds = 0 OR qo.phys_order_id IS NOT NULL)
order by poq.created_date


SET @step = 4

    /****************************************
    return final result
    ****************************************/
    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Return orders'
    IF @debug='Y' PRINT @status_text

    SELECT r.*
         , ordercat.category_desc AS order_category_description
         , dietsup.item_description AS diet_supplement_description
         , diettexture.item_description AS diet_texture_description
         , diettype.item_description AS diet_type_description
         , fluidcon.item_description AS fluid_consistency_description
         , route.item_description AS route_description
         , oq.quantity as prescription_quantity
         , oq.unit_of_measure as prescription_quantity_uom
         , oq.no_of_refills as prescription_no_of_refills
         , oq.dispense_interval as prescription_dispense_interval
         , oq.total_authorized_quantity as prescription_total_authorized_quantity
         
        FROM
            @result r
        LEFT JOIN PHO_ORDER_TYPE ordertype
            ON r.order_type_id = ordertype.order_type_id
        LEFT JOIN PHO_ORDER_CATEGORY ordercat
            ON ordertype.order_category_id = ordercat.order_category_id
        LEFT JOIN COMMON_CODE diettype
            ON r.diet_type = diettype.item_id
        LEFT JOIN COMMON_CODE diettexture
            ON r.diet_texture = diettexture.item_id
        LEFT JOIN COMMON_CODE [route]
            ON r.route_of_admin = route.item_id
        LEFT JOIN COMMON_CODE dietsup
            ON r.diet_supplement = dietsup.item_id
        LEFT JOIN COMMON_CODE fluidcon
            ON r.fluid_consistency = fluidcon.item_id
        LEFT JOIN pho_phys_order_quantity_info oq on oq.phys_order_id=r.phys_order_id


/**
may have to revisit column selection
**/
SET @step = 5
    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Return Schedules'
    IF @debug='Y' PRINT @status_text

    SELECT
        cpo.phys_order_id, vps.order_schedule_id, cpo.start_date, cpo.end_date, cpo.end_date_type, cpo.end_date_duration_type,
        cpo.end_date_duration, cpo.diagnoses, cpo.reassessment_required, cpo.directions,  vps.schedule_directions, cpo.supplementary_notes 'additional_directions', cpo.indications_for_use, vps.schedule_template
    FROM view_pho_phys_order cpo
    INNER JOIN view_pho_schedule vps
        ON cpo.order_schedule_id = vps.order_schedule_id
    INNER JOIN @result r
        ON r.phys_order_id = vps.phys_order_id

    GROUP BY
        cpo.phys_order_id, vps.order_schedule_id, cpo.start_date, cpo.end_date, cpo.end_date_type, cpo.end_date_duration_type,
        cpo.end_date_duration, cpo.diagnoses, cpo.reassessment_required, cpo.directions,  vps.schedule_directions, cpo.supplementary_notes, cpo.indications_for_use, vps.schedule_template


SET @step = 6
    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Return Drug Protocol Interaction'
    IF @debug='Y' PRINT @status_text

    SELECT podpa.phys_order_id, podpa.interaction_type, podpa.max_dose
    FROM pho_order_queue_drug_protocol_action podpa
    INNER JOIN @result r
        ON r.phys_order_id = podpa.phys_order_id

SET @step = 7
    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Return Unit Of Measure for Display'
    IF @debug='Y' PRINT @status_text

 	SELECT r.phys_order_id, uom.uomDescription 'dose_check_unit'
 	FROM pho_order_schedule pos
 	INNER JOIN @result r
        ON r.phys_order_id = pos.phys_order_id
	LEFT JOIN @tpmStandardUOM uom on (pos.quantity_uom_id=uom.uomId and pos.dose_uom_id is null) or (pos.quantity_uom_id is null and pos.dose_uom_id=uom.uomId)

	DROP table #tempResult
	DROP TABLE #orderStatusTable
	DROP TABLE #clients

    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Done'
    IF @debug='Y' PRINT @status_text

    SET @status_code = 0
    GOTO PgmSuccess
END TRY



--error trapping
BEGIN CATCH
    SELECT @error_code = @@error, @status_text = 'Error at step:'+convert(varchar(3),@step)+', '+ERROR_MESSAGE()

    SET @status_code = 1

    GOTO PgmAbend

END CATCH

--program success return
PgmSuccess:

IF @status_code = 0
BEGIN
    IF @debug='Y' PRINT 'Successfull execution of stored procedure'
    RETURN @status_code
END

--program failure return
PgmAbend:

IF @debug='Y' PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '   ' + convert(varchar(26),getdate())
    IF @debug='Y' PRINT 'Error code: '+convert(varchar(3),@error_code) + '; Error description:    ' +@status_text
    RETURN @status_code

GO

GRANT EXECUTE ON sproc_pho_list_resident_queued_orders TO public
GO

SET ANSI_NULLS OFF
SET QUOTED_IDENTIFIER OFF

GO

print 'C_Branch/04_StoredProcedures/sproc_pho_list_resident_queued_orders.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_resident_queued_orders.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_residentchart.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*****************************************************************************************************
** ---------------
**  Deprecated
** ---------------
**  Created By:
**  Created Date:
**
**	Purpose:  To return a list of Physician Orders.
**
**	Params:
**			@facId
**			@clientId
**			@facilityDateTime
**			@orderCategoryIdsCSV
**			@orderStatusCSV
**			@startDateoperator
**			@startDate
***			@endDateoperator
**			@endDate
**			@orderDateoperator
**			@orderDate
**			@createdBy
**			@orderedById
**			@orderTypeId
**			@adminRecordId
**			@routeOfAdminIdsCSV
**			@communicationMethodIdsCSV
**			@medicationSourceId
**			@pharmacyId
**			@providerId
**			@showLegacyOrder
**			@clientIdNumber
**			@clientStatus
**			@unit
**			@floor
**			@completedDate
**			@completedDateoperator
**			@discontinuedDate
**			@discontinuedDateoperator
**			@confirmedDate datetime,
**			@confirmedDateoperator
**			@confirmedBy
**			@medication
**			@medicationclassification
**			@holdDate
**			@holdDateoperator
**			@supplyStatusId
**			@fromIntegratedPharmacy
**			@medSrcTypeId
**			@physOrderId
**			@narcoticsOnly     - Narcotics order or not, 'Y' or 'N'
**          @alwaysShowOrderWithAlert
**			@orderLinkedOption	- (1) None, (2) Only, (3) Both
**			@orderClassId	- smallint (-1) All (1) Institutional order, (2) Discharge order
**			@includeRetired	- Show deleted physicians or not , 'Y' or 'N' 
**			@includeSlidingScale - show sliding scale information or not, 'Y' or 'N'. Defaulted to 'N'.
**			@historicalOrdersOnly - get historical orders only or not, 'Y' or 'N'. Defaulted to 'N'
**			@historicalOrdersOnlyPeriodStart - start of period to get historical orders for, if null get all historical orders
**			@debug          - Debug param, 'Y' or 'N'
**			@status_code    - SP execution flag, 0 for success.
**			@status_text    - SP error text if error occurs.
**
**  Special Instructions:  Run view_pho_order stsus first before running this
**	sproc during the build process.
**
**  Revision History:
**  2012-09-06        PCC-32548   Feng  Xia      added a new search criteria for showing only narcotics drugs
**  2012-04-03        PCC-29069   Nabil Hamade   changed order by from revision_date to edited_date for orders list
**  2016-04-04        PCC-92113   Ramin Shojaei Add condition to include deleted (retired) physician in the result set
**  2016-11-17 		  PCC-105022  Veerpal Khanuja	Added schedule_sliding_scale_id and flag custom_sliding_scale_exists in result set for schedules.
**  2016-11-17 		  PCC-105019  Veerpal Khanuja	Added alternate_dose in result set for schedules.
**	2017-01-23		  PCC-107915  Devika Bapat		Added apply_remove_flag in result set for schedules.
**	2017-03-08		  PCC-110558  Devika Bapat		Added date_start, date_stop, dose_uom_id, dose, indications_for_use, 
													quantity_uom_id, prn_admin, prn_admin_units, prn_admin_value, for schedules. 
**	2017-04-06		  PCC-113549  Devika Bapat		Added apply_to in result set for schedules.
**	2017-11-08		  CORE-5680   Elias Ghanem		Added condition to select historical orders only based on the historicalOrdersOnly and historicalOrdersOnlyPeriodStart parameters.
**  2018-01-03		  CORE-7999   Hao Liu           Added support to filter by old medical professional id if new id provided
**  2018-12-18		  CORE-24715  Samuel Martey     Changed the return block to return the schedules for struck-out orders as well to build directions from them.
**  2019-01-02		  CORE-24715  Samuel Martey     Optimize cases for selecting struck-out orders. Do not select when not requested in the union query
**  2019-03-11		  CORE-35559  Henry Jin			Added join to the table cr_alert_triggered_item_type_category when fecthing alerts.  
**  2019-07-17		  CORE-46275  Elias Ghanem		Return alerts of type 'O' or 'M' instead of only 'O'. Also modify the sorting of the returned result set to be
**													ASC instead of DESC. The sorting modification will not affect the final result displayed to the user since the Java code
**													handling the result set has been modified accordingly.  
**  2019-08-01		  CORE-43789  Elias Ghanem		Add configuration parameters to return orders having alerts of type M or having supplies with alerts of type D regardless of their status
**  2020/09/03 		  CORE-71858  Elias Ghanem 		When computing if order has Allergy, D2D or blackBox alerts, include alerts for supplies even even if the supplies are in Processed By Pharmacy status (3) not only if 
**													they are On Hand
**	2021-01-22  	  CORE-83505  Elias Ghanem      Add revision_date field to the schedules result set
**  2021-11-18 		  CORE-97119  Sree Naghasundharam  This Stored Procedure 'sproc_pho_list_residentchart' is herebry deprecated(CORE-97119).
**														New stored procedure 'sproc_pho_list_residentchart_v2' created to remove 'mmdb' references.
**														Any further changes to 'sproc_pho_list_residentchart' should also be made in the new stored procedure.
******************************************************************************************************************************************************/
IF EXISTS (SELECT *
               FROM
                   dbo.sysobjects
               WHERE
                   id = object_id(N'[dbo].[sproc_pho_list_residentchart]')
                   AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
    DROP PROCEDURE [dbo].[sproc_pho_list_residentchart]

SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[sproc_pho_list_residentchart]   @facId                        INT, --required
                                                        @clientId                     INT, --required
                                                        @facilityDateTime             DATETIME, --required
                                                        @orderCategoryIdsCSV          varchar(100), -- required comma seperated list of categegory id
                                                        @orderStatusCSV               varchar(100),
                                                        @startDateoperator            INT = 0, --0 equal to, -1 less than, 1 greater than
                                                        @startDate                    DATETIME, -- date to compare,
                                                        @endDateoperator              INT = 0, --0 equal to, -1 less than, 1 greater than
                									    @endDate                      DATETIME, -- date to compare,
                                                        @orderDateoperator            INT = 0, --0 equal to, -1 less than, 1 greater than
                                                        @orderDate                    DATETIME, -- date to compare,
                                                        @createdBy                    varchar(60),
                                                        @orderedById int,
                                                        @orderTypeId int,
                                                        @adminRecordId int,
                                                        @routeOfAdminIdsCSV varchar(50),
                                                        @communicationMethodIdsCSV varchar(50), -- required comma seperated list of communication method id
                                                        @medicationSourceId int,
                                                        @pharmacyId int,
                                                        @providerId int,
                                                        @showLegacyOrder char(1), -- Null both , Y - show only legacy order, N - show only new orders
                                                        @clientIdNumber varchar(100),
                                                        @clientStatus int,
                                                        @unit int,
                                                        @floor int,
                                                        @completedDate datetime,
                                                        @completedDateoperator int = 0, --0 equal to, -1 less than, 1 greater than
                                                        @discontinuedDate datetime,
                                                        @discontinuedDateoperator int = 0, --0 equal to, -1 less than, 1 greater than
                                                        @confirmedDate datetime,
                                                        @confirmedDateoperator int = 0, --0 equal to, -1 less than, 1 greater than
                                                        @confirmedBy varchar(100),
                                                        @medication varchar(200),
                                                        @medicationclassification varchar(200),
                                                        @holdDate datetime,
                                                        @holdDateoperator int = 0, --0 equal to, -1 less than, 1 greater than
                                                        @supplyStatusId     int,
                                                        @fromIntegratedPharmacy char(1),
                                                        @medSrcTypeId       int,
                                                        @physOrderId int,
                                                        @pageSize int,
                                                        @pageNumber int,
                                                        @sortByColumn varchar(100),
                                                        @sortByOrder  varchar(10),
                                                        @narcoticsOnly     char(1)  = 'N',
                                                        @alwaysShowOrderWithAlert char(1) = 'N',
														@orderLinkedOption	int,
														@orderClassId		smallint, -- required
														@pharmacyNCPDP varchar(10),
														@includeRetired char(1) = 'Y',
														@includeSlidingScale char(1)='N',
														@historicalOrdersOnly char(1) = 'N',
														@historicalOrdersOnlyPeriodStart datetime,
														@debug              char(1)  = 'N',
														@status_code        int  = 0 out,
                                                        @status_text        varchar(3000) out
                                                          --useful when debugging within sqlserver studio



/***********************************************************************************************

Purpose:
This procedure provides data shown on Resident' Order Chart
This procedure does not use VIEW_PHO_PHYS_ORDER

*************************************************************************************************/

AS
BEGIN TRY
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

DECLARE @step                       			int,
        @error_code                 			int,
        @num_records							int,
		@facIdLocal								int,
		@clientIdLocal							int,
		@drugAllergyCheckEnabled    			char,
		@drugInteractionEnabled					char,
		@doseCheckEnabled						char,
        @blackBoxEnabled						char,
		@orderClassId_local         			smallint,
		@pharmacyNCPDP_local					varchar(10),
		@oldOrderById							int,
		@includeStruckOutOrders					char,
		@showOrdersWithIntegrationAlerts 		varchar(1),
		@showOrdersWithSupplyIntegrationAlerts 	varchar(1)

set @clientIdLocal = @clientId
set @facIdLocal = @facId
SET @step = 0
SET @error_code = 0
SET @orderClassId_local = @orderClassId
SET @pharmacyNCPDP_local = @pharmacyNCPDP
SET @showOrdersWithIntegrationAlerts = 'Y'
SET @showOrdersWithSupplyIntegrationAlerts = 'Y'

SELECT @drugAllergyCheckEnabled=ISNULL(value,'N') FROM configuration_parameter WHERE name='enable_drug_allergy_check' AND value='Y' AND fac_id=@facId
SELECT @drugInteractionEnabled=ISNULL(value,'N') FROM configuration_parameter WHERE name='enable_drug_interaction' AND value='Y' AND fac_id=@facId
SELECT @doseCheckEnabled=ISNULL(value,'N') FROM configuration_parameter WHERE name='enable_dose_check' AND value='Y' AND fac_id=@facId
SELECT @blackBoxEnabled=ISNULL(value,'N') FROM configuration_parameter WHERE name='enable_black_box' AND value='Y' AND fac_id=@facId
SELECT @showOrdersWithIntegrationAlerts=ISNULL(value,'Y') FROM configuration_parameter WHERE name='show_orders_with_integration_alerts' AND value='N' AND fac_id=@facId
SELECT @showOrdersWithSupplyIntegrationAlerts=ISNULL(value,'Y') FROM configuration_parameter WHERE name='show_orders_with_supply_integration_alerts' AND value='N' AND fac_id=@facId

SET @oldOrderById = dbo.fn_medprof_getOldMedicalProfessionalId(@orderedById, @facId)

    DECLARE @result TABLE
	--create table #result
    (

        phys_order_id int not null PRIMARY KEY
        ,status int
        ,relationship int
        ,status_reason int
        ,fac_id int NOT NULL
        ,client_id int NOT NULL
        ,diet_type int
        ,diet_texture int
        ,diet_supplement int
        ,fluid_consistency int
        ,alter_med_src int
        ,nurse_pharm_notes varchar(512)
        ,created_by varchar(60)
        ,created_by_longname varchar(100)
        ,created_date datetime
        ,date_ordered datetime
        ,description varchar(500)
        ,related_generic varchar(250)
        ,dispense_as_written varchar(1)
        ,directions varchar(1000)
		,strength varchar(30)
        ,drug_strength varchar(100)
        ,drug_strength_uom varchar(10)
        ,discontinued_date datetime
        ,end_date datetime
        ,hold_date datetime
        ,hold_date_end datetime
        ,last_reorder_date datetime
        ,order_type_id int
        ,order_category_id int
        ,order_category_description varchar(250)
        ,family_portal_sort_order tinyint
        ,order_date datetime
        ,order_status int
        ,physician_id int
        ,reorder varchar(1)
        ,revision_by varchar(60)
        ,revision_date datetime
        ,edited_date datetime
        ,route_of_admin int
        ,start_date datetime
        ,order_verified varchar(1)
        ,next_refill_date datetime
        ,do_not_fill varchar(1)
        ,first_documented datetime
        ,origin_id int
        ,controlled_substance_code varchar(50)
        ,pharmacy_id int
        ,communication_method int
        ,legacy_order varchar(1)
        ,discharge_date datetime
        ,client_id_number varchar(35)
        ,resident_last_name varchar(50)
        ,resident_first_name varchar(50)
        ,orig_phys_order_id int
        ,pho_ext_lib_id int
        ,pho_ext_lib_med_id int
        ,pho_ext_lib_med_ddid int
        ,ext_lib_rxnorm_id varchar(10)
        ,strikeout_date datetime
        ,strikeout_by varchar(60)
		,strikeout_reason_code varchar(254)
		,vendor_phys_order_id varchar(30)
		,advanced_directive varchar(1)
		,end_date_filter datetime
		,linked_set_id int
		,linked_set_name varchar(100)
		,order_class_id tinyint
    )

	declare @orderData table
    (
        phys_order_id int not null PRIMARY KEY
        ,status int
        ,relationship int
        ,status_reason int
        ,fac_id int NOT NULL
        ,client_id int NOT NULL
        ,diet_type int
        ,diet_texture int
        ,diet_supplement int
        ,fluid_consistency int
        ,alter_med_src int
        ,nurse_pharm_notes varchar(512)
        ,created_by varchar(60)
        ,created_by_longname varchar(100)
        ,created_date datetime
        ,date_ordered datetime
        ,calculated_description varchar(500)
        ,related_generic varchar(250)
        ,dispense_as_written varchar(1)
        ,directions varchar(1000)
		,strength varchar(30)
        ,drug_strength varchar(100)
        ,drug_strength_uom varchar(10)
        ,discontinued_date datetime
        ,end_date datetime
        ,hold_date datetime
        ,hold_date_end datetime
        ,last_reorder_date datetime
        ,order_type_id int
        ,order_category_id int
        ,order_category_description varchar(250)
        ,family_portal_sort_order tinyint
        ,order_date datetime
        ,order_status int
        ,physician_id int
        ,reorder varchar(1)
        ,revision_by varchar(60)
        ,revision_date datetime
        ,edited_date datetime
        ,route_of_admin int
        ,start_date datetime
        ,order_verified varchar(1)
        ,next_refill_date datetime
        ,do_not_fill varchar(1)
        ,first_documented datetime
        ,origin_id int
        ,controlled_substance_code varchar(50)
        ,pharmacy_id int
        ,communication_method int
        ,legacy_order varchar(1)
        ,discharge_date datetime
        ,client_id_number varchar(35)
        ,resident_last_name varchar(50)
        ,resident_first_name varchar(50)
        ,orig_phys_order_id int
        ,pho_ext_lib_id int
        ,pho_ext_lib_med_id int
        ,pho_ext_lib_med_ddid int
        ,ext_lib_rxnorm_id varchar(10)
		,vendor_phys_order_id varchar(30)
		,advanced_directive varchar(1)
		, confirmed_by_audit_id int
       , ppone_phys_order_id int
		,description varchar(500)
		,linked_set_id int
		,linked_set_name varchar(100)
		,order_class_id tinyint
    )

   	declare @vpos table (
	[phys_order_id] [int] NOT NULL,
	[fac_id] [int] NOT NULL,
	[order_status] [int] NOT NULL,
	[order_relationship] [int] NULL,
	[status_reason] int NULL
	)

    DECLARE @routeOfAdminIds TABLE
    (
        route_of_admin int  not null
    )

    DECLARE @orderCategoryIds TABLE
    (
        order_category_id int  not null
    )

    DECLARE @communicationMethodIds TABLE
    (
        method_id int  not null
    )

    DECLARE @orderStatus TABLE
    (
        [status] int  not null
    )

    DECLARE @integratedPharmacies TABLE
    (
        pharmacy_id int not null
    )

    DECLARE @supplyCriteria TABLE
    (
        phys_order_id int not null
    )

	  DECLARE @medicationClassificationIds TABLE
    (
        medication_classification_id varchar(10) not null
    )

    DECLARE @physOrderAllergies TABLE
    (
      phys_order_id int  NOT NULL
    )

    DECLARE @physOrderDrugInteraction TABLE
    (
      phys_order_id int  NOT NULL,
      severity_code varchar(1)
    )

    DECLARE @physOrderBlackbox TABLE
    (
      phys_order_id int  NOT NULL
    )

    DECLARE @physOrderDoseCheck TABLE
    (
      phys_order_id int  NOT NULL,
      over_dose varchar(1)
    )

    DECLARE @physOrderNoDrugProtocolCheck TABLE
    (
      phys_order_id int  NOT NULL
    )

	DECLARE @dischargePharmacyNCPDP TABLE
    (
        discharge_pharm_phys_order_id int not null
    )

	DECLARE @ordersHavingAlerts TABLE
	(
		phys_order_id int  NOT NULL
	)

SET @step = 1
    INSERT INTO @orderCategoryIds (order_category_id)
    select * from dbo.Split(@orderCategoryIdsCSV, ',')
	delete from @orderCategoryIds where order_category_id=1 or order_category_id=3030
SET @step = 2
    INSERT INTO @communicationMethodIds (method_id)
    select * from dbo.Split(@communicationMethodIdsCSV, ',')
SET @step = 3
    INSERT INTO @routeOfAdminIds (route_of_admin)
    select * from dbo.Split(replace(@routeOfAdminIdsCSV,'_',','), ',')
SET @step = 4
    INSERT INTO @orderStatus (status)
    select * from dbo.Split(@orderStatusCSV, ',');
	SET @includeStruckOutOrders = CASE WHEN EXISTS (SELECT os.status FROM @orderStatus os WHERE status = 4) THEN 'Y' ELSE 'N' END;
SET @step = 5
    INSERT INTO @medicationClassificationIds (medication_classification_id)
    select * from dbo.Split(@medicationclassification, ',')

SET @step = 41
	INSERT INTO @integratedPharmacies (pharmacy_id)
	select distinct extFacId from (
		SELECT mp.ext_fac_id as extFacId
			FROM message_profile mp WITH (NOLOCK)
			INNER JOIN lib_message_profile lmp WITH (NOLOCK)
				ON lmp.message_profile_id = mp.message_profile_id
			       AND lmp.deleted = 'N' and lmp.is_enabled='Y'
			WHERE mp.is_enabled = 'Y' and mp.is_integrated_pharmacy='Y'
			AND mp.fac_id = @facIdLocal
			AND mp.message_protocol_id = 12
			GROUP BY mp.ext_fac_id
		UNION
		SELECT distinct mi.internal_id as extFacId
			FROM map_identifier mi WITH (NOLOCK)
			INNER JOIN lib_message_profile libmp WITH (NOLOCK)
			ON libmp.vendor_code = mi.vendor_code
			AND libmp.deleted = 'N'
			INNER JOIN message_profile mp WITH (NOLOCK)
			ON libmp.message_profile_id = mp.message_profile_id
			WHERE mi.map_type_id = 3 and mp.fac_id = @facIdLocal and  mi.fac_id = @facIdLocal
	) a where extFacId is not null

-- put all criteria related to pho_order_supply in here so that we
-- can make sure they interact correctly and we don't need a hundred
-- different subqueries in the main query, also only populate it if
-- we're going to need it
SET @step = 42
    IF @supplyStatusId IS NOT NULL
          OR @fromIntegratedPharmacy IS NOT NULL
          OR @medSrcTypeId IS NOT NULL
    BEGIN
      INSERT INTO @supplyCriteria (phys_order_id)
        SELECT phys_order_id
          FROM pho_order_supply WITH (NOLOCK)
          WHERE (active = 'Y' OR active = 'N')
            AND deleted = 'N'
            AND (@supplyStatusId IS NULL OR status = @supplyStatusId)
            AND (
              @fromIntegratedPharmacy IS NULL
              OR (
                @fromIntegratedPharmacy = 'Y'
                AND pharmacy_id IN (select * from @integratedPharmacies)
              )
              OR (
                @fromIntegratedPharmacy = 'N'
                AND pharmacy_id NOT IN (select * from @integratedPharmacies)
              )
            )
            AND (@medSrcTypeId IS NULL OR med_src_type_id = @medSrcTypeId)
    END

set @step = 43
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Function call'
IF @debug='Y'
PRINT @status_text

DECLARE @now datetime
set @now = dbo.fn_facility_getCurrentTime(@facIdLocal)

insert into @vpos
exec sproc_pho_getOrderStatus  @facIdLocal,@clientIdLocal,@physOrderId,@now,'N',@debug,@status_code out,@status_text out

SET @step = 5
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Start getting med classification'
IF @debug='Y'
    PRINT @status_text


	declare @medicationclassificationTable table
	(
		phys_order_id	int
	)

	if( @medicationclassification is not null )
	BEGIN
		insert into @medicationclassificationTable
		SELECT distinct poelmr.phys_order_id from pho_order_ext_lib_med_ref poelmr WITH (NOLOCK) INNER JOIN
		(
			SELECT poelc.phys_order_ext_lib_rec_id, pho_ext_lib_class_id 'class_id' from pho_order_ext_lib_cls poelc WITH (NOLOCK)
			UNION
			SELECT poelc.phys_order_ext_lib_rec_id, pho_ext_lib_sub_class_id 'class_id' from pho_order_ext_lib_cls poelc WITH (NOLOCK)
		) classes ON classes.phys_order_ext_lib_rec_id = poelmr.phys_order_ext_lib_rec_id
		INNER JOIN @medicationClassificationIds mclassids on classes.class_id = mclassids.medication_classification_id
    INNER JOIN @vpos vpos on vpos.phys_order_id = poelmr.phys_order_id
	END


SET @step = 5
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert orders/client/mpi data.'
IF @debug='Y'
    PRINT @status_text

declare @clientInfo table
(
	fac_id int,
	client_id int,
	discharge_date datetime,
	client_id_number varchar(35),
	first_name	varchar(50),
	last_name	varchar(50)
)
insert into @clientInfo ( 	fac_id , client_id , discharge_date , client_id_number,first_name, last_name )
select distinct
	c.fac_id,
	c.client_id,
	 c.discharge_date
     , c.client_id_number
     , m.last_name
     , m.first_name
from
	clients c
	INNER JOIN mpi  m  WITH (NOLOCK) ON m.mpi_id = c.mpi_id
where
c.client_id = @clientIdLocal




SET @step = 5
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Get common data for queries.'
IF @debug='Y'
    PRINT @status_text

IF(@orderClassId_local > -1)
BEGIN
	insert into @orderData
	select
		distinct ppo.phys_order_id
				 ,vpos.order_status
				 ,vpos.order_relationship
				 ,vpos.status_reason
				 , ppo.fac_id
				 , ppo.client_id
				 , ppo.diet_type
				 , ppo.diet_texture
				 , ppo.diet_supplement
				 , ppo.fluid_consistency
				 , ppo.alter_med_src
				 , ppo.nurse_pharm_notes
				 , ppo.created_by
				 , createdBySu.long_username
				 , ppo.created_date
				 , ppo.date_ordered
				 , case when ppo.order_category_id=3031 then diettype.item_description
							 when ppo.order_category_id=3032 then dietsup.item_description
							 when ppo.order_category_id=3023 then diettype.item_description
							 when ppo.order_category_id=3033 then 'Enteral Feed'
							 else ppo.description
						end 'calculated_description'
				 , ppo.related_generic
				 , ppo.dispense_as_written
				 , ppo.directions
				 , ppo.strength
				 , ppo.drug_strength
				 , ppo.drug_strength_uom
				 , ppo.discontinued_date
				 , ppo.end_date
				 , ppo.hold_date
				 , ppo.hold_date_end
				 , ppo.last_reorder_date
				 , ppo.order_type_id
				 , ppo.order_category_id
				 , ordercat.category_desc
				 , ordercat.family_portal_sort_order
				 , ppo.order_date
				 , ppo.order_status
				 , ppo.physician_id
				 , ppo.reorder
				 , ppo.revision_by
				 , ppo.revision_date
				 , CASE WHEN useraudit.edited_date is null THEN ppo.revision_date ELSE useraudit.edited_date END  'useraudit.edited_date'
				 , ppo.route_of_admin
				 , ppo.start_date
				 , isnull(ppo.order_verified, 'Y') 'order_verified'
				 , ppo.next_refill_date
				 , ppo.do_not_fill
				 , ppo.first_documented
				 , ppo.origin_id
				 , ppo.controlled_substance_code
				 , ppo.pharmacy_id
				 , ppo.communication_method
				 , CASE WHEN ppone.phys_order_id is null THEN 'Y' ELSE 'N' END  'ppone.phys_order_id'
				 , c.discharge_date
				 , c.client_id_number
				 , c.last_name
				 , c.first_name
				 , ppo.orig_phys_order_id
				 , lib.pho_ext_lib_id
				 , lib.pho_ext_lib_med_id
				 , lib.pho_ext_lib_med_ddid
				 , lib.ext_lib_rxnorm_id
				 , ppo.vendor_phys_order_id
				 , case
					when pso.std_order_id is not null and (pso.advanced_directive=1) then 'Y'
					when pstd.std_phys_order_id is not null and (pstd.advanced_directive='Y') then 'Y'
					else 'N'
				  end as 'advanced_directive'
				, confirmed_by_audit_id
				, ppone.phys_order_id
				, ppo.description
				, ls.linked_set_id
				, ls.set_description
				, ppo.order_class_id
	from
		@clientInfo c
		INNER JOIN pho_phys_order ppo WITH (NOLOCK)
			ON c.client_id = ppo.client_id
		INNER JOIN @vpos vpos
			ON vpos.phys_order_id = ppo.phys_order_id
		LEFT JOIN pho_phys_order_new_entry ppone WITH (NOLOCK)
			ON ppone.phys_order_id = ppo.phys_order_id
		LEFT JOIN pho_order_ext_lib_med_ref lib WITH (NOLOCK)
			ON lib.phys_order_id = ppo.phys_order_id AND lib.deleted='N'
		LEFT JOIN pho_std_phys_order pstd WITH (NOLOCK)
			ON pstd.std_phys_order_id = ppo.std_order_id
		LEFT JOIN pho_std_order pso WITH (NOLOCK)
			ON pso.std_order_id = ppo.std_order_id
		LEFT JOIN pho_phys_order_useraudit useraudit WITH (NOLOCK)
			ON useraudit.phys_order_id = ppo.phys_order_id
		LEFT JOIN PHO_ORDER_CATEGORY ordercat WITH (NOLOCK)
     		ON ppo.order_category_id = ordercat.order_category_id
		LEFT JOIN sec_user createdBySu  WITH (NOLOCK)
     		ON createdBySu.loginname = ppo.created_by
		LEFT JOIN COMMON_CODE diettype WITH (NOLOCK)
			ON ppo.diet_type = diettype.item_id
		LEFT JOIN COMMON_CODE dietsup WITH (NOLOCK)
			ON ppo.diet_supplement = dietsup.item_id
		LEFT JOIN pho_linked_set_item lsi on lsi.phys_order_id=ppo.phys_order_id
		LEFT JOIN pho_linked_set ls on ls.linked_set_id=lsi.linked_set_id

	where
		( @physOrderId IS NULL OR ppo.phys_order_id = @physOrderId  )
		AND (isnull(ppo.active_flag, 'Y') = 'Y')
		AND
			(
				(@narcoticsOnly = 'N')
				OR
				(
					ppo.controlled_substance_code IS NOT NULL AND LTRIM(RTRIM(ppo.controlled_substance_code)) IN ('2','3','4','5','6','99')
				)
			)
		AND (@orderLinkedOption=3 or (@orderLinkedOption=2 and lsi.phys_order_id=ppo.phys_order_id)
			or (@orderLinkedOption=1 and lsi.phys_order_id is null))
		AND order_class_id = @orderClassId_local
END
ELSE -- get both Institutional orders and Discharge orders
BEGIN
	insert into @orderData
	select
		distinct ppo.phys_order_id
				 ,vpos.order_status
				 ,vpos.order_relationship
				 ,vpos.status_reason
				 , ppo.fac_id
				 , ppo.client_id
				 , ppo.diet_type
				 , ppo.diet_texture
				 , ppo.diet_supplement
				 , ppo.fluid_consistency
				 , ppo.alter_med_src
				 , ppo.nurse_pharm_notes
				 , ppo.created_by
				 , createdBySu.long_username
				 , ppo.created_date
				 , ppo.date_ordered
				 , case when ppo.order_category_id=3031 then diettype.item_description
							 when ppo.order_category_id=3032 then dietsup.item_description
							 when ppo.order_category_id=3023 then diettype.item_description
							 when ppo.order_category_id=3033 then 'Enteral Feed'
							 else ppo.description
						end 'calculated_description'
				 , ppo.related_generic
				 , ppo.dispense_as_written
				 , ppo.directions
				 , ppo.strength
				 , ppo.drug_strength
				 , ppo.drug_strength_uom
				 , ppo.discontinued_date
				 , ppo.end_date
				 , ppo.hold_date
				 , ppo.hold_date_end
				 , ppo.last_reorder_date
				 , ppo.order_type_id
				 , ppo.order_category_id
				 , ordercat.category_desc
				 , ordercat.family_portal_sort_order
				 , ppo.order_date
				 , ppo.order_status
				 , ppo.physician_id
				 , ppo.reorder
				 , ppo.revision_by
				 , ppo.revision_date
				 , CASE WHEN useraudit.edited_date is null THEN ppo.revision_date ELSE useraudit.edited_date END  'useraudit.edited_date'
				 , ppo.route_of_admin
				 , ppo.start_date
				 , isnull(ppo.order_verified, 'Y') 'order_verified'
				 , ppo.next_refill_date
				 , ppo.do_not_fill
				 , ppo.first_documented
				 , ppo.origin_id
				 , ppo.controlled_substance_code
				 , ppo.pharmacy_id
				 , ppo.communication_method
				 , CASE WHEN ppone.phys_order_id is null THEN 'Y' ELSE 'N' END  'ppone.phys_order_id'
				 , c.discharge_date
				 , c.client_id_number
				 , c.last_name
				 , c.first_name
				 , ppo.orig_phys_order_id
				 , lib.pho_ext_lib_id
				 , lib.pho_ext_lib_med_id
         , lib.pho_ext_lib_med_ddid
         , lib.ext_lib_rxnorm_id
				 , ppo.vendor_phys_order_id
				 , case
					when pso.std_order_id is not null and (pso.advanced_directive=1) then 'Y'
					when pstd.std_phys_order_id is not null and (pstd.advanced_directive='Y') then 'Y'
					else 'N'
				  end as 'advanced_directive'
				, confirmed_by_audit_id
				, ppone.phys_order_id
				, ppo.description
				, ls.linked_set_id
				, ls.set_description
				, ppo.order_class_id
	from
		@clientInfo c
		INNER JOIN pho_phys_order ppo WITH (NOLOCK)
			ON c.client_id = ppo.client_id
		INNER JOIN @vpos vpos
			ON vpos.phys_order_id = ppo.phys_order_id
		LEFT JOIN pho_phys_order_new_entry ppone WITH (NOLOCK)
			ON ppone.phys_order_id = ppo.phys_order_id
		LEFT JOIN pho_order_ext_lib_med_ref lib WITH (NOLOCK)
			ON lib.phys_order_id = ppo.phys_order_id AND lib.deleted='N'
		LEFT JOIN pho_std_phys_order pstd WITH (NOLOCK)
			ON pstd.std_phys_order_id = ppo.std_order_id
		LEFT JOIN pho_std_order pso WITH (NOLOCK)
			ON pso.std_order_id = ppo.std_order_id
		LEFT JOIN pho_phys_order_useraudit useraudit WITH (NOLOCK)
			ON useraudit.phys_order_id = ppo.phys_order_id
		LEFT JOIN PHO_ORDER_CATEGORY ordercat WITH (NOLOCK)
     		ON ppo.order_category_id = ordercat.order_category_id
		LEFT JOIN sec_user createdBySu  WITH (NOLOCK)
     		ON createdBySu.loginname = ppo.created_by
		LEFT JOIN COMMON_CODE diettype WITH (NOLOCK)
			ON ppo.diet_type = diettype.item_id
		LEFT JOIN COMMON_CODE dietsup WITH (NOLOCK)
			ON ppo.diet_supplement = dietsup.item_id
		LEFT JOIN pho_linked_set_item lsi on lsi.phys_order_id=ppo.phys_order_id
		LEFT JOIN pho_linked_set ls on ls.linked_set_id=lsi.linked_set_id

	where
		( @physOrderId IS NULL OR ppo.phys_order_id = @physOrderId  )
		AND (isnull(ppo.active_flag, 'Y') = 'Y')
		AND
			(
				(@narcoticsOnly = 'N')
				OR
				(
					ppo.controlled_substance_code IS NOT NULL AND LTRIM(RTRIM(ppo.controlled_substance_code)) IN ('2','3','4','5','6','99')
				)
			)
		AND (@orderLinkedOption=3 or (@orderLinkedOption=2 and lsi.phys_order_id=ppo.phys_order_id)
			or (@orderLinkedOption=1 and lsi.phys_order_id is null))
END

-- remove the orders from @orderData that does not match the discharge order pharmacy only when discharge order and when the pharmacy search is provided
IF(@pharmacyNCPDP_local is not null)
BEGIN
	insert into @dischargePharmacyNCPDP
	select s.phys_order_id from pho_phys_order_discharge_snapshot s
	inner join @orderData o on o.phys_order_id = s.phys_order_id and o.order_class_id = 2
	where ncpdp_identifier = @pharmacyNCPDP_local

	delete from @orderData where order_class_id = 2 and phys_order_id NOT IN (select discharge_pharm_phys_order_id from @dischargePharmacyNCPDP)
END

SET @step = 5
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert non struckout orders into cache'
IF @debug='Y'
    PRINT @status_text
    INSERT INTO @result
    SELECT
		distinct
		 ppo.phys_order_id
        ,ppo.status
        ,ppo.relationship
        ,ppo.status_reason
        ,ppo.fac_id
        ,ppo.client_id
        ,ppo.diet_type
        ,ppo.diet_texture
        ,ppo.diet_supplement
        ,ppo.fluid_consistency
        ,ppo.alter_med_src
        ,ppo.nurse_pharm_notes
        ,ppo.created_by
        ,ppo.created_by_longname
        ,ppo.created_date
        ,ppo.date_ordered
        ,ppo.calculated_description
        ,ppo.related_generic
        ,ppo.dispense_as_written
        ,ppo.directions
		,ppo.strength
        ,ppo.drug_strength
        ,ppo.drug_strength_uom
        ,ppo.discontinued_date
        ,ppo.end_date
        ,ppo.hold_date
        ,ppo.hold_date_end
        ,ppo.last_reorder_date
        ,ppo.order_type_id
        ,ppo.order_category_id
        ,ppo.order_category_description
        ,ppo.family_portal_sort_order
        ,ppo.order_date
        ,ppo.order_status
        ,ppo.physician_id
        ,ppo.reorder
        ,ppo.revision_by
        ,ppo.revision_date
        ,ppo.edited_date
        ,ppo.route_of_admin
        ,ppo.start_date
        ,ppo.order_verified
        ,ppo.next_refill_date
        ,ppo.do_not_fill
        ,ppo.first_documented
        ,ppo.origin_id
        ,ppo.controlled_substance_code
        ,ppo.pharmacy_id
        ,ppo.communication_method
        ,ppo.legacy_order
        ,ppo.discharge_date
        ,ppo.client_id_number

        ,ppo.resident_last_name
        ,ppo.resident_first_name
        ,ppo.orig_phys_order_id
        ,ppo.pho_ext_lib_id
        ,ppo.pho_ext_lib_med_id
        ,ppo.pho_ext_lib_med_ddid
        ,ppo.ext_lib_rxnorm_id
		,null
		,null
		,null
		,ppo.vendor_phys_order_id
		,ppo.advanced_directive
        ,ppo.end_date
		,ppo.linked_set_id
		,ppo.linked_set_name
		,ppo.order_class_id
           FROM
				@orderData ppo
				INNER JOIN @orderStatus os
					on  os.status = ppo.status
				INNER JOIN @communicationMethodIds cm
					ON cm.method_id = isnull(ppo.communication_method, 3027)
				INNER JOIN @orderCategoryIds oc
					ON oc.order_category_id = ppo.order_category_id
				LEFT JOIN pho_order_type orderType WITH (NOLOCK)
            		ON ppo.order_type_id = orderType.order_type_id
				LEFT JOIN pho_order_supply pos
        			ON ppo.phys_order_id = pos.phys_order_id
				LEFT JOIN pho_phys_order_useraudit  useraudit
				    on useraudit.phys_order_id = ppo.phys_order_id
				LEFT JOIN pho_administration_record  adminRecord WITH (NOLOCK)
            		ON orderType.administration_record_id = adminRecord.administration_record_id
				LEFT JOIN cp_sec_user_audit confuser  WITH (NOLOCK)
					ON confuser.cp_sec_user_audit_id = ppo.confirmed_by_audit_id
				LEFT JOIN contact physcon ON physcon.contact_id = ppo.physician_id
            WHERE

                (@providerId IS NULL OR ppo.pharmacy_id = @providerId)
                AND
                (@orderedById IS NULL OR ppo.physician_id = @orderedById OR ppo.physician_id = @oldOrderById)
                AND
                (@orderTypeId IS NULL OR ppo.order_type_id = @orderTypeId)
                AND
                (@adminRecordId IS NULL OR adminRecord.administration_record_id = @adminRecordId)
                AND
                (@routeOfAdminIdsCSV IS NULL OR ppo.route_of_admin IN (SELECT route_of_Admin from @routeOfAdminIds))
                AND
                (@medicationSourceId IS NULL OR ppo.alter_med_src = @medicationSourceId)
                AND
                (@pharmacyId IS NULL OR ppo.pharmacy_id = @pharmacyId)
                AND
                (@createdBy is NULL OR ppo.created_by = @createdBy)
                AND
				(@confirmedBy is NULL OR confuser.loginname = @confirmedBy)

                --AND
                -- do not show invalid category and administrative orders
                --ppo.order_category_id <> 1 AND ppo.order_category_id <> 3030
                AND
                (
                    (@orderDate IS NULL OR @orderDateoperator IS NULL)
                    OR
                    (
                        (@orderDateoperator = 0 AND ppo.order_date >= @orderDate AND ppo.order_date < @orderDate + 1)
                        OR (@orderDateoperator = 1 AND ppo.order_date >= @orderDate + 1)
                        OR (@orderDateoperator = -1 AND ppo.order_date < @orderDate)
                    )
                )
                AND
                (
                    (@startDate IS NULL OR @startDateoperator IS NULL)
                    OR
                    (
                        (@startDateoperator = 0 AND ppo.start_date >= @startDate AND ppo.start_date < @startDate + 1)
                        OR (@startDateoperator = 1  AND ppo.start_date >= @startDate + 1)
                        OR (@startDateoperator = -1 AND ppo.start_date < @startDate)
                    )
                )
                AND
                (
                    (@endDate IS NULL OR @endDateoperator IS NULL)
                    OR
                    (
                        (@endDateoperator = 0 AND ppo.end_date >= @endDate AND ppo.end_date < @endDate + 1)
                        OR (@endDateoperator = 1  AND (ppo.end_date >= @endDate + 1 OR ppo.end_date IS NULL))
                        OR (@endDateoperator = -1 AND ppo.end_date < @endDate)
                    )
                )
	            AND
	            (
	                (@discontinuedDate IS NULL OR @discontinuedDateoperator IS NULL)
	                OR
	                (
	                    (@discontinuedDateoperator = 0 AND ppo.discontinued_date >= @discontinuedDate AND ppo.discontinued_date < @discontinuedDate + 1)
	                    OR (@discontinuedDateoperator = 1  AND ppo.discontinued_date >= @discontinuedDate + 1)
	                    OR (@discontinuedDateoperator = -1 AND ppo.discontinued_date < @discontinuedDate)
	                )
	            )
				AND
	            (
	                --This condition is to handle historical orders case ie to filter historical orders only when the proc is called in that scenario
					--If @historicalOrdersOnly = 'N' => the proc IS NOT called for historical orders only scenario and therefore this condition should not prevent returing the order (by testing order endDate and discontinuedDate)
					--If @historicalOrdersOnly = 'Y' but @historicalOrdersOnlyPeriodStart IS NULL => the proc IS called for historical orders only scenario but WITH NO limit on the period therefore this condition should not prevent returning the order neither (by testing order endDate and discontinuedDate)
					--If @historicalOrdersOnly = 'Y' and @historicalOrdersOnlyPeriodStart IS NOT NULL => the proc IS called for historical orders only scenario and WITH limit on the period and therefore, in order to be returned, order should fall in the specified period (order endDate and discontinuedDate should verify the below conditions)
					(@historicalOrdersOnlyPeriodStart IS NULL OR @historicalOrdersOnly = 'N')
	                OR
					(
					(ppo.end_Date IS NULL OR ppo.end_Date > @historicalOrdersOnlyPeriodStart)
					AND (ppo.discontinued_Date IS NULL OR ppo.discontinued_Date > @historicalOrdersOnlyPeriodStart)
					)

	            )
	            AND
	            (
	                (@holdDate IS NULL OR @holdDateoperator IS NULL)
	                OR
	                (
	                    (@holdDateoperator = 0 AND ppo.hold_date >= @holdDate AND ppo.hold_date < @holdDate + 1)
	                    OR (@holdDateoperator = 1  AND ppo.hold_date >= @holdDate + 1)
	                    OR (@holdDateoperator = -1 AND ppo.hold_date < @holdDate)
	                )
	            )
	            AND
	            (
	                (@completedDate IS NULL OR @completedDateoperator IS NULL)
	                OR
	                (
	                    (@completedDateoperator = 0 AND ppo.end_date >= @completedDate AND ppo.end_date < @completedDate + 1)
	                    OR (@completedDateoperator = 1  AND ppo.end_date >= @completedDate + 1)
	                    OR (@completedDateoperator = -1 AND ppo.end_date < @completedDate)
	                )
	            )
	            AND
	            (
	                (@confirmedDate IS NULL OR @confirmedDateoperator IS NULL)
	                OR
	                (
	                    (@confirmedDateoperator = 0 AND useraudit.confirmed_date >= @confirmedDate AND useraudit.confirmed_date < @confirmedDate + 1)
	                    OR (@confirmedDateoperator = 1  AND useraudit.confirmed_date >= @confirmedDate + 1)
	                    OR (@confirmedDateoperator = -1 AND useraudit.confirmed_date < @confirmedDate)
	                )
	            )
                AND
                (@showLegacyOrder IS NULL OR (@showLegacyOrder='Y' AND ppone_phys_order_id IS NULL) OR (@showLegacyOrder='N' AND ppone_phys_order_id IS NOT NULL))

                    AND
					(@medication IS NULL OR ppo.description LIKE '%' + @medication + '%' OR (pos.description LIKE '%' + @medication + '%'AND pos.active = 'Y'))
                    AND
                    (@clientIdNumber IS NULL OR client_id_number = @clientIdNumber)
                    AND
                    (
                        @clientStatus IS NULL
                        --discharged
                        OR (@clientStatus = 0 AND discharge_date IS NOT NULL AND discharge_date <= @facilityDateTime)
                        --active
                        OR (@clientStatus = 1 AND (discharge_date IS NULL OR discharge_date > @facilityDateTime))
                    )
                    AND
                    (
	                    @medicationclassification IS NULL OR
	                    ppo.phys_order_id  IN
	                    (
	                        select * from @medicationclassificationTable
	                    )
                    )
                    AND (
                      (
                        @supplyStatusId IS NULL
                        AND @fromIntegratedPharmacy IS NULL
                        AND @medSrcTypeId IS NULL
                      )
                      OR (
                        ppo.phys_order_id IN (select * from @supplyCriteria)
                      )
                    )
                    AND
                    ( @physOrderId IS NULL OR ppo.phys_order_id = @physOrderId  )
					AND (physcon.deleted = CASE WHEN @includeRetired = 'Y' THEN physcon.deleted ELSE 'N' END  OR ppo.physician_id IS NULL OR physcon.deleted is NULL)

            ORDER BY ppo.revision_by desc


--PCC-26565: Any orders (regardless of status) with alerts should always show in orders chart
SET @step = 51
if (@alwaysShowOrderWithAlert = 'Y')
BEGIN
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert orders having alerts into cache - considering duplicated order id'

	INSERT INTO @ordersHavingAlerts
	SELECT DISTINCT
	ppo.phys_order_id
	FROM @orderData ppo
	INNER JOIN cr_alert ca WITH (NOLOCK) ON
											ca.fac_id = ppo.fac_id
											AND ca.client_id = ppo.client_id
											AND ca.triggered_item_id = ppo.phys_order_id
											AND ca.triggered_item_type = 'O'
											AND ca.resolved <> 'Y'
											AND ca.deleted = 'N'
	WHERE ppo.status = 3 -- Consider Completed orders only

if (@showOrdersWithIntegrationAlerts = 'Y')
	INSERT INTO @ordersHavingAlerts
	SELECT DISTINCT
	ppo.phys_order_id
	FROM @orderData ppo
	INNER JOIN cr_alert ca WITH (NOLOCK) ON
											ca.fac_id = ppo.fac_id
											AND ca.client_id = ppo.client_id
											AND ca.triggered_item_id = ppo.phys_order_id
											AND ca.triggered_item_type = 'M'
											AND ca.resolved <> 'Y'
											AND ca.deleted = 'N'


if(@showOrdersWithSupplyIntegrationAlerts = 'Y')
	INSERT INTO @ordersHavingAlerts
	SELECT DISTINCT
	ppo.phys_order_id
	FROM @orderData ppo
	INNER JOIN pho_order_supply s ON s.phys_order_id = ppo.phys_order_id
	INNER JOIN cr_alert ca WITH (NOLOCK) ON
											ca.fac_id = ppo.fac_id
											AND ca.client_id = ppo.client_id
											AND ca.triggered_item_id = s.order_supply_id
											AND ca.triggered_item_type = 'D'
											AND ca.resolved <> 'Y'
											AND ca.deleted = 'N'


IF @debug='Y'
    PRINT @status_text
    INSERT INTO @result
    SELECT distinct
			ppo.phys_order_id
        ,ppo.status
        ,ppo.relationship
        ,ppo.status_reason
        ,ppo.fac_id
        ,ppo.client_id
        ,ppo.diet_type
        ,ppo.diet_texture
        ,ppo.diet_supplement
        ,ppo.fluid_consistency
        ,ppo.alter_med_src
        ,ppo.nurse_pharm_notes
        ,ppo.created_by
        ,ppo.created_by_longname
        ,ppo.created_date
        ,ppo.date_ordered
        ,ppo.calculated_description
        ,ppo.related_generic
        ,ppo.dispense_as_written
        ,ppo.directions
		,ppo.strength
        ,ppo.drug_strength
        ,ppo.drug_strength_uom
        ,ppo.discontinued_date
        ,ppo.end_date
        ,ppo.hold_date
        ,ppo.hold_date_end
        ,ppo.last_reorder_date
        ,ppo.order_type_id
        ,ppo.order_category_id
        ,ppo.order_category_description
        ,ppo.family_portal_sort_order
        ,ppo.order_date
        ,ppo.order_status
        ,ppo.physician_id
        ,ppo.reorder
        ,ppo.revision_by
        ,ppo.revision_date
        ,ppo.edited_date
        ,ppo.route_of_admin
        ,ppo.start_date
        ,ppo.order_verified
        ,ppo.next_refill_date
        ,ppo.do_not_fill
        ,ppo.first_documented
        ,ppo.origin_id
        ,ppo.controlled_substance_code
        ,ppo.pharmacy_id
        ,ppo.communication_method
        ,ppo.legacy_order
        ,ppo.discharge_date
        ,ppo.client_id_number
        ,ppo.resident_last_name
        ,ppo.resident_first_name
        ,ppo.orig_phys_order_id
        ,ppo.pho_ext_lib_id
        ,ppo.pho_ext_lib_med_id
        ,ppo.pho_ext_lib_med_ddid
        ,ppo.ext_lib_rxnorm_id
		,null
		,null
		,null
		,ppo.vendor_phys_order_id
		,ppo.advanced_directive
		,ppo.end_date
		,ppo.linked_set_id
		,ppo.linked_set_name
		,ppo.order_class_id
           FROM
            @orderData ppo
			INNER JOIN @orderCategoryIds oc
				ON oc.order_category_id = ppo.order_category_id
			INNER JOIN @ordersHavingAlerts oha ON oha.phys_order_id = ppo.phys_order_id
			LEFT JOIN contact physcon ON physcon.contact_id = ppo.physician_id
             WHERE
				oha.phys_order_id not in ( select phys_order_id from @result )
				AND (physcon.deleted = CASE WHEN @includeRetired = 'Y' THEN physcon.deleted ELSE 'N' END OR ppo.physician_id IS NULL OR physcon.deleted is NULL)
                --AND
                -- do not show invalid category and administrative orders
                --ppo.order_category_id <> 1 AND ppo.order_category_id <> 3030

            ORDER BY ppo.revision_by desc
END

SET @step = 6
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert struckout orders into cache = "' + CONVERT(VARCHAR(1), @includeStruckOutOrders) + '"';
IF @debug='Y'
    PRINT @status_text;
	IF @includeStruckOutOrders = 'Y'
	BEGIN
		WITH AUDIT AS
		(
			SELECT
				ppo.phys_order_id 'phys_order_id'
				 ,4  'status'
				 ,NULL	as relationship
				 ,NULL  as status_reason
				 , ppo.fac_id 'fac_id'
				 , ppo.client_id 'client_id'
				 , ppo.diet_type 'diet_type'
				 , ppo.diet_texture 'diet_texture'
				 , ppo.diet_supplement 'diet_supplement'
				 , ppo.fluid_consistency 'fluid_consistency'
				 , ppo.alter_med_src 'alter_med_src'
				 , ppo.created_by 'created_by'
				 --, createdBySu.long_username 'created_by_longname'
				 , ppo.created_date 'created_date'
				 , ppo.date_ordered 'date_ordered'
				/* , case when ppo.order_category_id=3031 then diettype.item_description
							 when ppo.order_category_id=3032 then dietsup.item_description
							 when ppo.order_category_id=3023 then diettype.item_description
							 when ppo.order_category_id=3033 then 'Enteral Feed'
							 else ppo.description
						end 'description'*/
				 , ppo.related_generic 'related_generic'
				 , ppo.dispense_as_written 'dispense_as_written'
				 , ppo.directions 'directions'
				 , ppo.strength
				 , ppo.drug_strength 'drug_strength'
				 , ppo.drug_strength_uom 'drug_strength_uom'
				 , ppo.discontinued_date 'discontinued_date'
				 , ppo.end_date 'end_date'
				 , ppo.hold_date 'hold_date'
				 , ppo.hold_date_end 'hold_date_end'
				 , ppo.last_reorder_date 'last_reorder_date'
				 , ppo.order_type_id 'order_type_id'
				 , ppo.order_category_id 'order_category_id'
				-- , ordercat.category_desc  'order_category_description'
				 , ppo.order_date 'order_date'
				 , ppo.order_status 'order_status'
				 , ppo.physician_id 'physician_id'
				 , ppo.reorder 'reorder'
				 , ppo.revision_by 'revision_by'
				 , ppo.revision_date 'revision_date'
				 , ppo.revision_date 'edited_date'
				 , ppo.route_of_admin 'route_of_admin'
				 , ppo.start_date 'start_date'
				 , isnull(ppo.order_verified, 'Y') 'order_verified'
				 , ppo.next_refill_date 'next_refill_date'
				 , ppo.do_not_fill 'do_not_fill'
				 , ppo.first_documented 'first_documented'
				 , ppo.origin_id 'origin_id'
				 , ppo.controlled_substance_code 'controlled_substance_code'
				 , ppo.pharmacy_id 'pharmacy_id'
				 , ppo.communication_method 'communication_method'
				-- , CASE WHEN ppone.phys_order_id is null THEN 'Y' ELSE 'N' END  'legacy_order'
				 , c.discharge_date 'discharge_date'
				 , c.client_id_number 'client_id_number'
				 , c.last_name 'resident_last_name'
				 , c.first_name 'resident_first_name'
				 , ppo.orig_phys_order_id 'orig_phys_order_id'
			   --  , lib.pho_ext_lib_id
			   --  , lib.pho_ext_lib_med_id
				 , ppo.strikeout_date
				 , ppo.strikeout_by
			   --  , strike_code.item_description 'strikeout_reason_description'
  	     		 , ppo.vendor_phys_order_id
  			  --	 , isnull(pstd.advanced_directive, 'N') 'advanced_directive'

		--added
				,ppo.std_order_id
				,ppo.active_flag
				,ppo.description
				,ppo.strikeout_reason_code
				,c.first_name
				,c.last_name
				,order_class_id
			FROM
					pho_phys_order_audit ppo WITH (NOLOCK)
					INNER JOIN @clientInfo c
						ON c.client_id = ppo.client_id
					INNER JOIN @orderStatus os
						on  os.status = 4
			WHERE
					ppo.event_type = 'S'
					--required
					AND ppo.fac_id = @facIdLocal
					AND c.fac_id = @facIdLocal
					AND ppo.order_class_id = @orderClassId_local
		)

		INSERT INTO @result
		SELECT distinct adt.phys_order_id 'phys_order_id'
				 ,4 'status'
				 ,NULL
				 ,NULL
				 , adt.fac_id 'fac_id'
				 , adt.client_id 'client_id'
				 , adt.diet_type 'diet_type'
				 , adt.diet_texture 'diet_texture'
				 , adt.diet_supplement 'diet_supplement'
				 , adt.fluid_consistency 'fluid_consistency'
				 , adt.alter_med_src 'alter_med_src'
				 , null
				 , adt.created_by 'created_by'
				 , createdBySu.long_username 'created_by_longname'
				 , adt.created_date 'created_date'
				 , adt.date_ordered 'date_ordered'
				 , case when adt.order_category_id=3031 then diettype.item_description
							 when adt.order_category_id=3032 then dietsup.item_description
							 when adt.order_category_id=3023 then diettype.item_description
							 when adt.order_category_id=3033 then 'Enteral Feed'
							 else adt.description
						end 'description'
				 , adt.related_generic 'related_generic'
				 , adt.dispense_as_written 'dispense_as_written'
				 , adt.directions 'directions'
				 , adt.strength
				 , adt.drug_strength 'drug_strength'
				 , adt.drug_strength_uom 'drug_strength_uom'
				 , adt.discontinued_date 'discontinued_date'
				 , adt.end_date 'end_date'
				 , adt.hold_date 'hold_date'
				 , adt.hold_date_end 'hold_date_end'
				 , adt.last_reorder_date 'last_reorder_date'
				 , adt.order_type_id 'order_type_id'
				 , adt.order_category_id 'order_category_id'
				 , ordercat.category_desc  'order_category_description'
				 , ordercat.family_portal_sort_order 'family_portal_sort_order'
				 , adt.order_date 'order_date'
				 , adt.order_status 'order_status'
				 , adt.physician_id 'physician_id'
				 , adt.reorder 'reorder'
				 , adt.revision_by 'revision_by'
				 , adt.revision_date 'revision_date'
				 , adt.revision_date 'edited_date'
				 , adt.route_of_admin 'route_of_admin'
				 , adt.start_date 'start_date'
				 , isnull(adt.order_verified, 'Y') 'order_verified'
				 , adt.next_refill_date 'next_refill_date'
				 , adt.do_not_fill 'do_not_fill'
				 , adt.first_documented 'first_documented'
				 , adt.origin_id 'origin_id'
				 , adt.controlled_substance_code 'controlled_substance_code'
				 , adt.pharmacy_id 'pharmacy_id'
				 , adt.communication_method 'communication_method'
				 , CASE WHEN ppone.phys_order_id is null THEN 'Y' ELSE 'N' END  'legacy_order'
				 , adt.discharge_date 'discharge_date'
				 , adt.client_id_number 'client_id_number'
				 , adt.last_name 'resident_last_name'
				 , adt.first_name 'resident_first_name'
				 , adt.orig_phys_order_id 'orig_phys_order_id'
				 , lib.pho_ext_lib_id
				 , lib.pho_ext_lib_med_id
				 , lib.pho_ext_lib_med_ddid
				 , lib.ext_lib_rxnorm_id

				 , adt.strikeout_date
				 , adt.strikeout_by
				 , strike_code.item_description 'strikeout_reason_description'
  	     		 , adt.vendor_phys_order_id
				 , case
					when pso.std_order_id is not null and (pso.advanced_directive=1) then 'Y'
					when pstd.std_phys_order_id is not null and (pstd.advanced_directive='Y') then 'Y'
					else 'N'
				  end as 'advanced_directive'
  	      		 ,adt.end_date
				 ,null
				 ,null
				 ,adt.order_class_id
				FROM AUDIT adt
					/*pho_phys_order_audit ppo WITH (NOLOCK)
					INNER JOIN @clientInfo c
						ON c.client_id = ppo.client_id
					INNER JOIN @orderStatus os
						on  os.status = 4*/
					INNER JOIN @communicationMethodIds cm
						ON cm.method_id = isnull(adt.communication_method, 3027)
					INNER JOIN @orderCategoryIds oc
						ON oc.order_category_id = adt.order_category_id
					LEFT JOIN pho_order_type orderType  WITH (NOLOCK)
        				ON adt.order_type_id = orderType.order_type_id
					LEFT JOIN pho_order_supply pos
        				ON adt.phys_order_id = pos.phys_order_id
					LEFT JOIN pho_administration_record  adminRecord WITH (NOLOCK)
        				ON orderType.administration_record_id = adminRecord.administration_record_id
					LEFT JOIN pho_phys_order_new_entry ppone WITH (NOLOCK)
						ON ppone.phys_order_id = adt.phys_order_id
					LEFT JOIN pho_order_ext_lib_med_ref lib WITH (NOLOCK)
						ON lib.phys_order_id = adt.phys_order_id
					LEFT JOIN COMMON_CODE strike_code WITH (NOLOCK)
						ON strike_code.item_id = adt.strikeout_reason_code
					LEFT JOIN pho_phys_order_useraudit useraudit WITH (NOLOCK)
							ON useraudit.phys_order_id = adt.phys_order_id
					LEFT JOIN cp_sec_user_audit confuser  WITH (NOLOCK)
							ON confuser.cp_sec_user_audit_id = useraudit.confirmed_by_audit_id
					LEFT JOIN pho_std_phys_order pstd WITH (NOLOCK)
						ON pstd.std_phys_order_id = adt.std_order_id
					LEFT JOIN pho_std_order pso WITH (NOLOCK)
						ON pso.std_order_id = adt.std_order_id
					LEFT JOIN PHO_ORDER_CATEGORY ordercat WITH (NOLOCK)
        				ON adt.order_category_id = ordercat.order_category_id
        			LEFT JOIN sec_user createdBySu  WITH (NOLOCK)
        				ON createdBySu.loginname = adt.created_by
					-- for sorting on description
					LEFT JOIN COMMON_CODE diettype WITH (NOLOCK)
						ON adt.diet_type = diettype.item_id
					LEFT JOIN COMMON_CODE dietsup WITH (NOLOCK)
						ON adt.diet_supplement = dietsup.item_id
					LEFT JOIN CONTACT physcon
					ON adt.physician_id = physcon.contact_id

					WHERE
					/*ppo.event_type = 'S'

					--required
					AND adt.fac_id = @facIdLocal
					AND c.fac_id = @facIdLocal
					AND*/
					(@providerId IS NULL OR adt.pharmacy_id = @providerId)
					AND
					(@orderedById IS NULL OR adt.physician_id = @orderedById OR adt.physician_id = @oldOrderById)
					AND
					(@orderTypeId IS NULL OR adt.order_type_id = @orderTypeId)
					AND
					(@adminRecordId IS NULL OR adminRecord.administration_record_id = @adminRecordId)
					AND
					(@routeOfAdminIdsCSV IS NULL OR adt.route_of_admin IN (SELECT route_of_Admin from @routeOfAdminIds))
					AND
					(@medicationSourceId IS NULL OR adt.alter_med_src = @medicationSourceId)
					AND
					(@pharmacyId IS NULL OR adt.pharmacy_id = @pharmacyId)
					AND
					(@createdBy is NULL OR adt.created_by = @createdBy)
					AND
					(@confirmedBy is NULL OR confuser.loginname = @confirmedBy)

					--AND
					-- do not show invalid category and administrative orders
					--ppo.order_category_id <> 1 AND ppo.order_category_id <> 3030
					AND
					(
						(@orderDate IS NULL OR @orderDateoperator IS NULL)
						OR
						(
							(@orderDateoperator = 0 AND adt.order_date >= @orderDate AND adt.order_date < @orderDate + 1)
							OR (@orderDateoperator = 1 AND adt.order_date >= @orderDate + 1)
							OR (@orderDateoperator = -1 AND adt.order_date < @orderDate)
						)
					)
					AND
					(
						(@startDate IS NULL OR @startDateoperator IS NULL)
						OR
						(
							(@startDateoperator = 0 AND adt.start_date >= @startDate AND adt.start_date < @startDate + 1)
							OR (@startDateoperator = 1  AND adt.start_date >= @startDate + 1)
							OR (@startDateoperator = -1 AND adt.start_date < @startDate)
						)
					)
					AND
					(
						(@endDate IS NULL OR @endDateoperator IS NULL)
						OR
						(
							(@endDateoperator = 0 AND adt.end_date >= @endDate AND adt.end_date < @endDate + 1)
							OR (@endDateoperator = 1  AND (adt.end_date >= @endDate + 1 OR adt.end_date IS NULL))
							OR (@endDateoperator = -1 AND adt.end_date < @endDate)
						)
					)
					AND
					(@showLegacyOrder IS NULL OR (@showLegacyOrder='Y' AND ppone.phys_order_id IS NULL) OR (@showLegacyOrder='N' AND ppone.phys_order_id IS NOT NULL))

						AND
						(@medication IS NULL OR adt.description LIKE '%' + @medication + '%' OR (pos.description LIKE '%' + @medication + '%'AND pos.active = 'Y'))
						AND
						(@clientIdNumber IS NULL OR adt.client_id_number = @clientIdNumber)
						AND
						(
							@clientStatus IS NULL
							--discharged
							OR (@clientStatus = 0 AND adt.discharge_date IS NOT NULL AND adt.discharge_date <= @facilityDateTime)
							--active
							OR (@clientStatus = 1 AND (adt.discharge_date IS NULL OR adt.discharge_date > @facilityDateTime))
						)
						AND
						(
							@medicationclassification IS NULL OR
							adt.phys_order_id  IN
							(
								select * from @medicationclassificationTable
							)
						)
						AND (
						  (
							@supplyStatusId IS NULL
							AND @fromIntegratedPharmacy IS NULL
							AND @medSrcTypeId IS NULL
						  )
						  OR (
							adt.phys_order_id IN (select * from @supplyCriteria)
						  )
						)
						AND
						( @physOrderId IS NULL OR adt.phys_order_id = @physOrderId  )
						AND
						(isnull(adt.active_flag, 'Y') = 'Y')
						AND (physcon.deleted = CASE WHEN @includeRetired = 'Y' THEN physcon.deleted ELSE 'N' END OR adt.physician_id IS NULL OR physcon.deleted is NULL)
				ORDER BY adt.revision_by desc
	END

SET @step = 7
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Do pagination'
IF @debug='Y'
    PRINT @status_text

select @num_records = count(*) from @result

-- when page number is 2 and there is only one page
-- hur 34499
if  @pageSize > 0 and (@pageSize * (@pageNumber-1)) >= @num_records
begin
	set @pageNumber = 1
end

IF (@sortByColumn = 'end_date')
BEGIN
	update  r
		set r.end_date_filter = r.discontinued_date from @result r where r.discontinued_date is not null
END

IF @sortByOrder='desc'
BEGIN
	;with tmp as
	(
		select row_number() over(ORDER BY
									 case
										when @sortByColumn = 'resident_last_name' then resident_last_name
										when @sortByColumn = 'description' then description
										when @sortByColumn = 'status' then CONVERT(varchar(50),status)
										when @sortByColumn = 'order_category_description' then order_category_description
										when @sortByColumn = 'created_date' then CONVERT(varchar(50),created_date,112)
										when @sortByColumn = 'created_by_longname' then created_by_longname
										when @sortByColumn = 'revision_date' then CONVERT(varchar(50),edited_date,112)
										when @sortByColumn = 'start_date' then CONVERT(varchar(50),start_date,112)
										when @sortByColumn = 'end_date' then CONVERT(varchar(50),end_date_filter,112)
										when @sortByColumn = 'family_portal_sort_order' then CONVERT(varchar(50),family_portal_sort_order)
										else CONVERT(varchar(50),revision_date,112)
									end
									desc) as rn from @result
	)
		-- hur 34499
		delete from tmp where @pageSize > 0 and (rn <= (@pageSize * (@pageNumber-1)) or rn > (@pageSize * @pageNumber))
END
ELSE
BEGIN
	;with tmp as
	(
		select row_number() over(ORDER BY
										case
										when @sortByColumn = 'resident_last_name' then resident_last_name
										when @sortByColumn = 'description' then description
										when @sortByColumn = 'status' then CONVERT(varchar(50),status)
										when @sortByColumn = 'order_category_description' then order_category_description
										when @sortByColumn = 'created_date' then CONVERT(varchar(50),created_date,112)
										when @sortByColumn = 'created_by_longname' then created_by_longname
										when @sortByColumn = 'start_date' then CONVERT(varchar(50),start_date,112)
										when @sortByColumn = 'end_date' then CONVERT(varchar(50),end_date_filter,112)
										when @sortByColumn = 'revision_date' then CONVERT(varchar(50),edited_date,112)
										when @sortByColumn = 'family_portal_sort_order' then CONVERT(varchar(50),family_portal_sort_order)
										else CONVERT(varchar(50),revision_date,112)
									end
									asc ) as rn from @result
	)
		-- hur 34499
		delete from tmp where @pageSize > 0 and (rn <= (@pageSize * (@pageNumber-1)) or rn > (@pageSize * @pageNumber))
END


SET @step = 7
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Select allergies for given page of orders'
IF @debug='Y'
    PRINT @status_text

--Do this near the end so we can avoid having to join onto the pho_phys_order and pho_phys_order_audit table directly
--Here we can just use the "page" to get only the needed allergies
IF(@drugAllergyCheckEnabled='Y')
BEGIN

 INSERT INTO @physOrderAllergies
 SELECT DISTINCT r.phys_order_id
  FROM @result r
  LEFT JOIN pho_order_supply pos on pos.phys_order_id=r.phys_order_id AND (pos.active = 'Y' and (pos.status=3 or pos.status=4 or pos.status=8)) AND pos.deleted = 'N' -- Only consider active and ("processed by pharmacy", "on hand" or reordered) supplies
  LEFT JOIN pho_phys_order_allergy_acknowledgement pa on pa.phys_order_id = r.phys_order_id
  LEFT JOIN pho_order_supply_allergy posa on posa.order_supply_id = pos.order_supply_id
  INNER JOIN allergy a on (a.allergy_id = pa.allergy_id or a.allergy_id=posa.allergy_id) AND a.client_id=@clientId
 WHERE (status_id=1 or a.status_id=3) AND (resolved_date is null OR resolved_date > @facilityDateTime)


END

SET @step = 7.1
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Select related Drugs for a given page of orders'
IF @debug='Y'
    PRINT @status_text

--Do this near the end so we can avoid having to join onto the pho_phys_order and pho_phys_order_audit table directly
--Here we can just use the "page" to get only the needed related drugs

IF(@drugInteractionEnabled='Y')
BEGIN
 INSERT INTO @physOrderDrugInteraction
 SELECT DISTINCT r.phys_order_id , pda.severity_code
  FROM @result r
  LEFT JOIN pho_order_supply pos on pos.phys_order_id=r.phys_order_id AND (pos.active = 'Y' and (pos.status=3 or pos.status=4 or pos.status=8)) AND pos.deleted = 'N' -- Only consider active and ("processed by pharmacy", "on hand" or reordered) supplies
  INNER JOIN pho_phys_order_drug_acknowledgement pda on pda.phys_order_id = r.phys_order_id
END

IF(@blackBoxEnabled='Y')
BEGIN
 INSERT INTO @physOrderBlackbox
 SELECT DISTINCT r.phys_order_id
  FROM @result r
  LEFT JOIN pho_order_supply pos on pos.phys_order_id=r.phys_order_id AND (pos.active = 'Y' and (pos.status=3 or pos.status=4 or pos.status=8)) AND pos.deleted = 'N' -- Only consider active and ("processed by pharmacy", "on hand" or reordered)supplies
  INNER JOIN pho_phys_order_blackbox_acknowledgement pba on pba.phys_order_id = r.phys_order_id
END

IF(@doseCheckEnabled='Y')
BEGIN
  INSERT INTO @physOrderDoseCheck
  SELECT DISTINCT r.phys_order_id,pba.over_dose
  FROM @result r
  INNER JOIN pho_phys_order_dose_check_acknowledgement pba on pba.phys_order_id = r.phys_order_id
END

IF(@drugInteractionEnabled='Y' or @blackBoxEnabled='Y' or @doseCheckEnabled='Y')
BEGIN
  INSERT INTO @physOrderNoDrugProtocolCheck
  SELECT DISTINCT r.phys_order_id
  FROM @result r
  INNER JOIN pho_phys_order_no_drug_protocol_checks ndpc on ndpc.phys_order_id = r.phys_order_id
END


SET @step = 8

    /****************************************
    return final result
    ****************************************/
    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Return orders'
    IF @debug='Y'
        PRINT @status_text
    SELECT physorder.*

         , isnull(tpocs.pharmacy_confirmation_sent, 0) AS pharmacy_confirmation_sent
         , isnull(tpos.shipped, 0) AS shipped
         , ordercat.category_desc AS order_category_description
         , ordercat.family_portal_sort_order AS family_portal_sort_order
         , physcon.first_name AS physician_first_name
         , physcon.last_name AS physician_last_name
         , dietsup.item_description AS diet_supplement_description
         , diettexture.item_description AS diet_texture_description
         , diettype.item_description AS diet_type_description
         , fluidcon.item_description AS fluid_consistency_description
         , route.item_description AS route_description
         , adminRecord.short_description AS administration_record_short_description
         , altAdminRecord.short_description AS alt_administration_record_short_description
         , isnull(createdBySu.long_username, physorder.created_by) 'created_by_longname'
         , isnull(revisionBySu.long_username, physorder.created_by) 'revision_by_longname'
         , isnull(useraudit.created_by_audit_id, 0) AS created_by_audit_id
         , isnull(useraudit.edited_by_audit_id, 0) AS edited_by_audit_id
         , edituser.long_username AS edited_by_long
         , edituser.position_description AS edited_by_position
         , edituser.designation_desc AS edited_by_designation
         , createuser.long_username AS created_by_audit_long
         , createuser.position_description AS created_by_position
         , createuser.designation_desc AS created_by_designation
         , useraudit.confirmed_date
         , isnull(useraudit.confirmed_by_audit_id, 0) AS confirmed_by_audit_id
         , confuser.long_username AS confirmed_by_long
         , confuser.position_description AS confirmed_by_position
         , confuser.designation_desc AS confirmed_by_designation
         , eef.name as pharmacy_name
         , poa.phys_order_id AS allergy_phys_order_id
         , pob.phys_order_id AS blackbox_phys_order_id
         , pdc.phys_order_id AS dose_check_phys_order_id
         , pdc.over_dose AS over_dose_value
         , ndpc.phys_order_id as no_drug_protocol_check_phys_order_id
         ,ua.long_username as signedByName
         ,ISNULL((case when ua.designation_desc = '' THEN NULL ELSE ua.designation_desc end),ua.position_description) as signedByCredential
         ,os.signature_date as signedDate
         ,at.description as authenticationTypeDescription
         ,ss.description as sourceTypeDescription
         ,os.authentication_type_id as authenticationTypeId
         ,os.signature_type_id as signatureTypeId
         ,os.source_type_id as sourceTypeId
         ,nctrlsc.new_controlled_substance_code as new_controlled_substance_code
         ,ppoe.sign_contact_id as digitallySigned
         ,oq.quantity as prescription_quantity
         ,oq.unit_of_measure as prescription_quantity_uom
         ,oq.no_of_refills as prescription_no_of_refills
         ,oq.dispense_interval as prescription_dispense_interval
         ,oq.total_authorized_quantity as prescription_total_authorized_quantity
         ,ti.orig_phys_order_id as original_ti_phys_order_id

        FROM
            @result physorder
        LEFT JOIN (SELECT physorder.phys_order_id
                        , convert(BIT, count(physorder.phys_order_id)) AS pharmacy_confirmation_sent
                       FROM
                           pho_pharmacy_order pharmorder
                       INNER JOIN @result physorder
                           ON (pharmorder.phys_order_id = physorder.phys_order_id OR pharmorder.phys_order_id = physorder.orig_phys_order_id)
                       WHERE
                           pharmorder.fac_id = @facIdLocal
                           AND --active orders
                           physorder.status = 1
                           AND pharmorder.created_date > isnull(physorder.last_reorder_date, physorder.date_ordered)
                       GROUP BY
                           physorder.phys_order_id) tpocs
            ON tpocs.phys_order_id = physorder.phys_order_id
        LEFT JOIN (SELECT physorder.phys_order_id AS phys_order_id
                        , convert(BIT, count(physorder.phys_order_id)) AS shipped
                       FROM
                           pho_pharmacy_order pharmorder
                       INNER JOIN @result physorder
                           ON (pharmorder.phys_order_id = physorder.phys_order_id OR pharmorder.phys_order_id = physorder.orig_phys_order_id)
                       WHERE
                           pharmorder.fac_id = @facIdLocal
                           AND pharmorder.created_date > physorder.last_reorder_date
                           AND pharmorder.receive_status <> 7 --WeTypePhoReceiveStatus.PCC_ORDER_COMPLETE
                           AND physorder.reorder = 'Y'
                       GROUP BY
                           physorder.phys_order_id) tpos
            ON tpos.phys_order_id = physorder.phys_order_id
        LEFT JOIN PHO_ORDER_TYPE ordertype
            ON physorder.order_type_id = ordertype.order_type_id
        LEFT JOIN PHO_ADMINISTRATION_RECORD adminRecord
            ON ordertype.administration_record_id = adminRecord.administration_record_id
        LEFT JOIN PHO_ADMINISTRATION_RECORD altAdminRecord
            ON ordertype.alt_administration_record_id = altAdminRecord.administration_record_id -- PCC-7725 add alt admin record
        LEFT JOIN CONTACT physcon
            ON physorder.physician_id = physcon.contact_id
        LEFT JOIN PHO_ORDER_CATEGORY ordercat
            ON ordertype.order_category_id = ordercat.order_category_id
        LEFT JOIN COMMON_CODE diettype
            ON physorder.diet_type = diettype.item_id
        LEFT JOIN COMMON_CODE diettexture
            ON physorder.diet_texture = diettexture.item_id
        LEFT JOIN COMMON_CODE [route]
            ON physorder.route_of_admin = route.item_id
        LEFT JOIN COMMON_CODE dietsup
            ON physorder.diet_supplement = dietsup.item_id
        LEFT JOIN COMMON_CODE fluidcon
            ON physorder.fluid_consistency = fluidcon.item_id
        LEFT JOIN sec_user createdBySu
            ON createdBySu.loginname = physorder.created_by
        LEFT JOIN sec_user revisionBySu
            ON revisionBySu.loginname = physorder.revision_by
        LEFT JOIN pho_phys_order_useraudit useraudit
            ON useraudit.phys_order_id = physorder.phys_order_id
        LEFT JOIN cp_sec_user_audit edituser
            ON edituser.cp_sec_user_audit_id = useraudit.edited_by_audit_id
        LEFT JOIN cp_sec_user_audit createuser
            ON createuser.cp_sec_user_audit_id = useraudit.created_by_audit_id
        LEFT JOIN cp_sec_user_audit confuser
            ON confuser.cp_sec_user_audit_id = useraudit.confirmed_by_audit_id
        LEFT JOIN emc_ext_facilities eef
          ON eef.ext_fac_id = physorder.pharmacy_id
        LEFT JOIN @physOrderAllergies poa ON poa.phys_order_id= physorder.phys_order_id
        LEFT JOIN @physOrderBlackbox pob ON pob.phys_order_id= physorder.phys_order_id
        LEFT JOIN @physOrderDoseCheck pdc ON pdc.phys_order_id = physorder.phys_order_id
        LEFT JOIN @physOrderNoDrugProtocolCheck ndpc ON ndpc.phys_order_id = physorder.phys_order_id

        LEFT JOIN pho_phys_order_sign os on os.phys_order_id = physorder.phys_order_id
        LEFT JOIN cp_sec_user_audit ua ON ua.cp_sec_user_audit_id = os.cp_sec_user_audit_id  --and os.phys_order_id = ?
        LEFT JOIN order_sign_authentication_type at on at.authentication_type_id = os.authentication_type_id
        LEFT JOIN order_sign_source_type ss on ss.source_type_id = os.source_type_id
        LEFT JOIN order_sign_signature_type st on st.signature_type_id = os.signature_type_id
        LEFT JOIN pho_phys_order_new_ctrlsubstancecode nctrlsc on nctrlsc.phys_order_id=physorder.phys_order_id
        LEFT JOIN pho_phys_order_esignature ppoe on ppoe.phys_order_id=physorder.phys_order_id
        LEFT JOIN pho_phys_order_quantity_info oq on oq.phys_order_id=physorder.phys_order_id
        LEFT JOIN pho_phys_order_ti ti on ti.phys_order_id = physorder.phys_order_id

SET @step = 9

SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return supplies '
    IF @debug='Y'
        PRINT @status_text

    -- supplies
    select pos.phys_order_id,
        pos.order_supply_id,
        pos.description as supply_description,
        pos.directions as supply_directions,
        pos.date_dispensed as date_dispensed,
        pos.last_received_date as supply_received_date,
		pos.received_date as supply_physical_received_date,
        pos.med_src_type_id as supply_med_src_type_id,
        pos.pharmacy_id as supply_pharmacy_id,
        eef.name as supply_pharmacy_name,
        pos.reordering as supply_reordering,
        pos.status AS supply_status,
        pos.new_supply_flag as supply_new_supply_flag,
        pos.last_reorder_date as supply_last_reorder_date,
        pos.disp_code as supply_disp_code,
        pos.pharm_nurse_notes as pharm_nurse_notes,
        pos.nurse_pharm_notes as nurse_pharm_notes,
        pos.disp_package_identifier as supply_disp_package_identifier,
        pos.controlled_substance_code as supply_controlled_substance_code,
        pos.prescription as supply_prescription,
        pos.do_not_fill as supply_do_not_fill,
        pos.inventory_on_hand as inventory_on_hand,
        pos.next_refill_date as next_refill_date,
        psd.pharmacy_order_id as pharmacy_order_id,
        CASE  WHEN ip.pharmacy_id IS NULL THEN 'N' ELSE 'Y' END 'integrated_pharmacy',
        pos.active as supply_active,
        mmdb.dbo.fn_pho_getImageFilenameByNDC(pos.drug_code) as imageFileName, -- PCC-33017
        pos.drug_code as drug_code
    FROM pho_order_supply pos
        INNER JOIN  @result result ON [result].phys_order_id = pos.phys_order_id
        LEFT JOIN emc_ext_facilities eef ON eef.ext_fac_id = pos.pharmacy_id
        left join pho_supply_dispense psd on psd.order_supply_id = pos.order_supply_id and psd.deleted='N'
        LEFT JOIN @integratedPharmacies ip
                    ON ip.pharmacy_id = pos.pharmacy_id
    WHERE (pos.active = 'Y' or pos.active = 'N') AND pos.deleted = 'N'
    ORDER BY pos.created_date DESC

SET @step = 10

SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return Administrative orders'
    IF @debug='Y'
        PRINT @status_text


-- administrative orders
select vpao.*, secuser.long_username 'created_by_long' , secuser.designation_desc as created_by_designation, ccc.item_description as created_by_position
,csua.long_username confirmed_by_username, csua.position_description as confirmed_by_position, csua.designation_desc as confirmed_by_designation, ua.confirmed_date as confirmed_date
FROM view_pho_administrative_order vpao
inner JOIN @result r ON r.phys_order_id = vpao.standard_phys_order_id
left join SEC_USER secuser on secuser.loginname = vpao.created_by
left join common_code ccc on ccc.item_id = secuser.position_id
left join pho_admin_order_useraudit ua ON ua.admin_order_id = vpao.admin_order_id
left join cp_sec_user_audit csua on csua.cp_sec_user_audit_id = ua.confirmed_by_audit_id
ORDER BY vpao.revision_date  DESC



/**
may have to revisit column selection
**/
    SET @step = 11
    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Return Schedules'
    IF @debug='Y'
      PRINT @status_text;

	WITH ORDER_SCHEDULES AS
	(
		SELECT
			vps.phys_order_id, vps.order_schedule_id, vps.order_schedule_start_date 'start_date', psd.last_admin_user, psd.last_admin_date, vps.order_schedule_end_date 'end_date', vps.end_date_type, vps.end_date_duration_type,
			vps.end_date_duration, vps.reassessment_required,  vps.schedule_directions, vps.additional_directions, vps.schedule_template, vps.schedule_type,
			vps.alternate_dose, vps.schedule_sliding_scale_id, vps.apply_remove_flag,
			vps.date_start,
			vps.date_stop,
			vps.dose_uom_id,
			vps.dose,
			vps.indications_for_use,
			vps.quantity_uom_id,
			vps.prn_admin,
			vps.prn_admin_units,
			vps.prn_admin_value,
			vps.apply_to,
			CASE WHEN oss.order_schedule_id is not null  THEN 1 ELSE 0 END as custom_sliding_scale_exists,
			vps.std_freq_id,
			vps.revision_date
		FROM view_pho_schedule vps
			LEFT OUTER JOIN dw_pho_order_schedule psd
				ON psd.order_schedule_id = vps.order_schedule_id
			LEFT JOIN pho_order_sliding_scale_range oss
				ON @includeSlidingScale='Y' AND oss.order_schedule_id=vps.order_schedule_id
			INNER JOIN @result r
				ON r.phys_order_id = vps.phys_order_id
		GROUP BY
			vps.phys_order_id, vps.order_schedule_id, vps.order_schedule_start_date, psd.last_admin_user, psd.last_admin_date, vps.order_schedule_end_date, vps.end_date_type, vps.end_date_duration_type,
			vps.end_date_duration, vps.reassessment_required,  vps.schedule_directions, vps.additional_directions, vps.schedule_template, vps.schedule_type,
			vps.alternate_dose, vps.schedule_sliding_scale_id,
			oss.order_schedule_id,
			vps.apply_remove_flag,
			vps.date_start,
			vps.date_stop,
			vps.dose_uom_id,
			vps.dose,
			vps.indications_for_use,
			vps.quantity_uom_id,
			vps.prn_admin,
			vps.prn_admin_units,
			vps.prn_admin_value,
			vps.apply_to,
			vps.std_freq_id,
			vps.revision_date
	)
	-- return: combine with schedules for struck-out orders
		SELECT * FROM ORDER_SCHEDULES
		UNION ALL
			SELECT
				psa.phys_order_id, psa.order_schedule_id, psa.schedule_start_date 'start_date', psd.last_admin_user, psd.last_admin_date, psa.schedule_end_date 'end_date', psa.schedule_end_date_type_id 'end_date_type', psa.schedule_duration_type_id 'end_date_duration_type',
				psa.schedule_duration 'end_date_duration', psa.reassessment_required,  psa.schedule_directions, psa.additional_directions, psa.schedule_template, psa.schedule_type,
				psa.alternate_dose_value 'alternate_dose', psa.sliding_scale_id 'schedule_sliding_scale_id', psa.apply_remove_flag,
				psa.date_start,
				psa.date_stop,
				psa.dose_uom_id,
				psa.dose_value 'dose',
				psa.indications_for_use,
				psa.quantity_uom_id,
				psa.prn_admin,
				psa.prn_admin_units,
				psa.prn_admin_value,
				psa.apply_to,
				CASE WHEN oss.order_schedule_id is not null  THEN 1 ELSE 0 END as custom_sliding_scale_exists,
				psa.std_freq_id,
				psa.revision_date
			FROM pho_order_schedule_audit psa
				INNER JOIN
				(
					SELECT MAX(posa.AUDIT_ID) 'latest_audit_id' FROM pho_order_schedule_audit posa
					INNER JOIN @result r ON r.phys_order_id = posa.phys_order_id AND r.status = 4
					GROUP BY posa.order_schedule_id
				) latest_schedule_audit ON latest_schedule_audit.latest_audit_id = PSA.audit_id
				INNER JOIN @orderStatus os	-- filter down to struck-out orders
					ON  os.status = 4
				LEFT OUTER JOIN dw_pho_order_schedule psd
					ON psd.order_schedule_id = psa.order_schedule_id
				LEFT JOIN pho_order_sliding_scale_range oss
					ON @includeSlidingScale='Y' AND oss.order_schedule_id=psa.order_schedule_id
				INNER JOIN @result r
					ON r.phys_order_id = psa.phys_order_id AND r.status = 4
			WHERE @includeStruckOutOrders = 'Y'
			GROUP BY
				psa.phys_order_id, psa.order_schedule_id, psa.schedule_start_date, psd.last_admin_user, psd.last_admin_date, psa.schedule_end_date, psa.schedule_end_date_type_id, psa.schedule_duration_type_id,
				psa.schedule_duration, psa.reassessment_required,  psa.schedule_directions, psa.additional_directions, psa.schedule_template, psa.schedule_type,
				psa.alternate_dose_value, psa.sliding_scale_id,
				oss.order_schedule_id,
				psa.apply_remove_flag,
				psa.date_start,
				psa.date_stop,
				psa.dose_uom_id,
				psa.dose_value,
				psa.indications_for_use,
				psa.quantity_uom_id,
				psa.prn_admin,
				psa.prn_admin_units,
				psa.prn_admin_value,
				psa.apply_to,
				psa.std_freq_id,
				psa.revision_date


     SET @step = 12

     SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return alerts '
     IF @debug='Y'
        PRINT @status_text

     /* ALERTS */
		SELECT PHYSORDER.PHYS_ORDER_ID   'phys_order_id',
               PHYSORDER.CLIENT_ID       'client_id',
               ALERT.ALERT_ID            'alert_id',
               ALERT.DESCRIPTION         'alert_desc',
               ALERT.MODULE              'module',
               ALERT.CREATED_DATE        'alert_created_date',
               ALERT.EFFECTIVE_DATE      'effective_date',
               ALERT.TRIGGERED_ITEM_ID   'triggered_item_id',
               ALERT.TRIGGERED_ITEM_TYPE 'triggered_item_type',
               ALERT.RESOLVED            'resolved',
               ALERT.RESOLVED_BY         'resolved_by',
			   CATITC.TRIGGERED_ITEM_TYPE_CATEGORY_ID 'triggered_item_type_category_id'
        FROM   @result PHYSORDER
               LEFT OUTER JOIN CR_ALERT ALERT
                 ON ALERT.TRIGGERED_ITEM_ID = PHYSORDER.PHYS_ORDER_ID
					and alert.fac_id = @facIdLocal
					and ( @clientIdLocal is null or alert.client_id=@clientIdLocal )
                    AND ALERT.TRIGGERED_ITEM_TYPE IN ('O', 'M') AND ALERT.RESOLVED <> 'Y' AND ALERT.deleted = 'N'
				LEFT OUTER JOIN CR_ALERT_TRIGGERED_ITEM_TYPE_CATEGORY CATITC
				 ON CATITC.ALERT_ID = ALERT.alert_id
		WHERE ALERT.ALERT_ID IS NOT NULL
        ORDER  BY ALERT.EFFECTIVE_DATE ASC


     SET @step = 13

     SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return the total number of records '
     IF @debug='Y'
        PRINT @status_text

     select @num_records as num_records

      SET @step = 14

     SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return alerts for Supplies '
     IF @debug='Y'
        PRINT @status_text

     /* ALERTS */
            SELECT PHYSORDER.PHYS_ORDER_ID   'phys_order_id',
               PHYSORDER.CLIENT_ID       'client_id',
               POS.ORDER_SUPPLY_ID        'order_supply_id',
               ALERT.ALERT_ID            'alert_id',
               ALERT.DESCRIPTION         'alert_desc',
               ALERT.MODULE              'module',
               ALERT.CREATED_DATE        'alert_created_date',
               ALERT.EFFECTIVE_DATE      'effective_date',
               ALERT.TRIGGERED_ITEM_ID   'triggered_item_id',
               ALERT.TRIGGERED_ITEM_TYPE 'triggered_item_type',
               ALERT.RESOLVED            'resolved',
               ALERT.RESOLVED_BY         'resolved_by'
        	FROM   pho_order_supply POS
                 LEFT JOIN @result PHYSORDER ON PHYSORDER.PHYS_ORDER_ID = POS.PHYS_ORDER_ID and (@clientIdLocal is null or PHYSORDER.client_id=@clientIdLocal )
               	 LEFT JOIN CR_ALERT ALERT ON ALERT.TRIGGERED_ITEM_ID = POS.ORDER_SUPPLY_ID and alert.fac_id = @facIdLocal and ALERT.client_id = PHYSORDER.client_id


       		 WHERE (
                           -- Only Show Pharmacy initated alerts
                           ALERT.TRIGGERED_ITEM_TYPE = 'C'
                                                OR ALERT.TRIGGERED_ITEM_TYPE = 'O'
                                                OR ALERT.TRIGGERED_ITEM_TYPE = 'D'
                                                OR ALERT.TRIGGERED_ITEM_TYPE = 'T'
                                         )
                                  AND ALERT.deleted = 'N'
       		 ORDER  BY ALERT.EFFECTIVE_DATE ASC

    SELECT r.phys_order_id, poda.severity_code
    FROM @result r
     INNER JOIN @physOrderDrugInteraction poda ON poda.phys_order_id= r.phys_order_id

    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Done'
    IF @debug='Y'
        PRINT @status_text
    SET @status_code = 0
    GOTO PgmSuccess
END TRY
--error trapping
BEGIN CATCH
    SELECT @error_code = @@error, @status_text = 'Error at step:'+convert(varchar(3),@step)+', '+ERROR_MESSAGE()

    SET @status_code = 1

    GOTO PgmAbend

END CATCH

--program success return
PgmSuccess:

IF @status_code = 0
BEGIN
    IF @debug='Y' PRINT 'Successfull execution of stored procedure'
    RETURN @status_code
END

--program failure return
PgmAbend:

IF @debug='Y' PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '   ' + convert(varchar(26),getdate())
    IF @debug='Y' PRINT 'Error code: '+convert(varchar(3),@error_code) + '; Error description:    ' +@status_text
    RETURN @status_code

GO
GRANT EXECUTE ON sproc_pho_list_residentchart TO public
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_pho_list_residentchart.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_residentchart.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_residentchart_v2.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*****************************************************************************************************
**  Created By:
**  Created Date:
**
**	Purpose:  To return a list of Physician Orders.
**			 Please note that this stored procedure is a copy of 'sproc_pho_list_residentchart' but has all MMDB references removed.
**
**
**	Params:
**			@facId
**			@clientId
**			@facilityDateTime
**			@orderCategoryIdsCSV
**			@orderStatusCSV
**			@startDateoperator
**			@startDate
***			@endDateoperator
**			@endDate
**			@orderDateoperator
**			@orderDate
**			@createdBy
**			@orderedById
**			@orderTypeId
**			@adminRecordId
**			@routeOfAdminIdsCSV
**			@communicationMethodIdsCSV
**			@medicationSourceId
**			@pharmacyId
**			@providerId
**			@showLegacyOrder
**			@clientIdNumber
**			@clientStatus
**			@unit
**			@floor
**			@completedDate
**			@completedDateoperator
**			@discontinuedDate
**			@discontinuedDateoperator
**			@confirmedDate datetime,
**			@confirmedDateoperator
**			@confirmedBy
**			@medication
**			@medicationclassification
**			@holdDate
**			@holdDateoperator
**			@supplyStatusId
**			@fromIntegratedPharmacy
**			@medSrcTypeId
**			@physOrderId
**			@narcoticsOnly     - Narcotics order or not, 'Y' or 'N'
**          @alwaysShowOrderWithAlert
**			@orderLinkedOption	- (1) None, (2) Only, (3) Both
**			@orderClassId	- smallint (-1) All (1) Institutional order, (2) Discharge order
**			@includeRetired	- Show deleted physicians or not , 'Y' or 'N' 
**			@includeSlidingScale - show sliding scale information or not, 'Y' or 'N'. Defaulted to 'N'.
**			@historicalOrdersOnly - get historical orders only or not, 'Y' or 'N'. Defaulted to 'N'
**			@historicalOrdersOnlyPeriodStart - start of period to get historical orders for, if null get all historical orders
**			@debug          - Debug param, 'Y' or 'N'
**			@status_code    - SP execution flag, 0 for success.
**			@status_text    - SP error text if error occurs.
**
**  Special Instructions:  Run view_pho_order stsus first before running this
**	sproc during the build process.
**
**  Revision History:
**  2012-09-06        PCC-32548   Feng  Xia      added a new search criteria for showing only narcotics drugs
**  2012-04-03        PCC-29069   Nabil Hamade   changed order by from revision_date to edited_date for orders list
**  2016-04-04        PCC-92113   Ramin Shojaei Add condition to include deleted (retired) physician in the result set
**  2016-11-17 		  PCC-105022  Veerpal Khanuja	Added schedule_sliding_scale_id and flag custom_sliding_scale_exists in result set for schedules.
**  2016-11-17 		  PCC-105019  Veerpal Khanuja	Added alternate_dose in result set for schedules.
**	2017-01-23		  PCC-107915  Devika Bapat		Added apply_remove_flag in result set for schedules.
**	2017-03-08		  PCC-110558  Devika Bapat		Added date_start, date_stop, dose_uom_id, dose, indications_for_use, 
													quantity_uom_id, prn_admin, prn_admin_units, prn_admin_value, for schedules. 
**	2017-04-06		  PCC-113549  Devika Bapat		Added apply_to in result set for schedules.
**	2017-11-08		  CORE-5680   Elias Ghanem		Added condition to select historical orders only based on the historicalOrdersOnly and historicalOrdersOnlyPeriodStart parameters.
**  2018-01-03		  CORE-7999   Hao Liu           Added support to filter by old medical professional id if new id provided
**  2018-12-18		  CORE-24715  Samuel Martey     Changed the return block to return the schedules for struck-out orders as well to build directions from them.
**  2019-01-02		  CORE-24715  Samuel Martey     Optimize cases for selecting struck-out orders. Do not select when not requested in the union query
**  2019-03-11		  CORE-35559  Henry Jin			Added join to the table cr_alert_triggered_item_type_category when fecthing alerts.  
**  2019-07-17		  CORE-46275  Elias Ghanem		Return alerts of type 'O' or 'M' instead of only 'O'. Also modify the sorting of the returned result set to be
**													ASC instead of DESC. The sorting modification will not affect the final result displayed to the user since the Java code
**													handling the result set has been modified accordingly.  
**  2019-08-01		  CORE-43789  Elias Ghanem		Add configuration parameters to return orders having alerts of type M or having supplies with alerts of type D regardless of their status
**  2020/09/03 		  CORE-71858  Elias Ghanem 		When computing if order has Allergy, D2D or blackBox alerts, include alerts for supplies even even if the supplies are in Processed By Pharmacy status (3) not only if 
**													they are On Hand
**	2021-01-22  	  CORE-83505  Elias Ghanem      Add revision_date field to the schedules result set
**  2021-11-18 		  CORE-97119  Sree Naghasundharam  Created this new stored procedure 'sproc_pho_list_residentchart_v2' and Removed MMDB references
******************************************************************************************************************************************************/
IF EXISTS (SELECT *
               FROM
                   dbo.sysobjects
               WHERE
                   id = object_id(N'[dbo].[sproc_pho_list_residentchart_v2]')
                   AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
    DROP PROCEDURE [dbo].[sproc_pho_list_residentchart_v2]

SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[sproc_pho_list_residentchart_v2]   @facId                        INT, --required
                                                        @clientId                     INT, --required
                                                        @facilityDateTime             DATETIME, --required
                                                        @orderCategoryIdsCSV          varchar(100), -- required comma seperated list of categegory id
                                                        @orderStatusCSV               varchar(100),
                                                        @startDateoperator            INT = 0, --0 equal to, -1 less than, 1 greater than
                                                        @startDate                    DATETIME, -- date to compare,
                                                        @endDateoperator              INT = 0, --0 equal to, -1 less than, 1 greater than
                									    @endDate                      DATETIME, -- date to compare,
                                                        @orderDateoperator            INT = 0, --0 equal to, -1 less than, 1 greater than
                                                        @orderDate                    DATETIME, -- date to compare,
                                                        @createdBy                    varchar(60),
                                                        @orderedById int,
                                                        @orderTypeId int,
                                                        @adminRecordId int,
                                                        @routeOfAdminIdsCSV varchar(50),
                                                        @communicationMethodIdsCSV varchar(50), -- required comma seperated list of communication method id
                                                        @medicationSourceId int,
                                                        @pharmacyId int,
                                                        @providerId int,
                                                        @showLegacyOrder char(1), -- Null both , Y - show only legacy order, N - show only new orders
                                                        @clientIdNumber varchar(100),
                                                        @clientStatus int,
                                                        @unit int,
                                                        @floor int,
                                                        @completedDate datetime,
                                                        @completedDateoperator int = 0, --0 equal to, -1 less than, 1 greater than
                                                        @discontinuedDate datetime,
                                                        @discontinuedDateoperator int = 0, --0 equal to, -1 less than, 1 greater than
                                                        @confirmedDate datetime,
                                                        @confirmedDateoperator int = 0, --0 equal to, -1 less than, 1 greater than
                                                        @confirmedBy varchar(100),
                                                        @medication varchar(200),
                                                        @medicationclassification varchar(200),
                                                        @holdDate datetime,
                                                        @holdDateoperator int = 0, --0 equal to, -1 less than, 1 greater than
                                                        @supplyStatusId     int,
                                                        @fromIntegratedPharmacy char(1),
                                                        @medSrcTypeId       int,
                                                        @physOrderId int,
                                                        @pageSize int,
                                                        @pageNumber int,
                                                        @sortByColumn varchar(100),
                                                        @sortByOrder  varchar(10),
                                                        @narcoticsOnly     char(1)  = 'N',
                                                        @alwaysShowOrderWithAlert char(1) = 'N',
														@orderLinkedOption	int,
														@orderClassId		smallint, -- required
														@pharmacyNCPDP varchar(10),
														@includeRetired char(1) = 'Y',
														@includeSlidingScale char(1)='N',
														@historicalOrdersOnly char(1) = 'N',
														@historicalOrdersOnlyPeriodStart datetime,
														@debug              char(1)  = 'N',
														@status_code        int  = 0 out,
                                                        @status_text        varchar(3000) out
                                                          --useful when debugging within sqlserver studio



/***********************************************************************************************

Purpose:
This procedure provides data shown on Resident' Order Chart
This procedure does not use VIEW_PHO_PHYS_ORDER

*************************************************************************************************/

AS
BEGIN TRY
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

DECLARE @step                       			int,
        @error_code                 			int,
        @num_records							int,
		@facIdLocal								int,
		@clientIdLocal							int,
		@drugAllergyCheckEnabled    			char,
		@drugInteractionEnabled					char,
		@doseCheckEnabled						char,
        @blackBoxEnabled						char,
		@orderClassId_local         			smallint,
		@pharmacyNCPDP_local					varchar(10),
		@oldOrderById							int,
		@includeStruckOutOrders					char,
		@showOrdersWithIntegrationAlerts 		varchar(1),
		@showOrdersWithSupplyIntegrationAlerts 	varchar(1)

set @clientIdLocal = @clientId
set @facIdLocal = @facId
SET @step = 0
SET @error_code = 0
SET @orderClassId_local = @orderClassId
SET @pharmacyNCPDP_local = @pharmacyNCPDP
SET @showOrdersWithIntegrationAlerts = 'Y'
SET @showOrdersWithSupplyIntegrationAlerts = 'Y'

SELECT @drugAllergyCheckEnabled=ISNULL(value,'N') FROM configuration_parameter WHERE name='enable_drug_allergy_check' AND value='Y' AND fac_id=@facId
SELECT @drugInteractionEnabled=ISNULL(value,'N') FROM configuration_parameter WHERE name='enable_drug_interaction' AND value='Y' AND fac_id=@facId
SELECT @doseCheckEnabled=ISNULL(value,'N') FROM configuration_parameter WHERE name='enable_dose_check' AND value='Y' AND fac_id=@facId
SELECT @blackBoxEnabled=ISNULL(value,'N') FROM configuration_parameter WHERE name='enable_black_box' AND value='Y' AND fac_id=@facId
SELECT @showOrdersWithIntegrationAlerts=ISNULL(value,'Y') FROM configuration_parameter WHERE name='show_orders_with_integration_alerts' AND value='N' AND fac_id=@facId
SELECT @showOrdersWithSupplyIntegrationAlerts=ISNULL(value,'Y') FROM configuration_parameter WHERE name='show_orders_with_supply_integration_alerts' AND value='N' AND fac_id=@facId

SET @oldOrderById = dbo.fn_medprof_getOldMedicalProfessionalId(@orderedById, @facId)

    DECLARE @result TABLE
	--create table #result
    (

        phys_order_id int not null PRIMARY KEY
        ,status int
        ,relationship int
        ,status_reason int
        ,fac_id int NOT NULL
        ,client_id int NOT NULL
        ,diet_type int
        ,diet_texture int
        ,diet_supplement int
        ,fluid_consistency int
        ,alter_med_src int
        ,nurse_pharm_notes varchar(512)
        ,created_by varchar(60)
        ,created_by_longname varchar(100)
        ,created_date datetime
        ,date_ordered datetime
        ,description varchar(500)
        ,related_generic varchar(250)
        ,dispense_as_written varchar(1)
        ,directions varchar(1000)
		,strength varchar(30)
        ,drug_strength varchar(100)
        ,drug_strength_uom varchar(10)
        ,discontinued_date datetime
        ,end_date datetime
        ,hold_date datetime
        ,hold_date_end datetime
        ,last_reorder_date datetime
        ,order_type_id int
        ,order_category_id int
        ,order_category_description varchar(250)
        ,family_portal_sort_order tinyint
        ,order_date datetime
        ,order_status int
        ,physician_id int
        ,reorder varchar(1)
        ,revision_by varchar(60)
        ,revision_date datetime
        ,edited_date datetime
        ,route_of_admin int
        ,start_date datetime
        ,order_verified varchar(1)
        ,next_refill_date datetime
        ,do_not_fill varchar(1)
        ,first_documented datetime
        ,origin_id int
        ,controlled_substance_code varchar(50)
        ,pharmacy_id int
        ,communication_method int
        ,legacy_order varchar(1)
        ,discharge_date datetime
        ,client_id_number varchar(35)
        ,resident_last_name varchar(50)
        ,resident_first_name varchar(50)
        ,orig_phys_order_id int
        ,pho_ext_lib_id int
        ,pho_ext_lib_med_id int
        ,pho_ext_lib_med_ddid int
        ,ext_lib_rxnorm_id varchar(10)
        ,strikeout_date datetime
        ,strikeout_by varchar(60)
		,strikeout_reason_code varchar(254)
		,vendor_phys_order_id varchar(30)
		,advanced_directive varchar(1)
		,end_date_filter datetime
		,linked_set_id int
		,linked_set_name varchar(100)
		,order_class_id tinyint
    )

	declare @orderData table
    (
        phys_order_id int not null PRIMARY KEY
        ,status int
        ,relationship int
        ,status_reason int
        ,fac_id int NOT NULL
        ,client_id int NOT NULL
        ,diet_type int
        ,diet_texture int
        ,diet_supplement int
        ,fluid_consistency int
        ,alter_med_src int
        ,nurse_pharm_notes varchar(512)
        ,created_by varchar(60)
        ,created_by_longname varchar(100)
        ,created_date datetime
        ,date_ordered datetime
        ,calculated_description varchar(500)
        ,related_generic varchar(250)
        ,dispense_as_written varchar(1)
        ,directions varchar(1000)
		,strength varchar(30)
        ,drug_strength varchar(100)
        ,drug_strength_uom varchar(10)
        ,discontinued_date datetime
        ,end_date datetime
        ,hold_date datetime
        ,hold_date_end datetime
        ,last_reorder_date datetime
        ,order_type_id int
        ,order_category_id int
        ,order_category_description varchar(250)
        ,family_portal_sort_order tinyint
        ,order_date datetime
        ,order_status int
        ,physician_id int
        ,reorder varchar(1)
        ,revision_by varchar(60)
        ,revision_date datetime
        ,edited_date datetime
        ,route_of_admin int
        ,start_date datetime
        ,order_verified varchar(1)
        ,next_refill_date datetime
        ,do_not_fill varchar(1)
        ,first_documented datetime
        ,origin_id int
        ,controlled_substance_code varchar(50)
        ,pharmacy_id int
        ,communication_method int
        ,legacy_order varchar(1)
        ,discharge_date datetime
        ,client_id_number varchar(35)
        ,resident_last_name varchar(50)
        ,resident_first_name varchar(50)
        ,orig_phys_order_id int
        ,pho_ext_lib_id int
        ,pho_ext_lib_med_id int
        ,pho_ext_lib_med_ddid int
        ,ext_lib_rxnorm_id varchar(10)
		,vendor_phys_order_id varchar(30)
		,advanced_directive varchar(1)
		, confirmed_by_audit_id int
       , ppone_phys_order_id int
		,description varchar(500)
		,linked_set_id int
		,linked_set_name varchar(100)
		,order_class_id tinyint
    )

   	declare @vpos table (
	[phys_order_id] [int] NOT NULL,
	[fac_id] [int] NOT NULL,
	[order_status] [int] NOT NULL,
	[order_relationship] [int] NULL,
	[status_reason] int NULL
	)

    DECLARE @routeOfAdminIds TABLE
    (
        route_of_admin int  not null
    )

    DECLARE @orderCategoryIds TABLE
    (
        order_category_id int  not null
    )

    DECLARE @communicationMethodIds TABLE
    (
        method_id int  not null
    )

    DECLARE @orderStatus TABLE
    (
        [status] int  not null
    )

    DECLARE @integratedPharmacies TABLE
    (
        pharmacy_id int not null
    )

    DECLARE @supplyCriteria TABLE
    (
        phys_order_id int not null
    )

	  DECLARE @medicationClassificationIds TABLE
    (
        medication_classification_id varchar(10) not null
    )

    DECLARE @physOrderAllergies TABLE
    (
      phys_order_id int  NOT NULL
    )

    DECLARE @physOrderDrugInteraction TABLE
    (
      phys_order_id int  NOT NULL,
      severity_code varchar(1)
    )

    DECLARE @physOrderBlackbox TABLE
    (
      phys_order_id int  NOT NULL
    )

    DECLARE @physOrderDoseCheck TABLE
    (
      phys_order_id int  NOT NULL,
      over_dose varchar(1)
    )

    DECLARE @physOrderNoDrugProtocolCheck TABLE
    (
      phys_order_id int  NOT NULL
    )

	DECLARE @dischargePharmacyNCPDP TABLE
    (
        discharge_pharm_phys_order_id int not null
    )

	DECLARE @ordersHavingAlerts TABLE
	(
		phys_order_id int  NOT NULL
	)

SET @step = 1
    INSERT INTO @orderCategoryIds (order_category_id)
    select * from dbo.Split(@orderCategoryIdsCSV, ',')
	delete from @orderCategoryIds where order_category_id=1 or order_category_id=3030
SET @step = 2
    INSERT INTO @communicationMethodIds (method_id)
    select * from dbo.Split(@communicationMethodIdsCSV, ',')
SET @step = 3
    INSERT INTO @routeOfAdminIds (route_of_admin)
    select * from dbo.Split(replace(@routeOfAdminIdsCSV,'_',','), ',')
SET @step = 4
    INSERT INTO @orderStatus (status)
    select * from dbo.Split(@orderStatusCSV, ',');
	SET @includeStruckOutOrders = CASE WHEN EXISTS (SELECT os.status FROM @orderStatus os WHERE status = 4) THEN 'Y' ELSE 'N' END;
SET @step = 5
    INSERT INTO @medicationClassificationIds (medication_classification_id)
    select * from dbo.Split(@medicationclassification, ',')

SET @step = 41
	INSERT INTO @integratedPharmacies (pharmacy_id)
	select distinct extFacId from (
		SELECT mp.ext_fac_id as extFacId
			FROM message_profile mp WITH (NOLOCK)
			INNER JOIN lib_message_profile lmp WITH (NOLOCK)
				ON lmp.message_profile_id = mp.message_profile_id
			       AND lmp.deleted = 'N' and lmp.is_enabled='Y'
			WHERE mp.is_enabled = 'Y' and mp.is_integrated_pharmacy='Y'
			AND mp.fac_id = @facIdLocal
			AND mp.message_protocol_id = 12
			GROUP BY mp.ext_fac_id
		UNION
		SELECT distinct mi.internal_id as extFacId
			FROM map_identifier mi WITH (NOLOCK)
			INNER JOIN lib_message_profile libmp WITH (NOLOCK)
			ON libmp.vendor_code = mi.vendor_code
			AND libmp.deleted = 'N'
			INNER JOIN message_profile mp WITH (NOLOCK)
			ON libmp.message_profile_id = mp.message_profile_id
			WHERE mi.map_type_id = 3 and mp.fac_id = @facIdLocal and  mi.fac_id = @facIdLocal
	) a where extFacId is not null

-- put all criteria related to pho_order_supply in here so that we
-- can make sure they interact correctly and we don't need a hundred
-- different subqueries in the main query, also only populate it if
-- we're going to need it
SET @step = 42
    IF @supplyStatusId IS NOT NULL
          OR @fromIntegratedPharmacy IS NOT NULL
          OR @medSrcTypeId IS NOT NULL
    BEGIN
      INSERT INTO @supplyCriteria (phys_order_id)
        SELECT phys_order_id
          FROM pho_order_supply WITH (NOLOCK)
          WHERE (active = 'Y' OR active = 'N')
            AND deleted = 'N'
            AND (@supplyStatusId IS NULL OR status = @supplyStatusId)
            AND (
              @fromIntegratedPharmacy IS NULL
              OR (
                @fromIntegratedPharmacy = 'Y'
                AND pharmacy_id IN (select * from @integratedPharmacies)
              )
              OR (
                @fromIntegratedPharmacy = 'N'
                AND pharmacy_id NOT IN (select * from @integratedPharmacies)
              )
            )
            AND (@medSrcTypeId IS NULL OR med_src_type_id = @medSrcTypeId)
    END

set @step = 43
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Function call'
IF @debug='Y'
PRINT @status_text

DECLARE @now datetime
set @now = dbo.fn_facility_getCurrentTime(@facIdLocal)

insert into @vpos
exec sproc_pho_getOrderStatus  @facIdLocal,@clientIdLocal,@physOrderId,@now,'N',@debug,@status_code out,@status_text out

SET @step = 5
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Start getting med classification'
IF @debug='Y'
    PRINT @status_text


	declare @medicationclassificationTable table
	(
		phys_order_id	int
	)

	if( @medicationclassification is not null )
	BEGIN
		insert into @medicationclassificationTable
		SELECT distinct poelmr.phys_order_id from pho_order_ext_lib_med_ref poelmr WITH (NOLOCK) INNER JOIN
		(
			SELECT poelc.phys_order_ext_lib_rec_id, pho_ext_lib_class_id 'class_id' from pho_order_ext_lib_cls poelc WITH (NOLOCK)
			UNION
			SELECT poelc.phys_order_ext_lib_rec_id, pho_ext_lib_sub_class_id 'class_id' from pho_order_ext_lib_cls poelc WITH (NOLOCK)
		) classes ON classes.phys_order_ext_lib_rec_id = poelmr.phys_order_ext_lib_rec_id
		INNER JOIN @medicationClassificationIds mclassids on classes.class_id = mclassids.medication_classification_id
    INNER JOIN @vpos vpos on vpos.phys_order_id = poelmr.phys_order_id
	END


SET @step = 5
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert orders/client/mpi data.'
IF @debug='Y'
    PRINT @status_text

declare @clientInfo table
(
	fac_id int,
	client_id int,
	discharge_date datetime,
	client_id_number varchar(35),
	first_name	varchar(50),
	last_name	varchar(50)
)
insert into @clientInfo ( 	fac_id , client_id , discharge_date , client_id_number,first_name, last_name )
select distinct
	c.fac_id,
	c.client_id,
	 c.discharge_date
     , c.client_id_number
     , m.last_name
     , m.first_name
from
	clients c
	INNER JOIN mpi  m  WITH (NOLOCK) ON m.mpi_id = c.mpi_id
where
c.client_id = @clientIdLocal




SET @step = 5
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Get common data for queries.'
IF @debug='Y'
    PRINT @status_text

IF(@orderClassId_local > -1)
BEGIN
	insert into @orderData
	select
		distinct ppo.phys_order_id
				 ,vpos.order_status
				 ,vpos.order_relationship
				 ,vpos.status_reason
				 , ppo.fac_id
				 , ppo.client_id
				 , ppo.diet_type
				 , ppo.diet_texture
				 , ppo.diet_supplement
				 , ppo.fluid_consistency
				 , ppo.alter_med_src
				 , ppo.nurse_pharm_notes
				 , ppo.created_by
				 , createdBySu.long_username
				 , ppo.created_date
				 , ppo.date_ordered
				 , case when ppo.order_category_id=3031 then diettype.item_description
							 when ppo.order_category_id=3032 then dietsup.item_description
							 when ppo.order_category_id=3023 then diettype.item_description
							 when ppo.order_category_id=3033 then 'Enteral Feed'
							 else ppo.description
						end 'calculated_description'
				 , ppo.related_generic
				 , ppo.dispense_as_written
				 , ppo.directions
				 , ppo.strength
				 , ppo.drug_strength
				 , ppo.drug_strength_uom
				 , ppo.discontinued_date
				 , ppo.end_date
				 , ppo.hold_date
				 , ppo.hold_date_end
				 , ppo.last_reorder_date
				 , ppo.order_type_id
				 , ppo.order_category_id
				 , ordercat.category_desc
				 , ordercat.family_portal_sort_order
				 , ppo.order_date
				 , ppo.order_status
				 , ppo.physician_id
				 , ppo.reorder
				 , ppo.revision_by
				 , ppo.revision_date
				 , CASE WHEN useraudit.edited_date is null THEN ppo.revision_date ELSE useraudit.edited_date END  'useraudit.edited_date'
				 , ppo.route_of_admin
				 , ppo.start_date
				 , isnull(ppo.order_verified, 'Y') 'order_verified'
				 , ppo.next_refill_date
				 , ppo.do_not_fill
				 , ppo.first_documented
				 , ppo.origin_id
				 , ppo.controlled_substance_code
				 , ppo.pharmacy_id
				 , ppo.communication_method
				 , CASE WHEN ppone.phys_order_id is null THEN 'Y' ELSE 'N' END  'ppone.phys_order_id'
				 , c.discharge_date
				 , c.client_id_number
				 , c.last_name
				 , c.first_name
				 , ppo.orig_phys_order_id
				 , lib.pho_ext_lib_id
				 , lib.pho_ext_lib_med_id
				 , lib.pho_ext_lib_med_ddid
				 , lib.ext_lib_rxnorm_id
				 , ppo.vendor_phys_order_id
				 , case
					when pso.std_order_id is not null and (pso.advanced_directive=1) then 'Y'
					when pstd.std_phys_order_id is not null and (pstd.advanced_directive='Y') then 'Y'
					else 'N'
				  end as 'advanced_directive'
				, confirmed_by_audit_id
				, ppone.phys_order_id
				, ppo.description
				, ls.linked_set_id
				, ls.set_description
				, ppo.order_class_id
	from
		@clientInfo c
		INNER JOIN pho_phys_order ppo WITH (NOLOCK)
			ON c.client_id = ppo.client_id
		INNER JOIN @vpos vpos
			ON vpos.phys_order_id = ppo.phys_order_id
		LEFT JOIN pho_phys_order_new_entry ppone WITH (NOLOCK)
			ON ppone.phys_order_id = ppo.phys_order_id
		LEFT JOIN pho_order_ext_lib_med_ref lib WITH (NOLOCK)
			ON lib.phys_order_id = ppo.phys_order_id AND lib.deleted='N'
		LEFT JOIN pho_std_phys_order pstd WITH (NOLOCK)
			ON pstd.std_phys_order_id = ppo.std_order_id
		LEFT JOIN pho_std_order pso WITH (NOLOCK)
			ON pso.std_order_id = ppo.std_order_id
		LEFT JOIN pho_phys_order_useraudit useraudit WITH (NOLOCK)
			ON useraudit.phys_order_id = ppo.phys_order_id
		LEFT JOIN PHO_ORDER_CATEGORY ordercat WITH (NOLOCK)
     		ON ppo.order_category_id = ordercat.order_category_id
		LEFT JOIN sec_user createdBySu  WITH (NOLOCK)
     		ON createdBySu.loginname = ppo.created_by
		LEFT JOIN COMMON_CODE diettype WITH (NOLOCK)
			ON ppo.diet_type = diettype.item_id
		LEFT JOIN COMMON_CODE dietsup WITH (NOLOCK)
			ON ppo.diet_supplement = dietsup.item_id
		LEFT JOIN pho_linked_set_item lsi on lsi.phys_order_id=ppo.phys_order_id
		LEFT JOIN pho_linked_set ls on ls.linked_set_id=lsi.linked_set_id

	where
		( @physOrderId IS NULL OR ppo.phys_order_id = @physOrderId  )
		AND (isnull(ppo.active_flag, 'Y') = 'Y')
		AND
			(
				(@narcoticsOnly = 'N')
				OR
				(
					ppo.controlled_substance_code IS NOT NULL AND LTRIM(RTRIM(ppo.controlled_substance_code)) IN ('2','3','4','5','6','99')
				)
			)
		AND (@orderLinkedOption=3 or (@orderLinkedOption=2 and lsi.phys_order_id=ppo.phys_order_id)
			or (@orderLinkedOption=1 and lsi.phys_order_id is null))
		AND order_class_id = @orderClassId_local
END
ELSE -- get both Institutional orders and Discharge orders
BEGIN
	insert into @orderData
	select
		distinct ppo.phys_order_id
				 ,vpos.order_status
				 ,vpos.order_relationship
				 ,vpos.status_reason
				 , ppo.fac_id
				 , ppo.client_id
				 , ppo.diet_type
				 , ppo.diet_texture
				 , ppo.diet_supplement
				 , ppo.fluid_consistency
				 , ppo.alter_med_src
				 , ppo.nurse_pharm_notes
				 , ppo.created_by
				 , createdBySu.long_username
				 , ppo.created_date
				 , ppo.date_ordered
				 , case when ppo.order_category_id=3031 then diettype.item_description
							 when ppo.order_category_id=3032 then dietsup.item_description
							 when ppo.order_category_id=3023 then diettype.item_description
							 when ppo.order_category_id=3033 then 'Enteral Feed'
							 else ppo.description
						end 'calculated_description'
				 , ppo.related_generic
				 , ppo.dispense_as_written
				 , ppo.directions
				 , ppo.strength
				 , ppo.drug_strength
				 , ppo.drug_strength_uom
				 , ppo.discontinued_date
				 , ppo.end_date
				 , ppo.hold_date
				 , ppo.hold_date_end
				 , ppo.last_reorder_date
				 , ppo.order_type_id
				 , ppo.order_category_id
				 , ordercat.category_desc
				 , ordercat.family_portal_sort_order
				 , ppo.order_date
				 , ppo.order_status
				 , ppo.physician_id
				 , ppo.reorder
				 , ppo.revision_by
				 , ppo.revision_date
				 , CASE WHEN useraudit.edited_date is null THEN ppo.revision_date ELSE useraudit.edited_date END  'useraudit.edited_date'
				 , ppo.route_of_admin
				 , ppo.start_date
				 , isnull(ppo.order_verified, 'Y') 'order_verified'
				 , ppo.next_refill_date
				 , ppo.do_not_fill
				 , ppo.first_documented
				 , ppo.origin_id
				 , ppo.controlled_substance_code
				 , ppo.pharmacy_id
				 , ppo.communication_method
				 , CASE WHEN ppone.phys_order_id is null THEN 'Y' ELSE 'N' END  'ppone.phys_order_id'
				 , c.discharge_date
				 , c.client_id_number
				 , c.last_name
				 , c.first_name
				 , ppo.orig_phys_order_id
				 , lib.pho_ext_lib_id
				 , lib.pho_ext_lib_med_id
         , lib.pho_ext_lib_med_ddid
         , lib.ext_lib_rxnorm_id
				 , ppo.vendor_phys_order_id
				 , case
					when pso.std_order_id is not null and (pso.advanced_directive=1) then 'Y'
					when pstd.std_phys_order_id is not null and (pstd.advanced_directive='Y') then 'Y'
					else 'N'
				  end as 'advanced_directive'
				, confirmed_by_audit_id
				, ppone.phys_order_id
				, ppo.description
				, ls.linked_set_id
				, ls.set_description
				, ppo.order_class_id
	from
		@clientInfo c
		INNER JOIN pho_phys_order ppo WITH (NOLOCK)
			ON c.client_id = ppo.client_id
		INNER JOIN @vpos vpos
			ON vpos.phys_order_id = ppo.phys_order_id
		LEFT JOIN pho_phys_order_new_entry ppone WITH (NOLOCK)
			ON ppone.phys_order_id = ppo.phys_order_id
		LEFT JOIN pho_order_ext_lib_med_ref lib WITH (NOLOCK)
			ON lib.phys_order_id = ppo.phys_order_id AND lib.deleted='N'
		LEFT JOIN pho_std_phys_order pstd WITH (NOLOCK)
			ON pstd.std_phys_order_id = ppo.std_order_id
		LEFT JOIN pho_std_order pso WITH (NOLOCK)
			ON pso.std_order_id = ppo.std_order_id
		LEFT JOIN pho_phys_order_useraudit useraudit WITH (NOLOCK)
			ON useraudit.phys_order_id = ppo.phys_order_id
		LEFT JOIN PHO_ORDER_CATEGORY ordercat WITH (NOLOCK)
     		ON ppo.order_category_id = ordercat.order_category_id
		LEFT JOIN sec_user createdBySu  WITH (NOLOCK)
     		ON createdBySu.loginname = ppo.created_by
		LEFT JOIN COMMON_CODE diettype WITH (NOLOCK)
			ON ppo.diet_type = diettype.item_id
		LEFT JOIN COMMON_CODE dietsup WITH (NOLOCK)
			ON ppo.diet_supplement = dietsup.item_id
		LEFT JOIN pho_linked_set_item lsi on lsi.phys_order_id=ppo.phys_order_id
		LEFT JOIN pho_linked_set ls on ls.linked_set_id=lsi.linked_set_id

	where
		( @physOrderId IS NULL OR ppo.phys_order_id = @physOrderId  )
		AND (isnull(ppo.active_flag, 'Y') = 'Y')
		AND
			(
				(@narcoticsOnly = 'N')
				OR
				(
					ppo.controlled_substance_code IS NOT NULL AND LTRIM(RTRIM(ppo.controlled_substance_code)) IN ('2','3','4','5','6','99')
				)
			)
		AND (@orderLinkedOption=3 or (@orderLinkedOption=2 and lsi.phys_order_id=ppo.phys_order_id)
			or (@orderLinkedOption=1 and lsi.phys_order_id is null))
END

-- remove the orders from @orderData that does not match the discharge order pharmacy only when discharge order and when the pharmacy search is provided
IF(@pharmacyNCPDP_local is not null)
BEGIN
	insert into @dischargePharmacyNCPDP
	select s.phys_order_id from pho_phys_order_discharge_snapshot s
	inner join @orderData o on o.phys_order_id = s.phys_order_id and o.order_class_id = 2
	where ncpdp_identifier = @pharmacyNCPDP_local

	delete from @orderData where order_class_id = 2 and phys_order_id NOT IN (select discharge_pharm_phys_order_id from @dischargePharmacyNCPDP)
END

SET @step = 5
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert non struckout orders into cache'
IF @debug='Y'
    PRINT @status_text
    INSERT INTO @result
    SELECT
		distinct
		 ppo.phys_order_id
        ,ppo.status
        ,ppo.relationship
        ,ppo.status_reason
        ,ppo.fac_id
        ,ppo.client_id
        ,ppo.diet_type
        ,ppo.diet_texture
        ,ppo.diet_supplement
        ,ppo.fluid_consistency
        ,ppo.alter_med_src
        ,ppo.nurse_pharm_notes
        ,ppo.created_by
        ,ppo.created_by_longname
        ,ppo.created_date
        ,ppo.date_ordered
        ,ppo.calculated_description
        ,ppo.related_generic
        ,ppo.dispense_as_written
        ,ppo.directions
		,ppo.strength
        ,ppo.drug_strength
        ,ppo.drug_strength_uom
        ,ppo.discontinued_date
        ,ppo.end_date
        ,ppo.hold_date
        ,ppo.hold_date_end
        ,ppo.last_reorder_date
        ,ppo.order_type_id
        ,ppo.order_category_id
        ,ppo.order_category_description
        ,ppo.family_portal_sort_order
        ,ppo.order_date
        ,ppo.order_status
        ,ppo.physician_id
        ,ppo.reorder
        ,ppo.revision_by
        ,ppo.revision_date
        ,ppo.edited_date
        ,ppo.route_of_admin
        ,ppo.start_date
        ,ppo.order_verified
        ,ppo.next_refill_date
        ,ppo.do_not_fill
        ,ppo.first_documented
        ,ppo.origin_id
        ,ppo.controlled_substance_code
        ,ppo.pharmacy_id
        ,ppo.communication_method
        ,ppo.legacy_order
        ,ppo.discharge_date
        ,ppo.client_id_number

        ,ppo.resident_last_name
        ,ppo.resident_first_name
        ,ppo.orig_phys_order_id
        ,ppo.pho_ext_lib_id
        ,ppo.pho_ext_lib_med_id
        ,ppo.pho_ext_lib_med_ddid
        ,ppo.ext_lib_rxnorm_id
		,null
		,null
		,null
		,ppo.vendor_phys_order_id
		,ppo.advanced_directive
        ,ppo.end_date
		,ppo.linked_set_id
		,ppo.linked_set_name
		,ppo.order_class_id
           FROM
				@orderData ppo
				INNER JOIN @orderStatus os
					on  os.status = ppo.status
				INNER JOIN @communicationMethodIds cm
					ON cm.method_id = isnull(ppo.communication_method, 3027)
				INNER JOIN @orderCategoryIds oc
					ON oc.order_category_id = ppo.order_category_id
				LEFT JOIN pho_order_type orderType WITH (NOLOCK)
            		ON ppo.order_type_id = orderType.order_type_id
				LEFT JOIN pho_order_supply pos
        			ON ppo.phys_order_id = pos.phys_order_id
				LEFT JOIN pho_phys_order_useraudit  useraudit
				    on useraudit.phys_order_id = ppo.phys_order_id
				LEFT JOIN pho_administration_record  adminRecord WITH (NOLOCK)
            		ON orderType.administration_record_id = adminRecord.administration_record_id
				LEFT JOIN cp_sec_user_audit confuser  WITH (NOLOCK)
					ON confuser.cp_sec_user_audit_id = ppo.confirmed_by_audit_id
				LEFT JOIN contact physcon ON physcon.contact_id = ppo.physician_id
            WHERE

                (@providerId IS NULL OR ppo.pharmacy_id = @providerId)
                AND
                (@orderedById IS NULL OR ppo.physician_id = @orderedById OR ppo.physician_id = @oldOrderById)
                AND
                (@orderTypeId IS NULL OR ppo.order_type_id = @orderTypeId)
                AND
                (@adminRecordId IS NULL OR adminRecord.administration_record_id = @adminRecordId)
                AND
                (@routeOfAdminIdsCSV IS NULL OR ppo.route_of_admin IN (SELECT route_of_Admin from @routeOfAdminIds))
                AND
                (@medicationSourceId IS NULL OR ppo.alter_med_src = @medicationSourceId)
                AND
                (@pharmacyId IS NULL OR ppo.pharmacy_id = @pharmacyId)
                AND
                (@createdBy is NULL OR ppo.created_by = @createdBy)
                AND
				(@confirmedBy is NULL OR confuser.loginname = @confirmedBy)

                --AND
                -- do not show invalid category and administrative orders
                --ppo.order_category_id <> 1 AND ppo.order_category_id <> 3030
                AND
                (
                    (@orderDate IS NULL OR @orderDateoperator IS NULL)
                    OR
                    (
                        (@orderDateoperator = 0 AND ppo.order_date >= @orderDate AND ppo.order_date < @orderDate + 1)
                        OR (@orderDateoperator = 1 AND ppo.order_date >= @orderDate + 1)
                        OR (@orderDateoperator = -1 AND ppo.order_date < @orderDate)
                    )
                )
                AND
                (
                    (@startDate IS NULL OR @startDateoperator IS NULL)
                    OR
                    (
                        (@startDateoperator = 0 AND ppo.start_date >= @startDate AND ppo.start_date < @startDate + 1)
                        OR (@startDateoperator = 1  AND ppo.start_date >= @startDate + 1)
                        OR (@startDateoperator = -1 AND ppo.start_date < @startDate)
                    )
                )
                AND
                (
                    (@endDate IS NULL OR @endDateoperator IS NULL)
                    OR
                    (
                        (@endDateoperator = 0 AND ppo.end_date >= @endDate AND ppo.end_date < @endDate + 1)
                        OR (@endDateoperator = 1  AND (ppo.end_date >= @endDate + 1 OR ppo.end_date IS NULL))
                        OR (@endDateoperator = -1 AND ppo.end_date < @endDate)
                    )
                )
	            AND
	            (
	                (@discontinuedDate IS NULL OR @discontinuedDateoperator IS NULL)
	                OR
	                (
	                    (@discontinuedDateoperator = 0 AND ppo.discontinued_date >= @discontinuedDate AND ppo.discontinued_date < @discontinuedDate + 1)
	                    OR (@discontinuedDateoperator = 1  AND ppo.discontinued_date >= @discontinuedDate + 1)
	                    OR (@discontinuedDateoperator = -1 AND ppo.discontinued_date < @discontinuedDate)
	                )
	            )
				AND
	            (
	                --This condition is to handle historical orders case ie to filter historical orders only when the proc is called in that scenario
					--If @historicalOrdersOnly = 'N' => the proc IS NOT called for historical orders only scenario and therefore this condition should not prevent returing the order (by testing order endDate and discontinuedDate)
					--If @historicalOrdersOnly = 'Y' but @historicalOrdersOnlyPeriodStart IS NULL => the proc IS called for historical orders only scenario but WITH NO limit on the period therefore this condition should not prevent returning the order neither (by testing order endDate and discontinuedDate)
					--If @historicalOrdersOnly = 'Y' and @historicalOrdersOnlyPeriodStart IS NOT NULL => the proc IS called for historical orders only scenario and WITH limit on the period and therefore, in order to be returned, order should fall in the specified period (order endDate and discontinuedDate should verify the below conditions)
					(@historicalOrdersOnlyPeriodStart IS NULL OR @historicalOrdersOnly = 'N')
	                OR
					(
					(ppo.end_Date IS NULL OR ppo.end_Date > @historicalOrdersOnlyPeriodStart)
					AND (ppo.discontinued_Date IS NULL OR ppo.discontinued_Date > @historicalOrdersOnlyPeriodStart)
					)

	            )
	            AND
	            (
	                (@holdDate IS NULL OR @holdDateoperator IS NULL)
	                OR
	                (
	                    (@holdDateoperator = 0 AND ppo.hold_date >= @holdDate AND ppo.hold_date < @holdDate + 1)
	                    OR (@holdDateoperator = 1  AND ppo.hold_date >= @holdDate + 1)
	                    OR (@holdDateoperator = -1 AND ppo.hold_date < @holdDate)
	                )
	            )
	            AND
	            (
	                (@completedDate IS NULL OR @completedDateoperator IS NULL)
	                OR
	                (
	                    (@completedDateoperator = 0 AND ppo.end_date >= @completedDate AND ppo.end_date < @completedDate + 1)
	                    OR (@completedDateoperator = 1  AND ppo.end_date >= @completedDate + 1)
	                    OR (@completedDateoperator = -1 AND ppo.end_date < @completedDate)
	                )
	            )
	            AND
	            (
	                (@confirmedDate IS NULL OR @confirmedDateoperator IS NULL)
	                OR
	                (
	                    (@confirmedDateoperator = 0 AND useraudit.confirmed_date >= @confirmedDate AND useraudit.confirmed_date < @confirmedDate + 1)
	                    OR (@confirmedDateoperator = 1  AND useraudit.confirmed_date >= @confirmedDate + 1)
	                    OR (@confirmedDateoperator = -1 AND useraudit.confirmed_date < @confirmedDate)
	                )
	            )
                AND
                (@showLegacyOrder IS NULL OR (@showLegacyOrder='Y' AND ppone_phys_order_id IS NULL) OR (@showLegacyOrder='N' AND ppone_phys_order_id IS NOT NULL))

                    AND
					(@medication IS NULL OR ppo.description LIKE '%' + @medication + '%' OR (pos.description LIKE '%' + @medication + '%'AND pos.active = 'Y'))
                    AND
                    (@clientIdNumber IS NULL OR client_id_number = @clientIdNumber)
                    AND
                    (
                        @clientStatus IS NULL
                        --discharged
                        OR (@clientStatus = 0 AND discharge_date IS NOT NULL AND discharge_date <= @facilityDateTime)
                        --active
                        OR (@clientStatus = 1 AND (discharge_date IS NULL OR discharge_date > @facilityDateTime))
                    )
                    AND
                    (
	                    @medicationclassification IS NULL OR
	                    ppo.phys_order_id  IN
	                    (
	                        select * from @medicationclassificationTable
	                    )
                    )
                    AND (
                      (
                        @supplyStatusId IS NULL
                        AND @fromIntegratedPharmacy IS NULL
                        AND @medSrcTypeId IS NULL
                      )
                      OR (
                        ppo.phys_order_id IN (select * from @supplyCriteria)
                      )
                    )
                    AND
                    ( @physOrderId IS NULL OR ppo.phys_order_id = @physOrderId  )
					AND (physcon.deleted = CASE WHEN @includeRetired = 'Y' THEN physcon.deleted ELSE 'N' END  OR ppo.physician_id IS NULL OR physcon.deleted is NULL)

            ORDER BY ppo.revision_by desc


--PCC-26565: Any orders (regardless of status) with alerts should always show in orders chart
SET @step = 51
if (@alwaysShowOrderWithAlert = 'Y')
BEGIN
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert orders having alerts into cache - considering duplicated order id'

	INSERT INTO @ordersHavingAlerts
	SELECT DISTINCT
	ppo.phys_order_id
	FROM @orderData ppo
	INNER JOIN cr_alert ca WITH (NOLOCK) ON
											ca.fac_id = ppo.fac_id
											AND ca.client_id = ppo.client_id
											AND ca.triggered_item_id = ppo.phys_order_id
											AND ca.triggered_item_type = 'O'
											AND ca.resolved <> 'Y'
											AND ca.deleted = 'N'
	WHERE ppo.status = 3 -- Consider Completed orders only

if (@showOrdersWithIntegrationAlerts = 'Y')
	INSERT INTO @ordersHavingAlerts
	SELECT DISTINCT
	ppo.phys_order_id
	FROM @orderData ppo
	INNER JOIN cr_alert ca WITH (NOLOCK) ON
											ca.fac_id = ppo.fac_id
											AND ca.client_id = ppo.client_id
											AND ca.triggered_item_id = ppo.phys_order_id
											AND ca.triggered_item_type = 'M'
											AND ca.resolved <> 'Y'
											AND ca.deleted = 'N'


if(@showOrdersWithSupplyIntegrationAlerts = 'Y')
	INSERT INTO @ordersHavingAlerts
	SELECT DISTINCT
	ppo.phys_order_id
	FROM @orderData ppo
	INNER JOIN pho_order_supply s ON s.phys_order_id = ppo.phys_order_id
	INNER JOIN cr_alert ca WITH (NOLOCK) ON
											ca.fac_id = ppo.fac_id
											AND ca.client_id = ppo.client_id
											AND ca.triggered_item_id = s.order_supply_id
											AND ca.triggered_item_type = 'D'
											AND ca.resolved <> 'Y'
											AND ca.deleted = 'N'


IF @debug='Y'
    PRINT @status_text
    INSERT INTO @result
    SELECT distinct
			ppo.phys_order_id
        ,ppo.status
        ,ppo.relationship
        ,ppo.status_reason
        ,ppo.fac_id
        ,ppo.client_id
        ,ppo.diet_type
        ,ppo.diet_texture
        ,ppo.diet_supplement
        ,ppo.fluid_consistency
        ,ppo.alter_med_src
        ,ppo.nurse_pharm_notes
        ,ppo.created_by
        ,ppo.created_by_longname
        ,ppo.created_date
        ,ppo.date_ordered
        ,ppo.calculated_description
        ,ppo.related_generic
        ,ppo.dispense_as_written
        ,ppo.directions
		,ppo.strength
        ,ppo.drug_strength
        ,ppo.drug_strength_uom
        ,ppo.discontinued_date
        ,ppo.end_date
        ,ppo.hold_date
        ,ppo.hold_date_end
        ,ppo.last_reorder_date
        ,ppo.order_type_id
        ,ppo.order_category_id
        ,ppo.order_category_description
        ,ppo.family_portal_sort_order
        ,ppo.order_date
        ,ppo.order_status
        ,ppo.physician_id
        ,ppo.reorder
        ,ppo.revision_by
        ,ppo.revision_date
        ,ppo.edited_date
        ,ppo.route_of_admin
        ,ppo.start_date
        ,ppo.order_verified
        ,ppo.next_refill_date
        ,ppo.do_not_fill
        ,ppo.first_documented
        ,ppo.origin_id
        ,ppo.controlled_substance_code
        ,ppo.pharmacy_id
        ,ppo.communication_method
        ,ppo.legacy_order
        ,ppo.discharge_date
        ,ppo.client_id_number
        ,ppo.resident_last_name
        ,ppo.resident_first_name
        ,ppo.orig_phys_order_id
        ,ppo.pho_ext_lib_id
        ,ppo.pho_ext_lib_med_id
        ,ppo.pho_ext_lib_med_ddid
        ,ppo.ext_lib_rxnorm_id
		,null
		,null
		,null
		,ppo.vendor_phys_order_id
		,ppo.advanced_directive
		,ppo.end_date
		,ppo.linked_set_id
		,ppo.linked_set_name
		,ppo.order_class_id
           FROM
            @orderData ppo
			INNER JOIN @orderCategoryIds oc
				ON oc.order_category_id = ppo.order_category_id
			INNER JOIN @ordersHavingAlerts oha ON oha.phys_order_id = ppo.phys_order_id
			LEFT JOIN contact physcon ON physcon.contact_id = ppo.physician_id
             WHERE
				oha.phys_order_id not in ( select phys_order_id from @result )
				AND (physcon.deleted = CASE WHEN @includeRetired = 'Y' THEN physcon.deleted ELSE 'N' END OR ppo.physician_id IS NULL OR physcon.deleted is NULL)
                --AND
                -- do not show invalid category and administrative orders
                --ppo.order_category_id <> 1 AND ppo.order_category_id <> 3030

            ORDER BY ppo.revision_by desc
END

SET @step = 6
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert struckout orders into cache = "' + CONVERT(VARCHAR(1), @includeStruckOutOrders) + '"';
IF @debug='Y'
    PRINT @status_text;
	IF @includeStruckOutOrders = 'Y'
	BEGIN
		WITH AUDIT AS
		(
			SELECT
				ppo.phys_order_id 'phys_order_id'
				 ,4  'status'
				 ,NULL	as relationship
				 ,NULL  as status_reason
				 , ppo.fac_id 'fac_id'
				 , ppo.client_id 'client_id'
				 , ppo.diet_type 'diet_type'
				 , ppo.diet_texture 'diet_texture'
				 , ppo.diet_supplement 'diet_supplement'
				 , ppo.fluid_consistency 'fluid_consistency'
				 , ppo.alter_med_src 'alter_med_src'
				 , ppo.created_by 'created_by'
				 --, createdBySu.long_username 'created_by_longname'
				 , ppo.created_date 'created_date'
				 , ppo.date_ordered 'date_ordered'
				/* , case when ppo.order_category_id=3031 then diettype.item_description
							 when ppo.order_category_id=3032 then dietsup.item_description
							 when ppo.order_category_id=3023 then diettype.item_description
							 when ppo.order_category_id=3033 then 'Enteral Feed'
							 else ppo.description
						end 'description'*/
				 , ppo.related_generic 'related_generic'
				 , ppo.dispense_as_written 'dispense_as_written'
				 , ppo.directions 'directions'
				 , ppo.strength
				 , ppo.drug_strength 'drug_strength'
				 , ppo.drug_strength_uom 'drug_strength_uom'
				 , ppo.discontinued_date 'discontinued_date'
				 , ppo.end_date 'end_date'
				 , ppo.hold_date 'hold_date'
				 , ppo.hold_date_end 'hold_date_end'
				 , ppo.last_reorder_date 'last_reorder_date'
				 , ppo.order_type_id 'order_type_id'
				 , ppo.order_category_id 'order_category_id'
				-- , ordercat.category_desc  'order_category_description'
				 , ppo.order_date 'order_date'
				 , ppo.order_status 'order_status'
				 , ppo.physician_id 'physician_id'
				 , ppo.reorder 'reorder'
				 , ppo.revision_by 'revision_by'
				 , ppo.revision_date 'revision_date'
				 , ppo.revision_date 'edited_date'
				 , ppo.route_of_admin 'route_of_admin'
				 , ppo.start_date 'start_date'
				 , isnull(ppo.order_verified, 'Y') 'order_verified'
				 , ppo.next_refill_date 'next_refill_date'
				 , ppo.do_not_fill 'do_not_fill'
				 , ppo.first_documented 'first_documented'
				 , ppo.origin_id 'origin_id'
				 , ppo.controlled_substance_code 'controlled_substance_code'
				 , ppo.pharmacy_id 'pharmacy_id'
				 , ppo.communication_method 'communication_method'
				-- , CASE WHEN ppone.phys_order_id is null THEN 'Y' ELSE 'N' END  'legacy_order'
				 , c.discharge_date 'discharge_date'
				 , c.client_id_number 'client_id_number'
				 , c.last_name 'resident_last_name'
				 , c.first_name 'resident_first_name'
				 , ppo.orig_phys_order_id 'orig_phys_order_id'
			   --  , lib.pho_ext_lib_id
			   --  , lib.pho_ext_lib_med_id
				 , ppo.strikeout_date
				 , ppo.strikeout_by
			   --  , strike_code.item_description 'strikeout_reason_description'
  	     		 , ppo.vendor_phys_order_id
  			  --	 , isnull(pstd.advanced_directive, 'N') 'advanced_directive'

		--added
				,ppo.std_order_id
				,ppo.active_flag
				,ppo.description
				,ppo.strikeout_reason_code
				,c.first_name
				,c.last_name
				,order_class_id
			FROM
					pho_phys_order_audit ppo WITH (NOLOCK)
					INNER JOIN @clientInfo c
						ON c.client_id = ppo.client_id
					INNER JOIN @orderStatus os
						on  os.status = 4
			WHERE
					ppo.event_type = 'S'
					--required
					AND ppo.fac_id = @facIdLocal
					AND c.fac_id = @facIdLocal
					AND ppo.order_class_id = @orderClassId_local
		)

		INSERT INTO @result
		SELECT distinct adt.phys_order_id 'phys_order_id'
				 ,4 'status'
				 ,NULL
				 ,NULL
				 , adt.fac_id 'fac_id'
				 , adt.client_id 'client_id'
				 , adt.diet_type 'diet_type'
				 , adt.diet_texture 'diet_texture'
				 , adt.diet_supplement 'diet_supplement'
				 , adt.fluid_consistency 'fluid_consistency'
				 , adt.alter_med_src 'alter_med_src'
				 , null
				 , adt.created_by 'created_by'
				 , createdBySu.long_username 'created_by_longname'
				 , adt.created_date 'created_date'
				 , adt.date_ordered 'date_ordered'
				 , case when adt.order_category_id=3031 then diettype.item_description
							 when adt.order_category_id=3032 then dietsup.item_description
							 when adt.order_category_id=3023 then diettype.item_description
							 when adt.order_category_id=3033 then 'Enteral Feed'
							 else adt.description
						end 'description'
				 , adt.related_generic 'related_generic'
				 , adt.dispense_as_written 'dispense_as_written'
				 , adt.directions 'directions'
				 , adt.strength
				 , adt.drug_strength 'drug_strength'
				 , adt.drug_strength_uom 'drug_strength_uom'
				 , adt.discontinued_date 'discontinued_date'
				 , adt.end_date 'end_date'
				 , adt.hold_date 'hold_date'
				 , adt.hold_date_end 'hold_date_end'
				 , adt.last_reorder_date 'last_reorder_date'
				 , adt.order_type_id 'order_type_id'
				 , adt.order_category_id 'order_category_id'
				 , ordercat.category_desc  'order_category_description'
				 , ordercat.family_portal_sort_order 'family_portal_sort_order'
				 , adt.order_date 'order_date'
				 , adt.order_status 'order_status'
				 , adt.physician_id 'physician_id'
				 , adt.reorder 'reorder'
				 , adt.revision_by 'revision_by'
				 , adt.revision_date 'revision_date'
				 , adt.revision_date 'edited_date'
				 , adt.route_of_admin 'route_of_admin'
				 , adt.start_date 'start_date'
				 , isnull(adt.order_verified, 'Y') 'order_verified'
				 , adt.next_refill_date 'next_refill_date'
				 , adt.do_not_fill 'do_not_fill'
				 , adt.first_documented 'first_documented'
				 , adt.origin_id 'origin_id'
				 , adt.controlled_substance_code 'controlled_substance_code'
				 , adt.pharmacy_id 'pharmacy_id'
				 , adt.communication_method 'communication_method'
				 , CASE WHEN ppone.phys_order_id is null THEN 'Y' ELSE 'N' END  'legacy_order'
				 , adt.discharge_date 'discharge_date'
				 , adt.client_id_number 'client_id_number'
				 , adt.last_name 'resident_last_name'
				 , adt.first_name 'resident_first_name'
				 , adt.orig_phys_order_id 'orig_phys_order_id'
				 , lib.pho_ext_lib_id
				 , lib.pho_ext_lib_med_id
				 , lib.pho_ext_lib_med_ddid
				 , lib.ext_lib_rxnorm_id

				 , adt.strikeout_date
				 , adt.strikeout_by
				 , strike_code.item_description 'strikeout_reason_description'
  	     		 , adt.vendor_phys_order_id
				 , case
					when pso.std_order_id is not null and (pso.advanced_directive=1) then 'Y'
					when pstd.std_phys_order_id is not null and (pstd.advanced_directive='Y') then 'Y'
					else 'N'
				  end as 'advanced_directive'
  	      		 ,adt.end_date
				 ,null
				 ,null
				 ,adt.order_class_id
				FROM AUDIT adt
					/*pho_phys_order_audit ppo WITH (NOLOCK)
					INNER JOIN @clientInfo c
						ON c.client_id = ppo.client_id
					INNER JOIN @orderStatus os
						on  os.status = 4*/
					INNER JOIN @communicationMethodIds cm
						ON cm.method_id = isnull(adt.communication_method, 3027)
					INNER JOIN @orderCategoryIds oc
						ON oc.order_category_id = adt.order_category_id
					LEFT JOIN pho_order_type orderType  WITH (NOLOCK)
        				ON adt.order_type_id = orderType.order_type_id
					LEFT JOIN pho_order_supply pos
        				ON adt.phys_order_id = pos.phys_order_id
					LEFT JOIN pho_administration_record  adminRecord WITH (NOLOCK)
        				ON orderType.administration_record_id = adminRecord.administration_record_id
					LEFT JOIN pho_phys_order_new_entry ppone WITH (NOLOCK)
						ON ppone.phys_order_id = adt.phys_order_id
					LEFT JOIN pho_order_ext_lib_med_ref lib WITH (NOLOCK)
						ON lib.phys_order_id = adt.phys_order_id
					LEFT JOIN COMMON_CODE strike_code WITH (NOLOCK)
						ON strike_code.item_id = adt.strikeout_reason_code
					LEFT JOIN pho_phys_order_useraudit useraudit WITH (NOLOCK)
							ON useraudit.phys_order_id = adt.phys_order_id
					LEFT JOIN cp_sec_user_audit confuser  WITH (NOLOCK)
							ON confuser.cp_sec_user_audit_id = useraudit.confirmed_by_audit_id
					LEFT JOIN pho_std_phys_order pstd WITH (NOLOCK)
						ON pstd.std_phys_order_id = adt.std_order_id
					LEFT JOIN pho_std_order pso WITH (NOLOCK)
						ON pso.std_order_id = adt.std_order_id
					LEFT JOIN PHO_ORDER_CATEGORY ordercat WITH (NOLOCK)
        				ON adt.order_category_id = ordercat.order_category_id
        			LEFT JOIN sec_user createdBySu  WITH (NOLOCK)
        				ON createdBySu.loginname = adt.created_by
					-- for sorting on description
					LEFT JOIN COMMON_CODE diettype WITH (NOLOCK)
						ON adt.diet_type = diettype.item_id
					LEFT JOIN COMMON_CODE dietsup WITH (NOLOCK)
						ON adt.diet_supplement = dietsup.item_id
					LEFT JOIN CONTACT physcon
					ON adt.physician_id = physcon.contact_id

					WHERE
					/*ppo.event_type = 'S'

					--required
					AND adt.fac_id = @facIdLocal
					AND c.fac_id = @facIdLocal
					AND*/
					(@providerId IS NULL OR adt.pharmacy_id = @providerId)
					AND
					(@orderedById IS NULL OR adt.physician_id = @orderedById OR adt.physician_id = @oldOrderById)
					AND
					(@orderTypeId IS NULL OR adt.order_type_id = @orderTypeId)
					AND
					(@adminRecordId IS NULL OR adminRecord.administration_record_id = @adminRecordId)
					AND
					(@routeOfAdminIdsCSV IS NULL OR adt.route_of_admin IN (SELECT route_of_Admin from @routeOfAdminIds))
					AND
					(@medicationSourceId IS NULL OR adt.alter_med_src = @medicationSourceId)
					AND
					(@pharmacyId IS NULL OR adt.pharmacy_id = @pharmacyId)
					AND
					(@createdBy is NULL OR adt.created_by = @createdBy)
					AND
					(@confirmedBy is NULL OR confuser.loginname = @confirmedBy)

					--AND
					-- do not show invalid category and administrative orders
					--ppo.order_category_id <> 1 AND ppo.order_category_id <> 3030
					AND
					(
						(@orderDate IS NULL OR @orderDateoperator IS NULL)
						OR
						(
							(@orderDateoperator = 0 AND adt.order_date >= @orderDate AND adt.order_date < @orderDate + 1)
							OR (@orderDateoperator = 1 AND adt.order_date >= @orderDate + 1)
							OR (@orderDateoperator = -1 AND adt.order_date < @orderDate)
						)
					)
					AND
					(
						(@startDate IS NULL OR @startDateoperator IS NULL)
						OR
						(
							(@startDateoperator = 0 AND adt.start_date >= @startDate AND adt.start_date < @startDate + 1)
							OR (@startDateoperator = 1  AND adt.start_date >= @startDate + 1)
							OR (@startDateoperator = -1 AND adt.start_date < @startDate)
						)
					)
					AND
					(
						(@endDate IS NULL OR @endDateoperator IS NULL)
						OR
						(
							(@endDateoperator = 0 AND adt.end_date >= @endDate AND adt.end_date < @endDate + 1)
							OR (@endDateoperator = 1  AND (adt.end_date >= @endDate + 1 OR adt.end_date IS NULL))
							OR (@endDateoperator = -1 AND adt.end_date < @endDate)
						)
					)
					AND
					(@showLegacyOrder IS NULL OR (@showLegacyOrder='Y' AND ppone.phys_order_id IS NULL) OR (@showLegacyOrder='N' AND ppone.phys_order_id IS NOT NULL))

						AND
						(@medication IS NULL OR adt.description LIKE '%' + @medication + '%' OR (pos.description LIKE '%' + @medication + '%'AND pos.active = 'Y'))
						AND
						(@clientIdNumber IS NULL OR adt.client_id_number = @clientIdNumber)
						AND
						(
							@clientStatus IS NULL
							--discharged
							OR (@clientStatus = 0 AND adt.discharge_date IS NOT NULL AND adt.discharge_date <= @facilityDateTime)
							--active
							OR (@clientStatus = 1 AND (adt.discharge_date IS NULL OR adt.discharge_date > @facilityDateTime))
						)
						AND
						(
							@medicationclassification IS NULL OR
							adt.phys_order_id  IN
							(
								select * from @medicationclassificationTable
							)
						)
						AND (
						  (
							@supplyStatusId IS NULL
							AND @fromIntegratedPharmacy IS NULL
							AND @medSrcTypeId IS NULL
						  )
						  OR (
							adt.phys_order_id IN (select * from @supplyCriteria)
						  )
						)
						AND
						( @physOrderId IS NULL OR adt.phys_order_id = @physOrderId  )
						AND
						(isnull(adt.active_flag, 'Y') = 'Y')
						AND (physcon.deleted = CASE WHEN @includeRetired = 'Y' THEN physcon.deleted ELSE 'N' END OR adt.physician_id IS NULL OR physcon.deleted is NULL)
				ORDER BY adt.revision_by desc
	END

SET @step = 7
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Do pagination'
IF @debug='Y'
    PRINT @status_text

select @num_records = count(*) from @result

-- when page number is 2 and there is only one page
-- hur 34499
if  @pageSize > 0 and (@pageSize * (@pageNumber-1)) >= @num_records
begin
	set @pageNumber = 1
end

IF (@sortByColumn = 'end_date')
BEGIN
	update  r
		set r.end_date_filter = r.discontinued_date from @result r where r.discontinued_date is not null
END

IF @sortByOrder='desc'
BEGIN
	;with tmp as
	(
		select row_number() over(ORDER BY
									 case
										when @sortByColumn = 'resident_last_name' then resident_last_name
										when @sortByColumn = 'description' then description
										when @sortByColumn = 'status' then CONVERT(varchar(50),status)
										when @sortByColumn = 'order_category_description' then order_category_description
										when @sortByColumn = 'created_date' then CONVERT(varchar(50),created_date,112)
										when @sortByColumn = 'created_by_longname' then created_by_longname
										when @sortByColumn = 'revision_date' then CONVERT(varchar(50),edited_date,112)
										when @sortByColumn = 'start_date' then CONVERT(varchar(50),start_date,112)
										when @sortByColumn = 'end_date' then CONVERT(varchar(50),end_date_filter,112)
										when @sortByColumn = 'family_portal_sort_order' then CONVERT(varchar(50),family_portal_sort_order)
										else CONVERT(varchar(50),revision_date,112)
									end
									desc) as rn from @result
	)
		-- hur 34499
		delete from tmp where @pageSize > 0 and (rn <= (@pageSize * (@pageNumber-1)) or rn > (@pageSize * @pageNumber))
END
ELSE
BEGIN
	;with tmp as
	(
		select row_number() over(ORDER BY
										case
										when @sortByColumn = 'resident_last_name' then resident_last_name
										when @sortByColumn = 'description' then description
										when @sortByColumn = 'status' then CONVERT(varchar(50),status)
										when @sortByColumn = 'order_category_description' then order_category_description
										when @sortByColumn = 'created_date' then CONVERT(varchar(50),created_date,112)
										when @sortByColumn = 'created_by_longname' then created_by_longname
										when @sortByColumn = 'start_date' then CONVERT(varchar(50),start_date,112)
										when @sortByColumn = 'end_date' then CONVERT(varchar(50),end_date_filter,112)
										when @sortByColumn = 'revision_date' then CONVERT(varchar(50),edited_date,112)
										when @sortByColumn = 'family_portal_sort_order' then CONVERT(varchar(50),family_portal_sort_order)
										else CONVERT(varchar(50),revision_date,112)
									end
									asc ) as rn from @result
	)
		-- hur 34499
		delete from tmp where @pageSize > 0 and (rn <= (@pageSize * (@pageNumber-1)) or rn > (@pageSize * @pageNumber))
END


SET @step = 7
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Select allergies for given page of orders'
IF @debug='Y'
    PRINT @status_text

--Do this near the end so we can avoid having to join onto the pho_phys_order and pho_phys_order_audit table directly
--Here we can just use the "page" to get only the needed allergies
IF(@drugAllergyCheckEnabled='Y')
BEGIN

 INSERT INTO @physOrderAllergies
 SELECT DISTINCT r.phys_order_id
  FROM @result r
  LEFT JOIN pho_order_supply pos on pos.phys_order_id=r.phys_order_id AND (pos.active = 'Y' and (pos.status=3 or pos.status=4 or pos.status=8)) AND pos.deleted = 'N' -- Only consider active and ("processed by pharmacy", "on hand" or reordered) supplies
  LEFT JOIN pho_phys_order_allergy_acknowledgement pa on pa.phys_order_id = r.phys_order_id
  LEFT JOIN pho_order_supply_allergy posa on posa.order_supply_id = pos.order_supply_id
  INNER JOIN allergy a on (a.allergy_id = pa.allergy_id or a.allergy_id=posa.allergy_id) AND a.client_id=@clientId
 WHERE (status_id=1 or a.status_id=3) AND (resolved_date is null OR resolved_date > @facilityDateTime)


END

SET @step = 7.1
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Select related Drugs for a given page of orders'
IF @debug='Y'
    PRINT @status_text

--Do this near the end so we can avoid having to join onto the pho_phys_order and pho_phys_order_audit table directly
--Here we can just use the "page" to get only the needed related drugs

IF(@drugInteractionEnabled='Y')
BEGIN
 INSERT INTO @physOrderDrugInteraction
 SELECT DISTINCT r.phys_order_id , pda.severity_code
  FROM @result r
  LEFT JOIN pho_order_supply pos on pos.phys_order_id=r.phys_order_id AND (pos.active = 'Y' and (pos.status=3 or pos.status=4 or pos.status=8)) AND pos.deleted = 'N' -- Only consider active and ("processed by pharmacy", "on hand" or reordered) supplies
  INNER JOIN pho_phys_order_drug_acknowledgement pda on pda.phys_order_id = r.phys_order_id
END

IF(@blackBoxEnabled='Y')
BEGIN
 INSERT INTO @physOrderBlackbox
 SELECT DISTINCT r.phys_order_id
  FROM @result r
  LEFT JOIN pho_order_supply pos on pos.phys_order_id=r.phys_order_id AND (pos.active = 'Y' and (pos.status=3 or pos.status=4 or pos.status=8)) AND pos.deleted = 'N' -- Only consider active and ("processed by pharmacy", "on hand" or reordered)supplies
  INNER JOIN pho_phys_order_blackbox_acknowledgement pba on pba.phys_order_id = r.phys_order_id
END

IF(@doseCheckEnabled='Y')
BEGIN
  INSERT INTO @physOrderDoseCheck
  SELECT DISTINCT r.phys_order_id,pba.over_dose
  FROM @result r
  INNER JOIN pho_phys_order_dose_check_acknowledgement pba on pba.phys_order_id = r.phys_order_id
END

IF(@drugInteractionEnabled='Y' or @blackBoxEnabled='Y' or @doseCheckEnabled='Y')
BEGIN
  INSERT INTO @physOrderNoDrugProtocolCheck
  SELECT DISTINCT r.phys_order_id
  FROM @result r
  INNER JOIN pho_phys_order_no_drug_protocol_checks ndpc on ndpc.phys_order_id = r.phys_order_id
END


SET @step = 8

    /****************************************
    return final result
    ****************************************/
    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Return orders'
    IF @debug='Y'
        PRINT @status_text
    SELECT physorder.*

         , isnull(tpocs.pharmacy_confirmation_sent, 0) AS pharmacy_confirmation_sent
         , isnull(tpos.shipped, 0) AS shipped
         , ordercat.category_desc AS order_category_description
         , ordercat.family_portal_sort_order AS family_portal_sort_order
         , physcon.first_name AS physician_first_name
         , physcon.last_name AS physician_last_name
         , dietsup.item_description AS diet_supplement_description
         , diettexture.item_description AS diet_texture_description
         , diettype.item_description AS diet_type_description
         , fluidcon.item_description AS fluid_consistency_description
         , route.item_description AS route_description
         , adminRecord.short_description AS administration_record_short_description
         , altAdminRecord.short_description AS alt_administration_record_short_description
         , isnull(createdBySu.long_username, physorder.created_by) 'created_by_longname'
         , isnull(revisionBySu.long_username, physorder.created_by) 'revision_by_longname'
         , isnull(useraudit.created_by_audit_id, 0) AS created_by_audit_id
         , isnull(useraudit.edited_by_audit_id, 0) AS edited_by_audit_id
         , edituser.long_username AS edited_by_long
         , edituser.position_description AS edited_by_position
         , edituser.designation_desc AS edited_by_designation
         , createuser.long_username AS created_by_audit_long
         , createuser.position_description AS created_by_position
         , createuser.designation_desc AS created_by_designation
         , useraudit.confirmed_date
         , isnull(useraudit.confirmed_by_audit_id, 0) AS confirmed_by_audit_id
         , confuser.long_username AS confirmed_by_long
         , confuser.position_description AS confirmed_by_position
         , confuser.designation_desc AS confirmed_by_designation
         , eef.name as pharmacy_name
         , poa.phys_order_id AS allergy_phys_order_id
         , pob.phys_order_id AS blackbox_phys_order_id
         , pdc.phys_order_id AS dose_check_phys_order_id
         , pdc.over_dose AS over_dose_value
         , ndpc.phys_order_id as no_drug_protocol_check_phys_order_id
         ,ua.long_username as signedByName
         ,ISNULL((case when ua.designation_desc = '' THEN NULL ELSE ua.designation_desc end),ua.position_description) as signedByCredential
         ,os.signature_date as signedDate
         ,at.description as authenticationTypeDescription
         ,ss.description as sourceTypeDescription
         ,os.authentication_type_id as authenticationTypeId
         ,os.signature_type_id as signatureTypeId
         ,os.source_type_id as sourceTypeId
         ,nctrlsc.new_controlled_substance_code as new_controlled_substance_code
         ,ppoe.sign_contact_id as digitallySigned
         ,oq.quantity as prescription_quantity
         ,oq.unit_of_measure as prescription_quantity_uom
         ,oq.no_of_refills as prescription_no_of_refills
         ,oq.dispense_interval as prescription_dispense_interval
         ,oq.total_authorized_quantity as prescription_total_authorized_quantity
         ,ti.orig_phys_order_id as original_ti_phys_order_id

        FROM
            @result physorder
        LEFT JOIN (SELECT physorder.phys_order_id
                        , convert(BIT, count(physorder.phys_order_id)) AS pharmacy_confirmation_sent
                       FROM
                           pho_pharmacy_order pharmorder
                       INNER JOIN @result physorder
                           ON (pharmorder.phys_order_id = physorder.phys_order_id OR pharmorder.phys_order_id = physorder.orig_phys_order_id)
                       WHERE
                           pharmorder.fac_id = @facIdLocal
                           AND --active orders
                           physorder.status = 1
                           AND pharmorder.created_date > isnull(physorder.last_reorder_date, physorder.date_ordered)
                       GROUP BY
                           physorder.phys_order_id) tpocs
            ON tpocs.phys_order_id = physorder.phys_order_id
        LEFT JOIN (SELECT physorder.phys_order_id AS phys_order_id
                        , convert(BIT, count(physorder.phys_order_id)) AS shipped
                       FROM
                           pho_pharmacy_order pharmorder
                       INNER JOIN @result physorder
                           ON (pharmorder.phys_order_id = physorder.phys_order_id OR pharmorder.phys_order_id = physorder.orig_phys_order_id)
                       WHERE
                           pharmorder.fac_id = @facIdLocal
                           AND pharmorder.created_date > physorder.last_reorder_date
                           AND pharmorder.receive_status <> 7 --WeTypePhoReceiveStatus.PCC_ORDER_COMPLETE
                           AND physorder.reorder = 'Y'
                       GROUP BY
                           physorder.phys_order_id) tpos
            ON tpos.phys_order_id = physorder.phys_order_id
        LEFT JOIN PHO_ORDER_TYPE ordertype
            ON physorder.order_type_id = ordertype.order_type_id
        LEFT JOIN PHO_ADMINISTRATION_RECORD adminRecord
            ON ordertype.administration_record_id = adminRecord.administration_record_id
        LEFT JOIN PHO_ADMINISTRATION_RECORD altAdminRecord
            ON ordertype.alt_administration_record_id = altAdminRecord.administration_record_id -- PCC-7725 add alt admin record
        LEFT JOIN CONTACT physcon
            ON physorder.physician_id = physcon.contact_id
        LEFT JOIN PHO_ORDER_CATEGORY ordercat
            ON ordertype.order_category_id = ordercat.order_category_id
        LEFT JOIN COMMON_CODE diettype
            ON physorder.diet_type = diettype.item_id
        LEFT JOIN COMMON_CODE diettexture
            ON physorder.diet_texture = diettexture.item_id
        LEFT JOIN COMMON_CODE [route]
            ON physorder.route_of_admin = route.item_id
        LEFT JOIN COMMON_CODE dietsup
            ON physorder.diet_supplement = dietsup.item_id
        LEFT JOIN COMMON_CODE fluidcon
            ON physorder.fluid_consistency = fluidcon.item_id
        LEFT JOIN sec_user createdBySu
            ON createdBySu.loginname = physorder.created_by
        LEFT JOIN sec_user revisionBySu
            ON revisionBySu.loginname = physorder.revision_by
        LEFT JOIN pho_phys_order_useraudit useraudit
            ON useraudit.phys_order_id = physorder.phys_order_id
        LEFT JOIN cp_sec_user_audit edituser
            ON edituser.cp_sec_user_audit_id = useraudit.edited_by_audit_id
        LEFT JOIN cp_sec_user_audit createuser
            ON createuser.cp_sec_user_audit_id = useraudit.created_by_audit_id
        LEFT JOIN cp_sec_user_audit confuser
            ON confuser.cp_sec_user_audit_id = useraudit.confirmed_by_audit_id
        LEFT JOIN emc_ext_facilities eef
          ON eef.ext_fac_id = physorder.pharmacy_id
        LEFT JOIN @physOrderAllergies poa ON poa.phys_order_id= physorder.phys_order_id
        LEFT JOIN @physOrderBlackbox pob ON pob.phys_order_id= physorder.phys_order_id
        LEFT JOIN @physOrderDoseCheck pdc ON pdc.phys_order_id = physorder.phys_order_id
        LEFT JOIN @physOrderNoDrugProtocolCheck ndpc ON ndpc.phys_order_id = physorder.phys_order_id

        LEFT JOIN pho_phys_order_sign os on os.phys_order_id = physorder.phys_order_id
        LEFT JOIN cp_sec_user_audit ua ON ua.cp_sec_user_audit_id = os.cp_sec_user_audit_id  --and os.phys_order_id = ?
        LEFT JOIN order_sign_authentication_type at on at.authentication_type_id = os.authentication_type_id
        LEFT JOIN order_sign_source_type ss on ss.source_type_id = os.source_type_id
        LEFT JOIN order_sign_signature_type st on st.signature_type_id = os.signature_type_id
        LEFT JOIN pho_phys_order_new_ctrlsubstancecode nctrlsc on nctrlsc.phys_order_id=physorder.phys_order_id
        LEFT JOIN pho_phys_order_esignature ppoe on ppoe.phys_order_id=physorder.phys_order_id
        LEFT JOIN pho_phys_order_quantity_info oq on oq.phys_order_id=physorder.phys_order_id
        LEFT JOIN pho_phys_order_ti ti on ti.phys_order_id = physorder.phys_order_id

SET @step = 9

SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return supplies '
    IF @debug='Y'
        PRINT @status_text

    -- supplies
    select pos.phys_order_id,
        pos.order_supply_id,
        pos.description as supply_description,
        pos.directions as supply_directions,
        pos.date_dispensed as date_dispensed,
        pos.last_received_date as supply_received_date,
		pos.received_date as supply_physical_received_date,
        pos.med_src_type_id as supply_med_src_type_id,
        pos.pharmacy_id as supply_pharmacy_id,
        eef.name as supply_pharmacy_name,
        pos.reordering as supply_reordering,
        pos.status AS supply_status,
        pos.new_supply_flag as supply_new_supply_flag,
        pos.last_reorder_date as supply_last_reorder_date,
        pos.disp_code as supply_disp_code,
        pos.pharm_nurse_notes as pharm_nurse_notes,
        pos.nurse_pharm_notes as nurse_pharm_notes,
        pos.disp_package_identifier as supply_disp_package_identifier,
        pos.controlled_substance_code as supply_controlled_substance_code,
        pos.prescription as supply_prescription,
        pos.do_not_fill as supply_do_not_fill,
        pos.inventory_on_hand as inventory_on_hand,
        pos.next_refill_date as next_refill_date,
        psd.pharmacy_order_id as pharmacy_order_id,
        CASE  WHEN ip.pharmacy_id IS NULL THEN 'N' ELSE 'Y' END 'integrated_pharmacy',
        pos.active as supply_active,
        '' as imageFileName, -- PCC-33017
        pos.drug_code as drug_code
    FROM pho_order_supply pos
        INNER JOIN  @result result ON [result].phys_order_id = pos.phys_order_id
        LEFT JOIN emc_ext_facilities eef ON eef.ext_fac_id = pos.pharmacy_id
        left join pho_supply_dispense psd on psd.order_supply_id = pos.order_supply_id and psd.deleted='N'
        LEFT JOIN @integratedPharmacies ip
                    ON ip.pharmacy_id = pos.pharmacy_id
    WHERE (pos.active = 'Y' or pos.active = 'N') AND pos.deleted = 'N'
    ORDER BY pos.created_date DESC

SET @step = 10

SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return Administrative orders'
    IF @debug='Y'
        PRINT @status_text


-- administrative orders
select vpao.*, secuser.long_username 'created_by_long' , secuser.designation_desc as created_by_designation, ccc.item_description as created_by_position
,csua.long_username confirmed_by_username, csua.position_description as confirmed_by_position, csua.designation_desc as confirmed_by_designation, ua.confirmed_date as confirmed_date
FROM view_pho_administrative_order vpao
inner JOIN @result r ON r.phys_order_id = vpao.standard_phys_order_id
left join SEC_USER secuser on secuser.loginname = vpao.created_by
left join common_code ccc on ccc.item_id = secuser.position_id
left join pho_admin_order_useraudit ua ON ua.admin_order_id = vpao.admin_order_id
left join cp_sec_user_audit csua on csua.cp_sec_user_audit_id = ua.confirmed_by_audit_id
ORDER BY vpao.revision_date  DESC



/**
may have to revisit column selection
**/
    SET @step = 11
    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Return Schedules'
    IF @debug='Y'
      PRINT @status_text;

	WITH ORDER_SCHEDULES AS
	(
		SELECT
			vps.phys_order_id, vps.order_schedule_id, vps.order_schedule_start_date 'start_date', psd.last_admin_user, psd.last_admin_date, vps.order_schedule_end_date 'end_date', vps.end_date_type, vps.end_date_duration_type,
			vps.end_date_duration, vps.reassessment_required,  vps.schedule_directions, vps.additional_directions, vps.schedule_template, vps.schedule_type,
			vps.alternate_dose, vps.schedule_sliding_scale_id, vps.apply_remove_flag,
			vps.date_start,
			vps.date_stop,
			vps.dose_uom_id,
			vps.dose,
			vps.indications_for_use,
			vps.quantity_uom_id,
			vps.prn_admin,
			vps.prn_admin_units,
			vps.prn_admin_value,
			vps.apply_to,
			CASE WHEN oss.order_schedule_id is not null  THEN 1 ELSE 0 END as custom_sliding_scale_exists,
			vps.std_freq_id,
			vps.revision_date
		FROM view_pho_schedule vps
			LEFT OUTER JOIN dw_pho_order_schedule psd
				ON psd.order_schedule_id = vps.order_schedule_id
			LEFT JOIN pho_order_sliding_scale_range oss
				ON @includeSlidingScale='Y' AND oss.order_schedule_id=vps.order_schedule_id
			INNER JOIN @result r
				ON r.phys_order_id = vps.phys_order_id
		GROUP BY
			vps.phys_order_id, vps.order_schedule_id, vps.order_schedule_start_date, psd.last_admin_user, psd.last_admin_date, vps.order_schedule_end_date, vps.end_date_type, vps.end_date_duration_type,
			vps.end_date_duration, vps.reassessment_required,  vps.schedule_directions, vps.additional_directions, vps.schedule_template, vps.schedule_type,
			vps.alternate_dose, vps.schedule_sliding_scale_id,
			oss.order_schedule_id,
			vps.apply_remove_flag,
			vps.date_start,
			vps.date_stop,
			vps.dose_uom_id,
			vps.dose,
			vps.indications_for_use,
			vps.quantity_uom_id,
			vps.prn_admin,
			vps.prn_admin_units,
			vps.prn_admin_value,
			vps.apply_to,
			vps.std_freq_id,
			vps.revision_date
	)
	-- return: combine with schedules for struck-out orders
		SELECT * FROM ORDER_SCHEDULES
		UNION ALL
			SELECT
				psa.phys_order_id, psa.order_schedule_id, psa.schedule_start_date 'start_date', psd.last_admin_user, psd.last_admin_date, psa.schedule_end_date 'end_date', psa.schedule_end_date_type_id 'end_date_type', psa.schedule_duration_type_id 'end_date_duration_type',
				psa.schedule_duration 'end_date_duration', psa.reassessment_required,  psa.schedule_directions, psa.additional_directions, psa.schedule_template, psa.schedule_type,
				psa.alternate_dose_value 'alternate_dose', psa.sliding_scale_id 'schedule_sliding_scale_id', psa.apply_remove_flag,
				psa.date_start,
				psa.date_stop,
				psa.dose_uom_id,
				psa.dose_value 'dose',
				psa.indications_for_use,
				psa.quantity_uom_id,
				psa.prn_admin,
				psa.prn_admin_units,
				psa.prn_admin_value,
				psa.apply_to,
				CASE WHEN oss.order_schedule_id is not null  THEN 1 ELSE 0 END as custom_sliding_scale_exists,
				psa.std_freq_id,
				psa.revision_date
			FROM pho_order_schedule_audit psa
				INNER JOIN
				(
					SELECT MAX(posa.AUDIT_ID) 'latest_audit_id' FROM pho_order_schedule_audit posa
					INNER JOIN @result r ON r.phys_order_id = posa.phys_order_id AND r.status = 4
					GROUP BY posa.order_schedule_id
				) latest_schedule_audit ON latest_schedule_audit.latest_audit_id = PSA.audit_id
				INNER JOIN @orderStatus os	-- filter down to struck-out orders
					ON  os.status = 4
				LEFT OUTER JOIN dw_pho_order_schedule psd
					ON psd.order_schedule_id = psa.order_schedule_id
				LEFT JOIN pho_order_sliding_scale_range oss
					ON @includeSlidingScale='Y' AND oss.order_schedule_id=psa.order_schedule_id
				INNER JOIN @result r
					ON r.phys_order_id = psa.phys_order_id AND r.status = 4
			WHERE @includeStruckOutOrders = 'Y'
			GROUP BY
				psa.phys_order_id, psa.order_schedule_id, psa.schedule_start_date, psd.last_admin_user, psd.last_admin_date, psa.schedule_end_date, psa.schedule_end_date_type_id, psa.schedule_duration_type_id,
				psa.schedule_duration, psa.reassessment_required,  psa.schedule_directions, psa.additional_directions, psa.schedule_template, psa.schedule_type,
				psa.alternate_dose_value, psa.sliding_scale_id,
				oss.order_schedule_id,
				psa.apply_remove_flag,
				psa.date_start,
				psa.date_stop,
				psa.dose_uom_id,
				psa.dose_value,
				psa.indications_for_use,
				psa.quantity_uom_id,
				psa.prn_admin,
				psa.prn_admin_units,
				psa.prn_admin_value,
				psa.apply_to,
				psa.std_freq_id,
				psa.revision_date


     SET @step = 12

     SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return alerts '
     IF @debug='Y'
        PRINT @status_text

     /* ALERTS */
		SELECT PHYSORDER.PHYS_ORDER_ID   'phys_order_id',
               PHYSORDER.CLIENT_ID       'client_id',
               ALERT.ALERT_ID            'alert_id',
               ALERT.DESCRIPTION         'alert_desc',
               ALERT.MODULE              'module',
               ALERT.CREATED_DATE        'alert_created_date',
               ALERT.EFFECTIVE_DATE      'effective_date',
               ALERT.TRIGGERED_ITEM_ID   'triggered_item_id',
               ALERT.TRIGGERED_ITEM_TYPE 'triggered_item_type',
               ALERT.RESOLVED            'resolved',
               ALERT.RESOLVED_BY         'resolved_by',
			   CATITC.TRIGGERED_ITEM_TYPE_CATEGORY_ID 'triggered_item_type_category_id'
        FROM   @result PHYSORDER
               LEFT OUTER JOIN CR_ALERT ALERT
                 ON ALERT.TRIGGERED_ITEM_ID = PHYSORDER.PHYS_ORDER_ID
					and alert.fac_id = @facIdLocal
					and ( @clientIdLocal is null or alert.client_id=@clientIdLocal )
                    AND ALERT.TRIGGERED_ITEM_TYPE IN ('O', 'M') AND ALERT.RESOLVED <> 'Y' AND ALERT.deleted = 'N'
				LEFT OUTER JOIN CR_ALERT_TRIGGERED_ITEM_TYPE_CATEGORY CATITC
				 ON CATITC.ALERT_ID = ALERT.alert_id
		WHERE ALERT.ALERT_ID IS NOT NULL
        ORDER  BY ALERT.EFFECTIVE_DATE ASC


     SET @step = 13

     SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return the total number of records '
     IF @debug='Y'
        PRINT @status_text

     select @num_records as num_records

      SET @step = 14

     SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return alerts for Supplies '
     IF @debug='Y'
        PRINT @status_text

     /* ALERTS */
            SELECT PHYSORDER.PHYS_ORDER_ID   'phys_order_id',
               PHYSORDER.CLIENT_ID       'client_id',
               POS.ORDER_SUPPLY_ID        'order_supply_id',
               ALERT.ALERT_ID            'alert_id',
               ALERT.DESCRIPTION         'alert_desc',
               ALERT.MODULE              'module',
               ALERT.CREATED_DATE        'alert_created_date',
               ALERT.EFFECTIVE_DATE      'effective_date',
               ALERT.TRIGGERED_ITEM_ID   'triggered_item_id',
               ALERT.TRIGGERED_ITEM_TYPE 'triggered_item_type',
               ALERT.RESOLVED            'resolved',
               ALERT.RESOLVED_BY         'resolved_by'
        	FROM   pho_order_supply POS
                 LEFT JOIN @result PHYSORDER ON PHYSORDER.PHYS_ORDER_ID = POS.PHYS_ORDER_ID and (@clientIdLocal is null or PHYSORDER.client_id=@clientIdLocal )
               	 LEFT JOIN CR_ALERT ALERT ON ALERT.TRIGGERED_ITEM_ID = POS.ORDER_SUPPLY_ID and alert.fac_id = @facIdLocal and ALERT.client_id = PHYSORDER.client_id


       		 WHERE (
                           -- Only Show Pharmacy initated alerts
                           ALERT.TRIGGERED_ITEM_TYPE = 'C'
                                                OR ALERT.TRIGGERED_ITEM_TYPE = 'O'
                                                OR ALERT.TRIGGERED_ITEM_TYPE = 'D'
                                                OR ALERT.TRIGGERED_ITEM_TYPE = 'T'
                                         )
                                  AND ALERT.deleted = 'N'
       		 ORDER  BY ALERT.EFFECTIVE_DATE ASC

    SELECT r.phys_order_id, poda.severity_code
    FROM @result r
     INNER JOIN @physOrderDrugInteraction poda ON poda.phys_order_id= r.phys_order_id

    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Done'
    IF @debug='Y'
        PRINT @status_text
    SET @status_code = 0
    GOTO PgmSuccess
END TRY
--error trapping
BEGIN CATCH
    SELECT @error_code = @@error, @status_text = 'Error at step:'+convert(varchar(3),@step)+', '+ERROR_MESSAGE()

    SET @status_code = 1

    GOTO PgmAbend

END CATCH

--program success return
PgmSuccess:

IF @status_code = 0
BEGIN
    IF @debug='Y' PRINT 'Successfull execution of stored procedure'
    RETURN @status_code
END

--program failure return
PgmAbend:

IF @debug='Y' PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '   ' + convert(varchar(26),getdate())
    IF @debug='Y' PRINT 'Error code: '+convert(varchar(3),@error_code) + '; Error description:    ' +@status_text
    RETURN @status_code

GO
GRANT EXECUTE ON sproc_pho_list_residentchart_v2 TO public
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_pho_list_residentchart_v2.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_residentchart_v2.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_electronic_prescription_report.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- =================================================================================
-- PCC-68693       :   script to create sproc_prp_rl_electronic_prescription_report Procedure
--						--
-- Written By:          Henny Ehghaghi
-- Reviewed By:
--
-- Script Type:         DDL
-- Target DB Type:      Client
-- Target ENVIRONMENT:  BOTH (US)
--
--
-- Re-Runable:          YES
--
-- Description of Script : Create sproc_prp_rl_electronic_prescription_report for integrated facilities in US
--
-- Special Instruction:
--
-- =================================================================================
/***********************************************************************************************************
Revision History:
-- 2015-01-30	H Ehghaghi			PCC-68693	3.7.6		Fixed duplicate client Id
-- 2015-02-11   H Ehghaghi			PCC-70809	3.7.6.1		Remove all security (facility and client) also add sort option base of user selected
															Showing facility address instead of resident address and add supervisor designation
-- 2015-02-11   H Ehghaghi			PCC-70809	3.7.6.1		No phys order ID exception and field name
-- 2015-02-23   H Ehghaghi			PCC-71400	3.7.6.1		Add Quantity To Dispense And Refills #
-- 2015-02-27   H Ehghaghi			PCC-71910	3.7.6.1		Show prescription information that was digitally signed and archived instead of current .
-- 2015-12-22   H Ehghaghi			PCC-87250	3.7.8.2		 add pharmacy name for discharge order .
-- 2016-01-15   H Ehghaghi			PCC-88050	3.7.9		 Add facility adderss and update client address .
-- 2016-02-01   H Ehghaghi			PCC-89148	3.7.9		Fixed  No of Refills  issue .
-- 2016-05-02   H Ehghaghi			PCC-94418	3.7.9		Fixed  order panding issue .
-- 2016-08-24   H Ehghaghi			PCC-99165	3.7.11		apply sort by on Electronic Prescription Report .
-- 2016-09-07   H Ehghaghi			PCC-100916 3.7.11		Fixed multi schedual order summery and directiond
-- 2016-09-09   H Ehghaghi			PCC-100916 3.7.11		Fixed summery description and showing drug form/strength/dose
-- 2016-09-12   H Ehghaghi			PCC-101215 3.7.11		 Updates on the Sort By options
-- 2017-09-06   Dom Christie		PCC-95068  3.7.14		Electronic Prescription report needs to contain PCC Message Id and Prescriber Order Number
-- 2017-09-22   Dom Christie		PCC-122281  3.7.14      Print message ID when an integrated pharmacy exists as the order source pharmacy
-- 2022-01-07   Jarek Zawojski      CORE-98068 4.4.9        Add attestation and registration_code to be used in CDN version of the report
-- 2022-02-08   Patrick Campbell    CORE-98962 4.4.9        Add CDN fields prescription_dispense_interval and total_authorized_quantity
*************************************************************************************************************/


IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_prp_rl_electronic_prescription_report' and ROUTINE_TYPE = 'PROCEDURE' )
BEGIN
DROP PROCEDURE dbo.sproc_prp_rl_electronic_prescription_report
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO



Create Procedure dbo.sproc_prp_rl_electronic_prescription_report
    @fac_id int
, @is_emc  bit = '0'
, @filter_list varchar(max)  = NULL --- which filters are on ( list of filtername=CSV of Selected ids from value_list for eg 'order_category=3022,3023;communication_method=3025;'
, @message varchar(max)	 = NULL
, @execution_user_login varchar(60)
, @rows_returned int out
, @debug_me char(1)  = '0'
, @status_code int  out 
, @status_text varchar(3000) out
/********************************************************************************
						   
Declare  @rows_ret int		,@statuscode int		,@statustext varchar(3000)
exec dbo.sproc_prp_rl_electronic_prescription_report
@fac_id =  '1' 
,@filter_list =  'client_id=-1;'
,@message ='<pharmacyOrderMessageType> 
  <subscriptionList>
       <vendorPharmacyId>173</vendorPharmacyId>
  	   <pccOrderId>2924056</pccOrderId>
	   <transmissionStatus> failed </transmissionStatus>
	   <transmissionDate> 12/17/2014 15:20:55 </transmissionDate> 
  </subscriptionList> 
  <subscriptionList>
       <vendorPharmacyId>173</vendorPharmacyId>
  	   <pccOrderId>2924057</pccOrderId>
	   <transmissionStatus> failed </transmissionStatus>
	   <transmissionDate> 12/18/2014 18:20:55 </transmissionDate> 
  </subscriptionList> 
   <subscriptionList>
       <vendorPharmacyId>5917</vendorPharmacyId>
  	   <pccOrderId>2923693</pccOrderId>
	   <transmissionStatus> failed </transmissionStatus>
	   <transmissionDate> 12/19/2014 7:20:55 </transmissionDate> 
  </subscriptionList> 
</pharmacyOrderMessageType>
'
,@execution_user_login =  '_system_' 
,@rows_returned = null
,@debug_me = 'n'
,@status_code = null
,@status_text = null


Select @rows_ret, @statuscode int, @statustext

**********************************************************************************/


as
Begin


SET NOCOUNT ON;
--declare Standard local variables required for any store proc
DECLARE  @vStep int
		,@vErr varchar(max)
		,@vdelim char(1)
		,@vRowCount int

--Facility Related variables, also used in capturing execution Statistics 
Declare @vFacIDs varchar(max)		
Declare @PRP_FacList as table(FacId int)
Declare @vFacWarningMsg varchar(max) --- to know whether it the returned list is restricted

Declare @vFacEMAREnabled char(1) -----match Administration_record_id with Alt_administration_id if notEMAREnabled


----Local Variables
DECLARE
@vmessage varchar(max)
	, @vFilterList varchar(max)
	, @vFacId int
	, @vSP_ClientId int
	, @visemc bit 
	, @vGetStatus_statuscode int 
	, @vGetStatus_statustext varchar(3000);


DECLARE   @term_admission varchar(50)
        , @term_client varchar(50)
        , @vTermClient varchar(50)
	    , @vTermClients varchar(50)
	    , @vTermFacility varchar(50)
	    , @vTermFacilities varchar(50)
	    , @vTermAdmission varchar(50)
	    , @vTermAdmissions varchar(50)
	    , @vTermDischarge varchar(50)
	    , @vTermDischarges varchar(50)
	    , @vTermRoom varchar(50)
	    , @vTermRooms varchar(50)
	    , @vTermAdvDirective varchar(50)
	    , @vMRNId int
	    , @vMRNDesc varchar(100)
        , @footer varchar(50)
        , @header varchar(50)

----------Governor and Statistics Variables
Declare

@vgsFacCount int
		,@vgsClientCount int
		,@vgsFacID varchar(max)		
		,@vgsClientId varchar(max)
		,@vgsParamName1 varchar(50) --- fields selected
		,@vgsParamValue1 varchar(1500) 
		,@vgsParamName2 varchar(50) ---filters applied
		,@vgsParamValue2 varchar(1500) 

		

-----Governor and Statistics Variables 
Declare  @vgs_program_name varchar(200)
		 ,@vgs_start_time datetime
		 ,@vgs_execution_user varchar(60)
		 ,@vgs_fill_end_time datetime

DECLARE   @vfil_client_id bit
	    , @vStartDate datetime
		, @vEndDate datetime
		, @XML xml
		, @vfil_integration_enable bit
		, @vSort  varchar(20)
		, @vCopy tinyint 
		, @vCharNewLine char(2)
		, @vReportType varchar(5)
		, @vLocationWithUnit bit='1';

CREATE TABLE #PRP_Multi_Filters( filter_name varchar(50), filter_value varchar(50) );
CREATE TABLE #PRP_Filters (filter_name varchar(100), filter_value varchar(max));

----client Access Varaibles
declare @client_id varchar(max)
Declare @vClientIDs varchar(max)		
Declare @vClientWarningMsg varchar(max)--- to know whether it the returned list is restricted

CREATE TABLE #clients(
                         client_id int
    , client_id_number varchar(35)
    , client_name varchar(200)
    , client_first_name varchar(100)
    , client_last_name varchar(150)
    , location varchar(500) ----with Facility_name
    , date_of_birth datetime
    , client_address1 varchar(50)
    , client_address2 varchar(50)
    , client_city varchar(75)
    , client_prov_state varchar(20)
    , client_postal varchar(50)
    , sex char(1)
    , bed_id int
    , hasAllergy char(1)
    , hasBed char(1)
    , hasDOB char(1)
    , hasGender char(1)

);

CREATE NONCLUSTERED INDEX _tmp_idx_clients on #Clients(client_id);

CREATE TABLE #PRP_PharmacyOrder	(client_id int ,
                                    physician_id int ,
                                    pharmacyId int,
                                    phys_order_id int,
                                    trans_status varchar(50),
                                    trans_date datetime);


Create Table #tempResult (
                             phys_order_id	int
    ,fac_id	int
    ,contact_id int
    ,description	varchar(500)
    ,drug_strength	varchar	(100)
    ,drug_strength_uom	varchar(10)
    ,created_date	datetime
    ,quantity	varchar(31)
    ,quantity_uom	varchar(20)
    ,no_of_refills	int
    ,directions	varchar(2000)
    ,client_id	int
    ,client_id_number	varchar(35)
    ,client_first_name	varchar(50)
    ,client_last_name	varchar(50)
    ,phys_first_name	varchar(50)
    ,phys_last_name	varchar(50)
    ,long_username	varchar(50)
    ,position_desc	varchar(50)
    ,designation_desc	varchar(20)
    ,dea_number	varchar(13)
    ,nadea_number	varchar(9)
    ,phys_address1	varchar(35)
    ,phys_address2	varchar(35)
    ,phys_address3	varchar(35)
    ,phys_city	varchar(50)
    ,phys_prov_state	varchar(3)
    ,phys_postal_zip_code	varchar(15)
    ,sup_first_name	varchar(50)
    ,sup_last_name	varchar(50)
    ,sup_position_desc	varchar(50)
    ,sup_designation_desc	varchar(20)
    ,sup_dea_number	varchar(13)
    ,pharmacyId int
    ,trans_status varchar(50)
    ,trans_date datetime
    ,location  varchar(100)
    ,order_date datetime
    ,summary varchar(max)
    ,registration_code varchar(30)
    ,attestation varchar(2800)
    ,prescription_dispense_interval int
    ,prescription_total_authorized_quantity varchar(31)
        );

BEGIN TRY

Set @status_code = 0   ---- Status Code 0 = Success, 1 = Exception
	set @status_text = null;
	set @rows_returned = 0;
	Set @vgs_program_name  = Object_name(@@ProcID);  ---Current Store Proc Name
	Set @vgs_start_time = getdate();
	Set @vgs_execution_user = @execution_user_login ;

select @vStep = 0
           if @debug_me='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Executing store proc :  ' + @vgs_program_name  + convert(varchar(26),getdate(),109)

	--set Standard variables
    set @vdelim = ','

	----Parameter Sniffing - use local variables when they are used in a where clause

SET @vFacID		  = @fac_id;
SET @vmessage     = replace(@message,'<?xml version="1.0" encoding="UTF-8" standalone="no"?>','');
	SET @vFilterList  = @filter_list;
	SET @visemc       =	@is_emc	;
	SET @vfil_integration_enable =0;
	set @vCharNewLine  = Char(13) + char(10)


select @vStep = 2
           if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Validating Input Parameters  ' +  convert(varchar(26),getdate(),109)

	----Validate all input parameters
	if (
		@message is null 
		or @fac_id is NULL 
		or @execution_user_login is null
		)
begin
		set @vErr = 'One or more of the following input parameters is invalid... '
					+ ' @fac_id=' + isnull(convert(varchar(10),@fac_id),'null/empty')
					+  ' @message=' + isnull(convert(varchar(10),@message),'null/empty')
					+ ', @execution_user_login=' + isnull(@execution_user_login,'null/empty')
	
		RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);
end
   --select @vmessage
select @vStep = 5
           if @debug_me='Y' Print 'STEP' +  convert(varchar(20), @vStep)  + ' Getting Terminoloy' + convert(varchar(26),getdate(),109)
Select
     --@vTermClient = term_client
        @term_client = term_client
     , @vTermClients = term_clients
     , @vTermFacility = term_facility
     , @vTermFacilities = term_facilities
     , @term_admission  = term_admission
     , @vTermAdmissions = term_admissions
     , @vTermDischarge = term_discharge
     , @vTermDischarges = term_discharges
     , @vTermRoom = term_room
     , @vTermRooms = term_rooms
     , @vTermAdvDirective = term_adv_directive
from [dbo].fn_prp_get_terminology(@vFacId,@visemc) ;

SET @vTermClient=@term_client
	 SET @vTermAdmission=@term_admission;



select @vStep = 20

    INSERT into #PRP_Filters
Select Left(Items,Charindex('=',Items)-1),right(Items, len(Items)-Charindex('=',Items))  from dbo.Split(@vFilterList,';')

    if @debug_me='Y'
select 111,* FROM #PRP_Filters

                      if @vCopy is null Set @vCopy = 1;
if @debug_me='Y' Print @vCopy ;

select @vStep = 40
           if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' determining which filters are used ' + convert(varchar(26),getdate(),109)


	   if Exists( select 1 from #PRP_Filters where filter_name = 'failed')  OR
			Exists( select 1 from #PRP_Filters where filter_name = 'success')
BEGIN
Select  @vStartDate		= Left(filter_value,Charindex(@vDelim,filter_value)-1)
        , @vEndDate		= Right(filter_value, len(filter_value)-Charindex(@vDelim,filter_value))
from #PRP_Filters where filter_name in ('failed','success');
END

	  
	if isDate(@vEndDate) = 1 Set @vEndDate = @vEndDate + 1 ;

	 if Exists( select 1 from #PRP_Filters where filter_name = 'sort_by')
BEGIN
Select  @vSort		= filter_value
from #PRP_Filters where filter_name in ('sort_by');
END
	IF @vSort IS NULL SET @vSort='client_name';


	 if Exists( select 1 from #PRP_Filters where filter_name = 'report_type')
BEGIN
Select  @vReportType		= filter_value
from #PRP_Filters where filter_name in ('report_type');
END

	   if @debug_me='Y' select 'filter_list' name,@vReportType reportType,@vSort sortBy, @vStartDate startdate,@vEndDate enddate


select @vStep = 45;
if @debug_me='Y' Print 'BEGIN STEP ' + convert(varchar(20), @vStep) + ' Getting user access client list ' + convert(varchar(26),getdate(),109);

	SET @client_id = (Select filter_value from #PRP_Filters where filter_name = 'client_id');
	if  @client_id is null Set @client_id = '-1';


Select @vClientIDs = @client_id

           if isnull(@vClientIDs,'-1') <> '-1'  ----should not be null or -1, if null or -1 then it means there is no filter on clients
BEGIN
		SET @vfil_client_id = '1'
    	Insert into #PRP_Multi_Filters
Select 'client_id', items from dbo.split(@vClientIds,@vDelim) b
END

	if @debug_me='Y' SELECT * FROM #PRP_Multi_Filters

                                   ----- transmission datat
    SET @xml =@vmessage;

INSERT INTO #PRP_PharmacyOrder (client_id, physician_id, pharmacyId, phys_order_id, trans_status, trans_date)
select po.client_id,po.physician_id,
    case when x2.value('vendorPharmacyId[1]','int')=po.pharmacy_id then po.pharmacy_id else po.pharmacy_id end	as pharmacyId
     ,x2.value('pccOrderId[1]','int')	as phys_order_id
     ,x2.value('transmissionStatus[1]','varchar(25)') tras_Status
     ,x2.value('transmissionDate[1]','datetime')  tras_Date
from  @XML.nodes('/pharmacyOrderMessageType/subscriptionList') AS ParamValues(x2)
	  inner join pho_phys_order po
on po.phys_order_id=x2.value('pccOrderId[1]','int')
    left join #PRP_Multi_Filters fil_client_id
    on fil_client_id.filter_name	= 'client_id'	and fil_client_id.filter_value = po.client_id
where po.fac_id = @vFacID
  AND ((@vfil_client_id	= '1' and fil_client_id.filter_value is not null) or  @vfil_client_id is null );


if @debug_me='Y'  	select * from #PRP_PharmacyOrder
-----getting the list of clients
select @vStep = 50
           if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' getting list of clients ' + convert(varchar(26),getdate(),109)
--if @vfil_client_status in (-1,1)  ----ALL or discharged
BEGIN
Insert into #clients
(	  client_id
, client_id_number
, client_name
, client_first_name
, client_last_name
, sex
, date_of_birth
, client_address1
, client_address2
, client_city
, client_prov_state
, client_postal
, bed_id
, hasallergy
, hasbed
, hasdob
, hasgender
, location

)
select distinct  c.client_id,	c.client_id_number
              , rtrim( ltrim(rtrim(isnull(m.first_name,'')))  + ' ' + ltrim(rtrim(isnull(m.last_name,''))) )
                                                                                                  as client_name
              , rtrim( ltrim(rtrim(isnull(m.first_name,''))))
              , ltrim(rtrim(isnull(m.last_name,'')))
              , m.sex
              , m.date_of_birth ---- Case when m.date_of_birth is not null then datediff(year,m.date_of_birth, @vReportDate) else null end as client_age
              , m.address1
              , m.address2
              , m.city
              , m.prov_state
              , m.postal_zip_code
              , loc.bed_id
              , CASE WHEN (cla.allergy ='To Be Determined' or  cla.allergy='' or cla.allergy is null) THEN 0 ELSE 1 END hasAllergy
              , CASE WHEN (loc.bed_id=-1 or loc.bed_id is null) THEN 0 ELSE 1 END hasBed
              , CASE WHEN (m.date_of_birth='' or  m.date_of_birth is null) THEN 0 ELSE 1 END hasDOB
              , CASE WHEN (m.sex='' or  m.sex is null) THEN 0 ELSE 1 END hasGender
              , Case when @vLocationWithUnit='1' then rtrim(ltrim(isnull(u.unit_desc,''))) + ' ' else '' end +
                rtrim(ltrim(isnull(r.room_desc,'')))  + ' ' + rtrim(ltrim(isnull(b.bed_desc,''))) as location
from ( Select po.client_id, mpi_id, client_id_number from dbo.clients  with (nolock)
		inner join #PRP_PharmacyOrder po on po.client_id=clients.client_id
    --left join #PRP_Multi_Filters fil_client_id		on fil_client_id.filter_name	= 'client_id'	and fil_client_id.filter_value = clients.client_id

       where clients.fac_id = @vFacID  and clients.deleted = 'N'
         --AND ((@vfil_client_id	= '1' and fil_client_id.filter_value is not null) or  @vfil_client_id is null )

     ) c
         inner join dbo.mpi m with (nolock) on c.mpi_id = m.mpi_id
    inner JOIN dbo.clients_attribute cla WITH (NOLOCK )
ON cla.client_id = c.client_id
    inner join ( Select client_id, bed_id, payer_type,row_num from
    (select client_id, bed_id, payer_type, row_number() OVER (partition by client_id order by effective_date desc ) as row_num
    From dbo.view_prp_census with (nolock) where fac_id = @vFacId and (record_type is null or record_type = 'C'))  vw
    where row_num = 1
    ) loc on c.client_id = loc.client_id and  (loc.payer_type IS NULL OR loc.payer_type <>'OutPatient')-- CDN payer_type is always empty string

    left join dbo.bed b with (nolock) on loc.bed_id=b.bed_id
    left join dbo.room r with (nolock) on b.room_id=r.room_id
    left join dbo.[floor] f with (nolock) on f.floor_id=r.floor_id
    left join dbo.unit u with (nolock) on  u.unit_id=r.unit_id ;



Set @vgsClientCount = @@ROWCOUNT ;  -------get the clients selected count
END


	if @debug_me='Y'  select 333,* from #Clients

select @vStep = 55
           if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' getting list of orders ' + convert(varchar(26),getdate(),109)



    INSERT INTO #tempresult
(phys_order_id
,fac_id
,contact_id
,description
,drug_strength
,drug_strength_uom
,created_date
,quantity
,quantity_uom
,no_of_refills
,directions
,client_id
,client_id_number
,client_first_name
,client_last_name
,phys_first_name
,phys_last_name
,long_username
,position_desc
,designation_desc
,dea_number
,nadea_number
,phys_address1
,phys_address2
,phys_address3
,phys_city
,phys_prov_state
,phys_postal_zip_code
,sup_first_name
,sup_last_name
,sup_position_desc
,sup_designation_desc
,sup_dea_number
,pharmacyId
,trans_status
,trans_date
,location
,order_date
,summary
,registration_code
,attestation
,prescription_dispense_interval
,prescription_total_authorized_quantity)
select
    pos.phys_order_id
     ,pos.fac_id
     ,pos.physician_id
     ,pos.drug_name+' '+isnull(pos.form,'')  description
     ,pos.drug_strength
     ,pos.drug_strength_uom
     ,pos.created_date
     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then qinf.quantity   -- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.quantity   -- discharge signature order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then qinf.quantity   --  pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.quantity   -- signature  order
    end quantity
     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then qinf.unit_of_measure   -- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.quantity_uom   -- discharge signature	order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then qinf.unit_of_measure   -- pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.quantity_uom   -- signed order
    end quantity_uom
     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then qinf.no_of_refills  -- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.no_of_refills   -- discharge signature	order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then qinf.no_of_refills   -- pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.no_of_refills   -- signed order
    end no_of_refills
     ,null directions
     ,clients.client_id
     ,clients.client_id_number
     ,clients.client_first_name
     ,clients.client_last_name
     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then physician.first_name  -- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.phys_first_name   -- discharge signature	order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then physician.first_name   -- pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.phys_first_name   -- signed order
    end phys_first_name
     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then physician.last_name  -- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.phys_last_name   -- discharge signature	order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then physician.last_name   -- pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.phys_last_name   -- signed order
    end phys_last_name
     ,po.long_username

     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then phys_position.item_description   -- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.position_desc  -- discharge signature	order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then phys_position.item_description   -- pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.position_desc   -- signed order
    end position_desc

     , case
           when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then ltrim(rtrim(isnull(staff.designation,phys_desig.item_description)))  -- discharge pending signature order
           when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.designation_desc  -- discharge signature	order
           when (posnap.phys_order_id is null and po.phys_order_id is null ) then ltrim(rtrim(isnull(staff.designation,phys_desig.item_description)))   -- pending signature order
           when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.designation_desc   -- signed order
    end 	designation_desc

     , case
           when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then   dea.dea_number-- discharge pending signature order
           when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.dea_number  -- discharge signature	order
           when (posnap.phys_order_id is null and po.phys_order_id is null ) then  dea.dea_number   -- pending signature order
           when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.dea_number   -- signed order
    end dea_number
     ,
    case
        when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then dea.nadea_number  -- discharge pending signature order
        when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.nadea_number  -- discharge signature	order
        when (posnap.phys_order_id is null and po.phys_order_id is null ) then dea.nadea_number   -- pending signature order
        when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.nadea_number   -- signed order
        end nadea_number
     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then addres.address1  -- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.phys_address1  -- discharge signature	order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then addres.address1   -- pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.phys_address1   -- signed order
    end phys_address1
     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then addres.address2  -- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.phys_address2  -- discharge signature	order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then addres.address2   -- pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.phys_address2   -- signed order
    end phys_address2
     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then addres.address3  -- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.phys_address3  -- discharge signature	order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then addres.address3   -- pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.phys_address3   -- signed order
    end phys_address3
     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then addres.city  -- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.phys_city  -- discharge signature	order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then addres.city   -- pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.phys_city   -- signed order
    end phys_city
     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then addres.prov_state  -- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.phys_prov_state  -- discharge signature	order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then addres.prov_state   -- pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.phys_prov_state   -- signed order
    end phys_prov_state
     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then addres.postal_zip_code  -- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.phys_postal_zip_code  -- discharge signature	order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then  addres.postal_zip_code  -- pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.phys_postal_zip_code   -- signed order
    end phys_postal_zip_code
     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then super.first_name  -- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.sup_first_name  -- discharge signature	order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then  super.first_name  -- pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.sup_first_name   -- signed order
    end sup_first_name
     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then super.last_name  -- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.sup_last_name  -- discharge signature	order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then  super.last_name  -- pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.sup_last_name   -- signed order
    end sup_last_name
     ,
    case
        when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then super_position.item_description  -- discharge pending signature order
        when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.sup_position_desc  -- discharge signature	order
        when (posnap.phys_order_id is null and po.phys_order_id is null ) then  super_position.item_description  -- pending signature order
        when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.sup_position_desc   -- signed order
        end sup_position_desc
     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then isnull(sup_staff.designation,super_desig.item_description)  -- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.sup_designation_desc  -- discharge signature	order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then  isnull(sup_staff.designation,super_desig.item_description)  -- pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.sup_designation_desc   -- signed order
    end sup_designation_desc
     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then   sup_dea.dea_number-- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then po.sup_dea_number  -- discharge signature	order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then  sup_dea.dea_number   -- pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then po.sup_dea_number   -- signed order
    end sup_dea_number
     ,OrderId.pharmacyId
     ,OrderId.trans_status
     ,OrderId.trans_date
     ,clients.location
     , case when @vReportType='ep' OR @vReportType='orders' then pos.order_date else null end order_date
     ,pos.description + ' ' + replace ( replace( replace ( replace ( replace( replace( isnull(' ' + ltrim(Stuff(isnull(OrderSumm.order_summary,''),1,5,'')),'') , '& ', '&amp;'), '<', '&lt;'), '>', '&gt;'), '"', '&quot;'), '''', '&#39;'), '&amp;#', '&#')
     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then staff.registration_code  -- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then contact_snapshot.registration_code  -- discharge signature order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then staff.registration_code   -- pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then contact_snapshot.registration_code   -- signed order
    end registration_code
     ,case
          when (posnap.phys_order_id is NOT null and po.phys_order_id is null ) then
              case when attestation.is_controlled_medication = 1 then fac_attestation.ctrl_medication_value else fac_attestation.non_ctrl_medication_value end  -- discharge pending signature order
          when (posnap.phys_order_id is NOT null and po.phys_order_id is not  null ) then order_snapshot_CDN.quantity_attestation  -- discharge signature	order
          when (posnap.phys_order_id is null and po.phys_order_id is null ) then
              case when attestation.is_controlled_medication = 1 then fac_attestation.ctrl_medication_value else fac_attestation.non_ctrl_medication_value end -- pending signature order
          when (posnap.phys_order_id is null and po.phys_order_id is not  null ) then order_snapshot_CDN.quantity_attestation   -- signed order
    end attestation
     , qinf.dispense_interval as prescription_dispense_interval
     , qinf.total_authorized_quantity as prescription_total_authorized_quantity

from view_prp_pho_phys_order_schedule  pos with (nolock)
	    inner JOIN #PRP_PharmacyOrder OrderId  with (nolock)
on OrderId.phys_order_id=pos.phys_order_id
    INNER JOIN #clients clients  with (nolock)
ON clients.client_id=pos.client_id
    left join view_pho_esignature po with (nolock)	-- signed order
on po.phys_order_id=pos.phys_order_id
    left join pho_phys_order_discharge_snapshot posnap	with (nolock) -- discharge order
on posnap.phys_order_id =pos.phys_order_id
    left join dbo.contact physician with (nolock ) on physician.contact_id =  pos.physician_id
    left join contact_address cadd  with (nolock ) on cadd.contact_id=  physician.contact_id
    left join address addres with (nolock ) on addres.address_id=cadd.address_id

    left join dbo.pho_phys_order_quantity_info qinf with (nolock) on  qinf.phys_order_id=pos.phys_order_id

    left outer join dbo.staff  with (nolock) on physician.contact_id=staff.contact_id

    left join dbo.common_code phys_desig with (nolock ) on phys_desig.item_id = staff.profession_id and phys_desig.item_code = 'profe'
    left join dbo.common_code phys_position with (nolock ) on phys_position.item_id = staff.position_id and phys_desig.item_code = 'posit'
    left join dbo.mp_dea_assignment  dea  with (nolock ) on dea.contact_id= staff.contact_id and dea.fac_id = @vFacId
    left join dbo.contact super with (nolock ) on super.contact_id =  dea.supervisor_contact_id
    left outer join dbo.staff sup_staff  with (nolock) on super.contact_id=sup_staff.contact_id
    left join dbo.common_code super_desig with (nolock ) on super_desig.item_id = sup_staff.profession_id and super_desig.item_code = 'profe'
    left join dbo.common_code super_position with (nolock ) on super_position.item_id = sup_staff.position_id and super_position.item_code = 'posit'
    left join dbo.mp_dea_assignment  sup_dea  with (nolock ) on sup_dea.contact_id= sup_staff.contact_id and sup_dea.fac_id = @vFacId
    left join dbo.pho_phys_order_attestation attestation with (nolock ) on attestation.phys_order_id = pos.phys_order_id
    left join dbo.facility_medical_attestation fac_attestation with (nolock ) on fac_attestation.facility_medical_attestation_id = attestation.facility_medical_attestation_id
    left join dbo.pho_phys_order_esignature_contact_snapshot contact_snapshot on contact_snapshot.contact_id = pos.physician_id
    left join dbo.pho_phys_order_esignature_order_snapshot_CDN order_snapshot_CDN on order_snapshot_CDN.phys_order_id = pos.phys_order_id
    Cross Apply (	Select order_summary.value('.','varchar(max)') as order_summary from
    (
    Select   Case when pos.schedule_template = '3' then ' THEN ' else ' AND ' end + isnull(directions,'')
    from dbo.view_prp_pho_phys_order_schedule ppo with (nolock)
    where ppo.phys_order_id = pos.phys_order_id
    order by ppo.order_schedule_id
    FOR XML PATH (''), TYPE
    ) a ( order_summary )
    ) OrderSumm;

Set @vgs_fill_end_time  = getdate() ; -- fill end time

	if (select count(1) from #tempresult)=0
Begin
		Set @status_code = 2 ; ----Set it warning
		 Raiserror( ' 0 rows Received', 11, 1 );
End



select @vStep = 70
           if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' returning final result ' + convert(varchar(26),getdate(),109)

;with tbBase
          as (
        Select distinct
            @vFacID as fac_id
                      , o.contact_id physician_id
                      , o.dea_number dea_number
                      , o.nadea_number nadea_number
                      , isnull( o.phys_first_name,'')  + isnull(' ' + o.phys_last_name,'')   as physician
                      , case when isnull( o.designation_desc,'')<>'' then COALESCE(', '+ o.designation_desc, '') else '' end	 as physician_designation
                      , CASE WHEN LTRIM(RTRIM(ISNULL(o.phys_address1,'')))<>'' THEN  LTRIM(RTRIM(o.phys_address1))  ELSE '' END
            + CASE WHEN LTRIM(RTRIM(ISNULL(o.phys_address2,'')))<>'' then COALESCE(' '+ ltrim(rtrim(o.phys_address2)), '') else '' END
            + CASE WHEN LTRIM(RTRIM(ISNULL(o.phys_address3,'')))<>'' then COALESCE(' '+ ltrim(rtrim(o.phys_address3)), '') else '' END 	phys_address

                      , CASE WHEN LTRIM(RTRIM(ISNULL(o.phys_city ,'')))<>''    THEN  LTRIM(RTRIM(ISNULL(o.phys_city ,''))) ELSE '' END	 phys_city
                      , CASE WHEN   LTRIM(RTRIM(ISNULL(o.phys_prov_state,'')))<>''  THEN LTRIM(RTRIM(ISNULL(o.phys_prov_state,''))) else '' end phys_prov_state
                      , CASE WHEN  LTRIM(RTRIM(ISNULL(o.phys_postal_zip_code,'')))<>''  then LTRIM(RTRIM(ISNULL(o.phys_postal_zip_code,''))) else '' end phys_postal_zip_code

                      , isnull( o.sup_first_name,'')  + isnull(' ' + o.sup_last_name,'') 	supervisor
                      , case when isnull( o.sup_designation_desc,'')<>'' then COALESCE(', '+ o.sup_designation_desc, '')	else '' end as supr_designation
                      , o.sup_dea_number supervisor_dea_number
                      , convert(varchar,o.client_id)		as client_id_str --- required for building group id
                      , c.client_name
                      , case when o.order_date is not null then convert(char(10),o.order_date,101)	else null end		 as order_date
                      , convert(char(10),o.created_date,101)			 as created_date
                      ,Convert(varchar,case when c.date_of_birth is not null then
                                                case
                                                    when ((MONTH(c.date_of_birth) * 100) + DAY(c.date_of_birth)) > ((MONTH(getdate()) * 100) + DAY(getdate())) then DATEDIFF(year,c.date_of_birth,getdate()) - 1
			else DATEDIFF(year,c.date_of_birth,getdate()) End 
			end) As client_age

                      --, Convert(varchar, Case when c.date_of_birth is not null then datediff(year,c.date_of_birth, o.order_date) else null end ) as client_age -- as per our BA age is calculated when the order date and not on the current date
                      , convert(char(10), c.date_of_birth, 101) as date_of_birth
                      , c.sex as client_gender
                      , fac.name as facility_name

                      , fac.address1 as fac_address1
                      , fac.address2 as fac_address2
                      , fac.city as fac_city
                      , fac.prov as fac_prov
                      , fac.tel  as fac_tel
                      , fac.pc as fac_pc
                      , c.client_address1
                      , c.client_address2
                      , c.client_city
                      , c.client_prov_state
                      , c.client_postal
                      , c.location
                      , o.summary order_summary

                      , case when ltrim(rtrim(o.quantity))<>'' then o.quantity else null end quantity
                      , case when ltrim(rtrim(o.quantity_uom))<>'' then o.quantity_uom else null end unit_of_measure
                      , case when ltrim(rtrim(o.no_of_refills))<>'' then o.no_of_refills else null end no_of_refills
                      , o.phys_order_id -----phys_order_id  is for QA testing only
                      , CASE WHEN cntr.phys_order_id=o.phys_order_id AND mp.message_profile_id=cntr.message_profile_id AND mp.ext_fac_id=o.pharmacyId THEN message_control_id ELSE NULL END message_control_id
                      ,o.pharmacyId
                      ,case when o.pharmacyId=0 and disorder.phys_order_id is not null then disorder.organization_name else ext_fac.name end pharmacy_name
                      ,o.trans_status
                      ,case when o.trans_date is not null and o.trans_date<>'' then
                                isnull(convert(char(10),o.trans_date,101) + ' '+  CONVERT(CHAR(5),o.trans_date,114),'') else null end trans_date
                      ,num
                      ,o.registration_code registration_code
                      ,o.attestation attestation
                      ,o.prescription_dispense_interval prescription_dispense_interval
                      ,o.prescription_total_authorized_quantity prescription_total_authorized_quantity

        From  #tempresult o with (nolock )
     inner join #Clients c on c.client_id = o.client_id
     inner join dbo.facility fac with (nolock) on fac.fac_id=@vFacId
     left outer join dbo.emc_ext_facilities ext_fac with (NOLOCK) on  ext_fac.ext_fac_id=o.pharmacyId
     left join message_profile mp on mp.ext_fac_id=o.pharmacyId
     left join pho_phys_order_outbound_message_control cntr on cntr.phys_order_id=o.phys_order_id AND mp.message_profile_id=cntr.message_profile_id
     left outer join pho_phys_order_discharge_snapshot disorder with (NOLOCK) on  disorder.phys_order_id=o.phys_order_id
     Inner join dbo.pcc_num_sequence num with (nolock)
 on num.num <= @vCopy
     )
     ,  tbWithSort
     as
     (
     -- this report does not require sorting, setting all of them to null
 Select fac_id
         ,  physician +  physician_designation as physician_designation
         , dea_number
         , nadea_number
         , case when ltrim(rtrim(phys_address))<>'' then  phys_address
     + case when phys_city<>'' then 	 COALESCE(', '+phys_city , '')
     + case when  phys_prov_state<>'' then COALESCE(', '+phys_prov_state , '')
     + case when  phys_postal_zip_code<>'' then  COALESCE(' '+phys_postal_zip_code , '')  else '' end
     else '' end
     else
     case when  phys_prov_state<>'' then COALESCE(', '+phys_prov_state , '')
     + case when  phys_postal_zip_code<>'' then  COALESCE(' '+phys_postal_zip_code , '')  else '' end
     else case when  phys_postal_zip_code<>'' then  COALESCE(' '+phys_postal_zip_code , '')  else '' end
     end
     end

     else
     case when phys_city<>'' then phys_city else '' end +
     case when  phys_prov_state<>'' then phys_prov_state
     + case when  phys_postal_zip_code<>'' then COALESCE(' '+phys_postal_zip_code , '') else '' end
     else  case when  phys_postal_zip_code<>'' then COALESCE(' '+phys_postal_zip_code , '') else '' end end

     end  physician_address
         , supervisor+supr_designation	 supervisor
         , supervisor_dea_number
         , client_name
         , order_date
         , created_date
         , client_age
         , client_gender
         , date_of_birth
         , upper(facility_name) as facility_name

         , fac_address1
         , fac_address2
         , fac_city
         , fac_prov
         , fac_tel
         , fac_pc
         , client_address1 client_address1
         , client_address2 client_address2
         , client_city client_city
         , client_prov_state client_prov_state
         , client_postal client_postal
         , order_summary as order_summary_related_generic
         ,	quantity
         ,	unit_of_measure
         ,	no_of_refills
         , phys_order_id
         ,message_control_id
         , pharmacy_name
         , trans_status
         , trans_date
         , cast(num as varchar) + '_' +
     Case when @vSort = 'physician_name' then
     convert(varchar, tbBase.physician_id)  +  '_'  + tbBase.client_id_str
     else
     tbBase.client_id_str  +  '_'  + convert(varchar, tbBase.physician_id )
     end

     as p_set_id
         ,
     case when  @vReportType='ep' then
     DENSE_RANK() OVER ( ORDER BY num,
     Case when @vSort='client_name' then client_name
     when @vSort='physician_name' then tbBase.physician+' '+client_name end ,
     case when   @vSort='trans_date' then tbBase.trans_date
     end desc,tbBase.order_summary--,physician_name

     )
     else
     DENSE_RANK() OVER ( ORDER BY num
         , Case when @vSort = 'physician_name' then tbBase.physician
     else tbBase.client_name
     end

         , Case when @vSort = 'physician_name' then tbBase.client_name
     else tbBase.physician
     end
         , Case when @vSort = 'physician_name' then tbBase.physician_id
     else cast(tbBase.client_id_str as int)
     end
         , Case when @vSort = 'physician_name' then cast(tbBase.client_id_str as int)
     else tbBase.physician_id
     end

         ,tbBase.trans_date, tbBase.order_summary
     )
     end as row_num
         , NULL as P1
         , NULL as P2
         , NULL as P3
         , registration_code
         , attestation
         , prescription_dispense_interval
         , prescription_total_authorized_quantity
 from tbBase
     )

Select
    fac_id
     , isnull(physician_designation ,'')  physician_designation
     , isnull(dea_number,'') dea_number
     , isnull(nadea_number ,'')  nadea_number
     , isnull(physician_address,'')  physician_address
     , isnull(supervisor,' ')	supervisor
     , isnull(supervisor_dea_number ,' ') supervisor_dea_number
     , client_name
     --, order_date
     , created_date
     , isnull(client_age,'') client_age
     , isnull(client_gender ,'') client_gender
     , isnull(date_of_birth ,'')  date_of_birth
     , isnull(facility_name ,'')  facility_name

     , isnull(fac_address1 ,'') fac_address1
     , isnull(fac_address2,'')  fac_address2
     , isnull(fac_city,'')  fac_city
     , isnull(fac_prov,'') fac_prov
     , isnull(fac_tel ,'')  fac_tel
     , isnull(fac_pc ,'')  fac_pc
     , isnull(client_address1 ,'')	client_address1
     , isnull(client_address2	,'')	client_address2
     , isnull(client_city  ,'')  client_city
     , isnull(client_prov_state ,'') client_prov_state
     , isnull(client_postal ,'')client_postal
     , order_summary_related_generic
     , isnull(quantity,'')  quantity
     , unit_of_measure	unit_of_measure
     , no_of_refills  no_of_refills
     , phys_order_id
     , message_control_id
     , pharmacy_name
     , trans_status
     , trans_date
     ,order_date
     , row_num
     , @vTermClient
     , Case when row_num =1 then @status_code else NULL  end as status_code
     , Case when row_num =1 then @status_text else NULL  end as status_text
     , isnull(registration_code ,'')  registration_code
     , isnull(attestation ,'')  attestation
     , isnull(prescription_dispense_interval, '') prescription_dispense_interval
     , isnull(prescription_total_authorized_quantity, '') prescription_total_authorized_quantity

from tbWithSort
Order by row_num



    if @debug_me='Y' Print 'Successful execution of stored procedure ' + Object_name(@@ProcID) + ' ' + convert(varchar(26),getdate(),109);


END TRY

BEGIN CATCH
if @status_code = 0 Set @Status_Code = 1 else set @status_code = 2  --- convert 3 to 2
	if @status_code = 1
BEGIN
select @Status_Text = Rtrim(Left('Stored Procedure Failed with error Code : ' +   Cast(@@error as Varchar(10)) +  ' Line Number : ' +  Cast(ERROR_LINE() as Varchar(5)) + ' ' +  ERROR_MESSAGE(),3000))

           if @debug_me='Y' Print 'Stored procedure failure in step:'+ convert(varchar(3),@vstep) + '	' + convert(varchar(26),getdate())
		if @debug_me='Y' Print 'Error code: '+convert(varchar(3),@vStep) + '; Error description:	' + @Status_Text
END


Select
    NULL fac_id
     ,NULL physician_designation
     ,NULL dea_number
     ,NULL nadea_number
     ,NULL physician_address
     ,NULL supervisor
     ,NULL supervisor_dea_number
     ,NULL client_name
     --, order_date
     ,NULL created_date
     ,NULL client_age
     ,NULL client_gender
     ,NULL date_of_birth
     ,NULL facility_name
     ,NULL fac_address1
     ,NULL fac_address2
     ,NULL fac_city
     ,NULL fac_prov
     ,NULL fac_tel
     ,NULL fac_pc
     ,NULL client_address1
     ,NULL client_address2
     ,NULL client_city
     ,NULL client_prov_state
     ,NULL client_postal
     ,NULL order_summary_related_generic
     ,NULL quantity
     ,NULL unit_of_measure
     ,NULL no_of_refills
     ,NULL phys_order_id
     ,NULL message_control_id
     ,NULL pharmacy_name
     ,NULL trans_status
     ,NULL trans_date
     ,NULL row_num
     ,@vTermClient
     , (case WHEN charindex('getorderstatus',@status_text)>0 THEN 0 else @status_code END) as status_code
     , @status_text as status_text
     ,NULL registration_code
     ,NULL attestation
     ,NULL prescription_dispense_interval
     ,NULL prescription_total_authorized_quantity



END CATCH

RETURN

END
GO

GRANT EXECUTE ON  dbo.sproc_prp_rl_electronic_prescription_report   to PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_prp_rl_electronic_prescription_report.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_electronic_prescription_report.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_rent_roll_report3.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*
===================================================================================================== 
PCC-54915:             Script to create [sproc_prp_rl_rent_roll_report3] Procedure  in Client Database

Written By:            Dominic Christie
Reviewed By:         
 
PCC-96830:             Migrate Stored Procedures
Revision By:           Thomas Kim
Reviewed By:    

Script Type:           DDL 
Target DB Type:        Client Database
Target ENVIRONMENT:    BOTH
 
Re-Runable:            YES
 
Description of Script: Display rent charges for beds in all rooms.
 
Special Instruction:  
=====================================================================================================
*/

IF EXISTS ( SELECT   ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_prp_rl_rent_roll_report3' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE dbo.sproc_prp_rl_rent_roll_report3
END
GO

CREATE Procedure dbo.sproc_prp_rl_rent_roll_report3  
	  @fac_id INT
	, @room_status VARCHAR(2500)
	, @show_empty_companion_beds BIT
	, @show_occupied_companion_beds BIT
	, @living_unit_id INT
	, @effective_date DATETIME
	, @execution_user_login VARCHAR(60)
	, @enforce_max_weight_flag BIT
	, @order_by INT = 0					-- 0(default) - by room, 1 - by last name, 2 - by first name
	, @report_format_type VARCHAR(3)	-- pdf or csv
	, @emc_flag BIT = 0
	, @rows_returned INT OUT
	, @debug_me CHAR(1) = 'N'
	, @status_code INT  OUT
	, @status_text VARCHAR(3000) OUT
  
/****************************************************************************************************  
--SAMPLE EXECUTION SCRIPT  
  
DECLARE @rows_ret int, @statuscode int, @statustext VARCHAR(3000);
EXEC dbo.sproc_prp_rl_rent_roll_report3
	@fac_id = 1,
	@room_status = '-1',
	@show_empty_companion_beds = 1,
	@show_occupied_companion_beds = 1,
	@living_unit_id = -1,
	@effective_date = '2020-07-30',
	@execution_user_login = 'pcc-parras',	-- use your pcc login here or script won't return any results
	@enforce_max_weight_flag = 1,
	@order_by = 0,							-- 0(default) - by room, 1 - by last name, 2 - by first name
	@report_format_type = 'pdf',			-- if not pdf, then csv
	@emc_flag = 0,
	@rows_returned = 0,
	@debug_me = 'Y',
	@status_code = null,
	@status_text = null;
SELECT @rows_ret, @statuscode int, @statustext;
*****************************************************************************************************/  

AS
BEGIN

SET NOCOUNT ON;  

--DECLARE Standard local variables required for any store proc  
DECLARE @vStep INT  
	,@vErr VARCHAR(MAX)  
	,@vRowCount INT  
	,@vLivingUnitID INT  
	,@vEffectiveDate DATETIME = CONVERT(DATE, @effective_date)	 -- truncate time
	,@vFirstDay DATETIME  
	,@vEndOfMonth DATETIME  
	,@vRoomStatus VARCHAR(2500)   
	,@vTotalDaysInMonth INT
	,@Today DATETIME = CONVERT(DATE, GETDATE())
	;
----Local Variables  
DECLARE @vFacId int  
	,@vReportId int  
	,@vCHARNewLine  CHAR(2)  
	,@vdelim CHAR(1)  
	,@visemc BIT  
	,@vselected_parameters VARCHAR(4000)
	,@vDefaultPayerID INT
	,@vDefaultEmptyBedScheduleID INT
	,@vZeroWeightRateId INT
	,@vDefaultSecurityDepositPayerId INT
;  
  
DECLARE @vFacIDs VARCHAR(max);
DECLARE @PRP_FacList as table(FacId int);
DECLARE @vFacWarningMsg VARCHAR(max);
DECLARE @vOrderBy INT = @order_by;
  
-----Governor and Statistics Variables   
DECLARE
	 @vgs_program_name VARCHAR(200) = Object_name(@@ProcID)  ---Current Store Proc Name  
	,@vgs_executiON_user VARCHAR(60)  
	,@vgs_fill_END_time DATETIME  
	,@vGeneric_statuscode int   
	,@vGeneric_statustext VARCHAR(3000)  
	,@vgsStepStartTime DATETIME  
	,@vgsTotalStartTime DATETIME  
	,@vgsFacID VARCHAR(max)		
	,@vgsParamName1 VARCHAR(12) 
	,@vgsParamValue1 VARCHAR(2500) 
	,@vgsParamName2 VARCHAR(19) 
	,@vgsParamValue2 VARCHAR(254) 
	,@vgsParamName3 VARCHAR(25)
	,@vgsParamValue3 VARCHAR(17)
	;

DECLARE 
	  @exclStatusType       CHAR (1)    = 'V'
	, @exclActionDischarge  VARCHAR(10) = 'Discharge'
	, @exclActionDeath		VARCHAR(10) = 'Death'
	;

BEGIN TRY

	SET @vStep = 1;
	SET @vgsStepStartTime = GETDATE();
	SET @vgsTotalStartTime = @vgsStepStartTime;
	IF @debug_me='Y'
	BEGIN
		IF @vgs_program_name IS NULL
			SET @vgs_program_name = 'SprocCodeTest'

		PRINT 'Executing store proc :  ' + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Set vars and Getting Parameter Details for Statistics Logging and Report Selection Header :  ' + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);
	END

	IF (@fac_id IS NULL  
		OR @execution_user_login IS NULL
		OR @living_unit_id IS NULL
		OR @effective_date IS NULL
		OR @room_status IS NULL
		)
	BEGIN
		SET @vErr = 'One or more of the following input parameters is invalid... '  
			+ ' @fac_id=' + isNULL(CONVERT(VARCHAR(10),@fac_id),'NULL/empty')  
			+ ', @execution_user_login=' + isNULL(@execution_user_login,'NULL/empty')  
			+ ', @living_unit_id=' + isNULL(CONVERT(VARCHAR(10),@living_unit_id),'NULL/empty')  
			+ ', @effective_date=' + isNULL(CONVERT(VARCHAR(26),@effective_date,109),'NULL/empty')  
			+ ', @room_status=' + isNULL(@room_status,'NULL/empty');
  
		RAISERROR (@vErr -- Message text  
					,11 -- Severity (RAISERROR with severity 11-19 will cause executiON to jump to the CATCH block)  
					,1 -- State  
			);  
	END  
  
	--SET Standard variables
	SET @status_code = 0;   ---- Status Code 0 = Success, 1 = Exception  
	SET @status_text = NULL;  
	SET @rows_returned = 0;  
	SET @vgs_execution_user = @execution_user_login; 
	SET @vdelim = ','
	SET @vCHARNewLine  = CHAR(13) + CHAR(10); 

	----Parameter Sniffing - use local variables when they are used in a where clause  
	SET @vFacID = @fac_id;
	SET @vLivingUnitID = @living_unit_id;  
	SET @vRoomStatus = @room_status;
	SET @vFirstDay = DATEADD(DAY, 1, EOMONTH(@vEffectiveDate, -1));
	SET @vEndOfMonth = DATEADD(DAY, 1, EOMONTH(@vEffectiveDate));
	SET @vEndOfMonth = DATEADD(SECOND, -1, @vEndOfMonth);

	SET @vTotalDaysInMonth = DAY(EOMONTH(@vEffectiveDate));
	-- set all the parameter name for statistics logging and for the Report Selection Header

	IF (@debug_me = 'Y')
		SELECT '@vEndOfMonth', @vEndOfMonth;

	SET @vgsParamName1  = 'Status';
	SET @vgsParamValue1 = IIF(@vRoomStatus = '-1', 'All', @vRoomStatus);

	SELECT @vgsParamName2 = term_room + ' Type'	
	FROM [dbo].fn_prp_get_terminology(@vFacID, @emc_flag) 
	WHERE fac_id=@vFacID 

	SELECT @vgsParamName3 = 'Show Companion ' + term_beds
	FROM [dbo].fn_prp_get_terminology(@vFacID, @emc_flag) 
	WHERE fac_id = @vFacID;

	SET @vgsParamValue3 =	CASE
								WHEN @show_empty_companion_beds = 1 AND @show_occupied_companion_beds = 1 
									THEN 'All'
								WHEN @show_empty_companion_beds = 1 OR @show_occupied_companion_beds = 1 
									THEN IIF(@show_empty_companion_beds = 1, 'Empty', 'Occupied')
								ELSE 'None'
							END;

	--Get default private payer for the facility
	SET @vDefaultPayerID = (
		SELECT TOP(1) default_payer_id
		FROM ar_configuration
		WHERE (fac_id = @fac_Id	OR fac_id = -1)
			AND default_payer_id IS NOT NULL
	);

	IF @debug_me = 'Y'
		SELECT '@vDefaultPayerID', @vDefaultPayerID

	SET @vDefaultSecurityDepositPayerId = (
		SELECT TOP(1) default_security_deposit_payer_id
		FROM ar_configuration
		WHERE (fac_id = @fac_Id	OR fac_id = -1)
			AND default_security_deposit_payer_id IS NOT NULL
	);
	IF @vLivingUnitID=-1
		SELECT @vgsParamValue2 = 'All';
	ELSE 
		SELECT @vgsParamValue2 = item_Description
		FROM common_code
		WHERE item_code='rtype'
			AND deleted='N'
			AND item_id=@vLivingUnitID

	SELECT @vselected_parameters = '    ' + @vgsParamName2 + ': ' + @vgsParamValue2 
		+ '    ' + @vgsParamName1 + ': ' +  @vgsParamValue1
		+ '    ' + @vgsParamName3 + ': ' +  @vgsParamValue3

	IF @debug_me='Y'
	BEGIN
		PRINT 'selected_parameters:' + @vselected_parameters;
		PRINT 'STEP ' +  CONVERT(VARCHAR(20), @vStep) + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';
	END;


	SET @vStep = 2; 
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep)
			+ ' Getting user access fac list '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);
  
	 SELECT  @vFacIds = fac_id, @vFacWarningMsg = msg
	 FROM  dbo.fn_prp_get_facility_access_list_delim(@fac_id,@vgs_execution_user); ---filter the fac list with user access  

	 IF @debug_me='Y'
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep)
			+ ' Facilities returned=[' + isNULL(@vFacIds,'NULL') + '] Facility access warning message=[' + isNULL(@vFacWarningMsg,'') + '] ' + CONVERT(VARCHAR(26),getdate(),109);
  
	 --facilities warnings  
	 IF @vFacWarningMsg is NOT NULL --- NOT NULL means restricted facilities access warning message  
	 BEGIN  
	  SET @status_code = 2; ----Set it to warning status  
	  SET @status_text = isNULL(@status_text,'') + @vFacWarningMsg;  
	 END   
  
	--fill facids into @PRP_FacList   
	 SELECT  @vFacId = Cast(items as int)
	 FROM dbo.Split(@vFacIds,@vDelim);  ----ONly ONe FacId is expected at a time

	 IF @@ROWCOUNT = 0  ---- only if there is any FacCount proceed further  
	 BEGIN  
	  IF @status_code = 0 
		SET @status_code = 3; --Set it to error status  
	  RAISERROR( @status_text,11,1);  
	 END   
  
	if @debug_me='Y' Print 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: ' + LTRIM(RTRIM(STR(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';
  
  
	SET @vStep = 3;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y'
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep)
			+ ' Creating Temp Tables and Table Variables Required for The Proc '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

	DECLARE @room_sum_for_jrxml TABLE
		(room_id					INT
		,total_market_rate			MONEY
		,total_actual_rate			MONEY
		,total_discount				MONEY
		,total_deposit_received		MONEY
		,bed_count					INT
		,total_occupied_weight		FLOAT
		);

	DECLARE @availableOccupiedDays TABLE (
		  bed_id         INT
		, occupied_days  INT
		, available_days INT
	);

	CREATE TABLE #RentRollData
		(fac_id INT  
		,room_id INT  
		,bed_id INT
		,client_id INT
		,room_desc VARCHAR(60)  
		,bed_desc VARCHAR(30)  
		,room_type  VARCHAR(250)  
		,sq_footage INT  
		,market_rate  MONEY
		,actual_rate  MONEY
		,room_rate VARCHAR(50)   
		,rate_type_id INT
		,weight float
		,primary_payer_name VARCHAR(50)
		,discount MONEY
		,deposit_required BIT
		,deposit_amount MONEY
		,deposit_received MONEY  
		,lease_start_date DATETIME   
		,lease_end_date DATETIME 
		,estimated_move_out DATETIME
		,occupied_days INT DEFAULT(0)
		,vacant_days INT DEFAULT(0)
		,bed_status  VARCHAR(250) 
		,bed_status_id CHAR(1) DEFAULT(0) 
		,room_status  VARCHAR(250)
		,bed_count INT 
		,inactive_no_show BIT
		,inactive_Days SMALLINT
		-----------These Columns are added to facilitate the summary calculation in JRXML
		,is_unit_occupied INT  
		,is_bed_occupied INT 
		,occupied_market_rate MONEY
		,occupied_actual_rate MONEY
		,occupied_discount MONEY
		,occupied_sq_footage  INT
		,occupied_bed_id INT
		,occupied_room_id INT
		,total_deposit_required  MONEY  
		,Status_type VARCHAR(150)
		,is_bed_addnl_bed BIT 
		,is_bed_addnl_row_UPT BIT
		,is_rv_weight_1  CHAR(1)   DEFAULT(0) 
		,is_market_rate BIT
		,is_companion BIT
		,anniversary_date DATETIME
		,is_incomplete_census BIT
		);  
  
	IF @debug_me='Y'
		PRINT 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';
  
  
	SET @vStep = 4;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep)
			+ ' Getting Default Rates and Dates for Rooms '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

	--Get standard schedule ID

	SELECT @vDefaultEmptyBedScheduleID = (
		SELECT TOP 1 alrs.schedule_id 
		FROM dbo.ar_lib_rate_schedule alrs WITH (NOLOCK)
			JOIN ar_rate_schedule ars WITH (NOLOCK)
				ON ars.schedule_id = alrs.schedule_id
					AND ars.fac_id = @vFacID
			JOIN ar_rate_status arss WITH (NOLOCK)
				ON arss.payer_id = @vDefaultPayerID
					AND arss.fac_id = ars.fac_id
					AND arss.schedule_id = ars.schedule_id
		WHERE alrs.deleted = 'N' 
			AND ((alrs.reg_id IS NULL AND (alrs.fac_id = '-1' OR alrs.fac_id = @vFacID)) OR (alrs.reg_id IS NOT NULL))
			AND alrs.description LIKE 'Standard%' 
		ORDER BY alrs.schedule_id
	);

	IF @vDefaultEmptyBedScheduleID IS NULL
	BEGIN
		SELECT @vDefaultEmptyBedScheduleID = (
			SELECT TOP 1 alrs.schedule_id 
			FROM dbo.ar_lib_rate_schedule alrs WITH (NOLOCK)
				JOIN ar_rate_schedule ars WITH (NOLOCK)
					ON ars.schedule_id = alrs.schedule_id
						AND ars.fac_id = @vFacID
				JOIN ar_rate_status arss WITH (NOLOCK)
					ON arss.payer_id = @vDefaultPayerID
						AND arss.fac_id = ars.fac_id
						AND arss.schedule_id = ars.schedule_id
			WHERE alrs.deleted = 'N' 
				AND ((alrs.reg_id IS NULL AND (alrs.fac_id = '-1' OR alrs.fac_id = @vFacID)) OR (alrs.reg_id IS NOT NULL))
			ORDER BY alrs.schedule_id
			);
	END;

	IF @debug_me = 'Y'
		SELECT '@vDefaultEmptyBedScheduleID', @vDefaultEmptyBedScheduleID;

	SELECT TOP (1) @vZeroWeightRateId = r.rate_type_Id
	FROM ar_rate_type_category c
		JOIN  ar_lib_rate_type l
			ON l.category_id = c.category_id
				AND l.deleted = 'N'
		JOIN ar_rate_type r
			ON r.rate_type_id = l.rate_type_id
				AND r.fac_id = @vFacId
	WHERE c.weight = 0
		AND c.deleted = 'N'
	ORDER BY r.rate_type_Id
	;

	IF @debug_me = 'Y'
		SELECT '@vZeroWeightRateId', @vZeroWeightRateId;

	IF @debug_me = 'Y'
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms ';


	SET @vStep = 5;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y'
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Handling the Inactive Beds '  + @vgs_program_name  + CONVERT(VARCHAR(26),GETDATE(),109);

	SELECT bed_id
		, inactive_days = DATEDIFF(dd, IIF(@vFirstDay > startdate, @vFirstDay, startdate), IIF(enddate IS NULL OR enddate > @vEffectiveDate , @vEffectiveDate, enddate)) + 1
	INTO #InactiveBeds
	FROM dbo.bed_state WITH (NOLOCK)
	WHERE deleted = 'N'
		AND startdate <= @vEffectiveDate
		AND (enddate IS NULL OR enddate > @vFirstDay)
		AND fac_id = @vFacID
	;

	SELECT bed_id
		, inactive_days = SUM(inactive_days)
	INTO #InactiveBedDays
	FROM #InactiveBeds
	GROUP BY bed_id
	;

	IF @debug_me = 'Y'
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms ';


	SET @vStep = 6;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Getting the Details for OCCUPIED Beds/Clients Rate '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

	SELECT room.fac_id
		, room.room_id
		, room.room_desc
		, bed.bed_id
		, bed.bed_Desc
		, roomtype.item_description
		, room.square_footage
		, rdr.deposit_required
		, rdr.deposit_amount
		, rdr.rate_type_id
		, total_deposit_required = IIF(rdr.deposit_required = 0, NULL, rdr.deposit_amount)
		, ib.inactive_days
	INTO #RoomBed
	FROM dbo.room WITH (NOLOCK)
		JOIN dbo.bed WITH (NOLOCK)
			ON bed.room_id = room.room_id
				AND bed.fac_id = room.fac_id
				AND bed.deleted = 'N'
				AND (bed.retired_date IS NULL OR bed.retired_date > @vEffectiveDate)
		JOIN dbo.room_date_range rdr WITH (NOLOCK)
			ON rdr.room_id = room.room_id
				AND rdr.deleted = 'N'
				AND rdr.effective_Date <= @vEffectiveDate
				AND (rdr.ineffective_date IS NULL OR rdr.ineffective_Date >= @vEffectiveDate)
		LEFT JOIN dbo.common_code roomtype WITH (NOLOCK)
			ON rdr.accommodation_id = roomtype.item_id
				AND roomtype.deleted='N'
				AND item_code = 'rtype'
		LEFT JOIN #InactiveBedDays ib
			ON ib.bed_id = bed.bed_id
				AND ib.inactive_days >= @vTotalDaysInMonth
	WHERE (@vLivingUnitID = -1 OR roomtype.item_id = @vLivingUnitID) --either ALL or specIFic
		AND room.fac_id = @vFacID
		AND room.deleted = 'N'
		AND ib.bed_id IS NULL
	;

	IF (@debug_me = 'Y')
		SELECT '#RoomBed', * 
		FROM #RoomBed
		ORDER BY room_id, bed_id;

	SELECT crpair.client_id
		, crpair.c_census_id
		, r_census_id = IIF(c.incomplete = 'Y', NULL, crpair.r_census_id)
		, c.status_code_id
		, c.action_code_id
		, c.bed_id
		, status_type = statusCode.action_type
		, actCode.action_type
		, r.actual_accomm_id
		, r.eff_schedule_id
		, c.primary_payer_id
		, primary_payer_name = lpay.description
		, ars.schedule_id
		, r.rugs_code
		, r.alternate_care_level
		, c_effective_date = c.effective_date
		, c_ineffective_date = c.ineffective_date
		, c.incomplete
	    , r_effective_date = r.effective_date
	INTO #CensusDetails
	FROM dbo.fn_census_flattenedFacilitySummary(@vFacID, @vEndOfMonth) crpair
		JOIN census_item c WITH (NOLOCK)
			ON c.census_id = crpair.c_census_id
				AND c.status_code_id NOT IN (-1, 17)
				AND c.effective_date <= @vEndOfMonth
				AND c.deleted = 'N'
		JOIN census_codes statusCode WITH (NOLOCK)
			ON statusCode.item_id = c.status_code_id 
				AND statusCode.deleted = 'N'
				AND statusCode.action_type <> @exclStatusType
		JOIN census_codes actCode WITH (NOLOCK)
			ON actCode.item_id = c.action_code_id 
				AND actCode.deleted = 'N'
				AND (actCode.action_type IS NULL OR actCode.action_type NOT IN (@exclActionDischarge, @exclActionDeath))
		LEFT JOIN census_item r WITH (NOLOCK)
			ON r.census_id = crpair.r_census_id
				AND r.deleted = 'N'
		LEFT JOIN ar_lib_payers lpay WITH (NOLOCK)
			ON lpay.payer_id = c.primary_payer_id
				AND lpay.deleted = 'N'
		LEFT JOIN dbo.ar_rate_status ars WITH (NOLOCK)
			ON ars.status_id = c.status_code_id
				AND ars.fac_id = c.fac_id
				AND ars.payer_id = c.primary_payer_id
	WHERE crpair.stop_billing_flag = 0
	;

	IF (@debug_me = 'Y')
		SELECT '#CensusDetails', * 
		FROM #CensusDetails
		ORDER BY client_id, c_census_id, bed_id;

	SELECT flat.client_id
		, flat.c_census_id
		, flat.r_census_id
		, flat.status_code_id
		, flat.action_code_id
		, flat.status_type
		, flat.action_type
		, flat.bed_id
		, flat.actual_accomm_id
		, flat.eff_schedule_id
		, flat.primary_payer_id
		, flat.primary_payer_name
		, flat.schedule_id
		, flat.rugs_code
		, flat.alternate_care_level
		, flat.c_effective_date
		, flat.c_ineffective_date
		, is_secondary_bed = 0
		, flat.incomplete
	    , flat.r_effective_date
	INTO #CensusPrimarySecondaryBeds
	FROM #CensusDetails flat
	UNION ALL
	SELECT flat.client_id
		, flat.c_census_id
		, flat.r_census_id
		, flat.status_code_id
		, flat.action_code_id
		, flat.status_type
		, flat.action_type
		, secc.bed_id
		, secr.actual_accomm_id
		, secr.eff_schedule_id
		, flat.primary_payer_id
		, flat.primary_payer_name
		, flat.schedule_id
		, flat.rugs_code
		, flat.alternate_care_level
		, flat.c_effective_date
		, flat.c_ineffective_date
		, is_secondary_bed = 1
		, flat.incomplete
	    , flat.r_effective_date
	FROM #CensusDetails flat
		JOIN census_item_secondary_bed secc WITH (NOLOCK)
			ON secc.census_id = flat.c_census_id
		LEFT JOIN census_item_secondary_rate secr WITH (NOLOCK)
			ON secr.census_id = flat.r_census_id
	;

	SELECT psbed.client_id
		, psbed.c_census_id
		, psbed.r_census_id
		, psbed.c_effective_date
		, psbed.c_ineffective_date
		, psbed.status_type
		, psbed.action_type
		, psbed.actual_accomm_id
		, psbed.eff_schedule_id
		, psbed.is_secondary_bed
		, psbed.primary_payer_id
		, psbed.primary_payer_name
		, psbed.schedule_id
		, psbed.rugs_code
		, psbed.alternate_care_level
		, psbed.bed_id
		, bed.room_id
		, rtc.weight
		, lrt.rate_type_id
		, rate_type_description = lrt.long_description
		, bed_row_num = ROW_NUMBER() OVER (PARTITION BY psbed.bed_id ORDER BY psbed.c_effective_date DESC) -- latest client in count, others ignored
		, psbed.incomplete
	    , psbed.r_effective_date
	INTO #CensusBedWeightFiltered
	FROM #CensusPrimarySecondaryBeds psbed
		JOIN #RoomBed bed
			ON bed.bed_id = psbed.bed_id
		LEFT JOIN ar_lib_rate_type lrt WITH (NOLOCK)
			ON lrt.rate_type_id = psbed.actual_accomm_id
				AND lrt.deleted = 'N' 
				AND lrt.version_flag = 1
		LEFT JOIN ar_rate_type_category rtc WITH (NOLOCK)
			ON rtc.category_id = lrt.category_id
				AND rtc.deleted = 'N'
	;

	SELECT cbed.bed_id
		, monthly_reimb_rate = 
			dbo.fn_ar_getCensusMonthlyPayRate
				( cbed.r_census_id
				, cbed.eff_schedule_id
				, cbed.rugs_code
				, cbed.alternate_care_level
				, cbed.is_secondary_bed
				)
		, monthly_pay_rate = 
			CASE
			WHEN effrs.is_market_rate = 1 THEN 
				Round(( effrs.percentage_of_market_rates * mr.monthly_rate ) / 100, 2)
			ELSE
				dbo.fn_ar_getCensusMonthlyRate
					( cbed.r_census_id
					, cbed.eff_schedule_id
					, cbed.rugs_code
					, cbed.alternate_care_level
					, cbed.is_secondary_bed
					)
			END
		, daily_reimb_rate = 
			dbo.fn_ar_getCensusDailyPayRate
				( cbed.r_census_id
				, cbed.eff_schedule_id
				, cbed.rugs_code
				, cbed.alternate_care_level
				, cbed.is_secondary_bed
				)
		, daily_pay_rate = 
			CASE
			WHEN effrs.is_market_rate = 1 THEN 
				Round(( effrs.percentage_of_market_rates * mr.daily_rate ) / 100, 2)
			ELSE
				dbo.fn_ar_getCensusDailyRate
					( cbed.r_census_id
					, cbed.eff_schedule_id
					, cbed.rugs_code
					, cbed.alternate_care_level
					, cbed.is_secondary_bed
					)
			END
		, cbed.client_id
		, rate_type = cbed.rate_type_description
		, rate_type_id = cbed.rate_type_id
		, is_market_rate = ISNULL(effrs.is_market_rate, 0)
		, cbed.eff_schedule_id
	INTO #CensusRateAmount
	FROM #CensusBedWeightFiltered cbed
		LEFT JOIN ar_eff_rate_schedule effrs WITH (NOLOCK)
			ON effrs.eff_schedule_id = cbed.eff_schedule_id
				AND effrs.schedule_id = cbed.schedule_id
				AND effrs.fac_id = @vFacID
				AND effrs.is_market_rate = 1
	    LEFT JOIN ar_date_range effdr WITH (NOLOCK)
	        ON effrs.eff_date_range_id = effdr.eff_date_range_id
		LEFT JOIN ar_market_rates mr WITH (NOLOCK)
		    ON mr.room_id = cbed.room_id
		        AND mr.rate_type_id = effrs.market_rate_type_id
		        AND mr.deleted = 'N'
		LEFT JOIN ar_date_range_market_rates mrd WITH (NOLOCK)
		    ON mrd.eff_date_range_id = mr.eff_date_range_id
		        AND mrd.fac_id = effrs.fac_id
		        AND mrd.deleted = 'N'
		        AND mrd.applied = 1
		        AND mrd.eff_date_from <= COALESCE(effdr.eff_date_from, cbed.r_effective_date)
		        AND (mrd.eff_date_to IS NULL
		                OR COALESCE(effdr.eff_date_from, cbed.r_effective_date) <= mrd.eff_date_to)
	WHERE cbed.r_census_id IS NOT NULL
		AND cbed.bed_row_num = 1
        AND (mr.eff_date_range_id is null or mrd.eff_date_range_id = mr.eff_date_range_id);
	;

	SELECT cbed.status_type
		, cbed.action_type
		, a.rate_type_id
		, a.rate_type room_rate
		, market_rate =	COALESCE(a.monthly_pay_rate  , a.daily_pay_rate * @vTotalDaysInMonth  , a.monthly_reimb_rate, a.daily_reimb_rate * @vTotalDaysInMonth)
		, actual_rate =	COALESCE(a.monthly_reimb_rate, a.daily_reimb_rate * @vTotalDaysInMonth, a.monthly_pay_rate  , a.daily_pay_rate * @vTotalDaysInMonth)
		, cbed.bed_id
		, cbed.room_id
		, cbed.weight
		, cbed.primary_payer_name
		, cbed.client_id
		, a.is_market_rate
		, bed_row_num = ROW_NUMBER() OVER (PARTITION BY cbed.bed_id ORDER BY cbed.c_effective_date DESC) -- latest client in count, others ignored
	INTO #ActualAndMarketRates
	FROM #CensusBedWeightFiltered cbed
		LEFT JOIN #CensusRateAmount a
			ON a.client_id = cbed.client_id
				AND a.bed_id = cbed.bed_id
	;

	SELECT DISTINCT client_id
	INTO #Clients
	FROM #CensusDetails
	;

	SELECT tr.client_id
		, deposit_received = SUM(tr.amount)
	INTO #DepositReceived
	FROM #Clients cl
		JOIN dbo.ar_transactions tr WITH (NOLOCK)
			ON tr.client_id = cl.client_id
				AND tr.payer_id = @vDefaultSecurityDepositPayerId
				AND tr.fac_id = @vFacId
				AND tr.transaction_type = 'C'
				AND tr.is_posted = 1
				AND tr.deleted = 'N'
	GROUP BY tr.client_id
	;

	SELECT a.client_id
		, rla.lease_start_date
		, rla.lease_end_date
		, rla.anniversary_date
		, lease_row_num = ROW_NUMBER() OVER (PARTITION BY a.client_id ORDER BY rla.lease_start_date desc)
	INTO #RentrollLeaseAgreement
	FROM #Clients a
		JOIN dbo.rentroll_lease_agreement rla WITH (NOLOCK)
			ON rla.client_id = a.client_id
				AND rla.lease_start_date <= @vEffectiveDate 
		JOIN  dbo.rentroll_agreement_type agrtype WITH (NOLOCK)
			ON agrtype.agreement_type_id = rla.agreement_type_id 
				AND agrtype.agreement_type IN ('lease','Rent') 
				AND agrtype.active = 1
	;

	INSERT INTO #RentRollData
		( fac_id
		, room_id
		, room_desc
		, bed_id
		, bed_desc
		, client_id
		, room_type
		, sq_footage
		, market_rate
		, actual_rate
		, room_rate
		, rate_type_id
		, weight
		, primary_payer_name
		, discount
		, deposit_required
		, deposit_amount
		, deposit_received
		, bed_status_id
		, is_bed_occupied
		, occupied_market_rate
		, occupied_actual_rate
		, occupied_discount
		, occupied_sq_footage
		, occupied_bed_id
		, occupied_room_id
		, total_deposit_required
		, status_type
		, lease_start_date
		, lease_end_date
		, inactive_no_show
		, inactive_Days
		, is_bed_addnl_bed
		, is_market_rate
		, is_companion
		, anniversary_date
		, is_incomplete_census
		)
	SELECT @vFacId
		, roombed.room_id
		, roombed.room_desc
		, roombed.bed_id
		, roombed.bed_Desc
		, rate.client_id
		, roombed.item_description
		, roombed.square_footage
		, rate.market_rate
		, rate.actual_rate
		, room_rate = IIF(rate.bed_id IS NULL OR rate.client_id IS NULL, censusbed.rate_type_description, rate.room_rate)
		, rate_type_id = COALESCE(rate.rate_type_id, roombed.rate_type_id)
		, weight = rate.weight
		, rate.primary_payer_name
		, discount = rate.market_rate - rate.actual_rate
		, roombed.deposit_required
		, deposit_amount = IIF(roombed.deposit_required = 0, NULL, IIF(rate.bed_id IS NULL, NULL, roombed.deposit_amount * rate.weight))
		, deposit_received = dr.deposit_received * (-1) ----as per the logic for transaction
		, bed_status_id = CASE
			WHEN rate.bed_id IS NULL THEN IIF(ISNULL(roombed.inactive_days, 0) > 0, 5, 4)
			ELSE
				CASE
					WHEN rate.status_type=@exclStatusType THEN 4
					WHEN ((rate.action_type = 'Room Reserve' AND rate.status_type <> @exclStatusType) OR rate.status_type = 'N' ) THEN 2
					ELSE 1
				END
			END
		, is_bed_occupied = CASE WHEN rate.bed_id IS NULL THEN 0 ELSE 1 END
		, occupied_market_rate = rate.market_rate
		, occupied_actual_rate = rate.actual_rate
		, occupied_discount = rate.market_rate - rate.actual_rate
		, occupied_sq_footage = CASE WHEN rate.bed_id IS NULL THEN NULL ELSE roombed.square_footage END
		, occupied_bed_id = rate.bed_id
		, occupied_room_id = rate.room_id
		, total_deposit_required = IIF(roombed.deposit_required = 0, NULL, roombed.deposit_amount)
		, rate.action_type
		, lease_start_date
		, lease_end_date
		, inactive_no_show = IIF(roombed.inactive_days IS NOT NULL AND roombed.inactive_days > 0, 1, 0)
		, roombed.inactive_days
		, is_bed_addnl_bed = ISNULL(censusbed.is_secondary_bed, 0)
		, rate.is_market_rate
		, is_companion = IIF(rate.weight = 0 AND rate.bed_id IS NOT NULL, 1, NULL)
		, rla.anniversary_date
		, is_incomplete_census = IIF(censusbed.incomplete = 'Y', 1, 0)
	FROM #RoomBed roombed
		LEFT JOIN #ActualAndMarketRates rate
			ON rate.bed_id = roombed.bed_id
				AND rate.bed_row_num = 1
		LEFT JOIN #CensusBedWeightFiltered censusbed
			ON censusbed.bed_id = roombed.bed_id
				AND censusbed.bed_row_num = 1
		LEFT JOIN #RentrollLeaseAgreement rla
			ON rla.client_id = rate.client_id 
				AND lease_row_num = 1
		LEFT JOIN #DepositReceived dr
			ON dr.client_id = rate.client_id
				AND ISNULL(censusbed.is_secondary_bed, 0) = 0
	;

	IF @debug_me='Y'
		SELECT '#RentRollData1', * 
		FROM #RentRollData
		ORDER BY room_id, bed_id, client_id;

	IF @debug_me='Y'
		PRINT 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' (OCCUPIED) complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';


	SET @vStep = 7;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Getting the Details for EMPTY Beds'  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

	SELECT s.schedule_id
		, s.eff_date_range_id
		, s.fac_id
		, s.eff_schedule_id
		, s.rate_type_id
		, s.is_manual_rate
		, s.is_manual_pay_rate
		, care_level_code = cti.care_level_code
		, s.is_custom_rate
		, alt.is_alt
		, s.is_market_rate
		, care_level_template_id = cti.care_level_template_id
		, s.rate_template_id
		, adr.eff_date_from
		, s.pay_rate_template_id
		, s.rate_template_pct
		, s.pay_rate_template_pct
	INTO #ScheduleDetails
	FROM ar_eff_rate_schedule s
		JOIN ar_date_range adr
			ON adr.eff_date_range_id = s.eff_date_range_id
				AND adr.fac_id = s.fac_id
				AND adr.deleted = 'N'
				AND adr.eff_date_from <= @vEffectiveDate
				AND (adr.eff_date_to >= @vEffectiveDate OR adr.eff_date_to IS NULL)
				AND adr.payer_id = @vDefaultPayerID
		CROSS JOIN (
				SELECT 0 AS is_alt
				UNION ALL
				SELECT 1
			) alt
		LEFT JOIN dbo.ar_lib_care_level_template_item cti WITH (NOLOCK)
			ON ((alt.is_alt = 1 AND adr.alt_care_level_template_id = cti.care_level_template_id)
					OR (alt.is_alt = 0 AND adr.care_level_template_id = cti.care_level_template_id))
				AND cti.effective_date <= adr.eff_date_from
				AND (cti.ineffective_date >= adr.eff_date_from OR cti.ineffective_date IS NULL)
				AND cti.deleted = 'N'
	WHERE s.schedule_id = @vDefaultEmptyBedScheduleID
	;

	SELECT aers.schedule_id
		, aers.eff_date_range_id
		, aers.fac_id
		, aers.eff_schedule_id
		, aers.rate_type_id
		, amr.room_id
		, monthly_rate = ROUND(( aers.percentage_of_market_rates * amr.monthly_rate ) / 100, 2)
		, daily_rate = ROUND(( aers.percentage_of_market_rates * amr.daily_rate ) / 100, 2)
	INTO #MarketRates
	FROM ar_eff_rate_schedule aers
		JOIN dbo.ar_market_rates amr
			ON aers.is_market_rate = 1
				AND amr.eff_date_range_id = aers.market_date_range_id
				AND amr.deleted = 'N'
				AND amr.rate_type_id = aers.market_rate_type_id
		JOIN ar_date_range_market_rates adrmr
			ON adrmr.eff_date_range_id = aers.market_date_range_id
				AND adrmr.fac_id = aers.fac_id
				AND adrmr.deleted = 'N'
				AND adrmr.eff_date_from <= @vEffectiveDate
				AND (adrmr.eff_date_to >= @vEffectiveDate OR adrmr.eff_date_to IS NULL)
				AND adrmr.applied = 1
	WHERE aers.fac_id = @vFacId
		AND aers.is_market_rate = 1
		AND aers.schedule_id = @vDefaultEmptyBedScheduleID
	;

	SELECT s.schedule_id
		, s.eff_date_range_id
		, s.fac_id
		, s.eff_schedule_id
		, s.rate_type_id
		, r.monthly_rate
		, r.daily_rate
		, sequence_no = cti.sequence_no
		, care_level_id = cti.care_level_id
	INTO #ManualRates
	FROM #ScheduleDetails s
		JOIN dbo.ar_rate_detail r WITH (NOLOCK) -- Manual rate.
			ON r.eff_schedule_id = s.eff_schedule_id
				AND(s.is_manual_rate = 1 OR s.is_manual_pay_rate = 1)
				AND s.is_alt = 0
				AND (r.care_level = s.care_level_code OR s.is_custom_rate = 1)
				AND r.fac_id = @vFacId
		LEFT JOIN ar_eff_rate_schedule ers
			ON ers.eff_schedule_id = r.eff_schedule_id
		LEFT JOIN ar_date_range adr
			ON adr.eff_date_range_id = ers.eff_date_range_id
				AND adr.deleted = 'N'
		LEFT JOIN ar_lib_care_level_template_item cti
			ON cti.care_level_template_id = adr.care_level_template_id
				AND cti.care_level_code = r.care_level
				AND cti.deleted = 'N'
	WHERE s.fac_id = @vFacId
		AND s.is_manual_rate = 1
	;

	SELECT t.rate_template_id,
		   t.care_level_template_id,
		   i.effective_date,
		   i.ineffective_date,
		   c.care_level_id,
		   c.care_level_code,
		   c.sequence_no as care_level_sequence_no,
		   r.daily_rate,
		   r.monthly_rate
	INTO #RateTemplate
	FROM ar_lib_rate_template t
		JOIN ar_lib_care_level_template ct 
			ON t.care_level_template_id = ct.care_level_template_id
		JOIN ar_lib_rate_template_info i 
			ON t.rate_template_id = i.rate_template_id
				AND i.is_accepted = 1
		JOIN ar_lib_care_level_template_item c 
			ON t.care_level_template_id = c.care_level_template_id
				AND i.effective_date >= c.effective_date 
				AND (i.effective_date <= c.ineffective_date OR c.ineffective_date IS NULL)
		LEFT JOIN ar_lib_rate_template_rate r 
			ON r.rate_template_info_id = i.rate_template_info_id
				AND r.care_level_id = c.care_level_id
	;

	SELECT s.schedule_id
		, s.eff_date_range_id
		, s.fac_id
		, s.eff_schedule_id
		, s.rate_type_id
		, monthly_rate = rt.monthly_rate * (s.rate_template_pct / 100)
		, daily_rate = rt.daily_rate * (s.rate_template_pct / 100)
		, s.is_alt
		, rt.care_level_sequence_no
		, rt.care_level_id
	INTO #TemplateRates
	FROM #ScheduleDetails s
		-- JOIN to templates to get the rate if we are not using a manual rate.
		LEFT JOIN #RateTemplate rt -- Standard template
			ON s.rate_template_id = rt.rate_template_id
				AND s.care_level_template_id = rt.care_level_template_id
				AND s.care_level_code = rt.care_level_code
				AND s.eff_date_from >= rt.effective_date
				AND (s.eff_date_from < rt.ineffective_date OR rt.ineffective_date is NULL)
		LEFT JOIN #RateTemplate pt -- Reimbursement Template
			ON 	s.pay_rate_template_id = pt.rate_template_id
				AND s.is_manual_pay_rate = 0
				AND s.care_level_template_id = pt.care_level_template_id
				AND s.care_level_code = pt.care_level_code
				AND s.eff_date_from >= pt.effective_date
				AND (s.eff_date_from < pt.ineffective_date OR pt.ineffective_date is NULL)
	WHERE s.fac_id = @vFacId
		AND s.is_manual_rate = 0
		AND s.is_market_rate = 0
	;

	SELECT mkt.schedule_id
		, mkt.eff_date_range_id
		, mkt.fac_id
		, mkt.eff_schedule_id
		, mkt.rate_type_id
		, mkt.room_id
		, mkt.monthly_rate
		, mkt.daily_rate
	INTO #AllRateTypes
	FROM #MarketRates mkt
	UNION
	SELECT m.schedule_id
		, m.eff_date_range_id
		, m.fac_id
		, m.eff_schedule_id
		, m.rate_type_id
		, room_id = NULL
		, m.monthly_rate
		, m.daily_rate
	FROM #ManualRates m
	UNION
	SELECT t.schedule_id
		, t.eff_date_range_id
		, t.fac_id
		, t.eff_schedule_id
		, t.rate_type_id
		, room_id = NULL
		, t.monthly_rate
		, t.daily_rate
	FROM #TemplateRates t
	;

	SELECT room_id
		, beds_count = COUNT(*)
	INTO #RoomCapacity
	FROM #RentRollData
	GROUP BY room_id
	;

	SELECT room_id
		, clients_count = COUNT(*)
	INTO #ClientInRoomCount
	FROM #RentRollData
	WHERE is_bed_occupied = 1 
		AND is_incomplete_census = 0
	GROUP BY room_id
	;

	SELECT 
		c.room_id
		, c.clients_count
		, r.beds_count
	INTO #PartiallyOccupiedRoom
	FROM #ClientInRoomCount c
	JOIN #RoomCapacity r
		ON r.room_id = c.room_id
			AND c.clients_count < r.beds_count
	;

	SELECT rc.room_id
	INTO #FullyAvailableRooms
	FROM #RoomCapacity rc
	LEFT JOIN #ClientInRoomCount c
		ON c.room_id = rc.room_id
	WHERE c.room_id IS NULL
	;

	SELECT 
		o.room_id
		, o.bed_id
		, o.is_incomplete_census
	INTO #FullyAvailableRoomBeds
	FROM #RentRollData o
	JOIN #FullyAvailableRooms f
		ON f.room_id = o.room_id
	;

	SELECT DISTINCT 
		rdr.room_id
		, rdr.rate_type_id
		, artc.weight
	INTO #DefaultRoomRateForEmptyBeds
	FROM #RentRollData o
		JOIN dbo.room_date_range rdr
			ON rdr.room_id = o.room_id
				AND rdr.deleted = 'N'
				AND rdr.effective_Date <= @vEffectiveDate
				AND (rdr.ineffective_date IS NULL OR rdr.ineffective_Date >= @vEffectiveDate)
		JOIN ar_lib_rate_type alrt
			ON alrt.rate_type_id = rdr.rate_type_id
				AND alrt.deleted = 'N'
		JOIN ar_rate_type_category artc
			ON artc.category_id = alrt.category_id
				AND artc.deleted = 'N'
	WHERE is_bed_occupied = 0
		OR is_incomplete_census = 1
	;

	SELECT
		rb.room_id 
		, rb.bed_Id
		, cumulative_weight = ROW_NUMBER() OVER (PARTITION BY rb.room_id ORDER BY IIF(rb.is_incomplete_census = 1, 1, 0) DESC, rb.bed_id) * d.weight
	INTO #CumulativeWeightForEmptyRoomBeds
	FROM #FullyAvailableRoomBeds rb
		JOIN #DefaultRoomRateForEmptyBeds d
			ON d.room_id = rb.room_id
	;

	SELECT
		c.room_id 
		, c.bed_Id
		, rate_type_id = Iif(c.cumulative_weight <= 1, d.rate_type_id, NULL)
		, weight = iif(c.cumulative_weight <= 1, d.weight, 0)
		, companion_flag = IIF(c.cumulative_weight > 1, 1, 0)
	INTO #EmptyRoomBedsRateTypes
	FROM #FullyAvailableRoomBeds a
		JOIN #CumulativeWeightForEmptyRoomBeds c
			ON c.room_id = a.room_id
				AND a.bed_id = c.bed_id
		JOIN #DefaultRoomRateForEmptyBeds d
			ON d.room_id = c.room_id
	;

	SELECT 
		room_id
		, weight_sum = SUM(weight)
	INTO #PartiallyOccupiedWeightSum
	FROM #RentRollData
	WHERE weight IS NOT NULL
	GROUP BY room_id
	;

	SELECT 
		s.room_id
		, r.beds_count
		, r.clients_count
		, occupied_weight_sum = s.weight_sum
		, remaining_weight = (1 - s.weight_sum)
	INTO #PartiallyOccupiedWeight
	FROM #PartiallyOccupiedWeightSum s
		JOIN #PartiallyOccupiedRoom r
			ON r.room_id = s.room_id
	;

	SELECT 
		w.room_id
		, category_weight = artc.weight
		, has_remainder = 
			CASE
				WHEN w.remaining_weight = 0 OR artc.weight = 0 THEN 0
				ELSE IIF(CAST(w.remaining_weight AS DECIMAL(5,2)) % CAST(artc.weight AS DECIMAL(5,2)) <= 0.02, 0, 1)
			END
		, beds_covered_by_rate_weight = 
			CASE
				WHEN w.remaining_weight = 0 OR artc.weight = 0 THEN 0
				ELSE CAST(IIF(w.remaining_weight / artc.weight > (w.beds_count - w.clients_count), w.beds_count - w.clients_count, w.remaining_weight / artc.weight) AS INT)
			END
		, art.rate_type_id
		, w.remaining_weight
	INTO #PartiallyOccupiedRateWeightAssignment
	FROM #PartiallyOccupiedWeight w
		JOIN ar_rate_type_category artc 
			ON artc.weight <= w.remaining_weight
				AND artc.deleted = 'N'
		JOIN ar_lib_rate_type alrt
			ON alrt.category_id = artc.category_id
				AND alrt.deleted = 'N'
		JOIN ar_rate_type art
			ON art.rate_type_id = alrt.rate_type_id
				AND art.fac_id = @vFacId
	UNION ALL
	SELECT
		w.room_id
		, 0
		, 0
		, 0
		, NULL
		, w.remaining_weight
	FROM #PartiallyOccupiedWeight w
	;

	SELECT 
		room_id
		, category_weight
		, beds_covered_by_rate_weight
		, rate_type_id
		, rate_type_rank = RANK() OVER (PARTITION BY room_id ORDER BY beds_covered_by_rate_weight DESC, category_weight DESC)
	INTO #PartiallyOccupiedWeightPriority
	FROM #PartiallyOccupiedRateWeightAssignment
	;

	SELECT 
		p.room_id
		, f.bed_id
		, p.category_weight
		, p.beds_covered_by_rate_weight
		, p.rate_type_id
		, empty_bed_rank = DENSE_RANK() OVER (PARTITION BY r.room_id ORDER BY IIF(f.is_incomplete_census = 1, 1, 0) DESC, f.bed_id)
	INTO #PartiallyOccupiedEmptyBedOrder
	FROM #PartiallyOccupiedRoom r
		JOIN #PartiallyOccupiedWeightPriority p
			ON p.room_id = r.room_id
				AND rate_type_rank = 1
		JOIN #RentRollData f
			ON f.room_id = r.room_id
				AND (f.is_bed_occupied = 0 OR f.is_incomplete_census = 1)
	;

	SELECT 
		r.room_id
		, r.bed_id
		, rate_type_id = IIF(r.empty_bed_rank <= r.beds_covered_by_rate_weight, r.rate_type_id, NULL)
		, weight = IIF(r.empty_bed_rank <= r.beds_covered_by_rate_weight, r.category_weight, 0)
		, companion_flag = IIF(r.empty_bed_rank <= r.beds_covered_by_rate_weight, 0, 1)
	INTO #PartiallyOccupiedRoomBedWeights
	FROM #PartiallyOccupiedEmptyBedOrder r
	;

	SELECT 
		e.room_id
		, e.bed_id
		, e.rate_type_id
		, e.weight
		, e.companion_flag
	INTO #EmptyBedRateTypes
	FROM #EmptyRoomBedsRateTypes e
	UNION
	SELECT 
		po.room_id
		, po.bed_id
		, po.rate_type_id
		, po.weight
		, po.companion_flag
	FROM #PartiallyOccupiedRoomBedWeights po
	;

	SELECT DISTINCT
		e.room_id
		, e.bed_id
		, rate_type_id = COALESCE(r.rate_type_id, @vZeroWeightRateId)
		, e.weight
		, e.companion_flag
	INTO #EmptyBedCompanionRateTypes
	FROM #EmptyBedRateTypes e
		LEFT JOIN ar_rate_type_category c
			ON c.weight = e.weight
				AND c.deleted = 'N'
		LEFT JOIN ar_lib_rate_type lib
			ON lib.category_id = c.category_id
				AND lib.deleted = 'N'	
		LEFT JOIN ar_rate_type r
			ON r.rate_type_id = lib.rate_type_id
				AND r.fac_id = @vFacId
	WHERE e.weight = 0
	;

	SELECT 
		e.room_id
		, e.bed_id
		, e.rate_type_id
		, e.weight
		, e.companion_flag
	INTO #EmptyBedAllRateTypes
	FROM #EmptyBedRateTypes e
	WHERE e.weight <> 0
	UNION
	SELECT 
		c.room_id
		, c.bed_id
		, c.rate_type_id
		, c.weight
		, c.companion_flag
	FROM #EmptyBedCompanionRateTypes c
	;

	SELECT m.schedule_id
		, m.eff_date_range_id
		, m.fac_id
		, m.eff_schedule_id
		, m.rate_type_id
		, o.room_id
		, o.bed_id
		, m.monthly_rate
		, m.daily_rate
	INTO #MarketRatesForEmptyBeds
	FROM #EmptyBedAllRateTypes o
		JOIN #MarketRates m
			ON m.rate_type_id = o.rate_type_id
				AND m.room_id = o.room_id
	;

	SELECT m.schedule_id
		, m.eff_date_range_id
		, m.fac_id
		, m.eff_schedule_id
		, m.rate_type_id
		, o.room_id
		, o.bed_id
		, m.monthly_rate
		, m.daily_rate
		, room_care_level_row_num = ROW_NUMBER() OVER(PARTITION BY o.room_id, o.bed_id ORDER BY IIF(m.monthly_rate IS NULL AND m.daily_rate IS NULL, 0, 1) DESC, m.sequence_no, m.care_level_id, m.rate_type_id)
	INTO #ManualRatesForEmptyBedsPrioritized
	FROM #EmptyBedAllRateTypes o
		JOIN #ManualRates m
			ON m.rate_type_id = o.rate_type_id
	;

	SELECT 
		mr.room_id
		, mr.bed_id
		, mr.monthly_rate
		, mr.daily_rate
		, mr.rate_type_id
	INTO #ManualRatesForEmptyBeds
	FROM #ManualRatesForEmptyBedsPrioritized mr
	WHERE mr.room_care_level_row_num = 1
	;

	SELECT t.schedule_id
		, t.eff_date_range_id
		, t.fac_id
		, t.eff_schedule_id
		, t.rate_type_id
		, o.room_id
		, t.monthly_rate
		, t.daily_rate
		, t.is_alt
		, room_care_level_row_num = ROW_NUMBER() OVER(PARTITION BY o.room_id ORDER BY t.is_alt, t.care_level_sequence_no, t.care_level_id)
	INTO #TemplateRatesForEmptyRooms
	FROM #EmptyBedAllRateTypes o
		JOIN #TemplateRates t
			ON t.rate_type_id = o.rate_type_id
	;

	SELECT t.schedule_id
		, t.eff_date_range_id
		, t.fac_id
		, t.eff_schedule_id
		, t.rate_type_id
		, o.room_id
		, o.bed_id
		, t.monthly_rate
		, t.daily_rate
		, t.is_alt
	INTO #TemplateRateForEmptyRoomBeds
	FROM #EmptyBedAllRateTypes o
		JOIN #TemplateRatesForEmptyRooms t
			ON t.room_id = o.room_id
				AND t.room_care_level_row_num = 1
	;

	SELECT
		o.room_id
		, o.bed_id   
		, market_rate = COALESCE(mr.monthly_rate, mkt.monthly_rate, t.monthly_rate, @vTotalDaysInMonth * COALESCE(mr.daily_rate, mkt.daily_rate, t.daily_rate))
		, o.rate_type_id 
		, o.weight
		, room_bed_row_num = ROW_NUMBER() OVER(PARTITION BY o.room_id, o.bed_id ORDER BY IIF((COALESCE(mr.monthly_rate, mkt.monthly_rate, t.monthly_rate, @vTotalDaysInMonth * COALESCE(mr.daily_rate, mkt.daily_rate, t.daily_rate))) IS NULL, 0, 1) DESC)
	INTO #EmptyBedsFinalPrioritized
	FROM #EmptyBedAllRateTypes o
		LEFT JOIN #ManualRatesForEmptyBeds mr
			ON mr.bed_id = o.bed_id
				AND mr.rate_type_id = o.rate_type_id
		LEFT JOIN #MarketRatesForEmptyBeds mkt
			ON mkt.bed_id = o.bed_id
				AND mkt.rate_type_id = o.rate_type_id
		LEFT JOIN #TemplateRateForEmptyRoomBeds t
			ON t.bed_id = o.bed_id
				AND t.rate_type_id = o.rate_type_id
	;

	SELECT
		e.room_id
		, e.bed_id
		, e.market_rate
		, rate_type_id = COALESCE(ebr.rate_type_id, e.rate_type_id)
		, is_companion = CONVERT(BIT, IIF(e.weight = 0, 1, 0))
		, e.weight
	INTO #EmptyBedsWithCompanion
	FROM #EmptyBedsFinalPrioritized e
		LEFT JOIN #EmptyBedAllRateTypes ebr
			ON ebr.bed_id = e.bed_id
				AND ebr.rate_type_id = e.rate_type_id
	WHERE e.room_bed_row_num = 1
	;

	UPDATE rrd
	SET
		market_rate = IIF(rrd.is_incomplete_census = 0, e.market_rate, NULL)
		, rate_type_id = e.rate_type_id
		, room_rate = IIF(rrd.is_incomplete_census = 0, alrt.long_description, NULL)
		, is_companion = e.is_companion
		, weight = e.weight
		, deposit_amount = IIF(rrd.deposit_required = 1, e.weight * rrd.total_deposit_required, NULL)
	FROM #RentRollData rrd
		JOIN #EmptyBedsWithCompanion e
			ON e.bed_id = rrd.bed_id
		LEFT JOIN ar_lib_rate_type alrt
			ON alrt.rate_type_id = e.rate_type_id
				AND alrt.deleted = 'N'
	WHERE rrd.is_bed_occupied = 0
		OR is_incomplete_census = 1;

	IF @debug_me='Y'
		select '#RentRollData2', * 
		from #RentRollData
		order by room_id, bed_id

	IF @debug_me='Y' PRINT 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' (EMPTY) complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';


	SET @vStep = 8;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Preparing SUM for Jrxml and Internal Calculation '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109) ;

	INSERT INTO @room_sum_for_jrxml 
		( room_id
		, total_market_rate
		, total_actual_rate
		, total_discount
		, total_deposit_received
		, bed_count
		)
	SELECT room_id
		, total_market_rate = SUM(market_rate)
		, total_actual_rate = SUM(actual_rate)
		, total_discount = SUM(discount)
		, total_deposit_received = SUM(deposit_received)
		, bed_count = SUM(is_bed_occupied)
	FROM #RentRollData rrd
	WHERE (rrd.is_bed_occupied = 0 AND (@show_empty_companion_beds = 1 OR ISNULL(rrd.is_companion, 0) = 0))
		OR (rrd.is_bed_occupied = 1 AND (@show_occupied_companion_beds = 1 OR ISNULL(rrd.is_companion, 0) = 0))
	GROUP BY room_id;

	WITH OccupiedRoomWeights AS (
		SELECT j.room_id
			, weight = ISNULL(SUM(rrd.weight), 0)
		FROM @room_sum_for_jrxml j
			JOIN #RentRollData rrd
				ON rrd.room_id = j.room_id
		WHERE is_bed_occupied = 1
		GROUP BY j.room_id
	)
	UPDATE j
	SET total_occupied_weight = ISNULL(o.weight, 0)
	FROM @room_sum_for_jrxml j
	JOIN OccupiedRoomWeights o
		ON o.room_id = j.room_id;

	IF @debug_me='Y' Print 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';
 
	IF (@debug_me='Y'  or @debug_me='weight')
		SELECT '@room_sum_for_jrxml',* FROM @room_sum_for_jrxml;


	SET @vStep = 9;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Handling the Future Dated Move Out Dates and the Bed Status based on the Dates for Client '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

	UPDATE rent
	SET estimated_move_out = COALESCE(cl.discharge_date, cl.estimated_discharge_date)
		, bed_status_id = IIF(rent.bed_status_id IN (1, 2) AND (cl.discharge_date IS NOT NULL OR cl.estimated_discharge_date IS NOT NULL), 3, rent.bed_status_id)
	FROM #RentRollData rent 
		JOIN clients cl WITH (NOLOCK)
			ON cl.client_id = rent.client_id
				AND cl.deleted = 'N'
	;

	IF @debug_me='Y' 
		PRINT 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';


	SET @vStep = 10;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Setting Occupied/Available Days for each bed '  + @vgs_program_name + ' ' + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

	IF NOT (@report_format_type = 'pdf' AND @emc_flag = 1)
	BEGIN
		INSERT INTO @availableOccupiedDays
		EXEC sproc_prp_rl_rent_roll_report_occ_avail 
				  @vFacId
				, @vFirstDay
				, @debug_me
				, @status_code
				, @status_text;

		UPDATE rrd
		SET occupied_days = IIF(aod.occupied_days IS NULL AND aod.available_days IS NULL, 0, aod.occupied_days)
			, vacant_days = IIF(aod.occupied_days IS NULL AND aod.available_days IS NULL, @vTotalDaysInMonth, aod.available_days)
		FROM #RentRollData rrd
			LEFT JOIN @availableOccupiedDays aod
				ON aod.bed_id = rrd.bed_id
	END

	IF @debug_me='Y' 
		PRINT 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';


	SET @vStep = 11;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Deriving the Bed Staus based on Weight and Move out Dates '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

	UPDATE r
	SET is_rv_weight_1 = 
		CASE 
			WHEN r.room_id = rj.room_id AND rj.total_occupied_weight > 0.98 AND bed_status_id = 4 THEN 1 
			ELSE is_rv_weight_1 
		END
	FROM #RentRollData r 
		INNER JOIN @room_sum_for_jrxml rj 
			ON rj.room_id=r.room_id;

	IF (@enforce_max_weight_flag = 1)
	BEGIN
		UPDATE r
		----this bit column is used to calculate the the Rented and Vacant occupied days that emerged as the Rented and Vacant due to weight 1
		SET bed_status_id = IIF(r.room_id = rj.room_id AND rj.total_occupied_weight > 0.98 AND rj.bed_count > 0 AND bed_status_id = 4, 2, bed_status_id)
		FROM #RentRollData r 
			INNER JOIN @room_sum_for_jrxml rj 
				ON rj.room_id = r.room_id
		WHERE r.is_bed_occupied = 0
		;
	END

	if @debug_me='Y' Print 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';
 
	IF (@debug_me='Y'  OR @debug_me='rate')---using rate to debug only the ouput for rate related data
		SELECT 'bed status #RentRollData',* 
		FROM #RentRollData
		ORDER BY room_id, bed_id;


	SET @vStep = 12;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Deriving Status For the Bed '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

	----No room and Bed Status are stored in table hence these section updates the room status on the fly based on the various combination of the bed status
	---Again the Bed Status are also calculated on the fly...

	UPDATE rrd
	SET room_status = 
		CASE
			WHEN countid = 2 THEN 
				CASE dco.bed_status_id
					WHEN 12 THEN 'Fully Occupied'
					WHEN 13 THEN 'Occupied with planned move out'
					WHEN 14 THEN 'Partially Occupied'
					WHEN 15 THEN 'Fully Occupied'
					WHEN 23 THEN 'Occupied with planned move out'
					WHEN 24 THEN 'Partially Occupied'
					WHEN 25 THEN 'Fully Rented & Vacant'
					WHEN 34 THEN 'Partially Occupied with planned move out'
					WHEN 35 THEN 'Occupied with planned move out'
					WHEN 45 THEN 'Fully Available'
				END
			WHEN countid = 1 THEN 
				CASE rrd.bed_status_id
					WHEN 1 THEN 'Fully Occupied'
					WHEN 2 THEN 'Fully Rented & Vacant'
					WHEN 3 THEN 'Occupied with planned move out'
					WHEN 4 THEN 'Fully Available'
					WHEN 5 THEN 'Fully Inactive'
				END
			ELSE
				CASE
					WHEN CHARINDEX('4', dco.bed_status_id) > 0 THEN 
						CASE 
							WHEN CHARINDEX('3', dco.bed_status_id)>0 THEN 'Partially Occupied with planned move out'
							ELSE 'Partially Occupied'
						END
					ELSE 
						CASE 
							WHEN CHARINDEX('3', dco.bed_status_id)>0 THEN 'Occupied with planned move out'
							ELSE 'Fully Occupied'
						END
				END
		END
	FROM #RentRollData rrd 
		INNER JOIN (
				SELECT count(DISTINCT bed_status_id )countid,room_id 
				FROM #RentRollData 
				GROUP BY room_id
			) co
			ON co.room_id=rrd.room_id
		INNER JOIN (
				SELECT room_id
					, REPLACE(ISNULL([1],'')+ISNULL([2],'')+ISNULL([3],'')+ISNULL([4],'')+ISNULL([5],''),' ', '' ) AS bed_status_id
				FROM (
						SELECT room_id
							, bed_status_id
						FROM #RentRollData
					) ps
					PIVOT (MAX(bed_status_id) FOR bed_status_id in ([1],[2],[3],[4],[5])) AS pvt
			) dco
			ON dco.room_id = rrd.room_id
	;

	IF @debug_me='Y' Print 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';


	IF (@debug_me='Y'  OR @debug_me='rate')---using rate to debug only the ouput for rate related data
		SELECT 'rooms status #RentRollData',* 
		FROM #RentRollData
		ORDER BY room_id, bed_id;


	SELECT @rows_returned = Count(*) 
	FROM #RentRollData 
	WHERE (@vRoomStatus='-1' OR room_status=@vRoomStatus);

	IF @rows_returned < 1 AND @emc_flag = 0
	BEGIN
		SELECT NULL fac_id
			,NULL fac_name
			,NULL fac_code
			,NULL room_id 
			,NULL room_desc
			,NULL unit_desc
			,NULL floor_desc
			,NULL room_desc_original
			,NULL bed_id
			,NULL bed_desc
			,NULL client_id
			,NULL client_name
			,NULL first_name
			,NULL last_name
			,NULL client_id_number
			,NULL sex
			,NULL primary_payer_name
			,NULL room_type
			,NULL sq_footage   
			,NULL market_rate 
			,NULL actual_rate  
			,NULL room_rate   
			,NULL discount
			,NULL deposit_required   
			,NULL deposit_received   
			,NULL lease_start
			,NULL lease_end
			,NULL resident_status
			,NULL move_in   
			,NULL estimated_move_out
			,NULL stay_days
			,NULL bed_status 
			,NULL room_status  
			,NULL is_unit_occupied
			,NULL occupied_bed_id
			,NULL occupied_room_id
			,NULL occupied_market_rate
			,NULL occupied_actual_rate
			,NULL occupied_discount
			,NULL occupied_sq_footage
			,NULL total_deposit_required   
			,NULL total_deposit_received   
			,NULL total_market_rate 
			,NULL total_actual_rate 
			,NULL total_discount 
			,NULL inactive_bed_status
			,NULL occupied_days
			,NULL vacant_days
			,NULL is_bed_addnl_bed
			,NULL potential_occupancy
			,NULL row_num
			,NULL ordering_row_num
			,0 status_code  
			,NULL status_text 
			,@vselected_parameters as selected_parameters
			,@effective_date effective_date;
	END
	ELSE
	BEGIN;

		SET @vStep = 13;
		SET @vgsStepStartTime = GETDATE();
		IF @debug_me='Y' 
			PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
				+ ' Vacant / Move In details For the Bed '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

		WITH BedsByRoom_CTE AS (
			SELECT room_id
				, potential_occupancy = COUNT(*) 
			FROM bed 
			WHERE deleted = 'N'
				AND (retired_date IS NULL OR retired_date > @vEffectiveDate)
			GROUP BY room_id
		),
		FinalOutput_CTE AS (
			SELECT rd.fac_id
				, rd.room_id
				, rd.bed_id
				, rd.bed_desc
				, rd.client_id
				, rd.room_type
				, rd.sq_footage
				, rd.market_rate
				, rd.actual_rate
				, rd.room_rate
				, rd.discount
				, deposit_required = rd.deposit_amount
				, rd.deposit_received
				, rd.lease_start_date lease_start
				, rd.lease_end_date lease_end
				, rd.estimated_move_out
				, rd.occupied_days
				, rd.vacant_days
				, rd.room_status
				, is_unit_occupied = IIF(rj.bed_count = 0, 0, 1)
				, rd.occupied_bed_id
				, rd.occupied_room_id
				, rd.occupied_market_rate
				, rd.occupied_actual_rate
				, rd.occupied_discount
				, rd.occupied_sq_footage
				, total_deposit_required = rd.total_deposit_required
				, total_deposit_received = rj.total_deposit_received
				, rj.total_market_rate
				, rj.total_actual_rate
				, total_discount = IIF(rj.bed_count = 0, NULL, rj.total_discount)
				, status_code = 0
				, status_text = NULL
				, selected_parameters = @vselected_parameters
				, rd.bed_status_id
				, rd.inactive_Days
				, rd.weight
				, rd.primary_payer_name
				, rd.is_bed_addnl_bed
				, bedsByRoom.potential_occupancy
				, is_companion = ISNULL(rd.is_companion, 0)
				, rd.is_bed_occupied
				, rd.anniversary_date
			FROM #RentRollData rd 
				JOIN @room_sum_for_jrxml rj
					ON rj.room_id = rd.room_id
				LEFT JOIN BedsByRoom_CTE bedsByRoom
					ON bedsByRoom.room_id = rd.room_id
			WHERE (@vRoomStatus = '-1' OR rd.room_status = @vRoomStatus)
				AND rd.inactive_no_show = 0
		),
		OccupiedRooms_CTE AS (
			SELECT DISTINCT 
				  room_id
				, bed_id
				, lease_start
				, lease_end
			FROM FinalOutput_CTE
			WHERE weight > 0.98
				AND bed_status_id IN (1, 3)
		)
		SELECT 
			  f.fac_id
			, facility.name AS fac_name
			, facility.facility_code AS fac_code
			, f.room_id
			, room_desc = unit.unit_desc + '-' + flr.floor_desc + '-' + room.room_desc
			, unit.unit_desc
			, flr.floor_desc
			, room_desc_original = room.room_desc
			, f.bed_id
			, f.bed_desc 
			, f.client_id
			, client_name = 
				CASE 
					WHEN @vOrderBy = 0 AND COALESCE(m.last_name, m.first_name, cl.client_id_number, '') = '' THEN 'None'
					WHEN @vOrderBy <> 0 AND COALESCE(m.last_name, m.first_name, cl.client_id_number, '') = '' THEN ''
					ELSE ltrim(rtrim(isNULL(m.last_name,''))) + ', ' + ltrim(rtrim(isNULL(m.first_name,''))) + ' (' + ltrim(rtrim(isNULL(cl.client_id_number,'')))+ ')'
				END
			, m.first_name
			, m.last_name
			, cl.client_id_number
			, m.sex
			, f.primary_payer_name
			, f.room_type
			, f.sq_footage   
			, f.market_rate  
			, f.actual_rate
			, f.room_rate   
			, f.discount
			, f.deposit_required   
			, f.deposit_received
			, lease_start   = COALESCE(occ.lease_start  , f.lease_start)
			, lease_end     = COALESCE(occ.lease_end    , f.lease_end)
			, resident_status = IIF(f.client_id IS NULL, NULL, 'Active')
			, move_in       = cl.admission_date
			, f.estimated_move_out
			, stay_days     = IIF(cl.admission_date <= @Today, DATEDIFF(dd, cl.admission_date, @Today) + 1, NULL)
			, f.occupied_days
			, f.vacant_days
			, bed_status = 
				CASE f.bed_status_id
					WHEN 1 THEN 'Occupied'
					WHEN 2 THEN 'Rented & Vacant' 
					WHEN 3 THEN 'Occupied with planned move out' 
					WHEN 4 THEN 'Available' 
					WHEN 5 THEN 'Inactive' 
				END
			, f.room_status
			, f.is_unit_occupied
			, f.occupied_bed_id
			, f.occupied_room_id
			, f.occupied_market_rate
			, f.occupied_actual_rate
			, f.occupied_discount
			, f.occupied_sq_footage
			, f.total_deposit_required
			, f.total_deposit_received
			, f.total_market_rate
			, f.total_actual_rate
			, f.total_discount
			, inactive_bed_Status = IIF(f.bed_status_id = 5, 1, 0)
			, f.is_bed_addnl_bed
			, f.potential_occupancy
			, f.status_code
			, f.status_text  
			, f.selected_parameters
			, effective_date = @vEffectiveDate
			, f.is_companion
			, f.anniversary_date
			, row_num = DENSE_RANK() OVER (ORDER BY unit.unit_desc, flr.floor_desc, room.room_desc)
		INTO #RentRollResult
		FROM FinalOutput_CTE f
			LEFT JOIN OccupiedRooms_CTE occ
				ON occ.room_id = f.room_id 
					AND occ.bed_id = f.bed_id 
					AND f.bed_status_id = 2
			JOIN dbo.room room WITH (NOLOCK) 
				ON f.room_id = room.room_id
					AND room.deleted = 'N'
			JOIN dbo.[floor] flr WITH (NOLOCK) 
				ON room.floor_id = flr.floor_id
					AND flr.deleted = 'N'
			JOIN dbo.unit unit WITH (NOLOCK) 
				ON room.unit_id = unit.unit_id
					AND unit.deleted = 'N'
			LEFT JOIN dbo.clients cl WITH (NOLOCK)
				ON cl.client_id = f.client_id 
					AND cl.fac_id = f.fac_id
					AND cl.deleted = 'N'
			LEFT JOIN dbo.mpi m WITH (NOLOCK) 
				ON m.mpi_id = cl.mpi_id
					AND m.deleted = 'N'
			JOIN facility ON facility.fac_id = f.fac_id
		WHERE (f.is_bed_occupied = 0 AND (@show_empty_companion_beds = 1 OR f.is_companion = 0))
			OR (f.is_bed_occupied = 1 AND (@show_occupied_companion_beds = 1 OR f.is_companion = 0))
		;

		IF @debug_me='Y'
			PRINT 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';


		SET @vStep = 14;
		SET @vgsStepStartTime = GETDATE();
		IF @debug_me='Y' 
			PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
				+ ' Ordering Result '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

		IF @vOrderBy = 1		-- last name
			WITH RowNum_CTE AS (
				SELECT *
					, ordering_row_num = DENSE_RANK() OVER (ORDER BY last_name, first_name, client_id_number, unit_desc, floor_desc, room_desc, bed_desc)
				FROM #RentRollResult 
			)
			SELECT *
			FROM RowNum_CTE
			ORDER BY ordering_row_num, unit_desc, floor_desc, room_desc, bed_desc
			;
		ELSE IF @vOrderBy = 2	-- first name
			WITH RowNum_CTE AS (
				SELECT *
					, ordering_row_num = DENSE_RANK() OVER (ORDER BY first_name, last_name, client_id_number, unit_desc, floor_desc, room_desc, bed_desc)
				FROM #RentRollResult
			)
			SELECT *
			FROM RowNum_CTE
			ORDER BY ordering_row_num, unit_desc, floor_desc, room_desc, bed_desc
			;
		ELSE					-- @vOrderBy = 0	-- room
			WITH RowNum_CTE AS (
				SELECT *
					, ordering_row_num = DENSE_RANK() OVER (ORDER BY unit_desc, floor_desc, room_desc)
				FROM #RentRollResult
			)
			SELECT *
			FROM RowNum_CTE
			ORDER BY ordering_row_num, bed_desc, room_type, client_name
			;

		IF @debug_me='Y'
			PRINT 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';

	END

	IF @debug_me='Y' Print 'Total execution time: ' + LTRIM(RTRIM(STR(DATEDIFF(ms, @vgsTotalStartTime, GETDATE()))))+ ' ms';

END TRY
  
BEGIN CATCH  
	SET @Status_Code = IIF(@status_code = 0, 1, 2);  --- convert 3 to 2

	IF @status_code = 1  
		SELECT @status_text = rtrim( LEFT( 'Stored Procedure failed WITH Error Code : ' + CAST(ERROR_NUMBER() AS VARCHAR(10)) +  ', Line Number : ' + CAST(ERROR_LINE() AS VARCHAR(10)) + ', Description : ' +  ERROR_MESSAGE(), 3000 ) );

	IF @emc_flag = 0
	BEGIN
		SELECT NULL fac_id
   			,NULL fac_name
   			,NULL fac_code
   			,NULL room_id 
   			,NULL room_desc   
   			,NULL unit_desc
   			,NULL floor_desc
   			,NULL room_desc_original
   			,NULL bed_id
   			,NULL bed_desc
   			,NULL client_id
   			,NULL client_name
   			,NULL first_name
   			,NULL last_name
   			,NULL client_id_number
   			,NULL sex
   			,NULL primary_payer_name
   			,NULL room_type
   			,NULL sq_footage   
   			,NULL market_rate 
   			,NULL actual_rate  
   			,NULL room_rate   
   			,NULL discount
   			,NULL deposit_required   
   			,NULL deposit_received   
   			,NULL lease_start 
   			,NULL lease_end
			,NULL resident_status
   			,NULL move_in 
   			,NULL estimated_move_out
   			,NULL stay_days
   			,NULL bed_status  
   			,NULL room_status 
   			,NULL is_unit_occupied
   			,NULL occupied_bed_id
   			,NULL occupied_room_id
   			,NULL occupied_market_rate
   			,NULL occupied_actual_rate
   			,NULL occupied_discount
   			,NULL occupied_sq_footage
   			,NULL total_deposit_required   
   			,NULL total_deposit_received   
   			,NULL total_market_rate 
   			,NULL total_actual_rate 
   			,NULL total_discount 
   			,NULL inactive_bed_status
   			,NULL occupied_days
   			,NULL vacant_days
   			,@status_code status_code  
   			,@status_text status_text   
   			,@vselected_parameters selected_parameters
   			,NULL effective_date
   			,NULL is_companion
   			,NULL anniversary_date
   			,NULL row_num
   			,NULL ordering_row_num;
	END
  
	IF @debug_me='Y'
	BEGIN
		Print 'Stored procedure failure in step: '+ convert(varchar(3),@vStep) + '     ' + convert(varchar(26), getdate());
		Print 'Error code: '+convert(varchar(3),@vStep) + '; Error description:      ' + @Status_Text;
	END
END CATCH  

IF OBJECT_ID('tempdb..#RentRollData') IS NOT NULL
BEGIN
	DROP TABLE #RentRollData;
END

IF OBJECT_ID('tempdb..#RentRollResult') IS NOT NULL
BEGIN
	DROP TABLE #RentRollResult;
END

RETURN;

END


GO
GRANT EXECUTE ON sproc_prp_rl_rent_roll_report3 TO PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_prp_rl_rent_roll_report3.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_rent_roll_report3.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_statements.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- PCC-117622       :   script to create sproc_prp_rl_statements Procedure  
--						-- 
-- Written By:          Ritch Moore
-- Reviewed By:         
-- 
-- Script Type:         DDL 
-- Target DB Type:      Client
-- Target ENVIRONMENT:  BOTH (US/CA) 
-- 
-- 
-- Re-Runable:          YES 
-- 
-- Description of Script : Create sproc_prp_rl_statements 
-- 
-- Special Instruction: 

-- 
-- =================================================================================

/***********************************************************************************
Revision History:
2017-06-23  Ritch Moore		PCC-117622	Initial creation of this stored proc - based on sproc_prp_rl_consolidated_statement with transaction logic from sproc_prp_rl_transaction_report
2017-06-23  Ritch Moore		PCC-117714	Resident Filter Logic + input param cleanup
2017-07-05  Ritch Moore		PCC-117677	Combine consecutive room charges if the rate has not changed (step 50)
2017-07-05  Ritch Moore		PCC-118468	Append date range at the end of the description when grouping by charge code or charge code category
2017-07-18  Ritch Moore		PCC-118334	Add order by functionality including reprint from
2017-07-26	Ritch Moore		PCC-118334	Accept new "Order By" parameter to statement stored proc
2017-07-26	Ritch Moore		PCC-118679	Add Room Location to Room Charges
2017-07-31	Ritch Moore		PCC-119896	Change sorting in the room combine logic
2017-07-31	Ritch Moore		PCC-119178	Other payer statement logic
2017-08-03	Ritch Moore		PCC-118977	Read checks payable to from the statement config table
2017-08-03	Ritch Moore		PCC-119183	Add resident status as an input parameter
2017-08-16	Ritch Moore		PCC-119293	Add additional values to informational payer data
2017-08-17	Ritch Moore		PCC-118699	Transaction sorting option
2017-08-17	Ritch Moore		PCC-120524	Suppress Net Zeros Transactions
2017-08-18	Ritch Moore		PCC-118685	Add Resident Trust data
2017-08-18	Ritch Moore		PCC-120217	Add EFT bank message
2017-08-21	Ritch Moore		PCC-120087	Reintroduce the Statement Date in configuration
2017-08-23	Ritch Moore		PCC-120806	Summarize Ancillary Charge's child transaction as the parent
2017-08-23	Ritch Moore		PCC-119715	Add additional Show Comments Options
2017-08-23	Ritch Moore		PCC-120749	Add Aging for Other Private statement payers
2017-08-30	Ritch Moore		PCC-121158	Summarize Other Co-insurance items
2017-08-30	Ritch Moore		PCC-121198	Remove Transaction Type Description from Description
2017-09-01	Ritch Moore		PCC-121288	Add Contact Country to output
2017-09-05	Ritch Moore		PCC-121242	Add GST/HST Registration #'s (for CDN statements)
2017-09-06	Ritch Moore		PCC-121426	Add case statement around appending the care level to transaction descriptions.
2017-09-06	Ritch Moore		PCC-121509	Address other payer aging/balance due mismatches
2017-09-08	Ritch Moore		PCC-121456	Conditional EFT statement message logic
2017-09-12	Ritch Moore		PCC-121797	Add if statements around transaction grouping (private and other payers separate
2017-09-13	Ritch Moore		PCC-121523	Payment Reversals will be enclosed by double asterisks
2017-09-20	Ritch Moore		PCC-122170	Wrap child transaction combining in statement type "if" statements
2017-09-22	Ritch Moore		PCC-122292	Keep Facility Group Addresses when run from EMC- no payer overrides
2017-09-26	Ritch Moore		PCC-122303	Add resident number after the resident name in payment coupon - limit to 2
2017-10-04	Ritch Moore		CORE-4190	Replace isnumeric function with try_convert as isnumeric returns true when commas exist (bed description 1,2,3 for instance)
2017-10-18	Ritch Moore		CORE-4612	Adjust invoice gathering joins for Canadian performance (ext)
2017-10-30	Ritch Moore		CORE-5462	Trust balance should not show on Statement when show balance on statement is set to No in the trust client configuration
2017-10-30	Ritch Moore		CORE-772	Support passing of invoice_id's for statement print link and trial billing
2017-11-20	Ritch Moore		CORE-7167	Include billed transactions in other invoices on the trial statement for the same billing date and generated date
2017-11-30	Ritch Moore		CORE-7473	Still generating consolidated statements in Statement when consolidate statement is not checked
2017-12-06	Ritch Moore		CORE-8101	Resolve issue with not pulling Resident Insurance Address into the statement
2017-12-19	Ritch Moore		CORE-7803	Return address needs to display facility/facility group address
2017-12-19	Ritch Moore		CORE-7953	Remove batch number and entry number on transaction description
2017-12-20	Ritch Moore		CORE-7957	Show Reversal transaction at top of each sorting group
2018-01-02	Ritch Moore		CORE-8776	Statement Message needs to be a sticky setting
2018-01-03	Ritch Moore		CORE-7950	Display Transaction Warning Message on the Statement *NEW*
2018-01-04	Ritch Moore		CORE-7975	In EMC, each facility/campus selected will generate statements using their own assigned template
2018-01-04	Ritch Moore		CORE-9169	Update to the source of checks payable to
2018-01-08	Ritch Moore		CORE-8365	Join update for other aging for performance
2018-02-05	Ritch Moore		CORE-10900	Performance tuning for Statement
2018-02-08	Ritch Moore		CORE-10905	Support for Portal Export format
2018-03-19	Ritch Moore		CORE-11907	Configurable Export Specification Updates
2018-04-02	Ritch Moore		CORE-14099	Configurable Export Payer Export filter
2018-04-04	Ritch Moore		CORE-14518	Consecutive room related transactions do not roll up in specific scenario with multiple contacts
2018-04-06	Ritch Moore		CORE-10718	New Identifier on new statement for Payment Portal
2018-04-30	Ritch Moore		CORE-15273	Replace payer temp table with ar_lib_payers with the export condition - performance
2018-06-18	Ritch Moore		CORE-17401	Update to include configurable account number option
2018-06-27	Ritch Moore		CORE-17930	Add the account number label to the Configurable export
2018-06-27	Ritch Moore		CORE-17932	Add the account number option to the Configurable export
2018-07-05	Ritch Moore		CORE-17759	Add distinct to temp invoice table load, when invoice_ids passed
2018-07-16	Ritch Moore		CORE-19445	Replace distinct added in CORE-17759 with Exists - as per DM
2018-08-01	Ritch Moore		CORE-19440	Only show informational payer balance when the balance greater than $0
2018-08-01	Ritch Moore		CORE-15744	New Statement should not consolidate Resident statements by all facility group types
2018-08-01	Ritch Moore		CORE-15353	Duplicate entries for residents in EMC when there are client records for the same resident within the billing office - rechecked in for snrzt issue
***********************************************************************************/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_prp_rl_statements' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE dbo.sproc_prp_rl_statements
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO


Create Procedure dbo.sproc_prp_rl_statements

  @export_mode bit = 0
, @template_id int = 0
, @fac_id varchar(max) = Null
, @include_inactive_fac_ids bit = 0
, @is_contact bit = 1
, @receiver_ids varchar(max)  = '-1'
, @client_status smallint = -1 --0=current, 1=discharged, -1=all
, @payer_id_list varchar(max) = '0'
, @invoice_id_list varchar(max) = Null
, @last_statement bit = 1
, @statement_start_date datetime = Null
, @statement_end_date datetime = Null
, @show_results varchar(2) = 'D' --D = Detail, C = Summarize by Charge Code, CC = Summarize by Charge Code Category, A = Summarize all Ancillary Charges
, @combine_children tinyint = 0 -- 0 = all transactions, 1 = combine all children, 2 = reimbursement rate (combine CA and CR with parent)
, @billing_group varchar(max) = Null
, @display_admit_date bit = 0
, @display_discharge_date bit = 0
, @reprint_from varchar(20)
, @show_aging bit = 0
, @cash_receipt_comments bit = 0
, @ancillary_comments bit = 0
, @adjustment_comments bit = 0
, @statement_message varchar(254) = ''
, @is_emc  bit = '0'
, @export_resend_flag bit = 0
, @include_prefix_facility_code bit ='0'
, @minimum_balance money = Null
, @use_effective_date_as_bill_date bit = 0
, @sort_by bit = 0 --0='Name', 1='location'
, @transaction_order char(1) = 'P' --'P' = transaction type/date, 'D' = date/trnsaction_type
, @is_new_eft char(1) = 'Y' -- 'N' = Old Canadian method, 'Y' = New method
, @account_number_source char(1) = 'C' -- 'C' = Contact Number, 'R' = Resident Number
, @combine_ancillary_flag bit = 0
, @execution_user_login varchar(60)
, @debug_me char(1)  = 'N'
, @rows_returned int = 0 out
, @status_code int = 0 out 
, @status_text varchar(3000) = Null out


/********************************************************************************

exec dbo.sproc_prp_rl_statements
  @export_mode = 0
, @template_id = 1
, @fac_id = '10'--'35,36,37'--1 --'8'
, @include_inactive_fac_ids = '0'
, @is_contact = 0
, @receiver_ids = '-1'
, @client_status = -1
, @payer_id_list = '0'
, @invoice_id_list = '1762871,1762864,1762872'
, @last_statement = '0'--'0'
, @statement_start_date = '1/1/2018'
, @statement_end_date = '3/31/2018'
, @show_results = 'D'
, @combine_children = 0
, @billing_group = Null--'363'
, @display_admit_date = '0'
, @display_discharge_date = '0'
, @reprint_from = ''
, @show_aging = '0'
, @cash_receipt_comments = 1
, @ancillary_comments = 1
, @adjustment_comments = 1
, @statement_message = ''
, @is_emc = 0
, @export_resend_flag = 1
, @include_prefix_facility_code  ='1'
, @minimum_balance = Null
, @use_effective_date_as_bill_date = 0
, @sort_by = 0
, @transaction_order = 'D'
, @is_new_eft = 'Y'
, @account_number_source = 'C'
, @execution_user_login = 'PCC-adhikj'
, @debug_me  = 'N'
, @rows_returned = 0
, @status_code = ''
, @status_text = ''     

**********************************************************************************/

as
Begin

SET NOCOUNT ON;

	DECLARE @sprocExecId bigint 
	DECLARE @startTime DATETIME = GETDATE()
	DECLARE @endTime DATETIME
	Declare @sprocParamLogEnable int = 0
	select @sprocParamLogEnable = count(1) from configuration_parameter
	where name = 'enable_ar_sproc_param_log' and value = 'Y'
	
	if @sprocParamLogEnable > 0
	BEGIN
		Begin try

			declare @params varchar(max)
			declare @proc_name nvarchar(128) = object_name(@@procid)
			select @params = '@export_mode=' + case when @export_mode is null then 'NULL' else cast(@export_mode as VARCHAR) end 
			+ ',@template_id=' + case when @template_id is null then 'NULL' else cast(@template_id as VARCHAR) end
			+ ',@fac_id=' + case when @fac_id is null then 'NULL' ELSE '''' + @fac_id + '''' end 
			+ ',@include_inactive_fac_ids=' + case when @include_inactive_fac_ids is null then 'NULL' else cast(@include_inactive_fac_ids as VARCHAR) end
			+ ',@is_contact=' + case when @is_contact is null then 'NULL' else cast(@is_contact as VARCHAR) end
			+ ',@receiver_ids=' + case when @receiver_ids is null then 'NULL' ELSE '''' + @receiver_ids + '''' end 
			+ ',@client_status=' + case when @client_status is null then 'NULL' else cast(@client_status as VARCHAR) end
			+ ',@payer_id_list=' + case when @payer_id_list is null then 'NULL' ELSE '''' + @payer_id_list + '''' end 
			+ ',@invoice_id_list=' + case when @invoice_id_list is null then 'NULL' ELSE '''' + @invoice_id_list + '''' end 
			+ ',@last_statement=' + case when @last_statement is null then 'NULL' else cast(@last_statement as VARCHAR) end
			+ ',@statement_start_date=' + case when @statement_start_date is null then 'NULL' else ''''+ convert(VARCHAR, @statement_start_date, 121) + '''' end
			+ ',@statement_end_date=' + case when @statement_end_date is null then 'NULL' else ''''+ convert(VARCHAR, @statement_end_date, 121) + '''' end
			+ ',@show_results=' + case when @show_results is null then 'NULL' ELSE '''' + @show_results + '''' end
			+ ',@combine_children=' + case when @combine_children is null then 'NULL' else cast(@combine_children as VARCHAR) end
			+ ',@billing_group=' + case when @billing_group is null then 'NULL' ELSE '''' + @billing_group + '''' end
			+ ',@display_admit_date=' + case when @display_admit_date is null then 'NULL' else cast(@display_admit_date as VARCHAR) end
			+ ',@display_discharge_date=' + case when @display_discharge_date is null then 'NULL' else cast(@display_discharge_date as VARCHAR) end
			+ ',@reprint_from=' + case when @reprint_from is null then 'NULL' ELSE '''' + @reprint_from + '''' end
			+ ',@show_aging=' + case when @show_aging is null then 'NULL' else cast(@show_aging as VARCHAR) end
			+ ',@cash_receipt_comments=' + case when @cash_receipt_comments is null then 'NULL' else cast(@cash_receipt_comments as VARCHAR) end
			+ ',@ancillary_comments=' + case when @ancillary_comments is null then 'NULL' else cast(@ancillary_comments as VARCHAR) end
			+ ',@adjustment_comments=' + case when @adjustment_comments is null then 'NULL' else cast(@adjustment_comments as VARCHAR) end
			+ ',@statement_message=' + case when @statement_message is null then 'NULL' ELSE '''' + @statement_message + '''' end
			+ ',@is_emc=' + case when @is_emc is null then 'NULL' else cast(@is_emc as VARCHAR) end
			+ ',@export_resend_flag=' + case when @export_resend_flag is null then 'NULL' else cast(@export_resend_flag as VARCHAR) end
			+ ',@include_prefix_facility_code=' + case when @include_prefix_facility_code is null then 'NULL' else cast(@include_prefix_facility_code as VARCHAR) end
			+ ',@minimum_balance=' + case when @minimum_balance is null then 'NULL' else cast(@minimum_balance as VARCHAR) end
			+ ',@use_effective_date_as_bill_date=' + case when @use_effective_date_as_bill_date is null then 'NULL' else cast(@use_effective_date_as_bill_date as VARCHAR) end
			+ ',@sort_by=' + case when @sort_by is null then 'NULL' else cast(@sort_by as VARCHAR) end
			+ ',@transaction_order=' + case when @transaction_order is null then 'NULL' ELSE '''' + @transaction_order + '''' end
			+ ',@is_new_eft=' + case when @is_new_eft is null then 'NULL' ELSE '''' + @is_new_eft + '''' end
			+ ',@account_number_source=' + case when @account_number_source is null then 'NULL' ELSE '''' + @account_number_source + '''' end
			+ ',@combine_ancillary_flag=' + case when @combine_ancillary_flag is null then 'NULL' else cast(@combine_ancillary_flag as VARCHAR) end
			+ ',@execution_user_login=' + case when @execution_user_login is null then 'NULL' ELSE '''' + @execution_user_login + '''' end 
			+ ',@debug_me=' + case when @debug_me is null then 'NULL' ELSE '''' + @debug_me + '''' end 
			+ ',@rows_returned=' + case when @rows_returned is null then 'NULL' else cast(@rows_returned as VARCHAR) end 
			+ ',@status_code=' + case when @status_code is null then 'NULL' else cast(@status_code as VARCHAR) end
			+ ',@status_text=' + case when @status_text is null then 'NULL' ELSE '''' + @status_text + '''' end 
						
			insert into ar_sproc_params_log (sproc_name, params,start_time)
			SELECT @proc_name, @params, @startTime

			set @sprocExecId = @@identity
		END TRY
		BEGIN CATCH
			set @sprocExecId = -1
		END CATCH
	END

--declare Standard local variables required for any store proc
DECLARE   @vStep int
		, @vErr varchar(max)
		, @vdelim char(1)
		, @vReportDate datetime
		, @vRowCount int
		, @vCflr varchar(10)
		, @vTermClient VARCHAR(50)
		, @vTermFacility VARCHAR(50)
		, @vTermAdmission VARCHAR(50)
		, @vTermDischarge VARCHAR(50)
		, @vTermRoom VARCHAR(50)

--Facility Related variables, also used in capturing execution Statistics 
Declare @vFacIDs varchar(max)		
Declare @PRP_FacList as table(FacId int)
Declare @vFacWarningMsg varchar(max) --- to know whether it the returned list is restricted

----Local Variables
DECLARE @vFacId varchar(max)
	, @vTemplateId varchar(max)
	, @vIncludeInactiveFacIds bit 
	, @vIsContact bit
	, @vReceiverIds varchar(max)
	, @vClientStatus smallint
	, @vPayerIdList varchar(max)
	, @vInvoiceIdList varchar(max)
	, @vLastStatement	bit
	, @vStatementStartDate datetime
	, @vLastInvoiceDate datetime
	, @vStatementEndDate datetime
	, @vSummarizeReversals bit
	, @vShowResults varchar(2)
	, @vCombineChildren tinyint
	, @vSuppress0value bit
	, @vBillingGroup varchar(max)
	, @vDisplayAdmitDate bit
	, @vDisplayDischargeDate bit
	, @vReprintFrom varchar(20)
	, @vIncludeResidentMessage bit
	, @vShowAging bit
	, @vOtherPayerSummary bit
	, @vCashReceiptComments bit
	, @vAncillaryComments bit
	, @vAdjustmentComments bit
	, @vStatementMessage varchar(500)
	, @vShowPaymentDueDate bit
    , @vFacIdListNotInGroup varchar(max)
	, @vIsEmc  bit
	, @vIncludeNonContacts  bit
--	, @vNonContactStatementStartDate datetime
    , @vIncludePrefixFacilityCode  bit
	, @vMinimumBalance money
	, @vUseEffectiveDateAsBillDate bit
	, @vChecksPayableTo	varchar(100)
	, @vPrivateStatementsIncluded bit
	, @vOtherStatementsIncluded bit
	, @vSortBy bit
	, @vTransactionOrder char(1)
	, @vIsNewEft char(1)
	, @vIsTrial bit
	, @vExportMode bit
	, @vExportResendFlag bit
	, @vShowInvoiceNumber bit
	, @vShowLocation bit 
	, @vShowResidentNumber bit 
	, @vShowTransactionWarningMessage bit 
	, @vTransactionWarningMessage varchar(200) 
	, @vDisplayUnitAndAmountFlag bit
	, @vPaymentInstructions varchar(1000)
	, @vShowOnlineID bit
	, @vAccountNumberLabel varchar(15)
	, @vAccountNumberSource char(1)
	, @vCombineRecurringAncillary bit
	, @vCombineCouncilPayerContribution bit

create table #client_ids_table
		(
			client_id int
		  );

create table #receiver_ids_table 
		 (
			contact_id numeric(18,1),
			consolidate_statement tinyint
		  );

create table #payer_ids_table 
		 (
			fac_id int,
			payer_id int, 
			bill_payer_id int,
			client_id int,
			statement_date datetime,
			generated_date datetime,
			trial_flag varchar(1)
		  );

create table #invoice_ids_table 
		 (
			invoice_id int,
			client_id int,
			payer_id int,
			statement_date datetime,
			generated_date datetime,
			trial_flag varchar(1)
		  );

create table #billing_group_table
		(
			 group_id int
		);

create table #contact_union_table 
		(
			  contact_id numeric(18,1)
			 ,contact_num int
			 ,payer_id int
			 ,client_id int
			 ,bill_date datetime
			 ,inv_created_date datetime
			 ,generated_date datetime
			 ,row_num int
		);

-----Governor and Statistics Variables 
Declare  @vgs_program_name varchar(200)
		 ,@vgs_start_time datetime
		 ,@vgs_execution_user varchar(60)
		 ,@vgs_fill_end_time datetime
		 ,@vgsStepStartTime datetime
		 ,@vgsStepEndTime datetime

----client Access Varaibles
Declare @vCheckClientId varchar(max)
Declare @vClientIDs varchar(max)		
Declare @vClientWarningMsg varchar(max)--- to know whether it the returned list is restricted

BEGIN TRY

Set @status_code = 0   ---- Status Code 0 = Success, 1 = Exception
set @status_text = null;
set @rows_returned = 0;
Set @vgs_program_name  = Object_name(@@ProcID);  ---Current Store Proc Name
Set @vgs_start_time = getdate();
Set @vgs_execution_user = @execution_user_login;
set @vdelim = ','
set @vCflr = Char(13)
set @vReportDate = getdate();
set @vIsTrial = 0
set @vStep = 0
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Executing store proc :  ' + @vgs_program_name  + convert(varchar(26),getdate(),109)

----Parameter Sniffing - use local variables when they are used in a where clause
SET @vFacID							= @fac_id;
SET @vTemplateId					= @template_id;
SET @vIncludeInactiveFacIds			= @include_inactive_fac_ids; 
SET @vIsContact						= @is_contact;
SET @vReceiverIds					= @receiver_ids;
SET @vClientStatus					= @client_status
SET @vPayerIdList					= @payer_id_list;
SET @vInvoiceIdList					= @invoice_id_list;
SET @vLastStatement					= @last_statement;
SET @vStatementStartDate			= convert(datetime, convert(varchar(10),@statement_start_date , 101) + ' 00:00:00');
SET @vStatementEndDate				= convert(datetime, convert(varchar(10),@statement_end_date , 101) + ' 23:59:59');
SET @vSummarizeReversals			= 1;
SET @vShowResults					= @show_results;
SET @vCombineChildren				= @combine_children;
SET @vBillingGroup					= isnull(@billing_group,'-1');
SET @vDisplayAdmitDate				= @display_admit_date;
SET @vDisplayDischargeDate			= @display_discharge_date;
SET @vReprintFrom					= @reprint_from; --case when @reprint_from is not null then @reprint_from+'%' else null end;
SET @vIncludeResidentMessage		= 1;
SET @vShowAging						= @show_aging;
SET @vCashReceiptComments			= @cash_receipt_comments;
SET @vAncillaryComments				= @ancillary_comments;
SET @vAdjustmentComments			= @adjustment_comments;
SET @vStatementMessage				= @statement_message;
SET @vShowPaymentDueDate			= 0;
SET @vIsEmc							= @is_emc;
SET @vIncludePrefixFacilityCode		= @include_prefix_facility_code;
SET @vIncludeNonContacts			= 0;
SET @vMinimumBalance				= @minimum_balance;
SET @vUseEffectiveDateAsBillDate	= @use_effective_date_as_bill_date;
SET @vSortBy						= @sort_by;
SET @vTransactionOrder				= @transaction_order;
SET @vIsNewEft						= @is_new_eft;
SET @vSuppress0value				= 1;
SET @vExportMode					= @export_mode;
SET @vExportResendFlag				= @export_resend_flag;

SET @vOtherPayerSummary				= 1;
SET @vShowOnlineID					= 1;
SET @vAccountNumberSource			= @account_number_source;
SET @vCombineRecurringAncillary		= @combine_ancillary_flag;
SET @vCombineCouncilPayerContribution = (select top 1 isnull(cp.value,0)
										from configuration_parameter cp 
										where name = 'combine_council_payer_contribution' and fac_id = -1);


--If @vReceiverIds = '-1' and (@vIsContact = 0 or @vPayerIdList = '0') --for all we want to pull as contacts, but only when private/outpatient is selected alone - other payers need the resident.
--	set @vIsContact = 1

--set hard coded export conditions
if @vExportMode = 1
	begin
		SET @vShowAging				= 0;
		SET @vOtherPayerSummary		= 0;
	end
	
If  @vReceiverIds = '-1'
	set @vIncludeNonContacts = 1
else
	set @vIncludeNonContacts = 0

If  @vReceiverIds <> '-1' and @vIsContact = 0
	begin
		INSERT into #client_ids_table select Cast(items as int) from dbo.Split(@vReceiverIds,@vdelim)
	end
	
If  @vReceiverIds <> '-1' and @vIsContact = 1
	begin
		INSERT into #receiver_ids_table select Cast(items as int), 2 from dbo.Split(@vReceiverIds,@vdelim)
	end
--else
--	begin

--	end

create table #contact_clients
	(
		  fac_id							int
		, contact_id						numeric(18,1) 
		, consolidate_statement				bit
		, client_id							int
		, invoice_id						int
		, statement_invoice_number			int
		, payer_id							int
		, payer								varchar(50)
		, inv_effective_date				datetime
		, inv_eff_date_from					datetime
		, inv_eff_date_to					datetime
		, remit_to_name						varchar(375)
		, remit_to_address1					varchar(70)
		, remit_to_address2					varchar(70)
		, remit_to_address3					varchar(70)
		, remit_to_city						varchar(75)
		, remit_to_county					varchar(75)
		, remit_to_prov_state				varchar(75)
		, remit_to_country					varchar(75)
		, remit_to_postal_zip_code			varchar(75)
		, remit_to_phone					varchar(35)
		, contact_title						varchar(30)
		, contact_first_name				varchar(120)
		, contact_last_name					varchar(50)
		, contact_address1					varchar(105)
		, contact_address2					varchar(120)
		, contact_address3					varchar(120)
		, contact_city						varchar(75)
		, contact_county					varchar(75)
		, contact_prov_state				varchar(75)
		, contact_postal_zip_code			varchar(75)
		, contact_country					varchar(75)
		, contact_email						varchar(75)
		, account_number					varchar(12)
		, generated_date					datetime
		, bill_date							datetime
		, aging_date						datetime
		, payment_due_date					datetime
		, pre_consolidated_payment_due_date	datetime
		, statement_through_date			datetime
		, amount_due						money
		, eft_message						varchar(500)
		, client_message					varchar(500)
		, group_message						varchar(max)
		, global_message					varchar(500)
		, previous_balance_due				money
		, payments							money
		, summary_fac_id					int
		, summary_charge_center				varchar(75)
		, summary_charge_center_code		varchar(5)
		, summary_charge_client_first_name	varchar(50)
		, summary_charge_client_last_name	varchar(50)
		, summary_charge_client_name		varchar(120)
		, summary_charge_client_number		varchar(35)
		, summary_charge_client_location	varchar(100)
		, summary_charge_client_dob			datetime
		, summary_charge_client_admission	datetime
		, summary_charge_client_discharge	datetime
		, summary_current_balance			money
		, summary_previous_balance_due		money
		, summary_payments					money
		, summary_late_fees					money
		, summary_client_balance_due		money
		, private_bills_to					varchar(2)
		, amount_past_due_yn				char(1)
		, term_used_for_client				varchar(25)
		, client_admit_date					datetime
		, client_discharge_date				datetime
		, client_mrn						varchar(25)
		, client_first_name					varchar(50)
		, client_last_name					varchar(50)
		, client_unit						varchar(50)
		, unit_order						numeric
		, client_room						varchar(50)
		, room_order						numeric
		, client_bed						varchar(50)
		, bed_order							numeric
		, patient_specific_message			varchar(500)
		, contact_num						int
		, non_consolidated_contact_num		int
		, client_list						varchar(500)
		, main_location						bit
		, consolidated_location_order		smallint
		, sort_location						varchar(100)
		);

CREATE CLUSTERED INDEX _tmp_idx_contact_clients on #contact_clients(contact_id,client_id,invoice_id);

create table #contact_return_to
	(
		  contact_num						int 
		, campus_id							int 
		, return_to_group_number			varchar(50)
		, return_to_name					varchar(375)
		, return_to_address1				varchar(70)
		, return_to_address2				varchar(70)
		, return_to_address3				varchar(70)
		, return_to_city					varchar(75)
		, return_to_county					varchar(75)
		, return_to_prov_state				varchar(75)
		, return_to_country					varchar(75)
		, return_to_postal_zip_code			varchar(75)
		, return_to_phone					varchar(35)
		);

CREATE CLUSTERED INDEX _tmp_idx_contact_payment_to on #contact_return_to(contact_num);

create table #local_transactions
	(
		  invoice_id					int
		, contact_id					numeric(18,1) 
		, batch_id						int
		, entry_number					int
		, client_id						int
		, auto_generated				varchar(1)
		, transaction_id				int
		, reversing_tx_id				int
		, distribution_tx_id			int
		, applied_payment_id			int
		, payer_id						int
		, parent_payer_id				int
		, days_account_id				int
		, dollars_account_id			int
		, fac_id						int
		, is_billed						bit
		, transaction_type				varchar(2)
		, parent_tx_type				varchar(2)
		, [description]					varchar(100)
		, alt_description				varchar(100)
		, cheque_number					varchar(50)
		, effective_date				datetime
		, transaction_date				datetime
		, bill_date						datetime
		, applied_date					datetime
		, generated_date				datetime
		, days_amount					int
		, daily_rate					money
		, monthly_rate					money
		, amount						money
		, care_level					varchar(5)
		, revenue_code					varchar(5)
		, hcpcs_code					varchar(5)
		, item_type_id					int
		, comment						varchar(200)
		, rate_type_id					int
		, rugs_modifier					varchar(2)
		, medicare_day					int
		, mppr_flag						bit
		, mark_as_billed_by				varchar(60)
		, mark_as_billed_date			datetime
		, mark_as_billed_comment		varchar(256)
		, transaction_type_group		tinyint
		, skip_bit						tinyint
	);

CREATE CLUSTERED INDEX _tmp_idx_local_transactions on #local_transactions(invoice_id,transaction_type,distribution_tx_id,reversing_tx_id);
CREATE NONCLUSTERED INDEX _tmp_nc_idx_local_transactions on #local_transactions(skip_bit,amount,auto_generated,distribution_tx_id)
	include (days_amount,daily_rate);

create table #child_transactions
	(
		  distribution_tx_id			int
		, transaction_type				varchar(2)
		, parent_tx_type				varchar(2)
		, contact_id					numeric(18,1) 
		, invoice_id					int
		, payer_id						int
		, days_amount					int
		, daily_rate					money
		, monthly_rate					money
		, amount						money
		, bill_date						datetime
		, generated_date				datetime
		, skip_bit						bit

	);

CREATE CLUSTERED INDEX _tmp_idx_child_transactions on #child_transactions(distribution_tx_id,parent_tx_type);

create table #transactions

	(
		  invoice_id					int
		, fac_id						int
		, contact_id					numeric(18,1) 
		, contact_num					int
		, client_id						int
		, payer_id						int
		, payer							varchar(100)
		, payer_type					varchar(20)
		, batch_id						int
		, entry_number					int
		, distribution_tx_id			bigint
		, transaction_id				bigint
		, reversing_tx_id				bigint
		, auto_generated				varchar(1)
		, bill_date						datetime
		, posting_date					datetime
		, effective_date				datetime
		, effective_from_date			datetime
		, effective_thru_date			datetime
		, generated_date				datetime
		, charge_code					varchar(12)
		, frequency						varchar(1)
		, revenue_code					varchar(5)
		, hcpcs_code					varchar(5)
		, mppr_flag						bit
		, tx_description				varchar(200)
		, care_level					varchar(5)
		, benefit_days					varchar(10)
		, parent_tx_type				varchar(2)
		, transaction_type				varchar(2)
		, unit_amount					money
		, units							int
		, amount						money
		, gl_account					varchar(75)
		, days_account					varchar(75)
		, billed						varchar(5)
		, comment						varchar(200)
		, cheque_number					varchar(50)
		, adjusted_tx_type				varchar(10)
		, recurring_tx					bit
		, reversed						bit
		, transaction_type_group		tinyint
		, ancillary_year				smallint
		, ancillary_month				tinyint
		, balance_due					money
		, other_payer					tinyint
		, aging_total					money
		, aging_current_label			varchar(10)
		, aging_current_amount			money
		, aging_30_label				varchar(10)
		, aging_30_amount				money
		, aging_60_label				varchar(10)
		, aging_60_amount				money
		, aging_90_label				varchar(10)
		, aging_90_amount				money
		, aging_120_label				varchar(10)
		, aging_120_amount				money
		, aging_150_label				varchar(10)
		, aging_150_amount				money
		, aging_180_label				varchar(10)
		, aging_180_amount				money
		, aging_210_label				varchar(10)
		, aging_210_amount				money
		, detail_order					int

	);

CREATE CLUSTERED INDEX _tmp_idx_consolidated_statement_detail on #transactions(contact_id,client_id,invoice_id);

create table #facilty_group_info
	(
		  facility_group_id				int
		, fac_id						int
		, remit_to_group_number			varchar(50)
		, remit_to_name					varchar(100)
		, remit_to_address1				varchar(120)
		, remit_to_address2				varchar(120)
		, remit_to_address3				varchar(120)
		, remit_to_city					varchar(120)
		, remit_to_county				varchar(120)
		, remit_to_prov_state			varchar(120)
		, remit_to_country				varchar(120)
		, remit_to_postal_zip_code		varchar(120)
		, remit_to_phone				varchar(35)
		, facility_group_number			varchar(50)
		, facility_group_name			varchar(100)
		, facility_group_address1		varchar(75)
		, facility_group_address2		varchar(75)
		, facility_group_address3		varchar(75)
		, facility_group_city			varchar(75)
		, facility_group_county			varchar(75)
		, facility_group_prov_state		varchar(75)
		, facility_group_country			varchar(75)
		, facility_group_postal_zip_code	varchar(75)
		, facility_group_phone				varchar(75)
		, facility_group_fax				varchar(75)
			
	);

create table #balance_forward_union
	(	 contact_id		numeric(18,1) --int
		,contact_num	int
		,client_id		int 
		,payer_id		int
		,invoice_date	datetime
		,payer_type		varchar(20)
		,amount			money 
	);

create table #balance_forward_amount
	(	 contact_id		numeric(18,1) --int
		,contact_num	int
		,client_id		int 
		,payer_id		int 
		,invoice_date	datetime
		,payer_type		varchar(20)
		,amount			money 
	);


create table #facility_list 
		 (
			  fac_id int
			, cheques_payable_to varchar(max)
			, gst_hst varchar(3)
			, gst_number varchar(15)
			, show_payment_due_date bit
			, country varchar(75)
			);

create table #invoices
	(
		  fac_id						int
		, client_id						int
		, invoice_id					int
		, created_date					datetime
		, statement_invoice_number		int
		, payer_id						int
		, effective_date				datetime
		, eff_date_from					datetime
		, eff_date_to					datetime
		, generated_date				datetime
		, payment_due_date				datetime
		, statement_through_date		datetime
		, trial_flag					char(1)
		);

CREATE CLUSTERED INDEX _tmp_idx_invoices on #invoices(client_id);

create table #cfilter (receiver_id int)

create table #subclass (subclass_id int)
create table #relationship (item_id int)
			
set @vgsStepEndTime=GETDATE();
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
			
select @vStep = 10
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Validating Input Parameters  ' +  convert(varchar(26),getdate(),109)

----Validate all input parameters
if (
		@execution_user_login is null
	)
	begin
		set @vErr = 'One or more of the following input parameters is invalid... '
					+ ', @execution_user_login=' + isnull(@execution_user_login,'null/empty')
		
		RAISERROR (@vErr -- Message text
						,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
						,1 -- State
						);
	end

set @vgsStepEndTime=GETDATE();
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

Select @vStep = 20;
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Loading temp tables ' + convert(varchar(26),getdate(),109);

--CORE-85860 performance tuning: existing logic does not check for deleted column, we're not changing this logic for now
insert into #subclass select item_id from dbo.common_code where item_description = 'Resident'
CREATE CLUSTERED INDEX _tmp_idx_subclass on #subclass(subclass_id);

insert into #relationship select item_id from dbo.common_code where item_description = 'Self'
CREATE CLUSTERED INDEX _tmp_idx_relationship on #relationship(item_id);

INSERT into #facility_list select Cast(items as int) fac_id,'', Null, Null, 0, '' from dbo.Split(@vFacId,@vdelim)

update fac set fac.gst_hst = (case when config.gst_hst = 0 then 'GST' when config.gst_hst = 1 then 'HST' else Null end), fac.gst_number = config.gst_number 
from #facility_list fac
inner join dbo.ar_configuration config with (nolock) on fac.fac_id = config.fac_id
inner join dbo.configuration_parameter parm with (nolock) on fac.fac_id = parm.fac_id and parm.name = 'show_gst' and parm.value = 'Y'

update fl set fl.cheques_payable_to = (case when sct.cheques_payable_to_option = 0 then fac.name when sct.cheques_payable_to_option = 1 
	then grp.name else sct.cheques_payable_to end), fl.show_payment_due_date = (Case when config.show_payment_due_date = 'Y' then 1 else 0 end),
	fl.country = (Case when cntry.item_id is null then '' else cntry.item_description end)
from #facility_list fl
inner join dbo.facility fac with (nolock) on fl.fac_id = fac.fac_id
inner join dbo.view_ar_statement_configuration_template_facility_mapping map with (nolock) on map.fac_id = fac.fac_id
inner join dbo.ar_statement_configuration_template sct with (nolock) on map.template_id = sct.template_id
inner join dbo.ar_configuration config with (nolock) on fl.fac_id = config.fac_id
left join dbo.facility_group_mapping fgm with (nolock) on fac.fac_id = fgm.fac_id
left join dbo.facility_group grp with (nolock) on fgm.facility_group_id = grp.facility_group_id and grp.[type_id] = 1
left join dbo.common_code cntry with (nolock) on fac.country_id = cntry.item_id
--select * from #facility_list
--select * from facility where fac_id in(80,81,82,83)
--print '@vBillingGroup = ' +@vBillingGroup
IF @vBillingGroup <> '-1' --and @vBillingGroup <> '0'
	begin
		insert INTO #billing_group_table select Cast(items as int) from dbo.Split(@vBillingGroup,@vdelim)
	end

declare @vBillingGroupIncludesMissing bit
	
select @vBillingGroupIncludesMissing = count(1) from #billing_group_table where group_id = 0
--select * from #billing_group_table
SET @vPrivateStatementsIncluded = 0
SET @vOtherStatementsIncluded = 0

INSERT into #payer_ids_table (payer_id, bill_payer_id) select Cast(items as int), Cast(items as int) from dbo.Split(@vPayerIdList,@vdelim)

if (select count(*) from #payer_ids_table where payer_id = 0) > 0
	begin
		if @vExportMode = 0
			INSERT into #payer_ids_table 
			select distinct pyr.fac_id,libpayer.payer_id, 0, Null, Null, Null, 'N'
			from dbo.ar_lib_payers libpayer with (nolock)
			inner join dbo.ar_payers pyr with (nolock) on libpayer.payer_id = pyr.payer_id
			inner join #facility_list pf on pyr.fac_id = pf.fac_id
			where libpayer.deleted='N' and 
			--(libpayer.payer_type  = 'Private' OR libpayer.payer_type  = 'Outpatient') and libpayer.bill_form = 'private' --old statment filter method.
			((libpayer.payer_type = 'Private' and libpayer.bill_form = 'private') or (libpayer.payer_type = 'Outpatient' and libpayer.outpatient_payer_type = 'Private'))
		else
			INSERT into #payer_ids_table 
			select distinct pyr.fac_id,libpayer.payer_id, 0, Null, Null, Null, 'N'
			from dbo.ar_lib_payers libpayer with (nolock)
			inner join dbo.ar_payers pyr with (nolock) on libpayer.payer_id = pyr.payer_id
			inner join #facility_list pf on pyr.fac_id = pf.fac_id
			where libpayer.deleted='N' and pyr.export_ps_flag = 'Y' and 
			--(libpayer.payer_type  = 'Private' OR libpayer.payer_type  = 'Outpatient') and libpayer.bill_form = 'private' --old statment filter method.
			((libpayer.payer_type = 'Private' and libpayer.bill_form = 'private') or (libpayer.payer_type = 'Outpatient' and libpayer.outpatient_payer_type = 'Private'))


		delete from #payer_ids_table where payer_id = 0 and bill_payer_id = 0

		SET @vPrivateStatementsIncluded = 1

	end

if (select count(*) from #payer_ids_table where bill_payer_id > 0) > 0
	SET @vOtherStatementsIncluded = 1

if (select count(*) from #payer_ids_table where bill_payer_id > 0) > 0
	begin
		SET @vOtherStatementsIncluded = 1
		if @vInvoiceIdList is null 
			begin

				insert into #payer_ids_table
				select pyr.fac_id, pyr.payer_id, pyr.payer_id, lpyr.client_id, lpyr.statement_date, lpyr.generated_date, 'N'
				from
				#payer_ids_table lpyr
				inner join dbo.ar_payers pyr on lpyr.payer_id = pyr.payer_id
				inner join #facility_list pf on pyr.fac_id = pf.fac_id
				where lpyr.bill_payer_id > 0

				delete from #payer_ids_table where fac_id is null

			end
	end

if @vInvoiceIdList is not null
	begin
		INSERT into #invoice_ids_table (invoice_id) select Cast(items as int) from dbo.Split(@vInvoiceIdList,@vdelim)

		update prntinv set prntinv.client_id = inv.client_id, prntinv.payer_id = inv.payer_id, prntinv.statement_date = inv.effective_date, prntinv.generated_date = invstat.generated_date,
			prntinv.trial_flag = inv.trial_flag
		from
		#invoice_ids_table prntinv
		inner join dbo.ar_invoice inv on prntinv.invoice_id = inv.invoice_id
		left join dbo.ar_invoice_statement invstat on inv.invoice_id = invstat.invoice_id

		update pyr set pyr.statement_date = prntinv.statement_date, pyr.generated_date = prntinv.generated_date, pyr.trial_flag = prntinv.trial_flag
		from
		#payer_ids_table pyr
		inner join #invoice_ids_table prntinv on pyr.payer_id = prntinv.payer_id

		insert into #payer_ids_table
		select pyr.fac_id, pyr.payer_id, pyr.bill_payer_id, prntinv.client_id, prntinv.statement_date, prntinv.generated_date, prntinv.trial_flag
		from
		#payer_ids_table pyr
		inner join #invoice_ids_table prntinv on pyr.payer_id = prntinv.payer_id

		delete pyr
		from
		#payer_ids_table pyr
		inner join #payer_ids_table dpyr on pyr.payer_id = dpyr.payer_id and pyr.statement_date = dpyr.statement_date and pyr.generated_date = dpyr.generated_date
		where pyr.client_id is null and dpyr.client_id is not null

		insert into #payer_ids_table
		select pyr.fac_id, pyr.payer_id, pyr.bill_payer_id, dpyr.client_id, dpyr.statement_date, dpyr.generated_date, dpyr.trial_flag
		from
		#payer_ids_table pyr
		left join #payer_ids_table dpyr on pyr.bill_payer_id = dpyr.bill_payer_id 
		where pyr.client_id is null and dpyr.client_id is not null
	
		delete from #payer_ids_table where client_id is null;

		with dups 
			as
			(select fac_id, payer_id, bill_payer_id, client_id, statement_date, generated_date, trial_flag,
				row_number() OVER ( PARTITION BY fac_id, payer_id, bill_payer_id, client_id, statement_date, generated_date, trial_flag ORDER BY fac_id, payer_id, bill_payer_id, client_id, statement_date, generated_date, trial_flag ) AS rwnum
				from #payer_ids_table
			)

		delete from dups where rwnum > 1
		
		IF (select COUNT(1) from #invoice_ids_table where trial_flag = 'Y') > 0
		begin
			set @vIsTrial=1
			set @vShowAging = 0 --aging won't include the trial bill transactions and will appear off
		end
	end

if isnull(@vReceiverIds, '-1') <> '-1' 
	insert into #cfilter select Cast(items as int) from dbo.Split(@vReceiverIds,@vdelim)

if @debug_me = 'Y' select * from #receiver_ids_table
if @debug_me = 'Y' select * from #payer_ids_table

--gather export variables

if @vExportMode = 1
	begin

		--select @vTemplateId = facmap.template_id from view_ar_statement_configuration_template_facility_mapping facmap where fac_id = @vFacId
		set @vTemplateId = (select top 1 facmap.template_id 
			from view_ar_statement_configuration_template_facility_mapping facmap 
			inner join #facility_list fl on facmap.fac_id = fl.fac_id order by facmap.fac_id)

		

		select 
			 @vDisplayAdmitDate = cfg.display_admit_date_flag,
			 @vDisplayDischargeDate = cfg.display_discharge_date_flag,
			 @vTransactionOrder = cfg.sort_option,
			 @vUseEffectiveDateAsBillDate = cfg.statement_date_option,
			 @vCombineChildren = cfg.transaction_display_option,
			 @vShowResults = cfg.ancillary_display_option,
			 @vCashReceiptComments = cfg.comment_from_cash,
			 @vAncillaryComments = cfg.comment_from_ancillary,
			 @vAdjustmentComments = cfg.comment_from_adjustments,
			 @vShowLocation = cfg.display_location_flag,
			 @vShowResidentNumber = cfg.display_resident_number_flag,
			 @vShowInvoiceNumber = cfg.display_invoice_number_flag,
			 @vShowTransactionWarningMessage = cfg.display_transaction_warning_message,
			 @vTransactionWarningMessage = cfg.transaction_warning_message,
			 @vDisplayUnitAndAmountFlag = cfg.display_unit_and_amount_flag,
			 @vPaymentInstructions = cfg.payment_instructions,
			 @vIncludePrefixFacilityCode = cfg.prefix_facility_code_to_account_number_flag,
			 @vAccountNumberLabel = cfg.account_number_label,
			 @vAccountNumberSource = cfg.account_number_source
		from dbo.ar_statement_configuration_template cfg with (nolock) where template_id = @vTemplateId
--select * from ar_statement_configuration_template
		--set terms
		if @vIsEmc = 1
			Select @vTermClient = term_client
				, @vTermFacility = term_facility
				, @vTermAdmission = term_admission
				, @vTermDischarge = term_discharge
				, @vTermRoom = term_room
			from [dbo].fn_prp_get_terminology(@vFacId,0)
			where fac_id = -1
		else
			Select @vTermClient = term_client
				, @vTermFacility = term_facility
				, @vTermAdmission = term_admission
				, @vTermDischarge = term_discharge
				, @vTermRoom = term_room
			from [dbo].fn_prp_get_terminology(@vFacId,0)
			where fac_id <> -1

	end

--select @vShowPaymentDueDate = cfg.display_payment_due_date from dbo.ar_statement_configuration_template cfg with (nolock) where template_id = @vTemplateId

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

Select @vStep = 30;
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Gathering invoices ' + convert(varchar(26),getdate(),109);

if @vLastStatement = 1 and @vInvoiceIdList is null
	begin

		if @vIsContact = 1
	
			select @vStatementStartDate = max(inv.effective_date)	
			from dbo.ar_invoice inv with (nolock)
				--inner join dbo.ar_invoice_statement invstat with (nolock) on inv.invoice_id = invstat.invoice_id
				inner join #facility_list fl on inv.fac_id = fl.fac_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and inv.trial_flag = 'N' and inv.deleted = 'N' and payer.bill_payer_id = 0
				inner join dbo.clients cl with (nolock) on inv.client_id = cl.client_id and cl.fac_id = inv.fac_id
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id 
				inner join dbo.contact_relationship conr with (nolock) on conr.reference_id = mpi.mpi_id and conr.deleted='N'
				left join #cfilter confilter on conr.contact_id = confilter.receiver_id
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
				left join #billing_group_table bg on grp.group_id = bg.group_id	
				where (@vClientStatus = -1 or (@vClientStatus = 0 and (cl.discharge_date is null or cl.discharge_date > @vReportDate)) or (@vClientStatus = 1 and cl.discharge_date <= @vReportDate)) 
				and (@vReceiverIds = '-1' or confilter.receiver_id is not null)
				and (@vBillingGroup = '-1' or (@vBillingGroup <> '-1' and ((clgrp.group_id is not null and bg.group_id is not null and @vBillingGroup <> '0') 
					or (isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null) )) or @vBillingGroup is null)

		else

			select @vStatementStartDate = max(inv.effective_date)	
			from dbo.ar_invoice inv with (nolock)
				inner join #facility_list fl on inv.fac_id = fl.fac_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and inv.trial_flag = 'N' and inv.deleted = 'N'
				inner join dbo.clients cl with (nolock) on inv.client_id = cl.client_id and cl.fac_id = inv.fac_id 
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id 
				left join #cfilter clfilter on inv.client_id = clfilter.receiver_id
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
				left join #billing_group_table bg on grp.group_id = bg.group_id	
				where (@vClientStatus = -1 or (@vClientStatus = 0 and (cl.discharge_date is null or cl.discharge_date > @vReportDate)) or (@vClientStatus = 1 and cl.discharge_date <= @vReportDate)) 
				and (@vReceiverIds = '-1' or clfilter.receiver_id is not null)
				and (@vBillingGroup = '-1' or (@vBillingGroup <> '-1' and ((clgrp.group_id is not null and bg.group_id is not null and @vBillingGroup <> '0') 
					or (isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null) )) or @vBillingGroup is null)

		SET @vStatementStartDate = convert(datetime, convert(varchar(10),@vStatementStartDate , 101) + ' 00:00:00');
		SET @vStatementEndDate = DATEADD(s,-1,DATEADD(mm, DATEDIFF(m,0,@vStatementStartDate)+1,0));
			
		if @debug_me='Y' print '@vStatementStartDate  ' +  convert(varchar(26),@vStatementStartDate,109)
		if @debug_me='Y' print '@vStatementEndDate  ' +  convert(varchar(26),@vStatementEndDate,109)
	
	end

if @vInvoiceIdList is null
	begin
		insert into #invoices
		select 
			  inv.fac_id
			, inv.client_id
			, inv.invoice_id
			, inv.created_date
			, inv.statement_invoice_number
			, inv.payer_id
			, inv.effective_date
			, inv.eff_date_from
			, inv.eff_date_to
			, invstat.generated_date
			, invstat.payment_due_date
			, invstat.statement_through_date
			, inv.trial_flag
		from dbo.ar_invoice inv with (nolock) 
			inner join #facility_list fac on inv.fac_id = fac.fac_id and inv.trial_flag = 'N' and inv.deleted = 'N'
			inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and inv.effective_date >= @vStatementStartDate and inv.effective_date <= @vStatementEndDate and inv.fac_id = payer.fac_id
			left join dbo.ar_invoice_statement invstat with (nolock) on inv.invoice_id = invstat.invoice_id
		where (@vExportMode = 0 OR inv.date_exported_ps IS NULL OR @vExportResendFlag = 1 )
	end

if @vInvoiceIdList is not null and @vOtherStatementsIncluded = 1
	begin
		insert into #invoices
		select 
			  inv.fac_id
			, inv.client_id
			, inv.invoice_id
			, inv.created_date
			, inv.statement_invoice_number
			, inv.payer_id
			, inv.effective_date
			, inv.eff_date_from
			, inv.eff_date_to
			, invstat.generated_date
			, invstat.payment_due_date
			, invstat.statement_through_date
			, inv.trial_flag
		from dbo.ar_invoice inv with (nolock)
			inner join #facility_list fac on inv.fac_id = fac.fac_id 
			inner join dbo.ar_invoice_statement invstat with (nolock) on inv.invoice_id = invstat.invoice_id --and pyrs.generated_date = invstat.generated_Date
			where exists(select 1 from #payer_ids_table pyrs where pyrs.payer_id = inv.payer_id and pyrs.bill_payer_id <> 0 and 
				inv.deleted='N' and pyrs.statement_date = inv.effective_date)

		set @vRowCount = isnull(@vRowCount,0) + @@rowcount

		if @vRowCount = 0
			set @vOtherStatementsIncluded = 0

	end

if @vInvoiceIdList is not null and @vPrivateStatementsIncluded = 1
	begin
		insert into #invoices
		select 
			  inv.fac_id
			, inv.client_id
			, inv.invoice_id
			, inv.created_date
			, inv.statement_invoice_number
			, inv.payer_id
			, inv.effective_date
			, inv.eff_date_from
			, inv.eff_date_to
			, invstat.generated_date
			, invstat.payment_due_date
			, invstat.statement_through_date
			, inv.trial_flag
		from dbo.ar_invoice inv with (nolock)
			inner join #facility_list fac on inv.fac_id = fac.fac_id 
			inner join dbo.ar_invoice_statement invstat with (nolock) on inv.invoice_id = invstat.invoice_id --and pyrs.generated_date = invstat.generated_Date
			where exists(select 1 from #payer_ids_table pyrs where pyrs.payer_id = inv.payer_id and pyrs.bill_payer_id = 0 and 
				inv.deleted='N' and pyrs.statement_date = inv.effective_date)
	end

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

If @vIsEmc = 1
	begin

		Select @vStep = 40;
		set @vgsStepStartTime = GETDATE()
		if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Getting facility group info ' + convert(varchar(26),getdate(),109);

		insert into #facilty_group_info
		select 
			  grp.facility_group_id
			, f.fac_id
			, grp.facility_group_code as remit_to_group_number
			, grp.name as remit_to_name
			, Case when isnull(grp.use_facility_group_address,0) <> 1 then adr.address1 
--						when fgm.fac_id is not null and grp.remit_to_address_id is not null then adr.address1 
					else grp.address1 end as remit_to_address1 
			, Case when isnull(grp.use_facility_group_address,0) <> 1 then adr.address2
--						when fgm.fac_id is not null and grp.remit_to_address_id is not null then adr.address2  
					else grp.address2 end as remit_to_address2
			, Case when isnull(grp.use_facility_group_address,0) <> 1 then adr.address3 
--						when fgm.fac_id is not null and grp.remit_to_address_id is not null then adr.address3
					else grp.address3 end as remit_to_address3 
			, Case when isnull(grp.use_facility_group_address,0) <> 1 then adr.city 
--						when fgm.fac_id is not null and grp.remit_to_address_id is not null then adr.city   
					else grp.city end as remit_to_city
			, Case when isnull(grp.use_facility_group_address,0) <> 1 then cntygrp.name 
					else cntyadr.name end as remit_to_county
			, Case when isnull(grp.use_facility_group_address,0) <> 1 then adr.prov_state 
--						when fgm.fac_id is not null and grp.remit_to_address_id is not null then adr.prov_state   
					else grp.prov_state end as remit_to_prov_state
			, Case when isnull(grp.use_facility_group_address,0) <> 1 then cntrygrp.item_description 
					else cntryadr.item_description end as remit_to_country
			, Case when isnull(grp.use_facility_group_address,0) <> 1 then adr.postal_zip_code
--						when fgm.fac_id is not null and grp.remit_to_address_id is not null then adr.postal_zip_code    
					else grp.postal_zip_code end as remit_to_postal_zip_code
			, Case when grp.use_facility_group_address <> 1 then grp.telephone2 
					else grp.telephone end as remit_to_phone
			, grp.facility_group_code as facility_group_number
			, grp.name as facility_group_name
			, grp.address1 as facility_group_address1
			, grp.address2 as facility_group_address2
			, grp.address3 as facility_group_address3
			, grp.city as facility_group_city
			, cntyadr.name as facility_group_county
			, grp.prov_state as facility_group_prov_state
			, cntrygrp.item_description as facility_group_country
			, grp.postal_zip_code as facility_group_postal_zip_code
			, grp.telephone as facility_group_phone
			, grp.fax as facility_group_fax

		from #facility_list fl
			inner join facility f with (nolock) on fl.fac_id = f.fac_id
			inner join dbo.facility_group_mapping fgm with (nolock) on f.fac_id = fgm.fac_id
			inner join dbo.facility_group grp with (nolock) on fgm.facility_group_id = grp.facility_group_id and grp.[type_id] = 1
			left join dbo.address adr with (nolock) on grp.remit_to_address_id = adr.address_id
			left join dbo.county cntygrp with (nolock) on adr.county_id = cntygrp.county_id
			left join dbo.county cntyadr with (nolock) on grp.county_id = cntyadr.county_id
			left join dbo.common_code cntrygrp with (nolock) on grp.country_id = cntrygrp.item_id
			left join dbo.common_code cntryadr with (nolock) on adr.country_id = cntryadr.item_id

		set @vgsStepEndTime=GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	end

if @debug_me='Y' select * from #facilty_group_info
if @debug_me='Y' select * from #facility_list

if @vInvoiceIdList is not null
	begin
	If @vPrivateStatementsIncluded = 1 -- process private statements as they are included
		begin	
			-----getting the list of contacts
			select @vStep = 70
			set @vgsStepStartTime = GETDATE()
			if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' gathering contacts clients and their invoices ' + convert(varchar(26),getdate(),109)
			--*********************************************************************************************************

			insert into #receiver_ids_table
			select distinct
				  conr.contact_id
				, conr.consolidate_statements
			from #invoice_ids_table prntinv
				--inner join dbo.ar_invoice inv with (nolock) on prntinv.invoice_id = inv.invoice_id
				inner join #invoices inv with (nolock) on prntinv.invoice_id = inv.invoice_id
				inner join dbo.clients cl with (nolock) on inv.client_id = cl.client_id 
				inner join  #facility_list fl on cl.fac_id = fl.fac_id 
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id = 0
				inner join dbo.ar_configuration config with (nolock) on fl.fac_id  = config.fac_id
				inner join dbo.contact_type_audit cta with (nolock) on mpi.mpi_id = cta.reference_id  --and (cta.contact_id = @vReceiverIds or @vReceiverIds = -1) 
					and config.contact_type_id = cta.[type_id] and cta.fac_id = inv.fac_id
					and cta.effective_date  <= inv.created_date AND (cta.ineffective_date  >= inv.created_date or cta.ineffective_date is null)
				inner join dbo.contact_relationship conr with (nolock) on conr.contact_id = cta.contact_id and conr.deleted='N' 
					and conr.reference_id = cta.reference_id and conr.subclass_id = cta.subclass_id --and cta.subclass_id = @vSubClassResidentID --9176
				inner join #subclass subc on cta.subclass_id = subc.subclass_id 
				--inner join dbo.common_code cc with (nolock) on cta.subclass_id = cc.item_id and cc.item_description = 'Resident'
				inner join dbo.contact_audit conta with (nolock) on cta.contact_id = conta.contact_id and conta.deleted='N'			
					and conta.effective_date  <= inv.created_date AND (conta.ineffective_date  >= inv.created_date or conta.ineffective_date is null)
				left join dbo.contact_address_audit conadd with (nolock) on cta.contact_id = conadd.contact_id 			
					and conadd.effective_date  <= inv.created_date AND (conadd.ineffective_date  >= inv.created_date or conadd.ineffective_date is null)
				left join dbo.address_audit cadd with (nolock) on conadd.address_id = cadd.address_id			
					and cadd.effective_date  <= inv.created_date AND (cadd.ineffective_date  >= inv.created_date or cadd.ineffective_date is null)	
				left join dbo.county cnty with (nolock) on cadd.county_id = cnty.county_id
				left join common_code country with (nolock) on cadd.country_id = country.item_id
				left join common_code_audit title with (nolock)	on isnull(title.deleted, 'N') = 'N' and conta.title_id = title.item_id 
					and title.effective_date  <= inv.created_date AND (title.ineffective_date  >= inv.created_date or title.ineffective_date is null)

			--resident statemments
			insert into #contact_clients
			select distinct
					fl.fac_id
				, conr.contact_id
				, conr.consolidate_statements as consolidate_statement
				, cl.client_id 
				, inv.invoice_id 
				, inv.statement_invoice_number
				, 0 as payer_id	
				, libpayer.description as payer 
				, inv.effective_date
				, inv.eff_date_from
				, inv.eff_date_to
				, hfac.name as remit_to_name
				, hfac.address1 as remit_to_address1
				, hfac.address2 as remit_to_address2
				, '' as remit_to_address3
				, hfac.city as remit_to_city
				, faccnty.name as remit_to_county
				, hfac.prov as remit_to_prov_state
				, fl.country
				, hfac.pc as remit_to_postal_zip_code
				, hfac.tel as remit_to_phone
				, title.item_description as contact_title
				, conta.first_name as contact_first_name
				, conta.last_name as contact_last_name
				, cadd.address1 as contact_address1
				, cadd.address2 as contact_address2
				, cadd.address3 as contact_address3
				, cadd.city as contact_city
				, cnty.name as contact_county
				, cadd.prov_state as contact_prov_state
				, cadd.postal_zip_code as contact_postal_zip_code
				, country.item_description as contact_country
				, null as contact_email
				, conr.contact_id as account_number
				, convert(varchar(10),isnull(inv.generated_date,'1/1/1900'), 101) as generated_date
				, convert(varchar(10),inv.effective_date, 101) as bill_date
				, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
				, inv.payment_due_date
				, Null as pre_consolidated_payment_due_date
				, inv.statement_through_date	
				, Null as amount_due
				, Null as eft_message
				, Case when @vIncludeResidentMessage = 1 then clcon.invoice_message else Null end as client_message
				, Null as group_message
				, Null as global_message
				, Null as previous_balance_due
				, Null as payments
				, fl.fac_id as summary_fac_id
				, hfac.name as summary_charge_center
				, hfac.facility_code as summary_charge_center_code
				, mpi.first_name as summary_charge_client_first_name
				, mpi.last_name as summary_charge_client_last_name
				, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
				, cl.client_id_number as summary_charge_client_number
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as summary_charge_client_location
				, mpi.date_of_birth as summary_charge_client_dob
				, cl.admission_date as summary_charge_client_admission
				, cl.discharge_date as summary_charge_client_discharge
				, 0.0 as summary_current_balance
				, 0.0 as summary_previous_balance_due
				, 0.0 as summary_payments
				, 0.0 as summary_late_fees
				, 0.0 as summary_client_balance_due	
				, '' as private_bills_to				
				, null as amount_past_due_yn	
				, null as term_used_for_client	
				, null as client_admit_date					
				, null as client_discharge_date				
				, null as client_mrn						
				, null as client_first_name					
				, null as client_last_name					
				, unit.unit_desc as client_unit
				, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
						when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
				, rm.room_desc as client_room
				, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
						when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
				, bd.bed_desc as client_bed
				, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
						when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
				, null as patient_specific_message
				, 0 as  contact_num
				, 0 as non_consolidated_contact_num			
				, '' as client_list
				, Case when relatcc.item_id is not null then 1 else 0 end as main_location
				, 0 as consolidated_location_order
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as sort_location
			from #receiver_ids_table confilter 
				inner join dbo.contact_relationship conr with (nolock) on confilter.contact_id = conr.contact_id and conr.deleted='N' 
				inner join dbo.mpi with (nolock) on conr.reference_id = mpi.mpi_id
					--and conr.reference_id = cta.reference_id and conr.subclass_id = cta.subclass_id 
				inner join dbo.clients cl with (nolock) on mpi.mpi_id = cl.mpi_id
				inner join #facility_list fl on cl.fac_id = fl.fac_id
				--inner join dbo.ar_invoice inv with (nolock) on cl.client_id = inv.client_id and  inv.deleted = 'N'
				inner join #invoices inv with (nolock) on cl.client_id = inv.client_id
				--inner join dbo.ar_payers payr with (nolock) on fl.fac_id = payr.fac_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id = 0 and inv.effective_date = payer.statement_date --and inv.trial_flag = payer.trial_flag and inv.client_id = payer.client_id
				--inner join dbo.ar_payers payr with (nolock) on payer.payer_id = payr.payer_id and payr.fac_id = fl.fac_id
				inner join dbo.ar_configuration config with (nolock) on fl.fac_id  = config.fac_id
				inner join dbo.contact_type_audit cta with (nolock) on  conr.contact_id = cta.contact_id and conr.reference_id = cta.reference_id 
					and config.contact_type_id = cta.[type_id] and cta.fac_id = inv.fac_id and conr.subclass_id = cta.subclass_id --and cta.subclass_id = @vSubClassResidentID --9176
					and cta.effective_date  <= inv.created_date AND (cta.ineffective_date  >= inv.created_date or cta.ineffective_date is null)
				inner join #subclass subc on cta.subclass_id = subc.subclass_id
				--inner join dbo.ar_invoice_statement invstat with (nolock) on inv.invoice_id = invstat.invoice_id and 
				--	convert(varchar(10),payer.generated_date, 101) = convert(varchar(10),invstat.generated_date, 101) 
				inner join dbo.ar_lib_payers libpayer with (nolock) on payer.payer_id = libpayer.payer_id 
				left join #relationship relatcc on conr.relationship_id = relatcc.item_id
				inner join dbo.contact_audit conta with (nolock) on cta.contact_id = conta.contact_id and conta.deleted='N'			
					and conta.effective_date  <= inv.created_date AND (conta.ineffective_date  >= inv.created_date or conta.ineffective_date is null)
				left join dbo.contact_address_audit conadd with (nolock) on cta.contact_id = conadd.contact_id 			
					and conadd.effective_date  <= inv.created_date AND (conadd.ineffective_date  >= inv.created_date or conadd.ineffective_date is null)
				left join dbo.address_audit cadd with (nolock) on conadd.address_id = cadd.address_id			
					and cadd.effective_date  <= inv.created_date AND (cadd.ineffective_date  >= inv.created_date or cadd.ineffective_date is null)	
				left join dbo.county cnty with (nolock) on cadd.county_id = cnty.county_id
				left join common_code country with (nolock) on cadd.country_id = country.item_id
				left join common_code_audit title with (nolock)	on isnull(title.deleted, 'N') = 'N' and conta.title_id = title.item_id 
					and title.effective_date  <= inv.created_date AND (title.ineffective_date  >= inv.created_date or title.ineffective_date is null)
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
				left join dbo.ar_client_configuration clcon with (nolock) on cl.client_id = clcon.client_id and clcon.deleted='N'
				left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
				left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
				left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
				left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
				inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
					and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)	
				left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id
				left join #invoice_ids_table prntinv on cl.client_id = prntinv.client_id
			where (@vIsTrial = 1 or inv.trial_flag = 'N')
				and conr.consolidate_statements = confilter.consolidate_statement and 
				((confilter.consolidate_statement = 0 and prntinv.client_id is not null) or (confilter.consolidate_statement = 1))						

			update con set con.private_bills_to	= payr.private_bills_to
			from #contact_clients con
			inner join dbo.ar_invoice inv with (nolock) on con.invoice_id = inv.invoice_id
			inner join dbo.ar_payers payr with (nolock) on inv.fac_id = payr.fac_id and inv.payer_id = payr.payer_id				

			insert into #contact_clients --residents without contacts
			select distinct
					cl.fac_id
				, 0 as contact_id
				, 0 as consolidate_statement
				, cl.client_id 
				, inv.invoice_id
				, inv.statement_invoice_number
				, 0 as payer_id	
				, libpayer.description as payer 
				, inv.effective_date
				, inv.eff_date_from
				, inv.eff_date_to
				, hfac.name as remit_to_name
				, hfac.address1 as remit_to_address1
				, hfac.address2 as remit_to_address2
				, '' as remit_to_address3
				, hfac.city as remit_to_city
				, faccnty.name as remit_to_county
				, hfac.prov as remit_to_prov_state
				, fl.country
				, hfac.pc as remit_to_postal_zip_code
				, hfac.tel as remit_to_phone
				, Null as contact_title
				, mpi.first_name as contact_first_name
				, mpi.last_name as contact_last_name
				, Null as contact_address1
				, Null as contact_address2
				, Null as contact_address3
				, Null as contact_city
				, Null as contact_county
				, Null as contact_prov_state
				, Null as contact_postal_zip_code
				, Null contact_country
				, Null as contact_email
				, 0 as account_number
				, convert(varchar(10),isnull(inv.generated_date,'1/1/1900'), 101) as generated_date
				, convert(varchar(10),inv.effective_date, 101) as bill_date
				, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
				, inv.payment_due_date
				, Null as pre_consolidated_payment_due_date
				, inv.statement_through_date	
				, Null as amount_due
				, Null as eft_message
				, Case when @vIncludeResidentMessage = 1 then clcon.invoice_message else Null end as client_message
				, Null as group_message
				, Null as global_message
				, Null as previous_balance_due
				, Null as payments
				, cl.fac_id as summary_fac_id
				, hfac.name as summary_charge_center
				, hfac.facility_code as summary_charge_center_code
				, mpi.first_name as summary_charge_client_first_name
				, mpi.last_name as summary_charge_client_last_name
				, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
				, cl.client_id_number as summary_charge_client_number
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as summary_charge_client_location
				, mpi.date_of_birth as summary_charge_client_dob
				, cl.admission_date as summary_charge_client_admission
				, cl.discharge_date as summary_charge_client_discharge
				, 0.0 as summary_current_balance
				, 0.0 as summary_previous_balance_due
				, 0.0 as summary_payments
				, 0.0 as summary_late_fees
				, 0.0 as summary_client_balance_due
				, payr.private_bills_to as private_bills_to			
				, null as amount_past_due_yn	
				, null as term_used_for_client				
				, null as client_admit_date					
				, null as client_discharge_date				
				, null as client_mrn						
				, null as client_first_name					
				, null as client_last_name					
				, unit.unit_desc as client_unit
				, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
						when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
				, rm.room_desc as client_room
				, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
						when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
				, bd.bed_desc as client_bed
				, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
						when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
				, null as patient_specific_message	
				, 0 as  contact_num
				, Dense_rank() over (ORDER BY mpi.last_name, mpi.first_name, cl.client_id, inv.effective_date) non_consolidated_contact_num
				--, 1 as non_consolidated_contact_num			
				, '' as client_list
				, 1 as main_location
				, 0 as consolidated_location_order
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as sort_location
			from #invoice_ids_table prntinv
				inner join dbo.clients cl with (nolock) on prntinv.client_id = cl.client_id
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
				--inner join dbo.ar_invoice inv with (nolock) on prntinv.client_id = inv.client_id and inv.deleted = 'N' --and prntinv.trial_flag = inv.trial_flag
				--and inv.effective_date = prntinv.statement_date
				inner join #invoices inv with (nolock) on prntinv.client_id = inv.client_id --and inv.deleted = 'N' --and prntinv.trial_flag = inv.trial_flag
					and inv.effective_date = prntinv.statement_date
				inner join #facility_list fl on cl.fac_id = fl.fac_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id = 0 and inv.client_id = payer.client_id										
				--inner join dbo.ar_invoice_statement invstat with (nolock) on inv.invoice_id = invstat.invoice_id and 
				--	convert(varchar(10),prntinv.generated_date, 101) = convert(varchar(10),invstat.generated_date, 101)
				inner join dbo.ar_lib_payers libpayer with (nolock) on inv.payer_id = libpayer.payer_id 
				inner join dbo.ar_payers payr with (nolock) on libpayer.payer_id = payr.payer_id and payr.fac_id = cl.fac_id
				inner join dbo.ar_payers_audit payraud with (nolock) on libpayer.payer_id = payraud.payer_id and payraud.fac_id = cl.fac_id
					and payraud.effective_date  <= inv.created_date AND (payraud.ineffective_date  >= inv.created_date or payraud.ineffective_date is null)
				inner join dbo.ar_configuration config with (nolock) on cl.fac_id  = config.fac_id
				left join #contact_clients concl on inv.invoice_id = concl.invoice_id
				--left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = cl.fac_id and grp.deleted='N'
				--left join #billing_group_table bg on grp.group_id = bg.group_id
				left join dbo.ar_client_configuration clcon with (nolock) on cl.client_id = clcon.client_id and clcon.deleted='N'
				left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
				left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
				left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
				left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
				inner join dbo.facility_audit hfac with (nolock) on cl.fac_id = hfac.fac_id
					and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)
				left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id
			where concl.invoice_id is null and (@vIsTrial = 1 or inv.trial_flag = 'N')	

			insert into #contact_clients --we need to check for other multiple contacts that may not have all appropriate invoices assigned
			select distinct
					mycon.fac_id
				, mycon.contact_id
				, mycon.consolidate_statement
				, myadd.client_id 
				, myadd.invoice_id
				, myadd.statement_invoice_number
				, 0 as payer_id	
				, myadd.payer 
				, myadd.inv_effective_date
				, myadd.inv_eff_date_from
				, myadd.inv_eff_date_to
				, mycon.remit_to_name
				, mycon.remit_to_address1
				, mycon.remit_to_address2
				, mycon.remit_to_address3
				, mycon.remit_to_city
				, mycon.remit_to_county
				, mycon.remit_to_prov_state
				, mycon.remit_to_country
				, mycon.remit_to_postal_zip_code
				, mycon.remit_to_phone
				, mycon.contact_title
				, mycon.contact_first_name
				, mycon.contact_last_name
				, mycon.contact_address1
				, mycon.contact_address2
				, mycon.contact_address3
				, mycon.contact_city
				, mycon.contact_county
				, mycon.contact_prov_state
				, mycon.contact_postal_zip_code
				, mycon.contact_country
				, mycon.contact_email
				, mycon.account_number
				, myadd.generated_date
				, myadd.bill_date
				, myadd.aging_date
				, myadd.payment_due_date
				, myadd.pre_consolidated_payment_due_date
				, myadd.statement_through_date	
				, myadd.amount_due
				, myadd.eft_message
				, myadd.client_message
				, myadd.group_message
				, myadd.global_message
				, myadd.previous_balance_due
				, myadd.payments
				, myadd.summary_fac_id
				, myadd.summary_charge_center
				, myadd.summary_charge_center_code
				, myadd.summary_charge_client_first_name
				, myadd.summary_charge_client_last_name
				, myadd.summary_charge_client_name
				, myadd.summary_charge_client_number
				, myadd.summary_charge_client_location
				, myadd.summary_charge_client_dob
				, myadd.summary_charge_client_admission
				, myadd.summary_charge_client_discharge
				, 0.0 as summary_current_balance
				, 0.0 as summary_previous_balance_due
				, 0.0 as summary_payments
				, 0.0 as summary_late_fees
				, 0.0 as summary_client_balance_due
				, myadd.private_bills_to				
				, null as amount_past_due_yn	
				, null as term_used_for_client				
				, null as client_admit_date					
				, null as client_discharge_date				
				, null as client_mrn						
				, null as client_first_name					
				, null as client_last_name					
				, myadd.client_unit	
				, myadd.unit_order					
				, myadd.client_room	
				, myadd.room_order					
				, myadd.client_bed
				, myadd.bed_order
				, null as patient_specific_message	
				, mycon.contact_num
				, mycon.non_consolidated_contact_num		
				, '' as client_list
				, myadd.main_location
				, myadd.consolidated_location_order	
				, myadd.sort_location
			from #contact_clients mycon
				inner join (SELECT b.contact_id,a.client_id, a.invoice_id, a.bill_date
					FROM(
						SELECT DISTINCT client_id , invoice_id, bill_date FROM #contact_clients where contact_id > 0) A
						INNER JOIN (
						SELECT DISTINCT contact_id, client_id FROM #contact_clients where contact_id > 0) B
						ON a.client_id = b.client_id 
						EXCEPT
						SELECT contact_id,client_id, invoice_id, bill_date FROM #contact_clients where contact_id > 0
						) toget
						on mycon.contact_id = toget.contact_id and mycon.client_id = toget.client_id and mycon.bill_date = toget.bill_date
				inner join #contact_clients myadd on toget.invoice_id = myadd.invoice_id

		end

		set @vgsStepEndTime=GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

		------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		-- other payer loading here
		if @vOtherStatementsIncluded = 1

		begin

		-----getting the list of contacts
		select @vStep = 80
		set @vgsStepStartTime = GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' gathering other payer invoices ' + convert(varchar(26),getdate(),109)

		insert into #contact_clients
			select distinct
					fl.fac_id
				, Case when payraud.private_bills_to = 'G'  then  -1 * isnull(CAST(conta.contact_id AS NUMERIC(18,1)),3.1) else -2.1 end  as contact_id  --AMRO
				, 0 as consolidate_statement
				, cl.client_id 
				, inv.invoice_id 
				, inv.statement_invoice_number
				, libpayer.payer_id	
				, libpayer.description as payer 
				, inv.effective_date
				, inv.eff_date_from
				, inv.eff_date_to
				, case when fgi.fac_id is null then hfac.name else fgi.remit_to_name end as remit_to_name
				, case when fgi.fac_id is null then hfac.address1 else fgi.remit_to_address1 end as remit_to_address1
				, case when fgi.fac_id is null then hfac.address2 else fgi.remit_to_address2 end as remit_to_address2
				, case when fgi.fac_id is null then '' else fgi.remit_to_address3 end as remit_to_address3
				, case when fgi.fac_id is null then hfac.city else fgi.remit_to_city end as remit_to_city
				, case when fgi.fac_id is null then faccnty.name else fgi.remit_to_county end as remit_to_county
				, case when fgi.fac_id is null then hfac.prov else fgi.remit_to_prov_state end as remit_to_prov_state
				, case when fgi.fac_id is null then fl.country else fgi.remit_to_country end as remit_to_country
				, case when fgi.fac_id is null then hfac.pc else fgi.remit_to_postal_zip_code end as remit_to_postal_zip_code
				, case when fgi.fac_id is null then hfac.tel else fgi.remit_to_phone end as remit_to_phone
				, Case when payraud.private_bills_to = 'G' then title.item_description else '' end as contact_title
				, Case when payraud.private_bills_to = 'G' and isnull(conta.first_name,'') <> '' then conta.first_name
					when payraud.private_bills_to = 'G' and isnull(conta.first_name,'') = '' then 'No Data Found'
					when payraud.private_bills_to <> 'G' and isnull(insco.description,'') = '' then 'No Data Found' else insco.description end as contact_first_name 
				, Case when payraud.private_bills_to = 'G' then conta.last_name else '' end as contact_last_name
				, Case when payraud.private_bills_to = 'G' and isnull(cadd.address1,'') = '' and  isnull(cadd.address2,'') = '' then 'No Address Found' 
					when payraud.private_bills_to = 'G' and isnull(cadd.address1,'') <> '' then cadd.address1		
					when payraud.private_bills_to <> 'G' and isnull(inscoadd.address1,'') = '' and isnull(inscoadd.address2,'') = '' then 'No Address Found' 
					else inscoadd.address1 end as contact_address1
				, Case when payraud.private_bills_to = 'G' then cadd.address2 else inscoadd.address2 end as contact_address2
				, Case when payraud.private_bills_to = 'G' then cadd.address3 else inscoadd.address3 end as contact_address3
				, Case when payraud.private_bills_to = 'G' then cadd.city else inscoadd.city end as contact_city
				, Case when payraud.private_bills_to = 'G' then ccnty.name else cnty.name end as contact_county
				, Case when payraud.private_bills_to = 'G' then cadd.prov_state else inscoadd.prov_state end as contact_prov_state
				, Case when payraud.private_bills_to = 'G' then cadd.postal_zip_code else inscoadd.postal_zip_code end as contact_postal_zip_code
				, Case when payraud.private_bills_to = 'G' then ccountry.item_description else country.item_description end as contact_country
				, null as contact_email
				, Case when payraud.private_bills_to = 'G' then conr.contact_id else '' end as account_number
				, '1/1/1900' as generated_date
				, convert(varchar(10),inv.effective_date, 101) as bill_date
				, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
				, inv.payment_due_date
				, Null as pre_consolidated_payment_due_date
				, inv.statement_through_date	
				, Null as amount_due
				, Null as eft_message
				, '' as client_message
				, Null as group_message
				, Null as global_message
				, Null as previous_balance_due
				, Null as payments
				, fl.fac_id as summary_fac_id
				, hfac.name as summary_charge_center
				, hfac.facility_code as summary_charge_center_code
				, mpi.first_name as summary_charge_client_first_name
				, mpi.last_name as summary_charge_client_last_name
				, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
				, cl.client_id_number as summary_charge_client_number
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as summary_charge_client_location
				, mpi.date_of_birth as summary_charge_client_dob
				, cl.admission_date as summary_charge_client_admission
				, cl.discharge_date as summary_charge_client_discharge
				, 0.0 as summary_current_balance
				, 0.0 as summary_previous_balance_due
				, 0.0 as summary_payments
				, 0.0 as summary_late_fees
				, 0.0 as summary_client_balance_due	
				, payr.private_bills_to as private_bills_to				
				, null as amount_past_due_yn	
				, null as term_used_for_client	
				, null as client_admit_date					
				, null as client_discharge_date				
				, null as client_mrn						
				, null as client_first_name					
				, null as client_last_name					
				, unit.unit_desc as client_unit
				, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
						when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
				, rm.room_desc as client_room
				, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
						when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
				, bd.bed_desc as client_bed
				, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
						when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
				, null as patient_specific_message
				, 0 as  contact_num
				, 0 as non_consolidated_contact_num			
				, '' as client_list
				, 1 as main_location
				, 0 as consolidated_location_order
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as sort_location
			--select flinv.*
			from #invoice_ids_table flinv
				inner join #invoices inv with (nolock) on flinv.invoice_id = inv.invoice_id
				inner join #facility_list fl on inv.fac_id = fl.fac_id
				inner join dbo.clients cl with (nolock) on inv.client_id = cl.client_id
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id > 0
				inner join dbo.ar_lib_payers libpayer with (nolock) on inv.payer_id = libpayer.payer_id 
				inner join dbo.ar_payers payr with (nolock) on libpayer.payer_id = payr.payer_id and payr.fac_id = fl.fac_id
				inner join dbo.ar_payers_audit payraud with (nolock) on libpayer.payer_id = payraud.payer_id and payraud.fac_id = fl.fac_id
				and payraud.effective_date  <= inv.created_date AND (payraud.ineffective_date  >= inv.created_date or payraud.ineffective_date is null)
				inner join dbo.ar_configuration config with (nolock) on fl.fac_id  = config.fac_id
				left join dbo.ar_client_payer_info policy with (nolock) on cl.client_id = policy.client_id and inv.payer_id = policy.payer_id
				left join dbo.client_ids clid with (nolock) on inv.client_id = clid.client_id and policy.policy_no_id = clid.id_type_id
				left join dbo.ar_payer_addresses_audit payradd with (nolock) on payraud.fac_id = payradd.fac_id and payraud.payer_id = payradd.payer_id and payraud.default_address_id = payradd.address_id and
					payradd.effective_date  <= inv.created_date AND (payradd.ineffective_date  >= inv.created_date or payradd.ineffective_date is null)
				left join dbo.ar_lib_insurance_companies_audit insco with (nolock) on payradd.insurance_id = insco.insurance_id and
					insco.effective_date  <= inv.created_date AND (insco.ineffective_date  >= inv.created_date or insco.ineffective_date is null)
				left join dbo.ar_insurance_addresses_audit inscoadd with (nolock) on payradd.address_id = inscoadd.address_id and
					inscoadd.effective_date  <= inv.created_date AND (inscoadd.ineffective_date  >= inv.created_date or inscoadd.ineffective_date is null)
				left join dbo.ar_provider_numbers provnum with (nolock) on inscoadd.address_id = provnum.address_id and fl.fac_id = provnum.fac_id
				left join dbo.county cnty with (nolock) on inscoadd.county_id = cnty.county_id
				left join common_code country with (nolock) on inscoadd.country_id = country.item_id
				left join #client_ids_table clfilter on inv.client_id = clfilter.client_id
				left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
				left join #billing_group_table bg on grp.group_id = bg.group_id
				left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
				left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
				left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
				left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
				inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
					and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)	
				left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id
						left join dbo.contact_type_audit cta with (nolock) on mpi.mpi_id = cta.reference_id  --and (cta.contact_id = @vReceiverIds or @vReceiverIds = -1) 
					and config.contact_type_id = cta.[type_id] and cta.fac_id = inv.fac_id
					and cta.effective_date  <= inv.created_date AND (cta.ineffective_date  >= inv.created_date or cta.ineffective_date is null)
				left join dbo.contact_relationship conr with (nolock) on conr.contact_id = cta.contact_id and conr.deleted='N' 
					and conr.reference_id = cta.reference_id and conr.subclass_id = cta.subclass_id --and cta.subclass_id = @vSubClassResidentID 
				left join #subclass subc on cta.subclass_id = subc.subclass_id
				left join #relationship relatcc on conr.relationship_id = relatcc.item_id
				left join dbo.contact_audit conta with (nolock) on cta.contact_id = conta.contact_id and conta.deleted='N'			
					and conta.effective_date  <= inv.created_date AND (conta.ineffective_date  >= inv.created_date or conta.ineffective_date is null)
				left join dbo.contact_address_audit conadd with (nolock) on cta.contact_id = conadd.contact_id 			
					and conadd.effective_date  <= inv.created_date AND (conadd.ineffective_date  >= inv.created_date or conadd.ineffective_date is null)
				left join dbo.address_audit cadd with (nolock) on conadd.address_id = cadd.address_id			
					and cadd.effective_date  <= inv.created_date AND (cadd.ineffective_date  >= inv.created_date or cadd.ineffective_date is null)	
				left join dbo.county ccnty with (nolock) on cadd.county_id = cnty.county_id
				left join common_code ccountry with (nolock) on cadd.country_id = ccountry.item_id
				left join common_code_audit title with (nolock)	on isnull(title.deleted, 'N') = 'N' and conta.title_id = title.item_id 
					and title.effective_date  <= inv.created_date AND (title.ineffective_date  >= inv.created_date or title.ineffective_date is null)		
			where payraud.private_bills_to <> 'I'

		set @vRowCount = @@rowcount

		insert into #contact_clients
			select distinct
					fl.fac_id
				, -2.1  as contact_id
				, 0 as consolidate_statement
				, cl.client_id 
				, inv.invoice_id 
				, inv.statement_invoice_number
				, libpayer.payer_id	
				, libpayer.description as payer 
				, inv.effective_date
				, inv.eff_date_from
				, inv.eff_date_to
				, case when fgi.fac_id is null then hfac.name else fgi.remit_to_name end as remit_to_name
				, case when fgi.fac_id is null then hfac.address1 else fgi.remit_to_address1 end as remit_to_address1
				, case when fgi.fac_id is null then hfac.address2 else fgi.remit_to_address2 end as remit_to_address2
				, case when fgi.fac_id is null then '' else fgi.remit_to_address3 end as remit_to_address3
				, case when fgi.fac_id is null then hfac.city else fgi.remit_to_city end as remit_to_city
				, case when fgi.fac_id is null then faccnty.name else fgi.remit_to_county end as remit_to_county
				, case when fgi.fac_id is null then hfac.prov else fgi.remit_to_prov_state end as remit_to_prov_state
				, case when fgi.fac_id is null then fl.country else fgi.remit_to_country end as remit_to_country
				, case when fgi.fac_id is null then hfac.pc else fgi.remit_to_postal_zip_code end as remit_to_postal_zip_code
				, case when fgi.fac_id is null then hfac.tel else fgi.remit_to_phone end as remit_to_phone
				, '' as contact_title
				, Case when isnull(insco.description,'') = '' then libpayer.description else insco.description end as contact_first_name 
				, '' as contact_last_name
				, Case when isnull(inscoadd.address1,'') = '' and isnull(inscoadd.address2,'') = '' then 'No Address Found' 
					else inscoadd.address1 end as contact_address1
				, inscoadd.address2 as contact_address2
				, inscoadd.address3 as contact_address3
				, inscoadd.city as contact_city
				, cnty.name as contact_county
				, inscoadd.prov_state as contact_prov_state
				, inscoadd.postal_zip_code as contact_postal_zip_code
				, country.item_description as contact_country
				, null as contact_email
				, '' as account_number
				, '1/1/1900' as generated_date
				, convert(varchar(10),inv.effective_date, 101) as bill_date
				, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
				, inv.payment_due_date
				, Null as pre_consolidated_payment_due_date
				, inv.statement_through_date	
				, null as amount_due
				, Null as eft_message
				, '' as client_message
				, Null as group_message
				, null as global_message
				, null as previous_balance_due
				, null as payments
				, fl.fac_id as summary_fac_id
				, hfac.name as summary_charge_center
				, hfac.facility_code as summary_charge_center_code
				, mpi.first_name as summary_charge_client_first_name
				, mpi.last_name as summary_charge_client_last_name
				, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
				, cl.client_id_number as summary_charge_client_number
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as summary_charge_client_location
				, mpi.date_of_birth as summary_charge_client_dob
				, cl.admission_date as summary_charge_client_admission
				, cl.discharge_date as summary_charge_client_discharge
				, 0.0 as summary_current_balance
				, 0.0 as summary_previous_balance_due
				, 0.0 as summary_payments
				, 0.0 as summary_late_fees
				, 0.0 as summary_client_balance_due	
				, payr.private_bills_to as private_bills_to				
				, null as amount_past_due_yn	
				, null as term_used_for_client	
				, null as client_admit_date					
				, null as client_discharge_date				
				, null as client_mrn						
				, null as client_first_name					
				, null as client_last_name					
				, unit.unit_desc as client_unit
				, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
						when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
				, rm.room_desc as client_room
				, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
						when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
				, bd.bed_desc as client_bed
				, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
						when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
				, null as patient_specific_message
				, 0 as  contact_num
				, 0 as non_consolidated_contact_num			
				, '' as client_list
				, 1 as main_location
				, 0 as consolidated_location_order
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as sort_location
			from #invoice_ids_table flinv
				inner join #invoices inv with (nolock) on flinv.invoice_id = inv.invoice_id
				inner join #facility_list fl on inv.fac_id = fl.fac_id
				inner join dbo.clients cl with (nolock) on inv.client_id = cl.client_id
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id > 0
				inner join dbo.ar_lib_payers libpayer with (nolock) on inv.payer_id = libpayer.payer_id 
				inner join dbo.ar_payers payr with (nolock) on libpayer.payer_id = payr.payer_id and payr.fac_id = fl.fac_id
				inner join dbo.ar_payers_audit payraud with (nolock) on libpayer.payer_id = payraud.payer_id and payraud.fac_id = fl.fac_id
				and payraud.effective_date  <= inv.created_date AND (payraud.ineffective_date  >= inv.created_date or payraud.ineffective_date is null)
				left join dbo.ar_client_payer_info cpiaud with (nolock) on cl.client_id = cpiaud.client_id and payraud.payer_id = cpiaud.payer_id and payraud.fac_id = cpiaud.fac_id and cpiaud.deleted = 'N'
					and cpiaud.effective_date  <= inv.effective_date AND (cpiaud.ineffective_date  >= inv.effective_date or cpiaud.ineffective_date is null) 
				left join dbo.ar_insurance_addresses_audit inscoadd with (nolock) on cpiaud.payer_address_id = inscoadd.address_id and
					inscoadd.effective_date  <= inv.created_date AND (inscoadd.ineffective_date  >= inv.created_date or inscoadd.ineffective_date is null)
				left join dbo.ar_lib_insurance_companies_audit insco with (nolock) on inscoadd.insurance_id = insco.insurance_id and
					insco.effective_date  <= inv.created_date AND (insco.ineffective_date  >= inv.created_date or insco.ineffective_date is null)
				left join dbo.ar_provider_numbers provnum with (nolock) on inscoadd.address_id = provnum.address_id and fl.fac_id = provnum.fac_id
				left join dbo.county cnty with (nolock) on inscoadd.county_id = cnty.county_id
				left join common_code country with (nolock) on inscoadd.country_id = country.item_id
				left join #client_ids_table clfilter on inv.client_id = clfilter.client_id
				left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
				left join #billing_group_table bg on grp.group_id = bg.group_id
				left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
				left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
				left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
				left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
				inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
					and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)	
				left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id							
			where payraud.private_bills_to = 'I'		

		set @vRowCount = isnull(@vRowCount,0) + @@rowcount

		if @vRowCount = 0
			set @vOtherStatementsIncluded = 0

		set @vgsStepEndTime=GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

		end

	end

else
	begin
		-----getting the list of contacts
		select @vStep = 70
		set @vgsStepStartTime = GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' gathering contacts clients and their invoices ' + convert(varchar(26),getdate(),109)
		--*********************************************************************************************************
		If @vPrivateStatementsIncluded = 1 -- process private statements as they are included
		begin	
			if @vIsContact = 0 and @vReceiverIds <> '-1' --get contacts for selected residents.  All clients will be treated as all contacts
				begin
					insert into #receiver_ids_table
					select distinct
						  conr.contact_id
						, conr.consolidate_statements
					from #client_ids_table clfilter
						inner join dbo.clients cl with (nolock) on clfilter.client_id = cl.client_id 
						inner join  #facility_list fl on cl.fac_id = fl.fac_id 
						inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
						inner join #invoices inv with (nolock) on cl.client_id = inv.client_id
						inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id = 0
						inner join dbo.ar_configuration config with (nolock) on fl.fac_id  = config.fac_id
						inner join dbo.contact_type_audit cta with (nolock) on mpi.mpi_id = cta.reference_id
							and config.contact_type_id = cta.[type_id] and cta.fac_id = inv.fac_id
							and cta.effective_date  <= inv.created_date AND (cta.ineffective_date  >= inv.created_date or cta.ineffective_date is null)
						inner join dbo.contact_relationship conr with (nolock) on conr.contact_id = cta.contact_id and conr.deleted='N' 
							and conr.reference_id = cta.reference_id and conr.subclass_id = cta.subclass_id
						inner join #subclass subc on cta.subclass_id = subc.subclass_id
						inner join dbo.contact_audit conta with (nolock) on cta.contact_id = conta.contact_id and conta.deleted='N'			
							and conta.effective_date  <= inv.created_date AND (conta.ineffective_date  >= inv.created_date or conta.ineffective_date is null)
						left join dbo.contact_address_audit conadd with (nolock) on cta.contact_id = conadd.contact_id 			
							and conadd.effective_date  <= inv.created_date AND (conadd.ineffective_date  >= inv.created_date or conadd.ineffective_date is null)
						left join dbo.address_audit cadd with (nolock) on conadd.address_id = cadd.address_id			
							and cadd.effective_date  <= inv.created_date AND (cadd.ineffective_date  >= inv.created_date or cadd.ineffective_date is null)	
						left join dbo.county cnty with (nolock) on cadd.county_id = cnty.county_id
						left join common_code country with (nolock) on cadd.country_id = country.item_id
						left join common_code_audit title with (nolock)	on isnull(title.deleted, 'N') = 'N' and conta.title_id = title.item_id 
							and title.effective_date  <= inv.created_date AND (title.ineffective_date  >= inv.created_date or title.ineffective_date is null)
						left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
						left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
						left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
						left join #billing_group_table bg on grp.group_id = bg.group_id
						left join dbo.ar_client_configuration clcon with (nolock) on cl.client_id = clcon.client_id and clcon.deleted='N'
						inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
							and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)	
						left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id					
					where (@vClientStatus = -1 or (@vClientStatus = 0 and (cl.discharge_date is null or cl.discharge_date > @vReportDate)) or (@vClientStatus = 1 and cl.discharge_date <= @vReportDate)) 
					and (@vBillingGroup = '-1' --or (@vBillingGroup <> '-1' and isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null )
					or (@vBillingGroup <> '-1' and ((clgrp.group_id is not null and bg.group_id is not null and @vBillingGroup <> '0') or (isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null) ))
					or @vBillingGroup is null)

				end

			--resident statemments
			insert into #contact_clients
			select distinct
					fl.fac_id
				, conr.contact_id
				, conr.consolidate_statements as consolidate_statement
				, cl.client_id 
				, inv.invoice_id 
				, inv.statement_invoice_number
				, 0 as payer_id	
				, libpayer.description as payer 
				, inv.effective_date
				, inv.eff_date_from
				, inv.eff_date_to
				, case when fgi.fac_id is null then hfac.name else fgi.remit_to_name end as remit_to_name
				, case when fgi.fac_id is null then hfac.address1 else fgi.remit_to_address1 end as remit_to_address1
				, case when fgi.fac_id is null then hfac.address2 else fgi.remit_to_address2 end as remit_to_address2
				, case when fgi.fac_id is null then '' else fgi.remit_to_address3 end as remit_to_address3
				, case when fgi.fac_id is null then hfac.city else fgi.remit_to_city end as remit_to_city
				, case when fgi.fac_id is null then faccnty.name else fgi.remit_to_county end as remit_to_county
				, case when fgi.fac_id is null then hfac.prov else fgi.remit_to_prov_state end as remit_to_prov_state
				, case when fgi.fac_id is null then fl.country else fgi.remit_to_country end as remit_to_country
				, case when fgi.fac_id is null then hfac.pc else fgi.remit_to_postal_zip_code end as remit_to_postal_zip_code
				, case when fgi.fac_id is null then hfac.tel else fgi.remit_to_phone end as remit_to_phone
				, title.item_description as contact_title
				, conta.first_name as contact_first_name
				, conta.last_name as contact_last_name
				, cadd.address1 as contact_address1
				, cadd.address2 as contact_address2
				, cadd.address3 as contact_address3
				, cadd.city as contact_city
				, cnty.name as contact_county
				, cadd.prov_state as contact_prov_state
				, cadd.postal_zip_code as contact_postal_zip_code
				, country.item_description as contact_country
				, null as contact_email
				, conr.contact_id as account_number
				, convert(varchar(10),isnull(inv.generated_date,'1/1/1900'), 101) as generated_date
				, convert(varchar(10),inv.effective_date, 101) as bill_date
				, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
				, inv.payment_due_date
				, Null as pre_consolidated_payment_due_date
				, inv.statement_through_date	
				, Null as amount_due
				, Null as eft_message
				, Case when @vIncludeResidentMessage = 1 then clcon.invoice_message else Null end as client_message
				, Null as group_message
				, Null as global_message
				, Null as previous_balance_due
				, Null as payments
				, fl.fac_id as summary_fac_id
				, hfac.name as summary_charge_center
				, hfac.facility_code as summary_charge_center_code
				, mpi.first_name as summary_charge_client_first_name
				, mpi.last_name as summary_charge_client_last_name
				, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
				, cl.client_id_number as summary_charge_client_number
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as summary_charge_client_location
				, mpi.date_of_birth as summary_charge_client_dob
				, cl.admission_date as summary_charge_client_admission
				, cl.discharge_date as summary_charge_client_discharge
				, 0.0 as summary_current_balance
				, 0.0 as summary_previous_balance_due
				, 0.0 as summary_payments
				, 0.0 as summary_late_fees
				, 0.0 as summary_client_balance_due	
				, payr.private_bills_to as private_bills_to					
				, null as amount_past_due_yn	
				, null as term_used_for_client	
				, null as client_admit_date					
				, null as client_discharge_date				
				, null as client_mrn						
				, null as client_first_name					
				, null as client_last_name					
				, unit.unit_desc as client_unit
				, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
						when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
				, rm.room_desc as client_room
				, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
						when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
				, bd.bed_desc as client_bed
				, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
						when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
				, null as patient_specific_message
				, 0 as  contact_num
				, 0 as non_consolidated_contact_num			
				, '' as client_list
				, Case when relatcc.item_id is not null then 1 else 0 end as main_location
				, 0 as consolidated_location_order
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as sort_location
			from #facility_list fl
				inner join dbo.clients cl with (nolock) on fl.fac_id = cl.fac_id
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
				inner join #invoices inv with (nolock) on cl.client_id = inv.client_id and fl.fac_id = inv.fac_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id = 0
				inner join dbo.ar_lib_payers libpayer with (nolock) on inv.payer_id = libpayer.payer_id 
				inner join dbo.ar_payers payr with (nolock) on libpayer.payer_id = payr.payer_id and payr.fac_id = fl.fac_id
				inner join dbo.ar_payers_audit payraud with (nolock) on libpayer.payer_id = payraud.payer_id and payraud.fac_id = fl.fac_id
					and payraud.effective_date  <= inv.created_date AND (payraud.ineffective_date  >= inv.created_date or payraud.ineffective_date is null)
				inner join dbo.ar_configuration config with (nolock) on fl.fac_id  = config.fac_id
				inner join dbo.contact_type_audit cta with (nolock) on mpi.mpi_id = cta.reference_id 
					and config.contact_type_id = cta.[type_id] and cta.fac_id = inv.fac_id
					and cta.effective_date  <= inv.created_date AND (cta.ineffective_date  >= inv.created_date or cta.ineffective_date is null)
				left join #receiver_ids_table confilter on cta.contact_id = confilter.contact_id
				inner join dbo.contact_relationship conr with (nolock) on conr.contact_id = cta.contact_id and conr.deleted='N' 
					and conr.reference_id = cta.reference_id and conr.subclass_id = cta.subclass_id 
				inner join #subclass subc on cta.subclass_id = subc.subclass_id
				left join #relationship relatcc on conr.relationship_id = relatcc.item_id				
				inner join dbo.contact_audit conta with (nolock) on cta.contact_id = conta.contact_id and conta.deleted='N'			
					and conta.effective_date  <= inv.created_date AND (conta.ineffective_date  >= inv.created_date or conta.ineffective_date is null)
				left join dbo.contact_address_audit conadd with (nolock) on cta.contact_id = conadd.contact_id 			
					and conadd.effective_date  <= inv.created_date AND (conadd.ineffective_date  >= inv.created_date or conadd.ineffective_date is null)
				left join dbo.address_audit cadd with (nolock) on conadd.address_id = cadd.address_id			
					and cadd.effective_date  <= inv.created_date AND (cadd.ineffective_date  >= inv.created_date or cadd.ineffective_date is null)	
				left join dbo.county cnty with (nolock) on cadd.county_id = cnty.county_id
				left join common_code country with (nolock) on cadd.country_id = country.item_id
				left join common_code_audit title with (nolock)	on isnull(title.deleted, 'N') = 'N' and conta.title_id = title.item_id 
					and title.effective_date  <= inv.created_date AND (title.ineffective_date  >= inv.created_date or title.ineffective_date is null)
				left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
				left join #billing_group_table bg on grp.group_id = bg.group_id
				left join dbo.ar_client_configuration clcon with (nolock) on cl.client_id = clcon.client_id and clcon.deleted='N'
				left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
				left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
				left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
				left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
				inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
					and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)	
				left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id
				left join #client_ids_table clids on cl.client_id = clids.client_id						
			where 
			(@vClientStatus = -1 or (@vClientStatus = 0 and (cl.discharge_date is null or cl.discharge_date > @vReportDate)) or (@vClientStatus = 1 and cl.discharge_date <= @vReportDate)) 
			and (@vReceiverIds = '-1' or confilter.contact_id is not null)
			and ((@vReceiverIds <> '-1' and @vIsContact = 0 and conr.consolidate_statements = confilter.consolidate_statement and 
				((confilter.consolidate_statement = 0 and clids.client_id is not null) or (confilter.consolidate_statement = 1))) or @vReceiverIds = '-1' or @vIsContact = 1)
			and (@vBillingGroup = '-1' --or (@vBillingGroup <> '-1' and isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null )
			or (@vBillingGroup <> '-1' and ((clgrp.group_id is not null and bg.group_id is not null and @vBillingGroup <> '0') or (isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null) ))
			or @vBillingGroup is null)

			if @vReceiverIds = '-1'
				begin
					insert into #contact_clients --residents without contacts
					select distinct
							fl.fac_id
						, 0 as contact_id
						, 0 as consolidate_statement
						, cl.client_id 
						, inv.invoice_id
						, inv.statement_invoice_number
						, 0 as payer_id	
						, libpayer.description as payer 
						, inv.effective_date
						, inv.eff_date_from
						, inv.eff_date_to
						, case when fgi.fac_id is null then hfac.name else fgi.remit_to_name end as remit_to_name
						, case when fgi.fac_id is null then hfac.address1 else fgi.remit_to_address1 end as remit_to_address1
						, case when fgi.fac_id is null then hfac.address2 else fgi.remit_to_address2 end as remit_to_address2
						, case when fgi.fac_id is null then '' else fgi.remit_to_address3 end as remit_to_address3
						, case when fgi.fac_id is null then hfac.city else fgi.remit_to_city end as remit_to_city
						, case when fgi.fac_id is null then faccnty.name else fgi.remit_to_county end as remit_to_county
						, case when fgi.fac_id is null then hfac.prov else fgi.remit_to_prov_state end as remit_to_prov_state
						, case when fgi.fac_id is null then fl.country else fgi.remit_to_country end as remit_to_country
						, case when fgi.fac_id is null then hfac.pc else fgi.remit_to_postal_zip_code end as remit_to_postal_zip_code
						, case when fgi.fac_id is null then hfac.tel else fgi.remit_to_phone end as remit_to_phone
						, Null as contact_title
						, mpi.first_name as contact_first_name
						, mpi.last_name as contact_last_name
						, Null as contact_address1
						, Null as contact_address2
						, Null as contact_address3
						, Null as contact_city
						, Null as contact_county
						, Null as contact_prov_state
						, Null as contact_postal_zip_code
						, Null contact_country
						, Null as contact_email
						, 0 as account_number
						, convert(varchar(10),isnull(inv.generated_date,'1/1/1900'), 101) as generated_date
						, convert(varchar(10),inv.effective_date, 101) as bill_date
						, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
						, inv.payment_due_date
						, Null as pre_consolidated_payment_due_date
						, inv.statement_through_date	
						, Null as amount_due
						, Null as eft_message
						, Case when @vIncludeResidentMessage = 1 then clcon.invoice_message else Null end as client_message
						, null as group_message
						, null as global_message
						, null as previous_balance_due
						, null as payments
						, fl.fac_id as summary_fac_id
						, hfac.name as summary_charge_center
						, hfac.facility_code as summary_charge_center_code
						, mpi.first_name as summary_charge_client_first_name
						, mpi.last_name as summary_charge_client_last_name
						, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
						, cl.client_id_number as summary_charge_client_number
						, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
							when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
							else '' end)) as summary_charge_client_location
						, mpi.date_of_birth as summary_charge_client_dob
						, cl.admission_date as summary_charge_client_admission
						, cl.discharge_date as summary_charge_client_discharge
						, 0.0 as summary_current_balance
						, 0.0 as summary_previous_balance_due
						, 0.0 as summary_payments
						, 0.0 as summary_late_fees
						, 0.0 as summary_client_balance_due
						, payr.private_bills_to as private_bills_to				
						, null as amount_past_due_yn	
						, null as term_used_for_client				
						, null as client_admit_date					
						, null as client_discharge_date				
						, null as client_mrn						
						, null as client_first_name					
						, null as client_last_name					
						, unit.unit_desc as client_unit
						, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
								when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
						, rm.room_desc as client_room
						, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
								when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
						, bd.bed_desc as client_bed
						, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
								when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
						, null as patient_specific_message	
						, 0 as  contact_num
						, Dense_rank() over (ORDER BY mpi.last_name, mpi.first_name, cl.client_id, inv.effective_date) non_consolidated_contact_num
						--, 0 as non_consolidated_contact_num			
						, '' as client_list
						, 1 as main_location
						, 0 as consolidated_location_order
						, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
							when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
							else '' end)) as sort_location
					from #facility_list fl
						inner join #invoices inv with (nolock) on fl.fac_id = inv.fac_id
						inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id = 0											
						inner join dbo.ar_lib_payers libpayer with (nolock) on inv.payer_id = libpayer.payer_id
						inner join dbo.ar_payers payr with (nolock) on libpayer.payer_id = payr.payer_id and payr.fac_id = fl.fac_id 
						inner join dbo.ar_payers_audit payraud with (nolock) on libpayer.payer_id = payraud.payer_id and payraud.fac_id = fl.fac_id
							and payraud.effective_date  <= inv.created_date AND (payraud.ineffective_date  >= inv.created_date or payraud.ineffective_date is null)
						inner join dbo.ar_configuration config with (nolock) on fl.fac_id  = config.fac_id
						inner join dbo.clients cl with (nolock) on inv.client_id = cl.client_id
						inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
						left join #contact_clients concl on inv.invoice_id = concl.invoice_id
						left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
						left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
						left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
						left join #billing_group_table bg on grp.group_id = bg.group_id
						left join dbo.ar_client_configuration clcon with (nolock) on cl.client_id = clcon.client_id and clcon.deleted='N'
						left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
						left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
						left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
						left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
						inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
							and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)
						left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id	
					where --payraud.private_bills_to = 'G' and 
					concl.invoice_id is null and (@vClientStatus = -1 or (@vClientStatus = 0 and (cl.discharge_date is null or cl.discharge_date > @vReportDate)) or (@vClientStatus = 1 and cl.discharge_date <= @vReportDate)) 
					and (@vBillingGroup = '-1' or (@vBillingGroup <> '-1' and isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null )
					or (@vBillingGroup <> '-1' and clgrp.group_id is not null and bg.group_id is not null and isnull(@vBillingGroupIncludesMissing,0) = 0 )
					or @vBillingGroup is null)

				end

			if @vReceiverIds <> '-1'  and  @vIsContact = 0
				begin
					insert into #contact_clients --residents without contacts
					select distinct
							fl.fac_id
						, 0 as contact_id
						, 0 as consolidate_statement
						, cl.client_id 
						, inv.invoice_id
						, inv.statement_invoice_number
						, 0 as payer_id	
						, libpayer.description as payer 
						, inv.effective_date
						, inv.eff_date_from
						, inv.eff_date_to
						, case when fgi.fac_id is null then hfac.name else fgi.remit_to_name end as remit_to_name
						, case when fgi.fac_id is null then hfac.address1 else fgi.remit_to_address1 end as remit_to_address1
						, case when fgi.fac_id is null then hfac.address2 else fgi.remit_to_address2 end as remit_to_address2
						, case when fgi.fac_id is null then '' else fgi.remit_to_address3 end as remit_to_address3
						, case when fgi.fac_id is null then hfac.city else fgi.remit_to_city end as remit_to_city
						, case when fgi.fac_id is null then faccnty.name else fgi.remit_to_county end as remit_to_county
						, case when fgi.fac_id is null then hfac.prov else fgi.remit_to_prov_state end as remit_to_prov_state
						, case when fgi.fac_id is null then fl.country else fgi.remit_to_country end as remit_to_country
						, case when fgi.fac_id is null then hfac.pc else fgi.remit_to_postal_zip_code end as remit_to_postal_zip_code
						, case when fgi.fac_id is null then hfac.tel else fgi.remit_to_phone end as remit_to_phone
						, Null as contact_title
						, mpi.first_name as contact_first_name
						, mpi.last_name as contact_last_name
						, Null as contact_address1
						, Null as contact_address2
						, Null as contact_address3
						, Null as contact_city
						, Null as contact_county
						, Null as contact_prov_state
						, Null as contact_postal_zip_code
						, Null contact_country
						, Null as contact_email
						, 0 as account_number
						, convert(varchar(10),isnull(inv.generated_date,'1/1/1900'), 101) as generated_date
						, convert(varchar(10),inv.effective_date, 101) as bill_date
						, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
						, inv.payment_due_date
						, Null as pre_consolidated_payment_due_date
						, inv.statement_through_date	
						, Null as amount_due
						, Null as eft_message
						, Case when @vIncludeResidentMessage = 1 then clcon.invoice_message else Null end as client_message
						, null as group_message
						, null as global_message
						, null as previous_balance_due
						, null as payments
						, fl.fac_id as summary_fac_id
						, hfac.name as summary_charge_center
						, hfac.facility_code as summary_charge_center_code
						, mpi.first_name as summary_charge_client_first_name
						, mpi.last_name as summary_charge_client_last_name
						, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
						, cl.client_id_number as summary_charge_client_number
						, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
							when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
							else '' end)) as summary_charge_client_location
						, mpi.date_of_birth as summary_charge_client_dob
						, cl.admission_date as summary_charge_client_admission
						, cl.discharge_date as summary_charge_client_discharge
						, 0.0 as summary_current_balance
						, 0.0 as summary_previous_balance_due
						, 0.0 as summary_payments
						, 0.0 as summary_late_fees
						, 0.0 as summary_client_balance_due
						, payr.private_bills_to as private_bills_to					
						, null as amount_past_due_yn	
						, null as term_used_for_client				
						, null as client_admit_date					
						, null as client_discharge_date				
						, null as client_mrn						
						, null as client_first_name					
						, null as client_last_name					
						, unit.unit_desc as client_unit
						, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
								when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
						, rm.room_desc as client_room
						, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
								when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
						, bd.bed_desc as client_bed
						, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
								when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
						, null as patient_specific_message	
						, 0 as  contact_num
						, Dense_rank() over (ORDER BY mpi.last_name, mpi.first_name, cl.client_id, inv.effective_date) non_consolidated_contact_num
						--, 1 as non_consolidated_contact_num			
						, '' as client_list
						, 1 as main_location
						, 0 as consolidated_location_order
						, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
							when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
							else '' end)) as sort_location
					from #facility_list fl
						inner join dbo.clients cl with (nolock) on fl.fac_id = cl.fac_id
						inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
						inner join #invoices inv with (nolock) on cl.client_id = inv.client_id
						inner join #client_ids_table clfilter on inv.client_id = clfilter.client_id
						inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id = 0											
						inner join dbo.ar_lib_payers libpayer with (nolock) on inv.payer_id = libpayer.payer_id 
						inner join dbo.ar_payers payr with (nolock) on libpayer.payer_id = payr.payer_id and payr.fac_id = fl.fac_id
						inner join dbo.ar_payers_audit payraud with (nolock) on libpayer.payer_id = payraud.payer_id and payraud.fac_id = fl.fac_id
							and payraud.effective_date  <= inv.created_date AND (payraud.ineffective_date  >= inv.created_date or payraud.ineffective_date is null)
						inner join dbo.ar_configuration config with (nolock) on fl.fac_id  = config.fac_id
						left join #contact_clients concl on inv.invoice_id = concl.invoice_id
						left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
						left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
						left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
						left join #billing_group_table bg on grp.group_id = bg.group_id
						left join dbo.ar_client_configuration clcon with (nolock) on cl.client_id = clcon.client_id and clcon.deleted='N'
						left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
						left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
						left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
						left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
						inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
							and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)
						left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id	
					where --payraud.private_bills_to = 'G' and 
					concl.invoice_id is null and (@vClientStatus = -1 or (@vClientStatus = 0 and (cl.discharge_date is null or cl.discharge_date > @vReportDate)) or (@vClientStatus = 1 and cl.discharge_date <= @vReportDate)) 
					and (@vBillingGroup = '-1' --or (@vBillingGroup <> '-1' and isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null )
					or (@vBillingGroup <> '-1' and ((clgrp.group_id is not null and bg.group_id is not null and @vBillingGroup <> '0') or (isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null) ))
					or @vBillingGroup is null)
				end

			if @vReceiverIds = '-1'  or (@vReceiverIds <> '-1'  and  @vIsContact = 0)
				begin
					insert into #contact_clients --we need to check for other multiple contacts that may not have all appropriate invoices assigned
					select distinct
							mycon.fac_id
						, mycon.contact_id
						, mycon.consolidate_statement
						, myadd.client_id 
						, myadd.invoice_id
						, myadd.statement_invoice_number
						, 0 as payer_id	
						, myadd.payer 
						, myadd.inv_effective_date
						, myadd.inv_eff_date_from
						, myadd.inv_eff_date_to
						, mycon.remit_to_name
						, mycon.remit_to_address1
						, mycon.remit_to_address2
						, mycon.remit_to_address3
						, mycon.remit_to_city
						, mycon.remit_to_county
						, mycon.remit_to_prov_state
						, mycon.remit_to_country
						, mycon.remit_to_postal_zip_code
						, mycon.remit_to_phone
						, mycon.contact_title
						, mycon.contact_first_name
						, mycon.contact_last_name
						, mycon.contact_address1
						, mycon.contact_address2
						, mycon.contact_address3
						, mycon.contact_city
						, mycon.contact_county
						, mycon.contact_prov_state
						, mycon.contact_postal_zip_code
						, mycon.contact_country
						, mycon.contact_email
						, mycon.account_number
						, myadd.generated_date
						, myadd.bill_date
						, myadd.aging_date
						, myadd.payment_due_date
						, myadd.pre_consolidated_payment_due_date
						, myadd.statement_through_date	
						, myadd.amount_due
						, myadd.eft_message
						, myadd.client_message
						, myadd.group_message
						, myadd.global_message
						, myadd.previous_balance_due
						, myadd.payments
						, myadd.summary_fac_id
						, myadd.summary_charge_center
						, myadd.summary_charge_center_code
						, myadd.summary_charge_client_first_name
						, myadd.summary_charge_client_last_name
						, myadd.summary_charge_client_name
						, myadd.summary_charge_client_number
						, myadd.summary_charge_client_location
						, myadd.summary_charge_client_dob
						, myadd.summary_charge_client_admission
						, myadd.summary_charge_client_discharge
						, 0.0 as summary_current_balance
						, 0.0 as summary_previous_balance_due
						, 0.0 as summary_payments
						, 0.0 as summary_late_fees
						, 0.0 as summary_client_balance_due
						, myadd.private_bills_to				
						, null as amount_past_due_yn	
						, null as term_used_for_client				
						, null as client_admit_date					
						, null as client_discharge_date				
						, null as client_mrn						
						, null as client_first_name					
						, null as client_last_name					
						, myadd.client_unit	
						, myadd.unit_order					
						, myadd.client_room	
						, myadd.room_order					
						, myadd.client_bed
						, myadd.bed_order
						, null as patient_specific_message	
						, mycon.contact_num
						, mycon.non_consolidated_contact_num		
						, '' as client_list
						, myadd.main_location
						, myadd.consolidated_location_order	
						, myadd.sort_location
					from #contact_clients mycon
						inner join (SELECT b.contact_id,a.client_id, a.invoice_id, a.bill_date
							FROM(
								SELECT DISTINCT client_id , invoice_id, bill_date FROM #contact_clients where contact_id > 0) A
								INNER JOIN (
								SELECT DISTINCT contact_id, client_id FROM #contact_clients where contact_id > 0) B
								ON a.client_id = b.client_id 
								EXCEPT
								SELECT contact_id,client_id, invoice_id, bill_date FROM #contact_clients where contact_id > 0
								) toget
								on mycon.contact_id = toget.contact_id and mycon.client_id = toget.client_id and mycon.bill_date = toget.bill_date
						inner join #contact_clients myadd on toget.invoice_id = myadd.invoice_id

				end
		end

		set @vgsStepEndTime=GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

		-- other payer loading here
		if @vOtherStatementsIncluded = 1

		begin		
		-----getting the list of contacts
		select @vStep = 80
		set @vgsStepStartTime = GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' gathering other payer invoices ' + convert(varchar(26),getdate(),109)
		------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

		insert into #contact_clients
			select distinct
					fl.fac_id
				, Case when payraud.private_bills_to = 'G'  then  -1 * isnull(CAST(conta.contact_id AS NUMERIC(18,1)),3.1) else -2.1 end  as contact_id  --AMRO
				, 0 as consolidate_statement
				, cl.client_id 
				, inv.invoice_id 
				, inv.statement_invoice_number
				, libpayer.payer_id	
				, libpayer.description as payer 
				, inv.effective_date
				, inv.eff_date_from
				, inv.eff_date_to
				, case when fgi.fac_id is null then hfac.name else fgi.remit_to_name end as remit_to_name
				, case when fgi.fac_id is null then hfac.address1 else fgi.remit_to_address1 end as remit_to_address1
				, case when fgi.fac_id is null then hfac.address2 else fgi.remit_to_address2 end as remit_to_address2
				, case when fgi.fac_id is null then '' else fgi.remit_to_address3 end as remit_to_address3
				, case when fgi.fac_id is null then hfac.city else fgi.remit_to_city end as remit_to_city
				, case when fgi.fac_id is null then faccnty.name else fgi.remit_to_county end as remit_to_county
				, case when fgi.fac_id is null then hfac.prov else fgi.remit_to_prov_state end as remit_to_prov_state
				, case when fgi.fac_id is null then fl.country else fgi.remit_to_country end as remit_to_country
				, case when fgi.fac_id is null then hfac.pc else fgi.remit_to_postal_zip_code end as remit_to_postal_zip_code
				, case when fgi.fac_id is null then hfac.tel else fgi.remit_to_phone end as remit_to_phone
				, Case when payraud.private_bills_to = 'G' then title.item_description else '' end as contact_title
				, Case when payraud.private_bills_to = 'G' and isnull(conta.first_name,'') <> '' then conta.first_name
					when payraud.private_bills_to = 'G' and isnull(conta.first_name,'') = '' then 'No Data Found'
					when payraud.private_bills_to <> 'G' and isnull(insco.description,'') = '' then 'No Data Found' else insco.description end as contact_first_name 
				, Case when payraud.private_bills_to = 'G' then conta.last_name else '' end as contact_last_name
				, Case when payraud.private_bills_to = 'G' and isnull(cadd.address1,'') = '' and  isnull(cadd.address2,'') = '' then 'No Address Found' 
					when payraud.private_bills_to = 'G' and isnull(cadd.address1,'') <> '' then cadd.address1		
					when payraud.private_bills_to <> 'G' and isnull(inscoadd.address1,'') = '' and isnull(inscoadd.address2,'') = '' then 'No Address Found' 
					else inscoadd.address1 end as contact_address1
				, Case when payraud.private_bills_to = 'G' then cadd.address2 else inscoadd.address2 end as contact_address2
				, Case when payraud.private_bills_to = 'G' then cadd.address3 else inscoadd.address3 end as contact_address3
				, Case when payraud.private_bills_to = 'G' then cadd.city else inscoadd.city end as contact_city
				, Case when payraud.private_bills_to = 'G' then ccnty.name else cnty.name end as contact_county
				, Case when payraud.private_bills_to = 'G' then cadd.prov_state else inscoadd.prov_state end as contact_prov_state
				, Case when payraud.private_bills_to = 'G' then cadd.postal_zip_code else inscoadd.postal_zip_code end as contact_postal_zip_code
				, Case when payraud.private_bills_to = 'G' then ccountry.item_description else country.item_description end as contact_country
				, null as contact_email
				, Case when payraud.private_bills_to = 'G' then conr.contact_id else '' end as account_number
				, '1/1/1900' as generated_date
				, convert(varchar(10),inv.effective_date, 101) as bill_date
				, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
				, inv.payment_due_date
				, Null as pre_consolidated_payment_due_date
				, inv.statement_through_date		
				, Null as amount_due
				, Null as eft_message
				, '' as client_message
				, Null as group_message
				, Null as global_message
				, Null as previous_balance_due
				, Null as payments
				, fl.fac_id as summary_fac_id
				, hfac.name as summary_charge_center
				, hfac.facility_code as summary_charge_center_code
				, mpi.first_name as summary_charge_client_first_name
				, mpi.last_name as summary_charge_client_last_name
				, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
				, cl.client_id_number as summary_charge_client_number
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as summary_charge_client_location
				, mpi.date_of_birth as summary_charge_client_dob
				, cl.admission_date as summary_charge_client_admission
				, cl.discharge_date as summary_charge_client_discharge
				, 0.0 as summary_current_balance
				, 0.0 as summary_previous_balance_due
				, 0.0 as summary_payments
				, 0.0 as summary_late_fees
				, 0.0 as summary_client_balance_due	
				, payr.private_bills_to as private_bills_to					
				, null as amount_past_due_yn	
				, null as term_used_for_client	
				, null as client_admit_date					
				, null as client_discharge_date				
				, null as client_mrn						
				, null as client_first_name					
				, null as client_last_name					
				, unit.unit_desc as client_unit
				, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
						when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
				, rm.room_desc as client_room
				, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
						when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
				, bd.bed_desc as client_bed
				, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
						when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
				, null as patient_specific_message
				, 0 as  contact_num
				, 0 as non_consolidated_contact_num			
				, '' as client_list
				, 1 as main_location
				, 0 as consolidated_location_order
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as sort_location
			from #facility_list fl
				inner join dbo.clients cl with (nolock) on fl.fac_id = cl.fac_id
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
				inner join #invoices inv with (nolock) on cl.client_id = inv.client_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id > 0
				inner join dbo.ar_lib_payers libpayer with (nolock) on inv.payer_id = libpayer.payer_id 
				inner join dbo.ar_payers payr with (nolock) on libpayer.payer_id = payr.payer_id and payr.fac_id = fl.fac_id
				inner join dbo.ar_payers_audit payraud with (nolock) on libpayer.payer_id = payraud.payer_id and payraud.fac_id = fl.fac_id
				and payraud.effective_date  <= inv.created_date AND (payraud.ineffective_date  >= inv.created_date or payraud.ineffective_date is null)
				inner join dbo.ar_configuration config with (nolock) on fl.fac_id  = config.fac_id
				left join dbo.ar_client_payer_info policy with (nolock) on cl.client_id = policy.client_id and inv.payer_id = policy.payer_id
				left join dbo.client_ids clid with (nolock) on inv.client_id = clid.client_id and policy.policy_no_id = clid.id_type_id
				left join dbo.ar_payer_addresses_audit payradd with (nolock) on payraud.fac_id = payradd.fac_id and payraud.payer_id = payradd.payer_id and payraud.default_address_id = payradd.address_id and
					payradd.effective_date  <= inv.created_date AND (payradd.ineffective_date  >= inv.created_date or payradd.ineffective_date is null)
				left join dbo.ar_lib_insurance_companies_audit insco with (nolock) on payradd.insurance_id = insco.insurance_id and
					insco.effective_date  <= inv.created_date AND (insco.ineffective_date  >= inv.created_date or insco.ineffective_date is null)
				left join dbo.ar_insurance_addresses_audit inscoadd with (nolock) on payradd.address_id = inscoadd.address_id and
					inscoadd.effective_date  <= inv.created_date AND (inscoadd.ineffective_date  >= inv.created_date or inscoadd.ineffective_date is null)
				left join dbo.ar_provider_numbers provnum with (nolock) on inscoadd.address_id = provnum.address_id and fl.fac_id = provnum.fac_id
				left join dbo.county cnty with (nolock) on inscoadd.county_id = cnty.county_id
				left join common_code country with (nolock) on inscoadd.country_id = country.item_id
				left join #client_ids_table clfilter on inv.client_id = clfilter.client_id
				left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
				left join #billing_group_table bg on grp.group_id = bg.group_id
				left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
				left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
				left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
				left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
				inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
					and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)	
				left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id
						left join dbo.contact_type_audit cta with (nolock) on mpi.mpi_id = cta.reference_id 
					and config.contact_type_id = cta.[type_id] and cta.fac_id = inv.fac_id
					and cta.effective_date  <= inv.created_date AND (cta.ineffective_date  >= inv.created_date or cta.ineffective_date is null)
				left join dbo.contact_relationship conr with (nolock) on conr.contact_id = cta.contact_id and conr.deleted='N' 
					and conr.reference_id = cta.reference_id and conr.subclass_id = cta.subclass_id 
				left join #relationship relatcc on conr.relationship_id = relatcc.item_id
				left join dbo.contact_audit conta with (nolock) on cta.contact_id = conta.contact_id and conta.deleted='N'			
					and conta.effective_date  <= inv.created_date AND (conta.ineffective_date  >= inv.created_date or conta.ineffective_date is null)
				left join dbo.contact_address_audit conadd with (nolock) on cta.contact_id = conadd.contact_id 			
					and conadd.effective_date  <= inv.created_date AND (conadd.ineffective_date  >= inv.created_date or conadd.ineffective_date is null)
				left join dbo.address_audit cadd with (nolock) on conadd.address_id = cadd.address_id			
					and cadd.effective_date  <= inv.created_date AND (cadd.ineffective_date  >= inv.created_date or cadd.ineffective_date is null)	
				left join dbo.county ccnty with (nolock) on cadd.county_id = cnty.county_id
				left join common_code ccountry with (nolock) on cadd.country_id = ccountry.item_id
				left join common_code_audit title with (nolock)	on isnull(title.deleted, 'N') = 'N' and conta.title_id = title.item_id 
					and title.effective_date  <= inv.created_date AND (title.ineffective_date  >= inv.created_date or title.ineffective_date is null)				
			where payraud.private_bills_to <> 'I' and (@vClientStatus = -1 or (@vClientStatus = 0 and (cl.discharge_date is null or cl.discharge_date > @vReportDate)) or (@vClientStatus = 1 and cl.discharge_date is not null and cl.discharge_date <= @vReportDate)) 
			and (@vReceiverIds = '-1' or clfilter.client_id is not null)
			and (@vBillingGroup = '-1' --or (@vBillingGroup <> '-1' and isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null )
			or (@vBillingGroup <> '-1' and ((clgrp.group_id is not null and bg.group_id is not null and @vBillingGroup <> '0') or (isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null) ))
			or @vBillingGroup is null)

		set @vRowCount = @@rowcount

		insert into #contact_clients
			select distinct
					fl.fac_id
				, -2.1  as contact_id
				, 0 as consolidate_statement
				, cl.client_id 
				, inv.invoice_id 
				, inv.statement_invoice_number
				, libpayer.payer_id	
				, libpayer.description as payer 
				, inv.effective_date
				, inv.eff_date_from
				, inv.eff_date_to
				, case when fgi.fac_id is null then hfac.name else fgi.remit_to_name end as remit_to_name
				, case when fgi.fac_id is null then hfac.address1 else fgi.remit_to_address1 end as remit_to_address1
				, case when fgi.fac_id is null then hfac.address2 else fgi.remit_to_address2 end as remit_to_address2
				, case when fgi.fac_id is null then '' else fgi.remit_to_address3 end as remit_to_address3
				, case when fgi.fac_id is null then hfac.city else fgi.remit_to_city end as remit_to_city
				, case when fgi.fac_id is null then faccnty.name else fgi.remit_to_county end as remit_to_county
				, case when fgi.fac_id is null then hfac.prov else fgi.remit_to_prov_state end as remit_to_prov_state
				, case when fgi.fac_id is null then fl.country else fgi.remit_to_country end as remit_to_country
				, case when fgi.fac_id is null then hfac.pc else fgi.remit_to_postal_zip_code end as remit_to_postal_zip_code
				, case when fgi.fac_id is null then hfac.tel else fgi.remit_to_phone end as remit_to_phone
				, '' as contact_title
				, Case when isnull(insco.description,'') = '' then libpayer.description else insco.description end as contact_first_name 
				, '' as contact_last_name
				, Case when isnull(inscoadd.address1,'') = '' and isnull(inscoadd.address2,'') = '' then 'No Address Found' 
					else inscoadd.address1 end as contact_address1
				, inscoadd.address2 as contact_address2
				, inscoadd.address3 as contact_address3
				, inscoadd.city as contact_city
				, cnty.name as contact_county
				, inscoadd.prov_state as contact_prov_state
				, inscoadd.postal_zip_code as contact_postal_zip_code
				,  country.item_description as contact_country
				, null as contact_email
				, '' as account_number
				, '1/1/1900' as generated_date
				, convert(varchar(10),inv.effective_date, 101) as bill_date
				, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
				, inv.payment_due_date
				, Null as pre_consolidated_payment_due_date
				, inv.statement_through_date	
				, Null as amount_due
				, Null as eft_message
				, '' as client_message
				, Null as group_message
				, Null as global_message
				, Null as previous_balance_due
				, Null as payments
				, fl.fac_id as summary_fac_id
				, hfac.name as summary_charge_center
				, hfac.facility_code as summary_charge_center_code
				, mpi.first_name as summary_charge_client_first_name
				, mpi.last_name as summary_charge_client_last_name
				, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
				, cl.client_id_number as summary_charge_client_number
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as summary_charge_client_location
				, mpi.date_of_birth as summary_charge_client_dob
				, cl.admission_date as summary_charge_client_admission
				, cl.discharge_date as summary_charge_client_discharge
				, 0.0 as summary_current_balance
				, 0.0 as summary_previous_balance_due
				, 0.0 as summary_payments
				, 0.0 as summary_late_fees
				, 0.0 as summary_client_balance_due	
				, payr.private_bills_to as private_bills_to						
				, null as amount_past_due_yn	
				, null as term_used_for_client	
				, null as client_admit_date					
				, null as client_discharge_date				
				, null as client_mrn						
				, null as client_first_name					
				, null as client_last_name					
				, unit.unit_desc as client_unit
				, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
						when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
				, rm.room_desc as client_room
				, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
						when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
				, bd.bed_desc as client_bed
				, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
						when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
				, null as patient_specific_message
				, 0 as  contact_num
				, 0 as non_consolidated_contact_num			
				, '' as client_list
				, 1 as main_location
				, 0 as consolidated_location_order
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as sort_location
			from #facility_list fl
				inner join dbo.clients cl with (nolock) on fl.fac_id = cl.fac_id
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
				inner join #invoices inv with (nolock) on cl.client_id = inv.client_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id > 0
				inner join dbo.ar_lib_payers libpayer with (nolock) on inv.payer_id = libpayer.payer_id 
				inner join dbo.ar_payers payr with (nolock) on libpayer.payer_id = payr.payer_id and payr.fac_id = fl.fac_id
				inner join dbo.ar_payers_audit payraud with (nolock) on libpayer.payer_id = payraud.payer_id and payraud.fac_id = fl.fac_id
				and payraud.effective_date  <= inv.created_date AND (payraud.ineffective_date  >= inv.created_date or payraud.ineffective_date is null)
				left join dbo.ar_client_payer_info cpiaud with (nolock) on cl.client_id = cpiaud.client_id and payraud.payer_id = cpiaud.payer_id and payraud.fac_id = cpiaud.fac_id and cpiaud.deleted = 'N'
					and cpiaud.effective_date  <= inv.effective_date AND (cpiaud.ineffective_date  >= inv.effective_date or cpiaud.ineffective_date is null) 
				left join dbo.ar_insurance_addresses_audit inscoadd with (nolock) on cpiaud.payer_address_id = inscoadd.address_id and
					inscoadd.effective_date  <= inv.created_date AND (inscoadd.ineffective_date  >= inv.created_date or inscoadd.ineffective_date is null)
				left join dbo.ar_lib_insurance_companies_audit insco with (nolock) on inscoadd.insurance_id = insco.insurance_id and
					insco.effective_date  <= inv.created_date AND (insco.ineffective_date  >= inv.created_date or insco.ineffective_date is null)
				left join dbo.ar_provider_numbers provnum with (nolock) on inscoadd.address_id = provnum.address_id and fl.fac_id = provnum.fac_id
				left join dbo.county cnty with (nolock) on inscoadd.county_id = cnty.county_id
				left join common_code country with (nolock) on inscoadd.country_id = country.item_id
				left join #client_ids_table clfilter on inv.client_id = clfilter.client_id
				left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
				left join #billing_group_table bg on grp.group_id = bg.group_id
				left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
				left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
				left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
				left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
				inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
					and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)	
				left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id							
			where payraud.private_bills_to = 'I' and (@vClientStatus = -1 or (@vClientStatus = 0 and (cl.discharge_date is null or cl.discharge_date > @vReportDate)) or (@vClientStatus = 1 and cl.discharge_date is not null and cl.discharge_date <= @vReportDate)) 
			and (@vReceiverIds = '-1' or clfilter.client_id is not null)
			and (@vBillingGroup = '-1' --or (@vBillingGroup <> '-1' and isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null )
			or (@vBillingGroup <> '-1' and ((clgrp.group_id is not null and bg.group_id is not null and @vBillingGroup <> '0') or (isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null) ))
			or @vBillingGroup is null)

		set @vRowCount = isnull(@vRowCount,0) + @@rowcount

		if @vRowCount = 0
			set @vOtherStatementsIncluded = 0

		set @vgsStepEndTime=GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

		end

	end

select @vStep = 85
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' grouping invoices ' + convert(varchar(26),getdate(),109)

--break by generated date
--select contact_num,* from #contact_clients order by 1
if @vSortBy = 1

	begin
		update con set 
				 con.client_unit = main.client_unit
				,con.unit_order = main.unit_order						
				,con.client_room = main.client_room
				,con.room_order = main.room_order						
				,con.client_bed = main.client_bed
				,con.bed_order = main.bed_order
				,con.sort_location = main.sort_location	
		from #contact_clients con
		inner join #contact_clients main on con.contact_id = main.contact_id and con.non_consolidated_contact_num = main.non_consolidated_contact_num
			and con.bill_date = main.bill_date and con.payer_id = main.payer_id and con.consolidate_statement = 1 and main.consolidate_statement = 1
			and con.main_location = 0 and main.main_location = 1

		--when there isn't a "main resident" in a multi resident statement, set it to the first location
		update con set 
				 con.client_unit = sortby.client_unit
				,con.unit_order = sortby.unit_order						
				,con.client_room = sortby.client_room
				,con.room_order = sortby.room_order						
				,con.client_bed = sortby.client_bed
				,con.bed_order = sortby.bed_order
				,con.sort_location = sortby.sort_location	
		from #contact_clients con
		inner join(
					select mincon.contact_id,mincon.bill_date,mincon.payer_id,mincon.generated_date,
					min(mincon.client_unit) as client_unit,min(mincon.unit_order) as unit_order,min(mincon.client_room) as client_room,min(mincon.room_order) as room_order,
					min(mincon.client_bed) as client_bed,min(mincon.bed_order) bed_order,min(mincon.sort_location) as sort_location
					from #contact_clients mincon
					inner join(
								select contact_id,non_consolidated_contact_num,bill_date,contact_last_name, contact_first_name,payer_id, generated_date
								from #contact_clients where main_location = 0 
								group by contact_id,non_consolidated_contact_num,bill_date,contact_last_name, contact_first_name,payer_id, generated_date
								having count(1) > 1
								) nomain on mincon.contact_id = nomain.contact_id and mincon.bill_date = nomain.bill_date and mincon.payer_id = nomain.payer_id and mincon.generated_date = nomain.generated_date
								group by  mincon.contact_id,mincon.bill_date,mincon.payer_id,mincon.generated_date
				) sortby on con.contact_id = sortby.contact_id and con.bill_date = sortby.bill_date and con.payer_id = sortby.payer_id and con.generated_date = sortby.generated_date

		update  con set con.contact_num = rnk.contact_num
		from #contact_clients con
		left join #facilty_group_info fg on con.fac_id = fg.fac_id
		inner join (select contact_id,non_consolidated_contact_num,bill_date,payer_id, generated_date, consolidate_statement, 
				case when fgi.fac_id is null then #contact_clients.fac_id else fgi.facility_group_id end as grp,
				invoice_id, 
			Dense_rank()  over (ORDER BY unit_order, client_unit, room_order, client_room, bed_order, client_bed, inv_effective_date, generated_date,(case when contact_id < 0 then invoice_id else 0 end) ,
				contact_last_name, contact_first_name, contact_id, consolidate_statement, 
				(case when fgi.fac_id is null then #contact_clients.fac_id else fgi.facility_group_id end),
				(case when consolidate_statement = 0 then client_id else 0 end)
				) contact_num from #contact_clients
				left join #facilty_group_info fgi on #contact_clients.fac_id = fgi.fac_id
				) rnk
			on con.contact_id= rnk.contact_id and con.bill_date= rnk.bill_date and con.payer_id= rnk.payer_id and con.non_consolidated_contact_num= rnk.non_consolidated_contact_num 
				and con.generated_date =  rnk.generated_date and con.consolidate_statement =  rnk.consolidate_statement and ((fg.fac_id is null and rnk.grp = con.fac_id) or (fg.fac_id is not null and rnk.grp = fg.facility_group_id))
			where (con.invoice_id = rnk.invoice_id)
	end
else
	If @vIsContact = 0
		begin
			update con set con.sort_location = con.summary_charge_client_name
			from #contact_clients con

			update con set con.sort_location = main.summary_charge_client_name
			from #contact_clients con
			inner join #contact_clients main on con.contact_id = main.contact_id and con.non_consolidated_contact_num = main.non_consolidated_contact_num
				and con.bill_date = main.bill_date and con.payer_id = main.payer_id and con.consolidate_statement = 1 and main.consolidate_statement = 1
				and con.main_location = 0 and main.main_location = 1
			
			--when there isn't a "main resident" in a multi resident statement, set it to the first resident alphabetically
			update con set con.sort_location = sortby.summary_charge_client_name
			from #contact_clients con
			inner join(
						select mincon.contact_id,mincon.bill_date,mincon.payer_id,mincon.generated_date,min(mincon.summary_charge_client_name) as summary_charge_client_name
						from #contact_clients mincon
						inner join(
									select contact_id,non_consolidated_contact_num,bill_date,contact_last_name, contact_first_name,payer_id, generated_date
									from #contact_clients where main_location = 0 
									group by contact_id,non_consolidated_contact_num,bill_date,contact_last_name, contact_first_name,payer_id, generated_date
									having count(1) > 1
								 ) nomain on mincon.contact_id = nomain.contact_id and mincon.bill_date = nomain.bill_date and mincon.payer_id = nomain.payer_id and mincon.generated_date = nomain.generated_date
									group by mincon.contact_id,mincon.bill_date,mincon.payer_id,mincon.generated_date
					) sortby on con.contact_id = sortby.contact_id and con.bill_date = sortby.bill_date and con.payer_id = sortby.payer_id and con.generated_date = sortby.generated_date

			update  con set con.contact_num = rnk.contact_num
			from #contact_clients con
			left join #facilty_group_info fg on con.fac_id = fg.fac_id
			inner join (select distinct contact_id,non_consolidated_contact_num,bill_date,payer_id, generated_date, consolidate_statement, 
					case when fgi.fac_id is null then #contact_clients.fac_id else fgi.facility_group_id end as grp,
					invoice_id, 
				Dense_rank()  over (ORDER BY sort_location ,inv_effective_date, generated_date, (case when consolidate_statement = 1 then '0' else sort_location end), case when contact_id < 0 then invoice_id else 0 end, 
					contact_last_name, contact_first_name, contact_id, (case when contact_id < 0 then invoice_id else 0 end), consolidate_statement, 
					(case when fgi.fac_id is null then #contact_clients.fac_id else fgi.facility_group_id end),
					(case when consolidate_statement = 0 then client_id else 0 end) 
					) contact_num from #contact_clients
					left join #facilty_group_info fgi on #contact_clients.fac_id = fgi.fac_id
					) rnk
				on con.contact_id= rnk.contact_id and con.bill_date= rnk.bill_date and con.payer_id= rnk.payer_id and con.non_consolidated_contact_num= rnk.non_consolidated_contact_num 
					and con.generated_date =  rnk.generated_date and con.consolidate_statement =  rnk.consolidate_statement and ((fg.fac_id is null and rnk.grp = con.fac_id) or (fg.fac_id is not null and rnk.grp = fg.facility_group_id))
			where (con.invoice_id = rnk.invoice_id)

		end
	else
		begin
			update  con set con.contact_num = rnk.contact_num
			from #contact_clients con
			left join #facilty_group_info fg on con.fac_id = fg.fac_id
			inner join (select contact_id,non_consolidated_contact_num,bill_date,contact_last_name, contact_first_name,payer_id, generated_date, consolidate_statement, 
					case when fgi.fac_id is null then #contact_clients.fac_id else fgi.facility_group_id end as grp,
					invoice_id, Dense_rank() over 
				(ORDER BY contact_last_name, contact_first_name, contact_id,payer_id
						, consolidate_statement, inv_effective_date, generated_date,(case when contact_id < 0 then invoice_id else 0 end), 
						(case when fgi.fac_id is null then #contact_clients.fac_id else fgi.facility_group_id end),
						(case when consolidate_statement = 0 then client_id else 0 end)  ) contact_num from #contact_clients
						left join #facilty_group_info fgi on #contact_clients.fac_id = fgi.fac_id 
						) rnk
				on con.contact_id= rnk.contact_id and con.bill_date= rnk.bill_date and con.payer_id= rnk.payer_id and con.non_consolidated_contact_num= rnk.non_consolidated_contact_num
				and con.generated_date =  rnk.generated_date and con.consolidate_statement =  rnk.consolidate_statement 
				and con.contact_last_name = rnk.contact_last_name and con.contact_first_name = rnk.contact_first_name and ((fg.fac_id is null and rnk.grp = con.fac_id) or (fg.fac_id is not null and rnk.grp = fg.facility_group_id))
				where (con.invoice_id = rnk.invoice_id)

		end

If @vIsContact = 0 and @vIsEmc = 1 and isnull(@vReceiverIds,'-1') <> '-1'

	delete dcon
	from #contact_clients dcon
	left join (select cc.contact_num from #contact_clients cc inner join #client_ids_table cl on cc.client_id = cl.client_id group by cc.contact_num) kcon
	on dcon.contact_num = kcon.contact_num
	where kcon.contact_num is null 

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

-----getting the list of contacts
select @vStep = 90
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' gathering messages + get latest contact info' + convert(varchar(26),getdate(),109)


if @vBillingGroup = '-1' or @vIsEmc = 1
	begin
		update  con set con.group_message = LEFT(invoicemessage.value('.','varchar(max)') , LEN(invoicemessage.value('.','varchar(max)')) -1 )--AS invoicemsg 
		FROM #contact_clients con
		CROSS APPLY
		( 
		SELECT ag.invoice_message + char(9) --+ ', '
			FROM  dbo.ar_group ag WITH (NOLOCK)
			inner join dbo.ar_client_group acg WITH (NOLOCK) on ag.group_id = acg.group_id
			WHERE acg.client_id = con.client_id and isnull(ag.invoice_message,'')<>''
			ORDER BY ag.created_date desc
			FOR XML PATH (''), TYPE
		) a ( invoicemessage )
	end

if @vBillingGroup <> '-1' and @vBillingGroup <> '0' and  @vIsEmc = 0
	begin
		update  con set con.group_message = LEFT(invoicemessage.value('.','varchar(max)') , LEN(invoicemessage.value('.','varchar(max)')) -1 )--AS invoicemsg 
		FROM #contact_clients con
		CROSS APPLY
		( 
		SELECT ltrim(rtrim(ag.invoice_message)) + char(9) --+ ', '
			FROM  dbo.ar_group ag WITH (NOLOCK)
			inner join dbo.ar_client_group acg WITH (NOLOCK) on ag.group_id = acg.group_id
			inner join #billing_group_table bg on ag.group_id = bg.group_id
			WHERE acg.client_id = con.client_id and isnull(ag.invoice_message,'')<>''
			ORDER BY ag.created_date desc
			FOR XML PATH (''), TYPE
		) a ( invoicemessage )
	end

--add eft messages
If  @vIsNewEft = 'N'
	begin
		update  con set con.eft_message = eft_info.invoice_message
		FROM #contact_clients con
		inner join dbo.ar_client_configuration config with (nolock) on con.client_id = config.client_id and isnull(eft_client,'N') = 'Y'
		inner join dbo.ar_eft_bank_info eft_info with (nolock) on config.fac_id = eft_info.fac_id
	end
else
	begin
		update  con set con.eft_message = coalesce(usfbc.invoice_message,cdnfbc.invoice_message,libeft.invoice_message)
		FROM #contact_clients con
		inner join #invoices inv with (nolock) on con.invoice_id = inv.invoice_id
		inner join dbo.ar_eft_client_configuration_history eftconfig with (nolock) on inv.client_id = eftconfig.client_id and eftconfig.[enabled] = 1
			and eftconfig.effective_date  <= inv.created_date and (eftconfig.ineffective_date  >= inv.created_date or eftconfig.ineffective_date is null)
		inner join dbo.ar_eft_facility_bank_configuration_history  fbc with (nolock) on inv.fac_id = fbc.fac_id
			and fbc.effective_date  <= inv.created_date and (fbc.ineffective_date  >= inv.created_date or fbc.ineffective_date is null)	 	
		inner join dbo.ar_lib_eft_bank_configuration_history libeft with (nolock) on fbc.eft_bank_configuration_id = libeft.eft_bank_configuration_id
			and libeft.effective_date  <= inv.created_date and (libeft.ineffective_date  >= inv.created_date or libeft.ineffective_date is null)	
		left join dbo.ar_eft_facility_us_bank_configuration_history usfbc with (nolock) on fbc.eft_bank_configuration_id = usfbc.eft_bank_configuration_id and inv.fac_id = usfbc.fac_id 
			and usfbc.effective_date  <= inv.created_date and (usfbc.ineffective_date  >= inv.created_date or usfbc.ineffective_date is null)	
		left join dbo.ar_eft_facility_ca_bank_configuration_history cdnfbc with (nolock) on fbc.eft_bank_configuration_id = cdnfbc.eft_bank_configuration_id and inv.fac_id = cdnfbc.fac_id 
			and cdnfbc.effective_date  <= inv.created_date and (cdnfbc.ineffective_date  >= inv.created_date or cdnfbc.ineffective_date is null)
	end	

--we need to determine if multiple invoices exist in a month, for different contacts, and update them to the contact info tied to the last created invoice

insert into #contact_union_table 
select a.contact_id, a.contact_num, a.payer_id, a.client_id, a.bill_date, a.inv_created_date, a.generated_date,
	ROW_NUMBER() OVER ( PARTITION BY a.payer_id, a.client_id, a.bill_date 
			order by  a.payer_id, a.client_id, a.bill_date desc, a.inv_created_date desc, a.generated_date desc) as rwnum

from
(select clcon.contact_id, clcon.contact_num, clcon.payer_id, clcon.client_id, clcon.bill_date, clcon.generated_date, max(inv.created_date) as inv_created_date
from #contact_clients clcon
	inner join #invoices inv with (nolock) on clcon.invoice_id	= inv.invoice_id and clcon.contact_id > -1
group by clcon.contact_id, clcon.payer_id, clcon.contact_num, clcon.client_id, clcon.bill_date, clcon.generated_date) a
inner join 	(select clcon.contact_id, clcon.contact_num, clcon.payer_id, clcon.client_id, clcon.bill_date, clcon.generated_date, max(inv.created_date) as inv_created_date
from #contact_clients clcon
	inner join #invoices inv with (nolock) on clcon.invoice_id	= inv.invoice_id and clcon.contact_id > -1
group by clcon.contact_id, clcon.contact_num, clcon.payer_id, clcon.client_id, clcon.bill_date, clcon.generated_date) b
on a.client_id = b.client_id and a.payer_id = b.payer_id and a.bill_date = b.bill_date and a.generated_date = b.generated_date and a.inv_created_date <> b.inv_created_date

delete mcon
from #contact_union_table mcon
inner join (select a.payer_id, a.client_id, a.bill_date, a.generated_date, a.inv_created_date
from #contact_union_table a
group by a.payer_id, a.client_id, a.bill_date, a.generated_date, a.inv_created_date having count(*)>1) dbl 
	on mcon.payer_id = dbl.payer_id and mcon.client_id = dbl.client_id and mcon.inv_created_date = dbl.inv_created_date and mcon.bill_date = dbl.bill_date and mcon.generated_date = dbl.generated_date
left join (select  c.payer_id, c.client_id, c.bill_date, c.generated_date, c.inv_created_date
from #contact_union_table c
group by c.payer_id, c.client_id, c.bill_date, c.generated_date, c.inv_created_date having count(*)=1) sgl on mcon.payer_id = sgl.payer_id and mcon.client_id = sgl.client_id
	and mcon.bill_date = sgl.bill_date and mcon.generated_date = sgl.generated_date
where sgl.client_id is null

if @debug_me='Y' select * from #contact_union_table order by row_num

IF (select COUNT(1) from #contact_union_table) > 0
	Begin	
		update a set a.contact_id = b.contact_id
				, a.contact_num = b.contact_num
				, a.consolidate_statement = b.consolidate_statement
				, a.non_consolidated_contact_num = b.non_consolidated_contact_num
				, a.remit_to_name = b.remit_to_name
				, a.remit_to_address1 = b.remit_to_address1
				, a.remit_to_address2 = b.remit_to_address2
				, a.remit_to_address3 = b.remit_to_address3
				, a.remit_to_city = b.remit_to_city
				, a.remit_to_county = b.remit_to_county
				, a.remit_to_prov_state = b.remit_to_prov_state
				, a.remit_to_postal_zip_code = b.remit_to_postal_zip_code
				, a.remit_to_phone = b.remit_to_phone
				, a.contact_title = b.contact_title
				, a.contact_first_name = b.contact_first_name
				, a.contact_last_name = b.contact_last_name
				, a.contact_address1 = b.contact_address1
				, a.contact_address2 = b.contact_address2
				, a.contact_address3 = b.contact_address3
				, a.contact_city = b.contact_city
				, a.contact_county = b.contact_county
				, a.contact_prov_state = b.contact_prov_state
				, a.contact_postal_zip_code = b.contact_postal_zip_code
				, a.contact_country = b.contact_country
				, a.contact_email = b.contact_email
				, a.account_number = b.account_number
				, a.summary_fac_id = b.summary_fac_id
				, a.summary_charge_center = b.summary_charge_center
		from #contact_clients a
			inner join #contact_union_table cutold on a.client_id = cutold.client_id and a.contact_num = cutold.contact_num 
				and a.bill_date = cutold.bill_date and cutold.row_num > 1
			inner join #contact_union_table cutnew on cutold.client_id = cutnew.client_id and cutold.bill_date = cutnew.bill_date
			inner join #contact_clients b on b.client_id = cutnew.client_id and b.contact_num = cutnew.contact_num 
				and b.bill_date = cutnew.bill_date and cutnew.row_num = 1

		update a set a.contact_id = b.contact_id
				, a.contact_num = b.contact_num
				, a.consolidate_statement = b.consolidate_statement
				, a.non_consolidated_contact_num = b.non_consolidated_contact_num
				, a.remit_to_name = b.remit_to_name
				, a.remit_to_address1 = b.remit_to_address1
				, a.remit_to_address2 = b.remit_to_address2
				, a.remit_to_address3 = b.remit_to_address3
				, a.remit_to_city = b.remit_to_city
				, a.remit_to_county = b.remit_to_county
				, a.remit_to_prov_state = b.remit_to_prov_state
				, a.remit_to_postal_zip_code = b.remit_to_postal_zip_code
				, a.remit_to_phone = b.remit_to_phone
				, a.contact_title = b.contact_title
				, a.contact_first_name = b.contact_first_name
				, a.contact_last_name = b.contact_last_name
				, a.contact_address1 = b.contact_address1
				, a.contact_address2 = b.contact_address2
				, a.contact_address3 = b.contact_address3
				, a.contact_city = b.contact_city
				, a.contact_county = b.contact_county
				, a.contact_prov_state = b.contact_prov_state
				, a.contact_postal_zip_code = b.contact_postal_zip_code
				, a.contact_country = b.contact_country
				, a.contact_email = b.contact_email
				, a.account_number = b.account_number
				, a.summary_fac_id = b.summary_fac_id
				, a.summary_charge_center = b.summary_charge_center
		from #contact_clients a
			inner join #contact_clients b on a.client_id = b.client_id and a.contact_num = b.contact_num and a.bill_date = b.bill_date
			--inner join dbo.ar_invoice inv with (nolock) on b.invoice_id	= inv.invoice_id
			inner join #invoices inv on b.invoice_id = inv.invoice_id
			inner join #contact_union_table ujoin on b.client_id = ujoin.client_id and b.contact_num = ujoin.contact_num 
				and b.bill_date = ujoin.bill_date and inv.created_date = ujoin.inv_created_date and ujoin.row_num = 1
		where a.invoice_id <> b.invoice_id

	end

if @vReprintFrom is not null
	begin

		declare @min_contact_num int
		if @vSortBy = 1
			select @min_contact_num = min(contact_num) from #contact_clients where sort_location like @vReprintFrom +'%'
		else
			If @vIsContact = 1
				select @min_contact_num = min(contact_num) from #contact_clients where contact_last_name like @vReprintFrom +'%'
			else
				select @min_contact_num = min(contact_num) from #contact_clients where summary_charge_client_name like @vReprintFrom +'%'

		delete from #contact_clients where contact_num < @min_contact_num
		
	end

if @vExportMode = 1 
	begin
			UPDATE dbo.ar_invoice
			SET ar_invoice.date_exported_ps = getDate()
			FROM dbo.ar_invoice
			JOIN #contact_clients ON ar_invoice.client_id = #contact_clients.client_id 
				AND ar_invoice.invoice_id = #contact_clients.invoice_id
	end

if @debug_me='Y'  select * from #contact_clients order by contact_num,non_consolidated_contact_num

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 100
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' gathering transaction detail data ' + convert(varchar(26),getdate(),109)
--*********************************************************************************************************

--update generated date on "other" statement rows for uniqueness in each bill date
update ccl set ccl.generated_date = dateadd(mm,contact_num,ccl.generated_date)
from #contact_clients ccl
inner join (select invoice_id from #contact_clients where contact_id <= -2.1  group by invoice_id having count(*) = 1) sngl on ccl.invoice_id = sngl.invoice_id
where ccl.contact_id <= -2.1  

if @vIsTrial = 0
	begin
		insert into #local_transactions
	
		select tx.invoice_id
			, ccl.contact_id
			, tx.batch_id
			, tx.entry_number
			, tx.client_id
			--, 'N' as auto_generated
			, isnull(tx.auto_generated,'N')
			, tx.transaction_id
			, tx.reversing_tx_id
			, tx.distribution_tx_id
			, 0 as applied_payment_id
			, tx.payer_id
			, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
			, tx.days_account_id
			, tx.dollars_account_id
			, tx.fac_id
			, tx.is_billed
			, tx.transaction_type
			, tx.parent_tx_type
			, tx.[description]
			, tx.alt_description
			, tx.cheque_number
			, tx.effective_date
			, tx.transaction_date
			, ccl.bill_date as bill_date
			, Null as applied_date
			, ccl.generated_date
			, tx.days_amount
			, tx.daily_rate
			, tx.monthly_rate
			, tx.amount
			, tx.care_level
			, Case when isnull(tx.revenue_code,'') = '' or tx.revenue_code = '-1' then '' else tx.revenue_code end as revenue_code
			, tx.hcpcs_code	
			, tx.item_type_id
			, tx.comment
			, tx.rate_type_id
			, tx.rugs_modifier
			, tx.medicare_day
			, tx.mppr_flag
			, tx.mark_as_billed_by
			, tx.mark_as_billed_date
			, tx.mark_as_billed_comment
			, Case when (tx.transaction_type in('r','dr','cl','cr','d') and tx.parent_tx_type = 'r'
				or ((tx.transaction_type = 'co'or tx.transaction_type = 'cw')
				and tx.auto_generated = 'y') or (tx.transaction_type = 'xr' 
				and tx.parent_tx_type = 'r')) then 1 
				when tx.transaction_type = 'c' then 3 
				else 2 end as transaction_type_group
			, 1
		from dbo.ar_transactions tx with (nolock)
			inner join (select distinct contact_id,invoice_id,bill_date,generated_date from #contact_clients) ccl on tx.invoice_id = ccl.invoice_id
			inner join dbo.ar_payers payer with (nolock) on tx.payer_id = payer.payer_id and tx.fac_id = payer.fac_id
			where tx.deleted = 'N'
			and not (tx.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
			and not (tx.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate') 
	end
else
	begin
		insert into #local_transactions --trials
		select tx.trial_invoice_id
			, ccl.contact_id
			, tx.batch_id
			, tx.entry_number
			, tx.client_id
			--, 'N' as auto_generated
			, isnull(tx.auto_generated,'N')
			, tx.transaction_id
			, tx.reversing_tx_id
			, tx.distribution_tx_id
			, 0 as applied_payment_id
			, tx.payer_id
			, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
			, tx.days_account_id
			, tx.dollars_account_id
			, tx.fac_id
			, tx.is_billed
			, tx.transaction_type
			, tx.parent_tx_type
			, tx.[description]
			, tx.alt_description
			, tx.cheque_number
			, tx.effective_date
			, tx.transaction_date
			, ccl.bill_date as bill_date
			, Null as applied_date
			, ccl.generated_date
			, tx.days_amount
			, tx.daily_rate
			, tx.monthly_rate
			, tx.amount
			, tx.care_level
			, Case when isnull(tx.revenue_code,'') = '' or tx.revenue_code = '-1' then '' else tx.revenue_code end as revenue_code
			, tx.hcpcs_code	
			, tx.item_type_id
			, tx.comment
			, tx.rate_type_id
			, tx.rugs_modifier
			, tx.medicare_day
			, tx.mppr_flag
			, tx.mark_as_billed_by
			, tx.mark_as_billed_date
			, tx.mark_as_billed_comment
			, Case when (tx.transaction_type in('r','dr','cl','cr','d') and tx.parent_tx_type = 'r'
				or ((tx.transaction_type = 'co'or tx.transaction_type = 'cw')
				and tx.auto_generated = 'y') or (tx.transaction_type = 'xr' 
				and tx.parent_tx_type = 'r')) then 1 
				when tx.transaction_type = 'c' then 3 
				else 2 end as transaction_type_group
			, 1
		from dbo.ar_transactions tx with (nolock)
			inner join (select distinct contact_id,invoice_id,bill_date,generated_date from #contact_clients) ccl on tx.trial_invoice_id = ccl.invoice_id
			inner join dbo.ar_payers payer with (nolock) on tx.payer_id = payer.payer_id and tx.fac_id = payer.fac_id
			where tx.deleted = 'N'
			and not (tx.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
			and not (tx.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate') 

		insert into #local_transactions	 --merged non-trials
		select tx.invoice_id
			, ccl.contact_id
			, tx.batch_id
			, tx.entry_number
			, tx.client_id
			--, 'N' as auto_generated
			, isnull(tx.auto_generated,'N')
			, tx.transaction_id
			, tx.reversing_tx_id
			, tx.distribution_tx_id
			, 0 as applied_payment_id
			, tx.payer_id
			, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
			, tx.days_account_id
			, tx.dollars_account_id
			, tx.fac_id
			, tx.is_billed
			, tx.transaction_type
			, tx.parent_tx_type
			, tx.[description]
			, tx.alt_description
			, tx.cheque_number
			, tx.effective_date
			, tx.transaction_date
			, ccl.bill_date as bill_date
			, Null as applied_date
			, ccl.generated_date
			, tx.days_amount
			, tx.daily_rate
			, tx.monthly_rate
			, tx.amount
			, tx.care_level
			, Case when isnull(tx.revenue_code,'') = '' or tx.revenue_code = '-1' then '' else tx.revenue_code end as revenue_code
			, tx.hcpcs_code	
			, tx.item_type_id
			, tx.comment
			, tx.rate_type_id
			, tx.rugs_modifier
			, tx.medicare_day
			, tx.mppr_flag
			, tx.mark_as_billed_by
			, tx.mark_as_billed_date
			, tx.mark_as_billed_comment
			, Case when (tx.transaction_type in('r','dr','cl','cr','d') and tx.parent_tx_type = 'r'
				or ((tx.transaction_type = 'co'or tx.transaction_type = 'cw')
				and tx.auto_generated = 'y') or (tx.transaction_type = 'xr' 
				and tx.parent_tx_type = 'r')) then 1 
				when tx.transaction_type = 'c' then 3 
				else 2 end as transaction_type_group
			, 1
		from dbo.ar_transactions tx with (nolock)
			inner join (select distinct contact_id,invoice_id,bill_date,generated_date from #contact_clients) ccl on tx.invoice_id = ccl.invoice_id
			inner join dbo.ar_payers payer with (nolock) on tx.payer_id = payer.payer_id and tx.fac_id = payer.fac_id
			where tx.deleted = 'N'
			and not (tx.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
			and not (tx.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate') 

	end

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 103
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' updating values based on transaction creation issues ' + convert(varchar(26),getdate(),109)

--update missing rate types on reversing transactions, so we can build the description later - reversing bug	
update rev set rev.rate_type_id = src.rate_type_id
from #local_transactions rev
inner join dbo.ar_transactions src with (nolock) on rev.reversing_tx_id = src.transaction_id and src.deleted='N' and rev.rate_type_id is null 

--CORE-9223 - 2 versions.  They both seem to result in the same descriptions
--update MPPR adjustment descriptions based on the parents charge code description
--update mppr set mppr.description = cc.description + ' Adjustment' 
--from #local_transactions mppr
--inner join dbo.ar_mppr_bumpup bmp with (nolock) on mppr.distribution_tx_id = bmp.bumpup_transaction_id 
--inner join dbo.ar_transactions src with (nolock) on mppr.distribution_tx_id = src.transaction_id and src.deleted='N' and mppr.description = 'MPPR Adjustment' 
--inner join dbo.ar_lib_charge_codes cc with (nolock) on src.item_type_id = cc.charge_code_id

--update MPPR adjustment descriptions based on the ancillary transaction description
--update mppr set mppr.description = prnt.description + ' Adjustment' 
--from #local_transactions mppr
--inner join dbo.ar_mppr_bumpup bmp with (nolock) on mppr.distribution_tx_id = bmp.bumpup_transaction_id 
--inner join dbo.ar_transactions src with (nolock) on bmp.reduction_transaction_id = src.transaction_id and src.deleted='N' and mppr.description = 'MPPR Adjustment' 
--inner join dbo.ar_transactions prnt with (nolock) on src.distribution_tx_id = prnt.transaction_id and src.deleted='N' 

update childcash set childcash.comment = parentcash.comment, childcash.cheque_number = parentcash.cheque_number 
	--,childcash.skip_bit = (case when lclpc.transaction_id is not null then 2 else 1 end)
from #local_transactions childcash
inner join dbo.ar_transactions parentcash with (nolock) on childcash.distribution_tx_id = parentcash.transaction_id
	and childcash.distribution_tx_id <> childcash.transaction_id and parentcash.distribution_tx_id = parentcash.transaction_id
	and childcash.transaction_type = 'C' and parentcash.transaction_type = 'C'

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

if @vSummarizeReversals = 1
	begin

		Select @vStep = 105;
		set @vgsStepStartTime = GETDATE()
		if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Summarizing Reversals ' + convert(varchar(26),getdate(),109);

		if @vPrivateStatementsIncluded =1
			begin
				insert into #local_transactions
	
				select tx.invoice_id
					, tx.contact_id
					, tx.batch_id
					, tx.entry_number
					, tx.client_id
					, tx.auto_generated
					, tx.transaction_id
					, tx.reversing_tx_id
					, tx.distribution_tx_id
					, tx.applied_payment_id
					, tx.payer_id
					, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
					, tx.days_account_id
					, tx.dollars_account_id
					, tx.fac_id
					, tx.is_billed
					, tx.transaction_type
					, tx.parent_tx_type
					, tx.[description]
					, tx.alt_description
					, tx.cheque_number
					, tx.effective_date
					, tx.transaction_date
					, tx.bill_date
					, tx.applied_date
					, tx.generated_date
					, tx.days_amount
					, tx.daily_rate
					, tx.monthly_rate
					, tx.amount + isnull(revtx.amount,0)
					, tx.care_level
					, tx.revenue_code
					, tx.hcpcs_code	
					, tx.item_type_id
					, tx.comment
					, tx.rate_type_id
					, tx.rugs_modifier
					, tx.medicare_day
					, tx.mppr_flag
					, tx.mark_as_billed_by
					, tx.mark_as_billed_date
					, tx.mark_as_billed_comment
					, tx.transaction_type_group
					, 2 as skip_bit
				from #local_transactions tx with (nolock)
				left join #local_transactions revtx with (nolock) on tx.reversing_tx_id = revtx.transaction_id and tx.bill_date = revtx.bill_date and 
					tx.generated_date = revtx.generated_date
				WHERE tx.contact_id > -2.1 and 
					((((tx.amount + isnull(revtx.amount,0)) <> 0 and revtx.reversing_tx_id is not null) or revtx.reversing_tx_id is null))

				delete from #local_transactions where skip_bit = 1 and contact_id >-2.1  
				update #local_transactions set skip_bit = 1 where skip_bit = 2 and contact_id >-2.1  
			end

	if @vOtherStatementsIncluded = 1
		begin
			insert into #local_transactions
	
				select tx.invoice_id
					, tx.contact_id
					, tx.batch_id
					, tx.entry_number
					, tx.client_id
					, tx.auto_generated
					, tx.transaction_id
					, tx.reversing_tx_id
					, tx.distribution_tx_id
					, tx.applied_payment_id
					, tx.payer_id
					, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
					, tx.days_account_id
					, tx.dollars_account_id
					, tx.fac_id
					, tx.is_billed
					, tx.transaction_type
					, tx.parent_tx_type
					, tx.[description]
					, tx.alt_description
					, tx.cheque_number
					, tx.effective_date
					, tx.transaction_date
					, tx.bill_date
					, tx.applied_date
					, tx.generated_date
					, tx.days_amount
					, tx.daily_rate
					, tx.monthly_rate
					, tx.amount + isnull(revtx.amount,0)
					, tx.care_level
					, tx.revenue_code
					, tx.hcpcs_code	
					, tx.item_type_id
					, tx.comment
					, tx.rate_type_id
					, tx.rugs_modifier
					, tx.medicare_day
					, tx.mppr_flag
					, tx.mark_as_billed_by
					, tx.mark_as_billed_date
					, tx.mark_as_billed_comment
					, tx.transaction_type_group
					, 2 as skip_bit
				from #local_transactions tx with (nolock)
				left join #local_transactions revtx with (nolock) on tx.reversing_tx_id = revtx.transaction_id and tx.bill_date = revtx.bill_date and 
					tx.generated_date = revtx.generated_date and tx.invoice_id = revtx.invoice_id
				WHERE tx.contact_id <= -2.1 and 
					((((tx.amount + isnull(revtx.amount,0)) <> 0 and revtx.reversing_tx_id is not null) or revtx.reversing_tx_id is null))

				delete from #local_transactions where skip_bit = 1 and contact_id <=-2.1  
				update #local_transactions set skip_bit = 1 where skip_bit = 2 and contact_id <=-2.1  
			end
		
		set @vgsStepEndTime=GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms' 
	end

if @vPrivateStatementsIncluded = 1
	begin
		if @vCombineChildren > 0
			begin

				Select @vStep = 110;
				set @vgsStepStartTime = GETDATE()
				if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Combining Private Child Transactions ' + convert(varchar(26),getdate(),109);

			if @vCombineChildren = 1
				begin

					insert into #child_transactions
					select 	  ctx.distribution_tx_id
							--, ctx.transaction_type
							, '' AS transaction_type
							, ctx.parent_tx_type
							, ctx.contact_id 
							, 0 as invoice_id
							, ctx.payer_id
							, sum(ctx.days_amount)
							, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
							, sum(ctx.monthly_rate)
							, sum(ctx.amount)
							, ctx.bill_date
							,ctx.generated_date
							, 0
					from #local_transactions ctx
					inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and anctx.payer_id = ctx.payer_id and ctx.contact_id = anctx.contact_id
					where  ctx.contact_id > -2.1 and anctx.contact_id > -2.1 and ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type
						and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900') and isnull(ctx.generated_date,'1/1/1900') = isnull(anctx.generated_date,'1/1/1900')
					group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.generated_date
					order by 1

					insert into #local_transactions
	
					select tx.invoice_id
						, tx.contact_id
						, tx.batch_id
						, tx.entry_number
						, tx.client_id
						, tx.auto_generated
						, tx.transaction_id
						, tx.reversing_tx_id
						, tx.distribution_tx_id
						, tx.applied_payment_id
						, tx.payer_id
						, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
						, tx.days_account_id
						, tx.dollars_account_id
						, tx.fac_id
						, tx.is_billed
						, tx.transaction_type
						, tx.parent_tx_type
						, tx.[description]
						, tx.alt_description
						, tx.cheque_number
						, tx.effective_date
						, tx.transaction_date
						, tx.bill_date
						, tx.applied_date
						, tx.generated_date
						, tx.days_amount
						, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
						, Null as monthly_rate
						, tx.amount + isnull(txca.amount,0) as amount
						, tx.care_level				
						, tx.revenue_code
						, tx.hcpcs_code	
						, tx.item_type_id
						, tx.comment
						, tx.rate_type_id
						, tx.rugs_modifier
						, tx.medicare_day
						, tx.mppr_flag
						, tx.mark_as_billed_by
						, tx.mark_as_billed_date
						, tx.mark_as_billed_comment
						, tx.transaction_type_group
						, 0
					from #local_transactions tx with (nolock)
					inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') 
						and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900') and tx.contact_id = txca.contact_id
						and tx.payer_id = txca.payer_id and tx.contact_id > -2.1

					-- recurring ancillary txns that have contractual adjustments: update daily_rate and days_amount so they can be consolidated later
					update tx 
					set tx.days_amount = Case when @vCombineRecurringAncillary = 1 and txca.daily_rate < 0 then (tx.days_amount - isnull(txca.days_amount,0)) else tx.days_amount end 
					,tx.daily_rate= Case when @vCombineRecurringAncillary = 1 and txca.daily_rate < 0 then (txca.daily_rate * -1) else tx.daily_rate end 
					from #local_transactions tx with (nolock)
					inner join #child_transactions txca with (nolock) 
						on tx.distribution_tx_id = txca.distribution_tx_id and txca.parent_tx_type='A' 		
					where tx.skip_bit=0 
					and tx.amount > 0			-- orig txn amount less Contractual Adj amount > 0
					and tx.auto_generated='R'	-- recurring ancillary


					delete tx 
					from #local_transactions tx
					inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id and tx.payer_id = parent.payer_id and tx.contact_id = parent.contact_id	
					inner join #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
						and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900')  and tx.contact_id = txca.contact_id
					where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.contact_id > -2.1 and parent.contact_id > -2.1

					delete tx 
					from #local_transactions tx
					inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id = parent.contact_id	
					where tx.skip_bit = 1 and parent.skip_bit = 0 and tx.contact_id > -2.1 and parent.contact_id > -2.1

		--********************************************************** children on different payer than parent
					delete from #child_transactions

					insert into #child_transactions
					select 	  ctx.distribution_tx_id
							--, ctx.transaction_type
							, '' AS transaction_type
							, ctx.parent_tx_type
							, ctx.contact_id 
							, 0 as invoice_id
							, ctx.payer_id
							, sum(ctx.days_amount)
							, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
							, sum(ctx.monthly_rate)
							, sum(ctx.amount)
							, ctx.bill_date
							,ctx.generated_date
							, 0
					from #local_transactions ctx
					inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and anctx.payer_id <> ctx.payer_id and ctx.contact_id = anctx.contact_id 
					where   ctx.contact_id > -2.1 and anctx.contact_id > -2.1 and ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type
					group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.generated_date
					order by 1

					insert into #local_transactions
	
					select tx.invoice_id
						, tx.contact_id
						, tx.batch_id
						, tx.entry_number
						, tx.client_id
						, tx.auto_generated
						, tx.transaction_id
						, tx.reversing_tx_id
						, tx.distribution_tx_id
						, tx.applied_payment_id
						, txca.payer_id
						, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
						, tx.days_account_id
						, tx.dollars_account_id
						, tx.fac_id
						, tx.is_billed
						, tx.transaction_type
						, tx.parent_tx_type
						, tx.[description]
						, tx.alt_description
						, tx.cheque_number
						, tx.effective_date
						, tx.transaction_date
						, txca.bill_date
						, tx.applied_date
						, tx.generated_date
						, tx.days_amount
						, isnull(txca.daily_rate,0) as daily_rate
						, Null as monthly_rate
						, isnull(txca.amount,0) as amount
						, tx.care_level				
						, tx.revenue_code
						, tx.hcpcs_code	
						, tx.item_type_id
						, tx.comment
						, tx.rate_type_id
						, tx.rugs_modifier
						, tx.medicare_day
						, tx.mppr_flag
						, tx.mark_as_billed_by
						, tx.mark_as_billed_date
						, tx.mark_as_billed_comment
						, tx.transaction_type_group
						, 0
					from #local_transactions tx with (nolock)
					inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id --and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
						and tx.payer_id <> txca.payer_id and tx.contact_id > -2.1 and tx.contact_id = txca.contact_id

					delete tx 
					from #local_transactions tx
					inner join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id--and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
					where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.contact_id > -2.1

		--********************************************************** 
				end

				if @vCombineChildren = 2
				begin
					insert into #child_transactions
					select 	  ctx.distribution_tx_id
							, '' AS transaction_type
							, ctx.parent_tx_type
							, ctx.contact_id 
							, 0 as invoice_id
							, ctx.payer_id
							, sum(ctx.days_amount)
							, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
							, sum(ctx.monthly_rate)
							, sum(ctx.amount)
							, ctx.bill_date
							, ctx.generated_date
							, 0
					from #local_transactions ctx
					inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and ctx.payer_id = anctx.payer_id and ctx.contact_id = anctx.contact_id
					where  ctx.contact_id > -2.1 and anctx.contact_id > -2.1 and ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type and ctx.transaction_type in('CR', 'CA')
						and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900') and isnull(ctx.generated_date,'1/1/1900') = isnull(anctx.generated_date,'1/1/1900')
					group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.generated_date
					order by 1

					insert into #local_transactions
	
					select tx.invoice_id
						, tx.contact_id
						, tx.batch_id
						, tx.entry_number
						, tx.client_id
						, tx.auto_generated
						, tx.transaction_id
						, tx.reversing_tx_id
						, tx.distribution_tx_id
						, tx.applied_payment_id
						, tx.payer_id
						, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
						, tx.days_account_id
						, tx.dollars_account_id
						, tx.fac_id
						, tx.is_billed
						, tx.transaction_type
						, tx.parent_tx_type
						, tx.[description]
						, tx.alt_description
						, tx.cheque_number
						, tx.effective_date
						, tx.transaction_date
						, tx.bill_date
						, tx.applied_date
						, tx.generated_date
						, tx.days_amount
						, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
						, Null as monthly_rate
						, tx.amount + isnull(txca.amount,0) as amount
						, tx.care_level				
						, tx.revenue_code
						, tx.hcpcs_code	
						, tx.item_type_id
						, tx.comment
						, tx.rate_type_id
						, tx.rugs_modifier
						, tx.medicare_day
						, tx.mppr_flag
						, tx.mark_as_billed_by
						, tx.mark_as_billed_date
						, tx.mark_as_billed_comment
						, tx.transaction_type_group
						, 0
					from #local_transactions tx with (nolock)
					inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
						and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900')
						and tx.payer_id = txca.payer_id and tx.contact_id > -2.1 and tx.contact_id = txca.contact_id

					-- recurring ancillary txns that have contractual adjustments: update daily_rate and days_amount so they can be consolidated later
					update tx 
					set tx.days_amount = Case when @vCombineRecurringAncillary = 1 and txca.daily_rate < 0 then (tx.days_amount - isnull(txca.days_amount,0)) else tx.days_amount end 
					,tx.daily_rate= Case when @vCombineRecurringAncillary = 1 and txca.daily_rate < 0 then (txca.daily_rate * -1) else tx.daily_rate end 
					from #local_transactions tx with (nolock)
					inner join #child_transactions txca with (nolock) 
						on tx.distribution_tx_id = txca.distribution_tx_id and txca.parent_tx_type='A' 		
					where tx.skip_bit=0 
					and tx.amount > 0			-- orig txn amount less Contractual Adj amount > 0
					and tx.auto_generated='R'	-- recurring ancillary

					delete tx 
					from #local_transactions tx
					inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id and tx.payer_id = parent.payer_id and tx.contact_id = parent.contact_id		
					inner join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
						and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900') and tx.contact_id = txca.contact_id
					where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.transaction_type in('CR', 'CA') and tx.contact_id > -2.1

					delete tx 
					from #local_transactions tx
					inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id = parent.contact_id	
					where tx.skip_bit = 1 and parent.skip_bit = 0 and tx.contact_id > -2.1 and parent.contact_id > -2.1

				end

				set @vgsStepEndTime=GETDATE()
				if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
			end
		end

if @vOtherStatementsIncluded = 1
	begin
		if @vCombineChildren > 0
			begin

				Select @vStep = 112;
				set @vgsStepStartTime = GETDATE()
				if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Combining Other Child Transactions ' + convert(varchar(26),getdate(),109);

			if @vCombineChildren = 1
				begin

					insert into #child_transactions
					select 	  ctx.distribution_tx_id
							--, ctx.transaction_type
							, '' AS transaction_type
							, ctx.parent_tx_type
							, ctx.contact_id 
							, ctx.invoice_id
							, ctx.payer_id
							, sum(ctx.days_amount)
							, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
							, sum(ctx.monthly_rate)
							, sum(ctx.amount)
							, ctx.bill_date
							, ctx.generated_date
							, 0
					from #local_transactions ctx
					inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and anctx.payer_id = ctx.payer_id and ctx.contact_id = anctx.contact_id
					where  ctx.contact_id <= -2.1 and anctx.contact_id <= -2.1 and ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type
						and ctx.invoice_id = anctx.invoice_id
					group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.invoice_id, ctx.generated_date
					order by 1

					insert into #local_transactions
	
					select tx.invoice_id
						, tx.contact_id
						, tx.batch_id
						, tx.entry_number
						, tx.client_id
						, tx.auto_generated
						, tx.transaction_id
						, tx.reversing_tx_id
						, tx.distribution_tx_id
						, tx.applied_payment_id
						, tx.payer_id
						, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
						, tx.days_account_id
						, tx.dollars_account_id
						, tx.fac_id
						, tx.is_billed
						, tx.transaction_type
						, tx.parent_tx_type
						, tx.[description]
						, tx.alt_description
						, tx.cheque_number
						, tx.effective_date
						, tx.transaction_date
						, tx.bill_date
						, tx.applied_date
						, tx.generated_date
						, tx.days_amount
						, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
						, Null as monthly_rate
						, tx.amount + isnull(txca.amount,0) as amount
						, tx.care_level				
						, tx.revenue_code
						, tx.hcpcs_code	
						, tx.item_type_id
						, tx.comment
						, tx.rate_type_id
						, tx.rugs_modifier
						, tx.medicare_day
						, tx.mppr_flag
						, tx.mark_as_billed_by
						, tx.mark_as_billed_date
						, tx.mark_as_billed_comment
						, tx.transaction_type_group
						, 0
					from #local_transactions tx with (nolock)
					inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') 
						and tx.invoice_id = txca.invoice_id and tx.payer_id = txca.payer_id and tx.contact_id <= -2.1 and tx.contact_id = txca.contact_id

					-- recurring ancillary txns that have contractual adjustments: update daily_rate and days_amount so they can be consolidated later
					update tx 
					set tx.days_amount = Case when @vCombineRecurringAncillary = 1 and txca.daily_rate < 0 then (tx.days_amount - isnull(txca.days_amount,0)) else tx.days_amount end 
					,tx.daily_rate= Case when @vCombineRecurringAncillary = 1 and txca.daily_rate < 0 then (txca.daily_rate * -1) else tx.daily_rate end 
					from #local_transactions tx with (nolock)
					inner join #child_transactions txca with (nolock) 
						on tx.distribution_tx_id = txca.distribution_tx_id and txca.parent_tx_type='A' 		
					where tx.skip_bit=0 
					and tx.amount > 0			-- orig txn amount less Contractual Adj amount > 0
					and tx.auto_generated='R'	-- recurring ancillary

					delete tx 
					from #local_transactions tx
					inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id and tx.payer_id = parent.payer_id and tx.contact_id = parent.contact_id		
					inner join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
						and tx.invoice_id = txca.invoice_id  and tx.contact_id = txca.contact_id
					where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.contact_id <= -2.1 and parent.contact_id <= -2.1

					delete tx 
					from #local_transactions tx
					inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id = parent.contact_id	
					where tx.skip_bit = 1 and parent.skip_bit = 0 and tx.contact_id <= -2.1 and parent.contact_id <= -2.1

				end

				if @vCombineChildren = 2
				begin
					insert into #child_transactions
					select 	  ctx.distribution_tx_id
							, '' AS transaction_type
							, ctx.parent_tx_type
							, ctx.contact_id 
							, ctx.invoice_id
							, ctx.payer_id
							, sum(ctx.days_amount)
							, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
							, sum(ctx.monthly_rate)
							, sum(ctx.amount)
							, ctx.bill_date
							, ctx.generated_date
							, 0
					from #local_transactions ctx
					inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and ctx.payer_id = anctx.payer_id and ctx.contact_id = anctx.contact_id
					where  ctx.contact_id <= -2.1 and anctx.contact_id <= -2.1 and ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type and ctx.transaction_type in('CR', 'CA')
						and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900') and ctx.invoice_id = anctx.invoice_id
					group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.invoice_id, ctx.generated_date
					order by 1

					insert into #local_transactions
	
					select tx.invoice_id
						, tx.contact_id
						, tx.batch_id
						, tx.entry_number
						, tx.client_id
						, tx.auto_generated
						, tx.transaction_id
						, tx.reversing_tx_id
						, tx.distribution_tx_id
						, tx.applied_payment_id
						, tx.payer_id
						, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
						, tx.days_account_id
						, tx.dollars_account_id
						, tx.fac_id
						, tx.is_billed
						, tx.transaction_type
						, tx.parent_tx_type
						, tx.[description]
						, tx.alt_description
						, tx.cheque_number
						, tx.effective_date
						, tx.transaction_date
						, tx.bill_date
						, tx.applied_date
						, tx.generated_date
						, tx.days_amount
						, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
						, Null as monthly_rate
						, tx.amount + isnull(txca.amount,0) as amount
						, tx.care_level				
						, tx.revenue_code
						, tx.hcpcs_code	
						, tx.item_type_id
						, tx.comment
						, tx.rate_type_id
						, tx.rugs_modifier
						, tx.medicare_day
						, tx.mppr_flag
						, tx.mark_as_billed_by
						, tx.mark_as_billed_date
						, tx.mark_as_billed_comment
						, tx.transaction_type_group
						, 0
					from #local_transactions tx with (nolock)
					inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
						and tx.invoice_id = txca.invoice_id	and tx.payer_id = txca.payer_id and tx.contact_id <= -2.1 and tx.contact_id = txca.contact_id

					-- recurring ancillary txns that have contractual adjustments: update daily_rate and days_amount so they can be consolidated later
					update tx 
					set tx.days_amount = Case when @vCombineRecurringAncillary = 1 and txca.daily_rate < 0 then (tx.days_amount - isnull(txca.days_amount,0)) else tx.days_amount end 
					,tx.daily_rate= Case when @vCombineRecurringAncillary = 1 and txca.daily_rate < 0 then (txca.daily_rate * -1) else tx.daily_rate end 
					from #local_transactions tx with (nolock)
					inner join #child_transactions txca with (nolock) 
						on tx.distribution_tx_id = txca.distribution_tx_id and txca.parent_tx_type='A' 		
					where tx.skip_bit=0 
					and tx.amount > 0			-- orig txn amount less Contractual Adj amount > 0
					and tx.auto_generated='R'	-- recurring ancillary

					delete tx 
					from #local_transactions tx
					inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id and tx.payer_id = parent.payer_id and tx.contact_id = parent.contact_id		
					inner join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
						and tx.invoice_id = txca.invoice_id and tx.contact_id = txca.contact_id
					where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.transaction_type in('CR', 'CA') and tx.contact_id <= -2.1 and parent.contact_id <= -2.1

					delete tx 
					from #local_transactions tx
					inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id = parent.contact_id		
					where tx.skip_bit = 1 and parent.skip_bit = 0 and tx.contact_id <= -2.1 and parent.contact_id <= -2.1

				end

				set @vgsStepEndTime=GETDATE()
				if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
			end
		end

--for ancillary charges that we are grouping, and the parent transaction doesn't exist, we want to ensure the group correctly
if @vShowResults = 'A' or @vShowResults = 'C' or @vShowResults = 'CC' or @vShowResults = 'R'
	begin

		Select @vStep = 115;
		set @vgsStepStartTime = GETDATE()
		if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' @vShowResults in(A,C,CC,R) - Combining Ancillary Child Transactions to parent not in the dataset ' + convert(varchar(26),getdate(),109);

		if @vPrivateStatementsIncluded = 1
		begin
			-- insert empty parent anicillary charge to roll children into - need this because the parent contains the charge code info
			insert into #local_transactions
	
			select distinct lcltx.invoice_id
				, lcltx.contact_id
				, tx.batch_id
				, tx.entry_number
				, tx.client_id
				--, 'N' as auto_generated
				, isnull(tx.auto_generated,'N')
				, tx.transaction_id
				, tx.reversing_tx_id
				, tx.distribution_tx_id
				, 0 as applied_payment_id
				, lcltx.payer_id
				, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id		
				, lcltx.days_account_id
				, lcltx.dollars_account_id
				, tx.fac_id
				, tx.is_billed
				, tx.transaction_type
				, tx.parent_tx_type
				, tx.[description]
				, tx.alt_description
				, tx.cheque_number
				, tx.effective_date
				, tx.transaction_date
				, lcltx.bill_date
				, Null as applied_date
				, lcltx.generated_date
				, tx.days_amount
				, 0 as daily_rate
				, Null as monthly_rate
				, 0 as amount
				, tx.care_level
				, tx.revenue_code
				, tx.hcpcs_code		
				, tx.item_type_id
				, tx.comment
				, tx.rate_type_id
				, tx.rugs_modifier
				, tx.medicare_day
				, tx.mppr_flag
				, tx.mark_as_billed_by
				, tx.mark_as_billed_date
				, tx.mark_as_billed_comment
				, Case when (tx.transaction_type in('r','dr','cl','cr','d')
					or ((tx.transaction_type = 'co'or tx.transaction_type = 'cw')
					and tx.auto_generated = 'y') or (tx.transaction_type = 'xr' 
					and tx.parent_tx_type = 'r')) then 1 
					when tx.transaction_type = 'c' then 3 
					else 2 end as transaction_type_group
				, 5
			from #local_transactions lcltx with (nolock)
			left join #local_transactions ntx on lcltx.distribution_tx_id = ntx.transaction_id and lcltx.parent_tx_type = 'A' and ntx.contact_id >-2.1
				and ntx.distribution_tx_id = ntx.transaction_id and lcltx.contact_id = ntx.contact_id 
			inner join dbo.ar_transactions tx with (nolock) on lcltx.distribution_tx_id = tx.transaction_id and lcltx.parent_tx_type = 'A'  
			where lcltx.contact_id >-2.1 and lcltx.parent_tx_type = 'A' and ntx.transaction_id is null and lcltx.payer_id = tx.payer_id

			delete from #child_transactions

			insert into #child_transactions
			select 	  ctx.distribution_tx_id
					--, ctx.transaction_type
					, '' AS transaction_type
					, ctx.parent_tx_type
					, ctx.contact_id 
					, 0 as invoice_id
					, ctx.payer_id
					, sum(ctx.days_amount)
					, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
					, sum(ctx.monthly_rate)
					, sum(ctx.amount)
					, ctx.bill_date
					, ctx.generated_date
					, 0
			from #local_transactions ctx
			inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and ctx.payer_id = anctx.payer_id and anctx.transaction_type = 'A' and anctx.skip_bit = 5
				and ctx.contact_id = anctx.contact_id 
			where  ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type
				and ctx.contact_id >-2.1 and anctx.contact_id >-2.1 
				and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900') and isnull(ctx.generated_date,'1/1/1900') = isnull(anctx.generated_date,'1/1/1900')
			group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.generated_date
			order by 1

			insert into #local_transactions
			select tx.invoice_id
				, tx.contact_id
				, tx.batch_id
				, tx.entry_number
				, tx.client_id
				, tx.auto_generated
				, tx.transaction_id
				, tx.reversing_tx_id
				, tx.distribution_tx_id
				, tx.applied_payment_id
				, tx.payer_id
				, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
				, tx.days_account_id
				, tx.dollars_account_id
				, tx.fac_id
				, tx.is_billed
				, tx.transaction_type
				, tx.parent_tx_type
				, tx.[description]
				, tx.alt_description
				, tx.cheque_number
				, tx.effective_date
				, tx.transaction_date
				, tx.bill_date
				, tx.applied_date
				, tx.generated_date
				, tx.days_amount
				--, tx.days_amount + isnull(txca.days_amount,0) as days_amount
				, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
				, Null as monthly_rate
				, tx.amount + isnull(txca.amount,0) as amount
				, tx.care_level
				, tx.revenue_code
				, tx.hcpcs_code		
				, tx.item_type_id
				, tx.comment
				, tx.rate_type_id
				, tx.rugs_modifier
				, tx.medicare_day
				, tx.mppr_flag
				, tx.mark_as_billed_by
				, tx.mark_as_billed_date
				, tx.mark_as_billed_comment
				, tx.transaction_type_group
				, 0
			from #local_transactions tx with (nolock)
			inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and tx.contact_id = txca.contact_id
				and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900')
			where tx.skip_bit = 5 and tx.contact_id >-2.1 

			--********************************************************** children on different payer than parent
	-- insert empty parent anicillary charge to roll children into - need this because the parent contains the charge code info
			insert into #local_transactions
	
			select distinct lcltx.invoice_id
				, lcltx.contact_id
				, tx.batch_id
				, tx.entry_number
				, tx.client_id
				--, 'N' as auto_generated
				, isnull(tx.auto_generated,'N')
				, tx.transaction_id
				, tx.reversing_tx_id
				, tx.distribution_tx_id
				, 0 as applied_payment_id
				, lcltx.payer_id
				, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
				, lcltx.days_account_id
				, lcltx.dollars_account_id
				, tx.fac_id
				, tx.is_billed
				, tx.transaction_type
				, tx.parent_tx_type
				, tx.[description]
				, tx.alt_description
				, tx.cheque_number
				, tx.effective_date
				, tx.transaction_date
				, lcltx.bill_date
				, Null as applied_date
				, lcltx.generated_date
				, tx.days_amount
				, 0 as daily_rate
				, Null as monthly_rate
				, 0 as amount
				, tx.care_level
				, tx.revenue_code
				, tx.hcpcs_code		
				, tx.item_type_id
				, tx.comment
				, tx.rate_type_id
				, tx.rugs_modifier
				, tx.medicare_day
				, tx.mppr_flag
				, tx.mark_as_billed_by
				, tx.mark_as_billed_date
				, tx.mark_as_billed_comment
				, Case when (tx.transaction_type in('r','dr','cl','cr','d')
					or ((tx.transaction_type = 'co'or tx.transaction_type = 'cw')
					and tx.auto_generated = 'y') or (tx.transaction_type = 'xr' 
					and tx.parent_tx_type = 'r')) then 1 
					when tx.transaction_type = 'c' then 3 
					else 2 end as transaction_type_group
				, 5
			from #local_transactions lcltx with (nolock)
			left join #local_transactions ntx on lcltx.distribution_tx_id = ntx.transaction_id and lcltx.parent_tx_type = 'A' and ntx.contact_id >-2.1 
				and ntx.distribution_tx_id = ntx.transaction_id and lcltx.payer_id <> ntx.payer_id and lcltx.contact_id = ntx.contact_id
			inner join dbo.ar_transactions tx with (nolock) on lcltx.distribution_tx_id = tx.transaction_id and lcltx.parent_tx_type = 'A'  
			where lcltx.parent_tx_type = 'A' and ntx.transaction_id is null and lcltx.payer_id <> tx.payer_id and lcltx.contact_id >-2.1  

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id 	and tx.contact_id = parent.contact_id
			left join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and tx.contact_id = txca.contact_id
			where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.contact_id >-2.1  and parent.contact_id >-2.1 
			and txca.distribution_tx_id is not null and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900')
			and tx.contact_id >-2.1  and parent.contact_id >-2.1 

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id = parent.contact_id
			where tx.skip_bit = 1 and parent.skip_bit = 0 and isnull(tx.bill_date,'1/1/1900') = isnull(parent.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(parent.generated_date,'1/1/1900')
				and tx.contact_id >-2.1  and parent.contact_id >-2.1 

			delete from #child_transactions

			insert into #child_transactions
			select 	  ctx.distribution_tx_id
					--, ctx.transaction_type
					, '' AS transaction_type
					, ctx.parent_tx_type
					, ctx.contact_id 
					, 0 as invoice_id
					, ctx.payer_id
					, sum(ctx.days_amount)
					, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
					, sum(ctx.monthly_rate)
					, sum(ctx.amount)
					, ctx.bill_date
					, ctx.generated_date
					, 0
			from #local_transactions ctx
			inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and ctx.contact_id = anctx.contact_id
				and anctx.transaction_type = 'A' and anctx.skip_bit = 5
			where  ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type and ctx.contact_id >-2.1  and anctx.contact_id >-2.1 
				--and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900')
			group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.generated_date
			order by 1 

			insert into #local_transactions
	
			select tx.invoice_id
				, tx.contact_id
				, tx.batch_id
				, tx.entry_number
				, tx.client_id
				, tx.auto_generated
				, tx.transaction_id
				, tx.reversing_tx_id
				, tx.distribution_tx_id
				, tx.applied_payment_id
				, txca.payer_id
				, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
				, tx.days_account_id
				, tx.dollars_account_id
				, tx.fac_id
				, tx.is_billed
				--, tx.transaction_type
				, 'A' as transaction_type
				, tx.parent_tx_type
				, tx.[description]
				, tx.alt_description
				, tx.cheque_number
				, tx.effective_date
				, tx.transaction_date
				, txca.bill_date
				, tx.applied_date
				, tx.generated_date
				, tx.days_amount
				, isnull(txca.daily_rate,0) as daily_rate
				, Null as monthly_rate
				, isnull(txca.amount,0) as amount
				, tx.care_level				
				, tx.revenue_code
				, tx.hcpcs_code	
				, tx.item_type_id
				, tx.comment
				, tx.rate_type_id
				, tx.rugs_modifier
				, tx.medicare_day
				, tx.mppr_flag
				, tx.mark_as_billed_by
				, tx.mark_as_billed_date
				, tx.mark_as_billed_comment
				, tx.transaction_type_group
				, 0
			from #local_transactions tx with (nolock)
			inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id  and tx.contact_id = txca.contact_id--and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
				--and tx.payer_id <> txca.payer_id
			where tx.skip_bit = 5

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id and tx.contact_id = parent.contact_id
			left join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and tx.contact_id = txca.contact_id 
			where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.contact_id >-2.1  and parent.contact_id >-2.1 
			and txca.distribution_tx_id is not null and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900')

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id = parent.contact_id
			where tx.skip_bit = 1 and parent.skip_bit = 0 and isnull(tx.bill_date,'1/1/1900') = isnull(parent.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(parent.generated_date,'1/1/1900')
			and tx.contact_id >-2.1  and parent.contact_id >-2.1 
	
			delete from #local_transactions where skip_bit=5	
		end

		if @vOtherStatementsIncluded = 1
		begin
			-- insert empty parent anicillary charge to roll children into - need this because the parent contains the charge code info
			insert into #local_transactions
	
			select distinct lcltx.invoice_id
				, lcltx.contact_id
				, tx.batch_id
				, tx.entry_number
				, tx.client_id
				--, 'N' as auto_generated
				, isnull(tx.auto_generated,'N')
				, tx.transaction_id
				, tx.reversing_tx_id
				, tx.distribution_tx_id
				, 0 as applied_payment_id
				, lcltx.payer_id
				, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
				, lcltx.days_account_id
				, lcltx.dollars_account_id
				, tx.fac_id
				, tx.is_billed
				, tx.transaction_type
				, tx.parent_tx_type
				, tx.[description]
				, tx.alt_description
				, tx.cheque_number
				, tx.effective_date
				, tx.transaction_date
				, lcltx.bill_date
				, Null as applied_date
				, lcltx.generated_date
				, tx.days_amount
				, 0 as daily_rate
				, Null as monthly_rate
				, 0 as amount
				, tx.care_level
				, tx.revenue_code
				, tx.hcpcs_code		
				, tx.item_type_id
				, tx.comment
				, tx.rate_type_id
				, tx.rugs_modifier
				, tx.medicare_day
				, tx.mppr_flag
				, tx.mark_as_billed_by
				, tx.mark_as_billed_date
				, tx.mark_as_billed_comment
				, Case when (tx.transaction_type in('r','dr','cl','cr','d')
					or ((tx.transaction_type = 'co'or tx.transaction_type = 'cw')
					and tx.auto_generated = 'y') or (tx.transaction_type = 'xr' 
					and tx.parent_tx_type = 'r')) then 1 
					when tx.transaction_type = 'c' then 3 
					else 2 end as transaction_type_group
				, 5
			from #local_transactions lcltx with (nolock)
			left join #local_transactions ntx on lcltx.distribution_tx_id = ntx.transaction_id and lcltx.parent_tx_type = 'A' and ntx.contact_id <= -2.1
				and ntx.distribution_tx_id = ntx.transaction_id and lcltx.contact_id = ntx.contact_id and lcltx.invoice_id = ntx.invoice_id 
			inner join dbo.ar_transactions tx with (nolock) on lcltx.distribution_tx_id = tx.transaction_id and lcltx.parent_tx_type = 'A'  
			where lcltx.contact_id <= -2.1 and lcltx.parent_tx_type = 'A' and ntx.transaction_id is null and lcltx.payer_id = tx.payer_id

			delete from #child_transactions

			insert into #child_transactions
			select 	  ctx.distribution_tx_id
					--, ctx.transaction_type
					, '' AS transaction_type
					, ctx.parent_tx_type
					, ctx.contact_id 
					, ctx.invoice_id
					, ctx.payer_id
					, sum(ctx.days_amount)
					, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
					, sum(ctx.monthly_rate)
					, sum(ctx.amount)
					, ctx.bill_date
					, ctx.generated_date
					, 0
			from #local_transactions ctx
			inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and ctx.payer_id = anctx.payer_id and anctx.transaction_type = 'A' and anctx.skip_bit = 5
				and ctx.contact_id = anctx.contact_id and ctx.invoice_id = anctx.invoice_id
			where  ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type
				and ctx.contact_id <= -2.1 and anctx.contact_id <= -2.1 
				and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900') 
			group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.invoice_id, ctx.generated_date
			order by 1

			insert into #local_transactions
			select tx.invoice_id
				, tx.contact_id
				, tx.batch_id
				, tx.entry_number
				, tx.client_id
				, tx.auto_generated
				, tx.transaction_id
				, tx.reversing_tx_id
				, tx.distribution_tx_id
				, tx.applied_payment_id
				, tx.payer_id
				, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
				, tx.days_account_id
				, tx.dollars_account_id
				, tx.fac_id
				, tx.is_billed
				, tx.transaction_type
				, tx.parent_tx_type
				, tx.[description]
				, tx.alt_description
				, tx.cheque_number
				, tx.effective_date
				, tx.transaction_date
				, tx.bill_date
				, tx.applied_date
				, tx.generated_date
				, tx.days_amount
				--, tx.days_amount + isnull(txca.days_amount,0) as days_amount
				, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
				, Null as monthly_rate
				, tx.amount + isnull(txca.amount,0) as amount
				, tx.care_level
				, tx.revenue_code
				, tx.hcpcs_code		
				, tx.item_type_id
				, tx.comment
				, tx.rate_type_id
				, tx.rugs_modifier
				, tx.medicare_day
				, tx.mppr_flag
				, tx.mark_as_billed_by
				, tx.mark_as_billed_date
				, tx.mark_as_billed_comment
				, tx.transaction_type_group
				, 0
			from #local_transactions tx with (nolock)
			inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id
				and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') and tx.invoice_id = txca.invoice_id and tx.contact_id = txca.contact_id 
			where tx.skip_bit = 5 and tx.contact_id <= -2.1 

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id and tx.contact_id = parent.contact_id and tx.invoice_id = parent.invoice_id
			left join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and tx.invoice_id = txca.invoice_id and tx.contact_id = txca.contact_id
			where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.contact_id <= 2  and parent.contact_id <= -2.1 
			and txca.distribution_tx_id is not null and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id = parent.contact_id
				and tx.invoice_id = parent.invoice_id
			where tx.skip_bit = 1 and parent.skip_bit = 0 and isnull(tx.bill_date,'1/1/1900') = isnull(parent.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(parent.generated_date,'1/1/1900')
			and tx.contact_id <= -2.1  and parent.contact_id <= -2.1 
	
			delete from #local_transactions where skip_bit=5	
		end

--********************************************************** 

		set @vgsStepEndTime=GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

		if @vCombineChildren = 0 --need to summarize ancillaries that have a parent and combine children was not selected
			begin
				if @vPrivateStatementsIncluded = 1
					begin
							Select @vStep = 120;
							set @vgsStepStartTime = GETDATE()
							if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' @vShowResults in(A,C,CC,R) - Combining Children not selected - Combine Ancillary Child Transactions to parent ' + convert(varchar(26),getdate(),109);

							delete from #child_transactions --eliminate the missing parent ones

							insert into #child_transactions
							select 	  ctx.distribution_tx_id
									--, ctx.transaction_type
									, '' AS transaction_type
									, ctx.parent_tx_type
									, ctx.contact_id 
									, 0 as invoice_id
									, ctx.payer_id
									, sum(ctx.days_amount)
									, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
									, sum(ctx.monthly_rate)
									, sum(ctx.amount)
									, ctx.bill_date
									, ctx.generated_date
									, 0
							from #local_transactions ctx
							inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and ctx.payer_id = anctx.payer_id and anctx.transaction_type = 'A' and anctx.skip_bit <> 5 and ctx.contact_id = anctx.contact_id
							where  ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type and ctx.contact_id >-2.1  and anctx.contact_id >-2.1 
								and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900') and isnull(ctx.generated_date,'1/1/1900') = isnull(anctx.generated_date,'1/1/1900')
							group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.generated_date
							order by 1

							insert into #local_transactions
							select tx.invoice_id
								, tx.contact_id
								, tx.batch_id
								, tx.entry_number
								, tx.client_id
								, tx.auto_generated
								, tx.transaction_id
								, tx.reversing_tx_id
								, tx.distribution_tx_id
								, tx.applied_payment_id
								, tx.payer_id
								, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
								, tx.days_account_id
								, tx.dollars_account_id
								, tx.fac_id
								, tx.is_billed
								, tx.transaction_type
								, tx.parent_tx_type
								, tx.[description]
								, tx.alt_description
								, tx.cheque_number
								, tx.effective_date
								, tx.transaction_date
								, tx.bill_date
								, tx.applied_date
								, tx.generated_date
								, tx.days_amount
								--, tx.days_amount + isnull(txca.days_amount,0) as days_amount
								, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
								, Null as monthly_rate
								, tx.amount + isnull(txca.amount,0) as amount
								, tx.care_level
								, tx.revenue_code
								, tx.hcpcs_code		
								, tx.item_type_id
								, tx.comment
								, tx.rate_type_id
								, tx.rugs_modifier
								, tx.medicare_day
								, tx.mppr_flag
								, tx.mark_as_billed_by
								, tx.mark_as_billed_date
								, tx.mark_as_billed_comment
								, tx.transaction_type_group
								, 0
							from #local_transactions tx with (nolock)
							inner join dbo.ar_payers payr with (nolock) on tx.payer_id = payr.payer_id and tx.fac_id = payr.fac_id
							inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and tx.contact_id = txca.contact_id
								and tx.contact_id >-2.1  and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900')

						delete tx 
						from #local_transactions tx
						inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id	and tx.contact_id >-2.1  and parent.contact_id >-2.1 
						left join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id 
						where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.contact_id = txca.contact_id
						and txca.distribution_tx_id is not null and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900')

						delete tx 
						from #local_transactions tx
						inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id >-2.1  and parent.contact_id >-2.1 
						where tx.skip_bit = 1 and parent.skip_bit = 0 and isnull(tx.bill_date,'1/1/1900') = isnull(parent.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(parent.generated_date,'1/1/1900')

			--********************************************************** children on different payer than parent
						delete from #child_transactions

						insert into #child_transactions
						select 	  ctx.distribution_tx_id
								--, ctx.transaction_type
								, '' AS transaction_type
								, ctx.parent_tx_type
								, ctx.contact_id 
								, 0 as invoice_id
								, ctx.payer_id
								, sum(ctx.days_amount)
								, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
								, sum(ctx.monthly_rate)
								, sum(ctx.amount)
								, ctx.bill_date
								, ctx.generated_date
								, 0
						from #local_transactions ctx
						join dbo.ar_payers payer on payer.payer_id = ctx.payer_id and payer.fac_id = ctx.fac_id 
						inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and anctx.payer_id <> ctx.payer_id and anctx.transaction_type = 'A' and anctx.skip_bit <> 5
							and ctx.contact_id >-2.1  and anctx.contact_id >-2.1  and ctx.contact_id = anctx.contact_id
						where  ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type 
							--and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900')
						group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.generated_date
						order by 1

						insert into #local_transactions
	
						select tx.invoice_id
							, tx.contact_id
							, tx.batch_id
							, tx.entry_number
							, tx.client_id
							, tx.auto_generated
							, tx.transaction_id
							, tx.reversing_tx_id
							, tx.distribution_tx_id
							, tx.applied_payment_id
							, txca.payer_id
							, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
							, tx.days_account_id
							, tx.dollars_account_id
							, tx.fac_id
							, tx.is_billed
							, tx.transaction_type
							, tx.parent_tx_type
							, tx.[description]
							, tx.alt_description
							, tx.cheque_number
							, tx.effective_date
							, tx.transaction_date
							, txca.bill_date
							, tx.applied_date
							, tx.generated_date
							, tx.days_amount
							, isnull(txca.daily_rate,0) as daily_rate
							, Null as monthly_rate
							, isnull(txca.amount,0) as amount
							, tx.care_level				
							, tx.revenue_code
							, tx.hcpcs_code	
							, tx.item_type_id
							, tx.comment
							, tx.rate_type_id
							, tx.rugs_modifier
							, tx.medicare_day
							, tx.mppr_flag
							, tx.mark_as_billed_by
							, tx.mark_as_billed_date
							, tx.mark_as_billed_comment
							, tx.transaction_type_group
							, 0
						from #local_transactions tx with (nolock)
						inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id  and tx.contact_id = txca.contact_id--and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
							and tx.payer_id <> txca.payer_id and tx.contact_id >-2.1

						delete tx 
						from #local_transactions tx
						inner join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and tx.contact_id = txca.contact_id--and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
							and tx.contact_id >-2.1
						where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0

						delete tx 
						from #local_transactions tx
						inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id >-2.1
						where tx.skip_bit = 1 and parent.skip_bit = 0
			
			--********************************************************** 
						set @vgsStepEndTime=GETDATE()
						if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
			end

				if @vOtherStatementsIncluded = 1
					begin
							Select @vStep = 121;
							set @vgsStepStartTime = GETDATE()
							if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' @vShowResults in(A,C,CC,R) - Combining Children not selected - Combine Ancillary Child Transactions to parent ' + convert(varchar(26),getdate(),109);

							delete from #child_transactions --eliminate the missing parent ones

							insert into #child_transactions
							select 	  ctx.distribution_tx_id
									--, ctx.transaction_type
									, '' AS transaction_type
									, ctx.parent_tx_type
									, ctx.contact_id 
									, ctx.invoice_id
									, ctx.payer_id
									, sum(ctx.days_amount)
									, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
									, sum(ctx.monthly_rate)
									, sum(ctx.amount)
									, ctx.bill_date
									, ctx.generated_date
									, 0
							from #local_transactions ctx
							inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and ctx.payer_id = anctx.payer_id and anctx.transaction_type = 'A' and anctx.skip_bit <> 5
								and ctx.contact_id <= -2.1  and anctx.contact_id <= -2.1  and ctx.contact_id = anctx.contact_id
							where  ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type
								and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900') and ctx.invoice_id = anctx.invoice_id
							group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.invoice_id, ctx.generated_date
							order by 1

							insert into #local_transactions
							select tx.invoice_id
								, tx.contact_id
								, tx.batch_id
								, tx.entry_number
								, tx.client_id
								, tx.auto_generated
								, tx.transaction_id
								, tx.reversing_tx_id
								, tx.distribution_tx_id
								, tx.applied_payment_id
								, tx.payer_id
								, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
								, tx.days_account_id
								, tx.dollars_account_id
								, tx.fac_id
								, tx.is_billed
								, tx.transaction_type
								, tx.parent_tx_type
								, tx.[description]
								, tx.alt_description
								, tx.cheque_number
								, tx.effective_date
								, tx.transaction_date
								, tx.bill_date
								, tx.applied_date
								, tx.generated_date
								, tx.days_amount
								--, tx.days_amount + isnull(txca.days_amount,0) as days_amount
								, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
								, Null as monthly_rate
								, tx.amount + isnull(txca.amount,0) as amount
								, tx.care_level
								, tx.revenue_code
								, tx.hcpcs_code		
								, tx.item_type_id
								, tx.comment
								, tx.rate_type_id
								, tx.rugs_modifier
								, tx.medicare_day
								, tx.mppr_flag
								, tx.mark_as_billed_by
								, tx.mark_as_billed_date
								, tx.mark_as_billed_comment
								, tx.transaction_type_group
								, 0
							from #local_transactions tx with (nolock)
							inner join dbo.ar_payers payr with (nolock) on tx.payer_id = payr.payer_id and tx.fac_id = payr.fac_id
							inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and tx.contact_id = txca.contact_id
								and tx.contact_id <= -2.1 and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') and tx.invoice_id = txca.invoice_id

						delete tx 
						from #local_transactions tx
						inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id	and tx.contact_id <= -2.1  and parent.contact_id <= -2.1 and parent.contact_id = tx.contact_id	
						left join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id 
						where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.contact_id = txca.contact_id
						and txca.distribution_tx_id is not null and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') and tx.invoice_id = txca.invoice_id

						delete tx 
						from #local_transactions tx
						inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id <= -2.1  and parent.contact_id <= -2.1 and parent.contact_id = tx.contact_id	
						where tx.skip_bit = 1 and parent.skip_bit = 0 and isnull(tx.bill_date,'1/1/1900') = isnull(parent.bill_date,'1/1/1900') and tx.invoice_id = parent.invoice_id


						set @vgsStepEndTime=GETDATE()
						if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
				end

		end
	end

Select @vStep = 125;
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Combining Consecutive Room Charges with no rate change ' + convert(varchar(26),getdate(),109);

delete from #local_transactions where parent_tx_type='R' and amount = 0.00 --cleanup before useless data before combining

If @vPrivateStatementsIncluded = 1 
	begin
		--flag duplicates to be skipped
		update tx set tx.skip_bit = 8
		from
		#local_transactions tx
		inner join (select tx.bill_date,tx.generated_date,tx.contact_id,tx.client_id,tx.effective_Date,tx.parent_tx_type,tx.transaction_type,tx.daily_rate,tx.monthly_rate,tx.days_amount, 
						case when tx.reversing_tx_id is null then 0 else 1 end as reversed
					from #local_transactions tx
					inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
					where tx.parent_tx_type='R' and ccl.contact_id > -2.1
					group by tx.bill_date,tx.generated_date,tx.contact_id,tx.client_id,tx.effective_Date,tx.parent_tx_type,tx.transaction_type,tx.daily_rate,tx.monthly_rate,tx.days_amount,
						case when tx.reversing_tx_id is null then 0 else 1 end
					having count(*) >1
					) dups on tx.bill_date = dups.bill_date and tx.generated_date = dups.generated_date and tx.client_id = dups.client_id and tx.contact_id = dups.contact_id and
					tx.effective_Date = dups.effective_Date and	tx.parent_tx_type = dups.parent_tx_type and tx.transaction_type = dups.transaction_type and
					isnull(tx.daily_rate,0) = isnull(dups.daily_rate,0) and isnull(tx.monthly_rate,0) = isnull(dups.monthly_rate,0) and tx.days_amount = dups.days_amount
					and (case when tx.reversing_tx_id is null then 0 else 1 end) = dups.reversed

		--flag groups that sum to $0 to be skipped
		update marked set skip_bit = 8
		from #local_transactions marked
		inner join (
					select tx.client_id, tx.contact_id, tx.bill_date, tx.generated_date, tx.effective_date, tx.transaction_type,tx.description, sum(tx.amount) as ttl, count(*) as cnt
					from #local_transactions tx
					inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
					where tx.parent_tx_type='R' and ccl.contact_id > -2.1 
					group by tx.client_id, tx.contact_id, tx.bill_date, tx.generated_date, tx.effective_date, tx.transaction_type, description having count (*) > 1
					) sum0 on marked.client_id = sum0.client_id and marked.contact_id = sum0.contact_id and marked.bill_date = sum0.bill_date
						and marked.generated_date = sum0.generated_date and marked.effective_date = sum0.effective_date and marked.transaction_type = sum0.transaction_type
						and marked.description = sum0.description and sum0.ttl = 0 and marked.skip_bit <> 8

		--non-reversed charges
			update nxt set nxt.skip_bit =(case when pre.daily_rate=nxt.daily_rate and pre.monthly_rate=nxt.monthly_rate and dateadd(dd,abs(pre.days_amount),pre.effective_date) = nxt.effective_date
				and datepart(mm,pre.effective_date) = datepart(mm,nxt.effective_date) and pre.generated_date=nxt.generated_date and pre.transaction_type=nxt.transaction_type 
				and ((@vCombineRecurringAncillary=1 and pre.item_type_id=nxt.item_type_id and pre.transaction_type='A' and nxt.transaction_type='A' ) OR (pre.parent_tx_type='R' and nxt.parent_tx_type='R')
					or (@vCombineCouncilPayerContribution = 1 and pre.parent_payer_id = nxt.parent_payer_id and pre.transaction_type='PC' and nxt.transaction_type='PC' 
					))
				then 9 else 1 end)
			from (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.generated_date
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.contact_id,tx.client_id
					order by  tx.contact_id,tx.client_id,tx.generated_date,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' 
					or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null)
					or (@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC'))
					and tx.reversing_tx_id is null and tx.skip_bit <> 8  and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC')  or ccl.contact_id > -2.1) 
					) pre
			join (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.generated_date
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.contact_id,tx.client_id
					order by  tx.contact_id,tx.client_id,tx.generated_date,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' 
				  or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null)
				  or (@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC'))
				and tx.reversing_tx_id is null and tx.skip_bit <> 8  and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC')  or ccl.contact_id > -2.1) 
				) nxt
			on pre.client_id=nxt.client_id and pre.contact_id=nxt.contact_id and pre.generated_date=nxt.generated_date and pre.transaction_type=nxt.transaction_type 
				and pre.rwnum=(nxt.rwnum-1)

		update myup set myup.days_amount = myup.days_amount + conttl.days_ttl, myup.amount = myup.amount + conttl.ttl--, myup.skip_bit = 7
		from #local_transactions myup
		inner join 
			(select contact_id,
				client_id, 
				skip_bit, 
				generated_date,
				transaction_type,
				isnull(parent_payer_id,0) as parent_payer_id,
				isnull(daily_rate,0) as daily_rate,
				isnull(monthly_rate,0) as monthly_rate,
				year(effective_date) as grp_year, 
				month(effective_date) as grp_month, 
				min(effective_date) as min_date,
				max(effective_date) as max_date, 
				sum(days_amount) as days_ttl, 
				sum(amount) as ttl
			from #local_transactions where (parent_tx_type='R' 
										or (transaction_type='A' and @vCombineRecurringAncillary=1 and auto_generated='R')
										or (transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 )) 
				and reversing_tx_id is null and skip_bit = 9
			group by contact_id, client_id, generated_date, skip_bit, transaction_type, isnull(parent_payer_id,0),isnull(daily_rate,0),isnull(monthly_rate,0), year(effective_date), month(effective_date)) conttl
			on myup.contact_id =  conttl.contact_id and myup.client_id =  conttl.client_id and myup.transaction_type =  conttl.transaction_type and myup.client_id = conttl.client_id and myup.generated_date = conttl.generated_date and 
				dateadd(dd,abs(myup.days_amount),myup.effective_date)  = conttl.min_date and isnull(myup.daily_rate,0) =  conttl.daily_rate and isnull(myup.monthly_rate,0) =  conttl.monthly_rate 
				and myup.skip_bit <> 9 and myup.skip_bit <> 8
				and myup.reversing_tx_id is null
				and (myup.transaction_type <> 'PC' or myup.parent_payer_id = conttl.parent_payer_id)

			delete from #local_transactions where skip_bit=9

		--negative reversed charges
			update nxt set nxt.skip_bit =(case when pre.daily_rate=nxt.daily_rate and pre.monthly_rate=nxt.monthly_rate and dateadd(dd,abs(pre.days_amount),pre.effective_date) = nxt.effective_date
				and datepart(mm,pre.effective_date) = datepart(mm,nxt.effective_date) and pre.generated_date=nxt.generated_date and pre.transaction_type=nxt.transaction_type 
				and ((@vCombineRecurringAncillary=1 and pre.item_type_id=nxt.item_type_id and pre.transaction_type='A' and nxt.transaction_type='A' ) OR (@vCombineCouncilPayerContribution=1 and pre.parent_payer_id=nxt.parent_payer_id and pre.transaction_type='PC' and nxt.transaction_type='PC' ) OR (pre.parent_tx_type='R' and nxt.parent_tx_type='R'))
				then 9 else 1 end)
			from (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.generated_date
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.contact_id,tx.client_id
					order by  tx.contact_id,tx.client_id,tx.generated_date,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC'))
			and tx.reversing_tx_id is not null and tx.days_amount < 0 and tx.skip_bit <> 8 and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC')  or ccl.contact_id > -2.1)) pre
			join (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.generated_date
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.contact_id,tx.client_id
					order by  tx.contact_id,tx.client_id,tx.generated_date,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1))
			and tx.reversing_tx_id is not null and tx.days_amount < 0 and tx.skip_bit <> 8 and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC')  or ccl.contact_id > -2.1) ) nxt			
			on pre.contact_id=nxt.contact_id and pre.client_id=nxt.client_id and pre.generated_date=nxt.generated_date and pre.transaction_type=nxt.transaction_type 
				and pre.rwnum=(nxt.rwnum-1)

		update myup set myup.days_amount = myup.days_amount + conttl.days_ttl, myup.amount = myup.amount + conttl.ttl
		from #local_transactions myup
		inner join 
			(select contact_id,
				client_id, 
				skip_bit, 
				generated_date,
				transaction_type,
				isnull(parent_payer_id,0) as parent_payer_id,
				isnull(daily_rate,0) as daily_rate,
				isnull(monthly_rate,0) as monthly_rate,
				year(effective_date) as grp_year, 
				month(effective_date) as grp_month, 
				min(effective_date) as min_date,
				max(effective_date) as max_date, 
				sum(days_amount) as days_ttl, 
				sum(amount) as ttl
			from #local_transactions where (parent_tx_type='R' or (transaction_type='A' and @vCombineRecurringAncillary=1 and auto_generated='R') OR (transaction_type='PC' and @vCombineCouncilPayerContribution=1 )) 
				and reversing_tx_id is not null and skip_bit = 9 and days_amount < 0
			group by contact_id,client_id, skip_bit, generated_date, transaction_type, isnull(parent_payer_id,0), isnull(daily_rate,0),isnull(monthly_rate,0), year(effective_date), month(effective_date)) conttl
			on myup.contact_id =  conttl.contact_id and myup.client_id =  conttl.client_id and myup.transaction_type =  conttl.transaction_type and myup.client_id =  conttl.client_id and 
				dateadd(dd,abs(myup.days_amount),myup.effective_date)  = conttl.min_date and myup.skip_bit <> 9 and myup.skip_bit <> 8
				and myup.reversing_tx_id is not null and myup.days_amount < 0 and myup.generated_date =  conttl.generated_date
				and isnull(myup.daily_rate,0) =  conttl.daily_rate and isnull(myup.monthly_rate,0) =  conttl.monthly_rate 
				and (myup.transaction_type <> 'PC' or myup.parent_payer_id = conttl.parent_payer_id)

			delete from #local_transactions where skip_bit=9

		--positive reversed charges
			update nxt set nxt.skip_bit =(case when pre.daily_rate=nxt.daily_rate and pre.monthly_rate=nxt.monthly_rate and dateadd(dd,abs(pre.days_amount),pre.effective_date) = nxt.effective_date
				and datepart(mm,pre.effective_date) = datepart(mm,nxt.effective_date) and pre.generated_date=nxt.generated_date and pre.transaction_type=nxt.transaction_type 
				and ((@vCombineRecurringAncillary=1 and pre.item_type_id=nxt.item_type_id and pre.transaction_type='A' and nxt.transaction_type='A' ) OR (@vCombineCouncilPayerContribution=1 and pre.parent_payer_id=nxt.parent_payer_id and pre.transaction_type='PC' and nxt.transaction_type='PC' ) OR (pre.parent_tx_type='R' and nxt.parent_tx_type='R'))
				then 9 else 1 end)
			from (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.generated_date
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.contact_id,tx.client_id
					order by  tx.contact_id,tx.client_id,tx.generated_date,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) OR (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1 ))
				and tx.reversing_tx_id is not null and tx.days_amount > 0 and tx.skip_bit <> 8 and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC')  or ccl.contact_id > -2.1)) pre
			join (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.generated_date
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.contact_id,tx.client_id
					order by  tx.contact_id,tx.client_id,tx.generated_date,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1 ))
				and tx.reversing_tx_id is not null and tx.days_amount > 0 and tx.skip_bit <> 8 and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC')  or ccl.contact_id > -2.1)) nxt
			on pre.contact_id=nxt.contact_id and pre.client_id=nxt.client_id and pre.generated_date=nxt.generated_date and pre.transaction_type=nxt.transaction_type 
				and pre.rwnum=(nxt.rwnum-1)

		update myup set myup.days_amount = myup.days_amount + conttl.days_ttl, myup.amount = myup.amount + conttl.ttl
		from #local_transactions myup
		inner join 
			(select contact_id,
				client_id, 
				skip_bit,
				generated_date, 
				transaction_type,
				isnull(parent_payer_id,0) as parent_payer_id,
				isnull(daily_rate,0) as daily_rate,
				isnull(monthly_rate,0) as monthly_rate, 
				year(effective_date) as grp_year, 
				month(effective_date) as grp_month, 
				min(effective_date) as min_date,
				max(effective_date) as max_date, 
				sum(days_amount) as days_ttl, 
				sum(amount) as ttl
			from #local_transactions where (parent_tx_type='R' or (transaction_type='A' and @vCombineRecurringAncillary=1 and auto_generated='R') or (transaction_type='PC' and @vCombineCouncilPayerContribution=1 )) 
				and reversing_tx_id is not null and skip_bit = 9 and days_amount > 0
			group by contact_id,client_id, skip_bit, generated_date, transaction_type, isnull(parent_payer_id,0), isnull(daily_rate,0),isnull(monthly_rate,0), year(effective_date), month(effective_date)) conttl
			on myup.client_id =  conttl.client_id and myup.transaction_type =  conttl.transaction_type and myup.client_id =  conttl.client_id and myup.contact_id =  conttl.contact_id and 
				dateadd(dd,abs(myup.days_amount),myup.effective_date)  = conttl.min_date and myup.skip_bit <> 9 and myup.skip_bit <> 8
				and myup.reversing_tx_id is not null and myup.days_amount > 0 and myup.generated_date =  conttl.generated_date
				and isnull(myup.daily_rate,0) =  conttl.daily_rate and isnull(myup.monthly_rate,0) =  conttl.monthly_rate 
				and (myup.transaction_type <> 'PC' or myup.parent_payer_id = conttl.parent_payer_id)				

			delete from #local_transactions where skip_bit=9
			update #local_transactions set skip_bit = 1 where skip_bit = 8

	end

if @vOtherStatementsIncluded = 1 
	begin

		--flag duplicates to be skipped
		update tx set tx.skip_bit = 8
		from
		#local_transactions tx
		inner join (select tx.bill_date,tx.invoice_id,tx.contact_id,tx.client_id,tx.effective_Date,tx.parent_tx_type,tx.transaction_type,tx.daily_rate,tx.monthly_rate,tx.days_amount, 
						case when tx.reversing_tx_id is null then 0 else 1 end as reversed
					from #local_transactions tx
					inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
					where tx.parent_tx_type='R' and ccl.contact_id <= -2.1
					group by tx.bill_date,tx.invoice_id,tx.contact_id,tx.client_id,tx.effective_Date,tx.parent_tx_type,tx.transaction_type,tx.daily_rate,tx.monthly_rate,tx.days_amount,
						case when tx.reversing_tx_id is null then 0 else 1 end
					having count(*) >1
					) dups on tx.bill_date = dups.bill_date and tx.invoice_id = dups.invoice_id and tx.client_id = dups.client_id and tx.contact_id = dups.contact_id and
					tx.effective_Date = dups.effective_Date and	tx.parent_tx_type = dups.parent_tx_type and tx.transaction_type = dups.transaction_type and
					isnull(tx.daily_rate,0) = isnull(dups.daily_rate,0) and isnull(tx.monthly_rate,0) = isnull(dups.monthly_rate,0) and tx.days_amount = dups.days_amount
					and (case when tx.reversing_tx_id is null then 0 else 1 end) = dups.reversed

		--flag groups that sum to $0 to be skipped
		update marked set skip_bit = 8
		from #local_transactions marked
		inner join (
					select tx.contact_id,tx.client_id, tx.bill_date, tx.invoice_id, tx.effective_date, tx.transaction_type,tx.description, sum(tx.amount) as ttl, count(*) as cnt
					from #local_transactions tx
					inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
					where tx.parent_tx_type='R' and ccl.contact_id <= -2.1 
					group by tx.contact_id,tx.client_id, tx.bill_date, tx.invoice_id, tx.effective_date, tx.transaction_type, description having count (*) > 1
					) sum0 on marked.contact_id = sum0.contact_id and marked.client_id = sum0.client_id and marked.bill_date = sum0.bill_date
						and marked.invoice_id = sum0.invoice_id and marked.effective_date = sum0.effective_date and marked.transaction_type = sum0.transaction_type
						and marked.description = sum0.description and sum0.ttl = 0 and marked.skip_bit <> 8

		--non-reversed charges
			update nxt set nxt.skip_bit =(case when pre.daily_rate=nxt.daily_rate and pre.monthly_rate=nxt.monthly_rate and dateadd(dd,abs(pre.days_amount),pre.effective_date) = nxt.effective_date
				and datepart(mm,pre.effective_date) = datepart(mm,nxt.effective_date) and pre.invoice_id=nxt.invoice_id and pre.transaction_type=nxt.transaction_type 
				and ((@vCombineRecurringAncillary=1 and pre.item_type_id=nxt.item_type_id and pre.transaction_type='A' and nxt.transaction_type='A' ) OR (@vCombineCouncilPayerContribution=1 and pre.parent_payer_id=nxt.parent_payer_id and pre.transaction_type='PC' and nxt.transaction_type='PC' ) OR (pre.parent_tx_type='R' and nxt.parent_tx_type='R'))
				then 9 else 1 end)
			from (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.invoice_id
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.client_id
					order by  tx.contact_id,tx.client_id,tx.invoice_id,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1 ))
				and tx.reversing_tx_id is null and tx.skip_bit <> 8  and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC')  or ccl.contact_id > -2.1) 
				) pre
			join (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.invoice_id
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.client_id
					order by  tx.contact_id,tx.client_id,tx.invoice_id,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1 ))
				and tx.reversing_tx_id is null and tx.skip_bit <> 8  and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC') or ccl.contact_id <= -2.1) 
				) nxt
			on pre.contact_id=nxt.contact_id and pre.client_id=nxt.client_id and pre.invoice_id=nxt.invoice_id and pre.transaction_type=nxt.transaction_type 
				and pre.rwnum=(nxt.rwnum-1)

		update myup set myup.days_amount = myup.days_amount + conttl.days_ttl, myup.amount = myup.amount + conttl.ttl--, myup.skip_bit = 7
		from #local_transactions myup
		inner join 
			(select contact_id,
				client_id, 
				skip_bit, 
				invoice_id,
				transaction_type,
				isnull(parent_payer_id,0) as parent_payer_id,
				isnull(daily_rate,0) as daily_rate,
				isnull(monthly_rate,0) as monthly_rate,
				year(effective_date) as grp_year, 
				month(effective_date) as grp_month, 
				min(effective_date) as min_date,
				max(effective_date) as max_date, 
				sum(days_amount) as days_ttl, 
				sum(amount) as ttl
			from #local_transactions where (parent_tx_type='R' or (transaction_type='A' and @vCombineRecurringAncillary=1 and auto_generated='R')
															   or (transaction_type='PC' and @vCombineCouncilPayerContribution=1 )) 
				and reversing_tx_id is null and skip_bit = 9
			group by contact_id,client_id, invoice_id, skip_bit, transaction_type, isnull(parent_payer_id,0), isnull(daily_rate,0),isnull(monthly_rate,0), year(effective_date), month(effective_date)) conttl
			on myup.contact_id =  conttl.contact_id and myup.client_id =  conttl.client_id and myup.transaction_type =  conttl.transaction_type and myup.client_id = conttl.client_id and myup.invoice_id = conttl.invoice_id and 
				dateadd(dd,abs(myup.days_amount),myup.effective_date)  = conttl.min_date and isnull(myup.daily_rate,0) =  conttl.daily_rate and isnull(myup.monthly_rate,0) =  conttl.monthly_rate 
				and myup.skip_bit <> 9 and myup.skip_bit <> 8
				and myup.reversing_tx_id is null
				and (myup.transaction_type <> 'PC' or myup.parent_payer_id = conttl.parent_payer_id)
				

			delete from #local_transactions where skip_bit=9

		--negative reversed charges
			update nxt set nxt.skip_bit =(case when pre.daily_rate=nxt.daily_rate and pre.monthly_rate=nxt.monthly_rate and dateadd(dd,abs(pre.days_amount),pre.effective_date) = nxt.effective_date
				and datepart(mm,pre.effective_date) = datepart(mm,nxt.effective_date) and pre.invoice_id=nxt.invoice_id and pre.transaction_type=nxt.transaction_type 
				and ((@vCombineRecurringAncillary=1 and pre.item_type_id=nxt.item_type_id and pre.transaction_type='A' and nxt.transaction_type='A' ) OR (@vCombineCouncilPayerContribution=1 and pre.parent_payer_id=nxt.parent_payer_id and pre.transaction_type='PC' and nxt.transaction_type='PC' ) OR (pre.parent_tx_type='R' and nxt.parent_tx_type='R'))
				then 9 else 1 end)
			from (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.invoice_id
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.client_id
					order by  tx.contact_id,tx.client_id,tx.invoice_id,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1 ))
			and tx.reversing_tx_id is not null and tx.days_amount < 0 and tx.skip_bit <> 8 and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC') or ccl.contact_id <= -2.1)) pre
			join (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.invoice_id
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.client_id
					order by  tx.contact_id,tx.client_id,tx.invoice_id,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1 ))
			and tx.reversing_tx_id is not null and tx.days_amount < 0 and tx.skip_bit <> 8 and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC') or ccl.contact_id <= -2.1)) nxt
			on pre.contact_id=nxt.contact_id and pre.client_id=nxt.client_id and pre.invoice_id=nxt.invoice_id and pre.transaction_type=nxt.transaction_type 
				and pre.rwnum=(nxt.rwnum-1)

		update myup set myup.days_amount = myup.days_amount + conttl.days_ttl, myup.amount = myup.amount + conttl.ttl
		from #local_transactions myup
		inner join 
			(select contact_id,
				client_id, 
				skip_bit, 
				invoice_id,
				transaction_type,
				isnull(parent_payer_id,0) as parent_payer_id,
				isnull(daily_rate,0) as daily_rate,
				isnull(monthly_rate,0) as monthly_rate,
				year(effective_date) as grp_year, 
				month(effective_date) as grp_month, 
				min(effective_date) as min_date,
				max(effective_date) as max_date, 
				sum(days_amount) as days_ttl, 
				sum(amount) as ttl
			from #local_transactions where (parent_tx_type='R' or (transaction_type='A' and @vCombineRecurringAncillary=1 and auto_generated='R') or (transaction_type='PC' and @vCombineCouncilPayerContribution=1 )) 
				and reversing_tx_id is not null and skip_bit = 9 and days_amount < 0
			group by contact_id,client_id, skip_bit, invoice_id, transaction_type, isnull(parent_payer_id,0), isnull(daily_rate,0),isnull(monthly_rate,0), year(effective_date), month(effective_date)) conttl
			on myup.contact_id = conttl.contact_id and myup.client_id = conttl.client_id and myup.transaction_type =  conttl.transaction_type and myup.client_id =  conttl.client_id and 
				dateadd(dd,abs(myup.days_amount),myup.effective_date) = conttl.min_date and myup.skip_bit <> 9 and myup.skip_bit <> 8
				and myup.reversing_tx_id is not null and myup.days_amount < 0 and myup.invoice_id =  conttl.invoice_id
				and isnull(myup.daily_rate,0) =  conttl.daily_rate and isnull(myup.monthly_rate,0) =  conttl.monthly_rate 
				and (myup.transaction_type <> 'PC' or myup.parent_payer_id = conttl.parent_payer_id)

			delete from #local_transactions where skip_bit=9

		--positive reversed charges
			update nxt set nxt.skip_bit =(case when pre.daily_rate=nxt.daily_rate and pre.monthly_rate=nxt.monthly_rate and dateadd(dd,abs(pre.days_amount),pre.effective_date) = nxt.effective_date
				and datepart(mm,pre.effective_date) = datepart(mm,nxt.effective_date) and pre.invoice_id=nxt.invoice_id and pre.transaction_type=nxt.transaction_type 
				and ((@vCombineRecurringAncillary=1 and pre.item_type_id=nxt.item_type_id and pre.transaction_type='A' and nxt.transaction_type='A' ) OR (@vCombineCouncilPayerContribution=1 and pre.parent_payer_id=nxt.parent_payer_id and pre.transaction_type='PC' and nxt.transaction_type='PC' ) OR (pre.parent_tx_type='R' and nxt.parent_tx_type='R'))
				then 9 else 1 end)
			from (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.invoice_id
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.client_id
					order by  tx.contact_id,tx.client_id,tx.invoice_id,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1  ))
				and tx.reversing_tx_id is not null and tx.days_amount > 0 and tx.skip_bit <> 8 and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC') or ccl.contact_id <= -2.1)) pre
			join (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.invoice_id
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.client_id
					order by  tx.contact_id,tx.client_id,tx.invoice_id,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1 ))
				and tx.reversing_tx_id is not null and tx.days_amount > 0 and tx.skip_bit <> 8 and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC') or ccl.contact_id <= -2.1)) nxt
			on pre.contact_id=nxt.contact_id and pre.client_id=nxt.client_id and pre.invoice_id=nxt.invoice_id and pre.transaction_type=nxt.transaction_type 
				and pre.rwnum=(nxt.rwnum-1)

		update myup set myup.days_amount = myup.days_amount + conttl.days_ttl, myup.amount = myup.amount + conttl.ttl
		from #local_transactions myup
		inner join 
			(select contact_id,
				client_id, 
				skip_bit,
				invoice_id, 
				transaction_type,
				isnull(parent_payer_id,0) as parent_payer_id,
				isnull(daily_rate,0) as daily_rate,
				isnull(monthly_rate,0) as monthly_rate, 
				year(effective_date) as grp_year, 
				month(effective_date) as grp_month, 
				min(effective_date) as min_date,
				max(effective_date) as max_date, 
				sum(days_amount) as days_ttl, 
				sum(amount) as ttl
			from #local_transactions where (parent_tx_type='R' or (transaction_type='A' and @vCombineRecurringAncillary=1 and auto_generated='R') or (transaction_type='PC' and @vCombineCouncilPayerContribution=1 )) 
				and reversing_tx_id is not null and skip_bit = 9 and days_amount > 0
			group by contact_id, client_id, skip_bit, invoice_id, transaction_type, isnull(parent_payer_id,0), isnull(daily_rate,0),isnull(monthly_rate,0), year(effective_date), month(effective_date)) conttl
			on myup.contact_id = conttl.contact_id and myup.client_id = conttl.client_id and myup.transaction_type =  conttl.transaction_type and myup.client_id =  conttl.client_id and 
				dateadd(dd,abs(myup.days_amount),myup.effective_date) = conttl.min_date and myup.skip_bit <> 9 and myup.skip_bit <> 8
				and myup.reversing_tx_id is not null and myup.days_amount > 0 and myup.invoice_id =  conttl.invoice_id
				and isnull(myup.daily_rate,0) =  conttl.daily_rate and isnull(myup.monthly_rate,0) =  conttl.monthly_rate 
				and (myup.transaction_type <> 'PC' or myup.parent_payer_id = conttl.parent_payer_id)

			delete from #local_transactions where skip_bit=9
			update #local_transactions set skip_bit = 1 where skip_bit = 8

	end

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

Select @vStep = 130;
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Formating and grouping transaction Data ' + convert(varchar(26),getdate(),109);
	
if @vShowResults = 'D'

	begin

		INSERT INTO #transactions	
		SELECT 
			  concl.invoice_id
			, tx.fac_id
			, concl.contact_id
			, concl.contact_num
			, tx.client_id
			, tx.payer_id
			, libpayer.description AS payer
			, libpayer.payer_type
			, tx.batch_id
			, tx.entry_number
			, tx.distribution_tx_id
			, tx.transaction_id
			, tx.reversing_tx_id
			, isnull(tx.auto_generated, 'N') as auto_generated
			, concl.bill_date
			, tx.transaction_date as posting_date
			, tx.effective_date
			, Null as effective_from_date
			, Null as effective_thru_date
			, tx.generated_date
			, libcc.charge_code
			, isnull(rtx.charge_frequency,'O') as frequency
			, tx.revenue_code
			, tx.hcpcs_code
			, tx.mppr_flag
			, Case when tx.transaction_type = 'R' and isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> '' 
					then rtype.long_description + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then 
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' + convert(varchar(4),YEAR(tx.effective_date))
					end) 
					+ (case when isnull(arpayer.show_care_level,'N') = 'Y'  and isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
				and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') = ''  
				and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'CL' and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X','CA') and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' then tx.description
				when tx.transaction_type ='PC' and @vCombineCouncilPayerContribution=1  then 
					LEFT(tx.description,CHARINDEX(':',tx.description)-1)+': ' + FORMAT(tx.effective_date,'MMM dd') + 
						(case 
							when (abs(tx.days_amount) > 1 and (DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) < 10) then '-' + '0' + CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' + convert(varchar(4),YEAR(tx.effective_date))
							when abs(tx.days_amount) > 1 then '-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' + convert(varchar(4),YEAR(tx.effective_date))
							else ' ' +	convert(varchar(4),YEAR(tx.effective_date)) end)
				when tx.transaction_type ='CA' and isnull(tx.alt_description,'')='' then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')'
				when tx.transaction_type = 'CO' and tx.parent_tx_type <> 'R' then tx.description --+  ' Coinsurance'
				when tx.transaction_type = 'XR' and tx.parent_tx_type ='A' then tx.description --+  ' Reimb. Reduction' 
				when tx.transaction_type = 'CX' and tx.parent_tx_type ='R' then 'Room Excess' 
				when (tx.transaction_type in('XR','CO', 'D', 'CR') or (tx.transaction_type = 'CL' and isnull(tx.alt_description,'')='')) and tx.parent_tx_type = 'R' then
				(Case 
					when isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> ''  
						then rtype.long_description + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(arpayer.show_care_level,'N') = 'Y' and isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
						and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' +
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then  
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'XR'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'CO'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else
							' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end) --+ ' Coinsurance'
					else 
						(case when tx.transaction_type = 'XR' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
							(case when abs(tx.days_amount) > 1 then
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else  ' ' +	convert(varchar(4),YEAR(tx.effective_date))
							end)
						else 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') +
							(case when abs(tx.days_amount) > 1 then 
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else ' ' + convert(varchar(4),YEAR(tx.effective_date))
							end) --+
							--(case when tx.transaction_type = 'D' then ' Deductible' 
							--	when tx.transaction_type = 'CO' then ' Coinsurance' else '' end)  
						end)
					end
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				) --+ (case when tx.transaction_type = 'CL' then ' Coverage Deductible' else '' end) 
				 --+ (case when tx.transaction_type = 'CR' then ' Contractural Adj.' else '' end) 
				else tx.description end as detail_description
			, tx.care_level
			, Case when tx.transaction_type = 'R' and libpayer.pps_flag='Y' then ltrim(rtrim(str(tx.medicare_day))) + '-' 
				+ltrim(rtrim(str((
					case when tx.days_amount < 0 and (tx.days_amount*-1) > 1 then tx.days_amount*-1 + tx.medicare_day -1
					when tx.days_amount > 0 and (tx.days_amount*-1) = 1 then tx.days_amount*-1  + tx.medicare_day
					when tx.days_amount > 1 then tx.days_amount + tx.medicare_day -1
					else tx.days_amount + tx.medicare_day end))))
				else Null
					end as benefit_days
			, tx.parent_tx_type
			, tx.transaction_type
			, tx.daily_rate as unit_amount
			, case when tx.transaction_type = 'XR' then Null else tx.days_amount end as number_of_units
			, tx.amount
			, acct.account_number as gl_account
			, daysacct.account_number as days_account
			, case when tx.is_billed = 1 and isnull(tx.invoice_id,0) > 0 then 'Y'
				when tx.is_billed = 1 and isnull(tx.invoice_id,0) < 0 then 'N/A' else 'N' end as billed
			, tx.comment
			, tx.cheque_number
			, case when libcc.adjustment_type is not null and tx.transaction_type = 'X' then libcc.transaction_type + '_' + libcc.adjustment_type 
				when recur.transaction_id is not null then 'Recur'
				when tx.mppr_flag = 1 or convert(bit, case when bump.bumpup_transaction_id is null then 0 else 1 end) = 'true' then 'MPPR'
				else tx.transaction_type end as adjusted_tx_type
			, case when recur.transaction_id is null then 0 else 1 end as recurring_tx
			, case when tx.reversing_tx_id is null then 0 else 1 end as reversed
			, tx.transaction_type_group
			, 0 as ancillary_year
			, 0 as ancillary_month
			, 0 as balance_due
			, 0 as other_payer
			, NULL as aging_total
			, NULL as aging_current_label
			, NULL as aging_current_amount
			, NULL as aging_30_label
			, NULL as aging_30_amount
			, NULL as aging_60_label
			, NULL as aging_60_amount
			, NULL as aging_90_label
			, NULL as aging_90_amount
			, NULL as aging_120_label
			, NULL as aging_120_amount
			, NULL as aging_150_label
			, NULL as aging_150_amount
			, NULL as aging_180_label
			, NULL as aging_180_amount
			, NULL as aging_210_label
			, NULL as aging_210_amount
			, 0 as detail_order		
		FROM #local_transactions tx with (nolock)
		inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
		inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
		inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'
		left join dbo.ar_transactions_location_room roomLocation with (nolock) on roomLocation.transaction_id = tx.transaction_id    
		left join dbo.ar_transaction_recurring_tx_refs recur with (nolock) on tx.transaction_id = recur.transaction_id
		left join dbo.ar_recurring_transactions rtx with (nolock) on rtx.transaction_id = recur.recurring_tx_id
		left join dbo.ar_batch batch with (nolock) on tx.batch_id = batch.batch_id
		left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
		left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
		left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
		left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
		left join dbo.ar_mppr_bumpup bump with (nolock) on tx.distribution_tx_id = bump.bumpup_transaction_id  
		where tx.transaction_type <> 'TA'
	end

if @vShowResults = 'A'

	begin

		INSERT INTO #transactions	
		SELECT 
			  concl.invoice_id
			, tx.fac_id
			, concl.contact_id
			, concl.contact_num
			, tx.client_id
			, tx.payer_id
			, libpayer.description AS payer
			, libpayer.payer_type
			, tx.batch_id
			, tx.entry_number
			, tx.distribution_tx_id
			, tx.transaction_id
			, tx.reversing_tx_id
			, isnull(tx.auto_generated, 'N') as auto_generated
			, concl.bill_date
			, tx.transaction_date as posting_date
			, tx.effective_date
			, Null as effective_from_date
			, Null as effective_thru_date
			, tx.generated_date
			, libcc.charge_code
			, isnull(rtx.charge_frequency,'O') as frequency
			, tx.revenue_code
			, tx.hcpcs_code
			, tx.mppr_flag
			, Case when tx.transaction_type = 'R' and isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> '' 
					then rtype.long_description + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then 
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' + convert(varchar(4),YEAR(tx.effective_date))
					end) 
					+ (case when isnull(arpayer.show_care_level,'N') = 'Y'  and isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
				and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') = ''  
				and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'CL' and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X','CA') and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' then tx.description
				when tx.transaction_type ='CA' and isnull(tx.alt_description,'')='' then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')'
				when tx.transaction_type = 'CO' and tx.parent_tx_type <> 'R' then tx.description --+  ' Coinsurance'
				when tx.transaction_type = 'XR' and tx.parent_tx_type ='A' then tx.description --+  ' Reimb. Reduction' 
				when tx.transaction_type = 'CX' and tx.parent_tx_type ='R' then 'Room Excess' 
				when (tx.transaction_type in('XR','CO', 'D', 'CR') or (tx.transaction_type = 'CL' and isnull(tx.alt_description,'')='')) and tx.parent_tx_type = 'R' then
				(Case 
					when isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> ''  
						then rtype.long_description + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(arpayer.show_care_level,'N') = 'Y' and isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
						and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' +
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then  
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'XR'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'CO'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else
							' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end) --+ ' Coinsurance'
					else 
						(case when tx.transaction_type = 'XR' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
							(case when abs(tx.days_amount) > 1 then
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else  ' ' +	convert(varchar(4),YEAR(tx.effective_date))
							end)
						else 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') +
							(case when abs(tx.days_amount) > 1 then 
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else ' ' + convert(varchar(4),YEAR(tx.effective_date))
							end) --+
							--(case when tx.transaction_type = 'D' then ' Deductible' 
							--	when tx.transaction_type = 'CO' then ' Coinsurance' else '' end)  
						end)
					end
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				) --+ (case when tx.transaction_type = 'CL' then ' Coverage Deductible' else '' end) 
				 --+ (case when tx.transaction_type = 'CR' then ' Contractural Adj.' else '' end) 
				else tx.description end as detail_description
			, tx.care_level
			, Case when tx.transaction_type = 'R' and libpayer.pps_flag='Y' then ltrim(rtrim(str(tx.medicare_day))) + '-' 
				+ltrim(rtrim(str((
					case when tx.days_amount < 0 and (tx.days_amount*-1) > 1 then tx.days_amount*-1 + tx.medicare_day -1
					when tx.days_amount > 0 and (tx.days_amount*-1) = 1 then tx.days_amount*-1  + tx.medicare_day
					when tx.days_amount > 1 then tx.days_amount + tx.medicare_day -1
					else tx.days_amount + tx.medicare_day end))))
				else Null
					end as benefit_days
			, tx.parent_tx_type
			, tx.transaction_type
			, tx.daily_rate as unit_amount
			, case when tx.transaction_type = 'XR' then Null else tx.days_amount end as number_of_units
			, tx.amount
			, acct.account_number as gl_account
			, daysacct.account_number as days_account
			, case when tx.is_billed = 1 and isnull(tx.invoice_id,0) > 0 then 'Y'
				when tx.is_billed = 1 and isnull(tx.invoice_id,0) < 0 then 'N/A' else 'N' end as billed
			, tx.comment
			, tx.cheque_number
			, case when libcc.adjustment_type is not null and tx.transaction_type = 'X' then libcc.transaction_type + '_' + libcc.adjustment_type 
				when recur.transaction_id is not null then 'Recur'
				when tx.mppr_flag = 1 or convert(bit, case when bump.bumpup_transaction_id is null then 0 else 1 end) = 'true' then 'MPPR'
				else tx.transaction_type end as adjusted_tx_type
			, case when recur.transaction_id is null then 0 else 1 end as recurring_tx
			, case when tx.reversing_tx_id is null then 0 else 1 end as reversed
			, tx.transaction_type_group
			, 0 as ancillary_year
			, 0 as ancillary_month
			, 0 as balance_due
			, 0 as other_payer
			, NULL as aging_total
			, NULL as aging_current_label
			, NULL as aging_current_amount
			, NULL as aging_30_label
			, NULL as aging_30_amount
			, NULL as aging_60_label
			, NULL as aging_60_amount
			, NULL as aging_90_label
			, NULL as aging_90_amount
			, NULL as aging_120_label
			, NULL as aging_120_amount
			, NULL as aging_150_label
			, NULL as aging_150_amount
			, NULL as aging_180_label
			, NULL as aging_180_amount
			, NULL as aging_210_label
			, NULL as aging_210_amount
			, 0 as detail_order				
		FROM #local_transactions tx with (nolock)
		inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
		inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
		inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'  
		left join dbo.ar_transactions_location_room roomLocation with (nolock) on roomLocation.transaction_id = tx.transaction_id   
		left join dbo.ar_transaction_recurring_tx_refs recur with (nolock) on tx.transaction_id = recur.transaction_id
		left join dbo.ar_recurring_transactions rtx with (nolock) on rtx.transaction_id = recur.recurring_tx_id
		left join dbo.ar_batch batch with (nolock) on tx.batch_id = batch.batch_id
		left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
		left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
		left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
		left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
		left join dbo.ar_mppr_bumpup bump with (nolock) on tx.distribution_tx_id = bump.bumpup_transaction_id  
		WHERE 
			tx.transaction_type <> 'A' and tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA')

		If @vPrivateStatementsIncluded = 1 
			begin
				INSERT INTO #transactions		
				SELECT 
					  --concl.invoice_id
					 min(concl.invoice_id) as invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					--, case when tx.is_billed = 0 then 'Ancillary Charges' else 
					--	'Ancillary Charges ' + convert(varchar(3), tx.bill_date,100) +' ' + convert(varchar(4),datepart(yyyy,tx.bill_date),100) end as detail_description
					, Case when min(tx.effective_date) <> max(tx.effective_date) then 'Ancillary Charges: ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else 'Ancillary Charge(s)' end as detail_description
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, '' as transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, 'A' as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.bill_date) as ancillary_year
					, datepart(mm,tx.bill_date) as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
				FROM #local_transactions tx with (nolock)
				inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					tx.transaction_type = 'A' and concl.contact_id > -2.1
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.transaction_type, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date)

				INSERT INTO #transactions	
				SELECT 
					  min(concl.invoice_id) as invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then  tx.description +': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else tx.description end as detail_description
					--, tx.description as detail_description
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, '' as transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, 'A' as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.bill_date) as ancillary_year
					, datepart(mm,tx.bill_date) as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
				FROM #local_transactions tx with (nolock)
				inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA' and concl.contact_id > -2.1
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.transaction_type, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date), tx.description 
		end

	if @vOtherStatementsIncluded = 1 
		begin
			INSERT INTO #transactions		
				SELECT 
					 concl.invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					--, case when tx.is_billed = 0 then 'Ancillary Charges' else 
					--	'Ancillary Charges ' + convert(varchar(3), tx.bill_date,100) +' ' + convert(varchar(4),datepart(yyyy,tx.bill_date),100) end as detail_description
					, Case when min(tx.effective_date) <> max(tx.effective_date) then 'Ancillary Charges: ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else 'Ancillary Charge(s)' end as detail_description
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, '' as transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, 'A' as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.bill_date) as ancillary_year
					, datepart(mm,tx.bill_date) as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
				FROM #local_transactions tx with (nolock)
				inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					tx.transaction_type = 'A' and concl.contact_id <= -2.1
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.transaction_type, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.invoice_id, concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date)

				INSERT INTO #transactions	
				SELECT 
					  concl.invoice_id 
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then  tx.description +': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else tx.description end as detail_description
					--, tx.description as detail_description
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, '' as transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, 'A' as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.bill_date) as ancillary_year
					, datepart(mm,tx.bill_date) as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
				FROM #local_transactions tx with (nolock)
				inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA' and concl.contact_id <= -2.1
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.transaction_type, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.invoice_id, concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date), tx.description 
		end

	end

if @vShowResults = 'C'

	begin

		INSERT INTO #transactions	
		SELECT 
			  concl.invoice_id
			, tx.fac_id
			, concl.contact_id
			, concl.contact_num
			, tx.client_id
			, tx.payer_id
			, libpayer.description AS payer
			, libpayer.payer_type
			, tx.batch_id
			, tx.entry_number
			, tx.distribution_tx_id
			, tx.transaction_id
			, tx.reversing_tx_id
			, isnull(tx.auto_generated, 'N') as auto_generated
			, concl.bill_date
			, tx.transaction_date as posting_date
			, tx.effective_date
			, Null as effective_from_date
			, Null as effective_thru_date
			, tx.generated_date
			, libcc.charge_code
			, isnull(rtx.charge_frequency,'O') as frequency
			, tx.revenue_code
			, tx.hcpcs_code
			, tx.mppr_flag
			, Case when tx.transaction_type = 'R' and isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> '' 
					then rtype.long_description + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then 
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' + convert(varchar(4),YEAR(tx.effective_date))
					end) 
					+ (case when isnull(arpayer.show_care_level,'N') = 'Y'  and isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
				and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') = ''  
				and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'CL' and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X','CA') and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' then tx.description
				when tx.transaction_type ='CA' and isnull(tx.alt_description,'')='' then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')'
				when tx.transaction_type = 'CO' and tx.parent_tx_type <> 'R' then tx.description --+  ' Coinsurance'
				when tx.transaction_type = 'XR' and tx.parent_tx_type ='A' then tx.description --+  ' Reimb. Reduction' 
				when tx.transaction_type = 'CX' and tx.parent_tx_type ='R' then 'Room Excess' 
				when (tx.transaction_type in('XR','CO', 'D', 'CR') or (tx.transaction_type = 'CL' and isnull(tx.alt_description,'')='')) and tx.parent_tx_type = 'R' then
				(Case 
					when isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> ''  
						then rtype.long_description + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(arpayer.show_care_level,'N') = 'Y' and isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
						and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' +
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then  
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'XR'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'CO'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else
							' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end) --+ ' Coinsurance'
					else 
						(case when tx.transaction_type = 'XR' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
							(case when abs(tx.days_amount) > 1 then
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else  ' ' +	convert(varchar(4),YEAR(tx.effective_date))
							end)
						else 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') +
							(case when abs(tx.days_amount) > 1 then 
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else ' ' + convert(varchar(4),YEAR(tx.effective_date))
							end) --+
							--(case when tx.transaction_type = 'D' then ' Deductible' 
							--	when tx.transaction_type = 'CO' then ' Coinsurance' else '' end)  
						end)
					end
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				) --+ (case when tx.transaction_type = 'CL' then ' Coverage Deductible' else '' end) 
				 --+ (case when tx.transaction_type = 'CR' then ' Contractural Adj.' else '' end) 
				else tx.description end as detail_description
			, tx.care_level
			, Case when tx.transaction_type = 'R' and libpayer.pps_flag='Y' then ltrim(rtrim(str(tx.medicare_day))) + '-' 
				+ltrim(rtrim(str((
					case when tx.days_amount < 0 and (tx.days_amount*-1) > 1 then tx.days_amount*-1 + tx.medicare_day -1
					when tx.days_amount > 0 and (tx.days_amount*-1) = 1 then tx.days_amount*-1  + tx.medicare_day
					when tx.days_amount > 1 then tx.days_amount + tx.medicare_day -1
					else tx.days_amount + tx.medicare_day end))))
				else Null
					end as benefit_days
			, tx.parent_tx_type
			, tx.transaction_type
			, tx.daily_rate as unit_amount
			, case when tx.transaction_type = 'XR' then Null else tx.days_amount end as number_of_units
			, tx.amount
			, acct.account_number as gl_account
			, daysacct.account_number as days_account
			, case when tx.is_billed = 1 and isnull(tx.invoice_id,0) > 0 then 'Y'
				when tx.is_billed = 1 and isnull(tx.invoice_id,0) < 0 then 'N/A' else 'N' end as billed
			, tx.comment
			, tx.cheque_number
			, case when libcc.adjustment_type is not null and tx.transaction_type = 'X' then libcc.transaction_type + '_' + libcc.adjustment_type 
				when recur.transaction_id is not null then 'Recur'
				when tx.mppr_flag = 1 or convert(bit, case when bump.bumpup_transaction_id is null then 0 else 1 end) = 'true' then 'MPPR'
				else tx.transaction_type end as adjusted_tx_type
			, case when recur.transaction_id is null then 0 else 1 end as recurring_tx
			, case when tx.reversing_tx_id is null then 0 else 1 end as reversed
			, tx.transaction_type_group	
			, 0 as ancillary_year
			, 0 as ancillary_month	
			, 0 as balance_due
			, 0 as other_payer
			, NULL as aging_total
			, NULL as aging_current_label
			, NULL as aging_current_amount
			, NULL as aging_30_label
			, NULL as aging_30_amount
			, NULL as aging_60_label
			, NULL as aging_60_amount
			, NULL as aging_90_label
			, NULL as aging_90_amount
			, NULL as aging_120_label
			, NULL as aging_120_amount
			, NULL as aging_150_label
			, NULL as aging_150_amount
			, NULL as aging_180_label
			, NULL as aging_180_amount
			, NULL as aging_210_label
			, NULL as aging_210_amount
			, 0 as detail_order		
		FROM #local_transactions tx with (nolock)
		inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
		inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
		inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'
		left join dbo.ar_transactions_location_room roomLocation with (nolock) on roomLocation.transaction_id = tx.transaction_id     
		left join dbo.ar_transaction_recurring_tx_refs recur with (nolock) on tx.transaction_id = recur.transaction_id
		left join dbo.ar_recurring_transactions rtx with (nolock) on rtx.transaction_id = recur.recurring_tx_id
		left join dbo.ar_batch batch with (nolock) on tx.batch_id = batch.batch_id
		left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
		left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
		left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
		left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
		left join dbo.ar_mppr_bumpup bump with (nolock) on tx.distribution_tx_id = bump.bumpup_transaction_id  
		WHERE 
			libcc.charge_code_id is null and tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA')

		If @vPrivateStatementsIncluded = 1 
			begin

				INSERT INTO #transactions	
				SELECT 
					  min(concl.invoice_id) as invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, libcc.charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')<>'' then 
						--(Case when min(tx.effective_date) <> max(tx.effective_date) then 
						--	'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + tx.alt_description
						(Case when min(tx.effective_date) <> max(tx.effective_date) then tx.alt_description + ': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else
							tx.alt_description 
						end)
						else 
						--(Case when min(tx.effective_date) <> max(tx.effective_date) then 
						--	'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + libcc.description
						(Case when min(tx.effective_date) <> max(tx.effective_date) then libcc.description + ': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')

						else
							libcc.description
						end)
						end as detail_description	
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
					FROM #local_transactions tx with (nolock)
					inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					left join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					where tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA') and concl.invoice_id > -2.1
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.parent_tx_type, tx.transaction_type, tx.care_level, libcc.charge_code 
					,tx.alt_description, libcc.description, tx.is_billed, tx.transaction_type_group, tx.bill_date, concl.contact_id, concl.contact_num, concl.bill_date, tx.generated_date
					, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date)

				INSERT INTO #transactions	
				SELECT 
					  min(concl.invoice_id) as invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then  tx.description +': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else tx.description end as detail_description
					--, tx.description as detail_description
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, tx.transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.bill_date) as ancillary_year
					, datepart(mm,tx.bill_date) as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
				FROM #local_transactions tx with (nolock)
				inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					libcc.charge_code_id is null and tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA' and concl.invoice_id > -2.1
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.transaction_type, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date), tx.description 

			end

		If @vOtherStatementsIncluded = 1 
			begin

				INSERT INTO #transactions	
				SELECT 
					  concl.invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, libcc.charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')<>'' then 
						--(Case when min(tx.effective_date) <> max(tx.effective_date) then 
						--	'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + tx.alt_description
						(Case when min(tx.effective_date) <> max(tx.effective_date) then tx.alt_description + ': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else
							tx.alt_description 
						end)
						else 
						--(Case when min(tx.effective_date) <> max(tx.effective_date) then 
						--	'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + libcc.description
						(Case when min(tx.effective_date) <> max(tx.effective_date) then libcc.description + ': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')

						else
							libcc.description
						end)
						end as detail_description	
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
					FROM #local_transactions tx with (nolock)
					inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					left join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					where tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA') and concl.invoice_id <= -2.1
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.parent_tx_type, tx.transaction_type, tx.care_level, libcc.charge_code 
					,tx.alt_description, libcc.description, tx.is_billed, tx.transaction_type_group, tx.bill_date, concl.contact_id, concl.contact_num, concl.invoice_id, concl.bill_date, tx.generated_date
					, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date)

				INSERT INTO #transactions	
				SELECT 
					  concl.invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then  tx.description +': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else tx.description end as detail_description
					--, tx.description as detail_description
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, tx.transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.bill_date) as ancillary_year
					, datepart(mm,tx.bill_date) as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
				FROM #local_transactions tx with (nolock)
				inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					libcc.charge_code_id is null and tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA' and concl.invoice_id <= -2.1
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.transaction_type, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.invoice_id, concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date), tx.description 

			end

	end

if @vShowResults = 'CC'

	begin

		INSERT INTO #transactions	
		SELECT 
			  concl.invoice_id
			, tx.fac_id
			, concl.contact_id
			, concl.contact_num
			, tx.client_id
			, tx.payer_id
			, libpayer.description AS payer
			, libpayer.payer_type
			, tx.batch_id
			, tx.entry_number
			, tx.distribution_tx_id
			, tx.transaction_id
			, tx.reversing_tx_id
			, isnull(tx.auto_generated, 'N') as auto_generated
			, concl.bill_date
			, tx.transaction_date as posting_date
			, tx.effective_date
			, Null as effective_from_date
			, Null as effective_thru_date
			, tx.generated_date
			, libcc.charge_code
			, isnull(rtx.charge_frequency,'O') as frequency
			, tx.revenue_code
			, tx.hcpcs_code
			, tx.mppr_flag
			, Case when tx.transaction_type = 'R' and isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> '' 
					then rtype.long_description + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then 
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' + convert(varchar(4),YEAR(tx.effective_date))
					end) 
					+ (case when isnull(arpayer.show_care_level,'N') = 'Y'  and isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
				and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') = ''  
				and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'CL' and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X','CA') and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' then tx.description
				when tx.transaction_type ='CA' and isnull(tx.alt_description,'')='' then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')'
				when tx.transaction_type = 'CO' and tx.parent_tx_type <> 'R' then tx.description --+  ' Coinsurance'
				when tx.transaction_type = 'XR' and tx.parent_tx_type ='A' then tx.description --+  ' Reimb. Reduction' 
				when tx.transaction_type = 'CX' and tx.parent_tx_type ='R' then 'Room Excess' 
				when (tx.transaction_type in('XR','CO', 'D', 'CR') or (tx.transaction_type = 'CL' and isnull(tx.alt_description,'')='')) and tx.parent_tx_type = 'R' then
				(Case 
					when isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> ''  
						then rtype.long_description + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(arpayer.show_care_level,'N') = 'Y' and isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
						and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' +
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then  
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'XR'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'CO'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else
							' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end) --+ ' Coinsurance'
					else 
						(case when tx.transaction_type = 'XR' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
							(case when abs(tx.days_amount) > 1 then
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else  ' ' +	convert(varchar(4),YEAR(tx.effective_date))
							end)
						else 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') +
							(case when abs(tx.days_amount) > 1 then 
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else ' ' + convert(varchar(4),YEAR(tx.effective_date))
							end) --+
							--(case when tx.transaction_type = 'D' then ' Deductible' 
							--	when tx.transaction_type = 'CO' then ' Coinsurance' else '' end)  
						end)
					end
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				) --+ (case when tx.transaction_type = 'CL' then ' Coverage Deductible' else '' end) 
				 --+ (case when tx.transaction_type = 'CR' then ' Contractural Adj.' else '' end) 
				else tx.description end as detail_description
			, tx.care_level
			, Case when tx.transaction_type = 'R' and libpayer.pps_flag='Y' then ltrim(rtrim(str(tx.medicare_day))) + '-' 
				+ltrim(rtrim(str((
					case when tx.days_amount < 0 and (tx.days_amount*-1) > 1 then tx.days_amount*-1 + tx.medicare_day -1
					when tx.days_amount > 0 and (tx.days_amount*-1) = 1 then tx.days_amount*-1  + tx.medicare_day
					when tx.days_amount > 1 then tx.days_amount + tx.medicare_day -1
					else tx.days_amount + tx.medicare_day end))))
				else Null
					end as benefit_days
			, tx.parent_tx_type
			, tx.transaction_type
			, tx.daily_rate as unit_amount
			, case when tx.transaction_type = 'XR' then Null else tx.days_amount end as number_of_units
			, tx.amount
			, acct.account_number as gl_account
			, daysacct.account_number as days_account
			, case when tx.is_billed = 1 and isnull(tx.invoice_id,0) > 0 then 'Y'
				when tx.is_billed = 1 and isnull(tx.invoice_id,0) < 0 then 'N/A' else 'N' end as billed
			, tx.comment
			, tx.cheque_number
			, case when libcc.adjustment_type is not null and tx.transaction_type = 'X' then libcc.transaction_type + '_' + libcc.adjustment_type 
				when recur.transaction_id is not null then 'Recur'
				when tx.mppr_flag = 1 or convert(bit, case when bump.bumpup_transaction_id is null then 0 else 1 end) = 'true' then 'MPPR'
				else tx.transaction_type end as adjusted_tx_type
			, case when recur.transaction_id is null then 0 else 1 end as recurring_tx
			, case when tx.reversing_tx_id is null then 0 else 1 end as reversed
			, tx.transaction_type_group	
			, 0 as ancillary_year
			, 0 as ancillary_month	
			, 0 as balance_due
			, 0 as other_payer
			, NULL as aging_total
			, NULL as aging_current_label
			, NULL as aging_current_amount
			, NULL as aging_30_label
			, NULL as aging_30_amount
			, NULL as aging_60_label
			, NULL as aging_60_amount
			, NULL as aging_90_label
			, NULL as aging_90_amount
			, NULL as aging_120_label
			, NULL as aging_120_amount
			, NULL as aging_150_label
			, NULL as aging_150_amount
			, NULL as aging_180_label
			, NULL as aging_180_amount
			, NULL as aging_210_label
			, NULL as aging_210_amount
			, 0 as detail_order		
		FROM #local_transactions tx with (nolock)
		inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
		inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
		inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
		left join dbo.ar_transactions_location_room roomLocation with (nolock) on roomLocation.transaction_id = tx.transaction_id  
		left join dbo.ar_transaction_recurring_tx_refs recur with (nolock) on tx.transaction_id = recur.transaction_id
		left join dbo.ar_recurring_transactions rtx with (nolock) on rtx.transaction_id = recur.recurring_tx_id
		left join dbo.ar_batch batch with (nolock) on tx.batch_id = batch.batch_id
		left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
		left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
		left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
		left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
		left join dbo.ar_mppr_bumpup bump with (nolock) on tx.distribution_tx_id = bump.bumpup_transaction_id  
		WHERE 
			libcc.charge_code_id is null and tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA')

		If @vPrivateStatementsIncluded = 1 
			begin

				INSERT INTO #transactions	
				SELECT 
					  min(concl.invoice_id) as invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					--, Case when min(tx.effective_date) <> max(tx.effective_date) then 
					--		'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + cat.cat_description
					, Case when min(tx.effective_date) <> max(tx.effective_date) then cat.cat_description + ': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else
							cat.cat_description
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month
					, 0 as balance_due	
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order	
					FROM #local_transactions tx with (nolock)
					inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					inner join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					where tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA') and concl.invoice_id > -2.1
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.parent_tx_type,
					tx.transaction_type, tx.care_level, cat.item_cat_id, cat.cat_description,tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date)

				INSERT INTO #transactions	
				SELECT 
					  min(concl.invoice_id) as invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					--, Case when min(tx.effective_date) <> max(tx.effective_date) then 
					--		'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + libcc.description
					, Case when min(tx.effective_date) <> max(tx.effective_date) then libcc.description + ' ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else
							libcc.description
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
					FROM #local_transactions tx with (nolock)
					inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					left join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					where cat.item_cat_id is null and tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA') and concl.invoice_id > -2.1
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.parent_tx_type,
					tx.transaction_type, tx.care_level, libcc.charge_code, libcc.description, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date)

				INSERT INTO #transactions	
				SELECT 
					  min(concl.invoice_id) as invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then  tx.description +': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else tx.description end as detail_description
					--, tx.description as detail_description
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, tx.transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.bill_date) as ancillary_year
					, datepart(mm,tx.bill_date) as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
				FROM #local_transactions tx with (nolock)
				inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					libcc.charge_code_id is null and tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA' and concl.invoice_id > -2.1
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.transaction_type, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date), tx.description

			end

		If @vOtherStatementsIncluded = 1 
			begin

				INSERT INTO #transactions	
				SELECT 
					  concl.invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					--, Case when min(tx.effective_date) <> max(tx.effective_date) then 
					--		'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + cat.cat_description
					, Case when min(tx.effective_date) <> max(tx.effective_date) then cat.cat_description + ': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else
							cat.cat_description
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month
					, 0 as balance_due	
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order	
					FROM #local_transactions tx with (nolock)
					inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					inner join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					where tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA') and concl.invoice_id <= -2.1
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.parent_tx_type,
					tx.transaction_type, tx.care_level, cat.item_cat_id, cat.cat_description,tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.invoice_id, concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date)

				INSERT INTO #transactions	
				SELECT 
					  concl.invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					--, Case when min(tx.effective_date) <> max(tx.effective_date) then 
					--		'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + libcc.description
					, Case when min(tx.effective_date) <> max(tx.effective_date) then libcc.description + ' ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else
							libcc.description
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
					FROM #local_transactions tx with (nolock)
					inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					left join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					where cat.item_cat_id is null and tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA') and concl.invoice_id <= -2.1
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.parent_tx_type,
					tx.transaction_type, tx.care_level, libcc.charge_code, libcc.description, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.invoice_id, concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date)

				INSERT INTO #transactions	
				SELECT 
					  concl.invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then  tx.description +': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else tx.description end as detail_description
					--, tx.description as detail_description
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, tx.transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.bill_date) as ancillary_year
					, datepart(mm,tx.bill_date) as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
				FROM #local_transactions tx with (nolock)
				inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					libcc.charge_code_id is null and tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA' and concl.invoice_id <= -2.1
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.transaction_type, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.invoice_id, concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date), tx.description

			end

	end

--summarize Tax transactions
INSERT INTO #transactions	
SELECT 
	  concl.invoice_id
	, tx.fac_id
	, concl.contact_id
	, concl.contact_num
	, tx.client_id
	, tx.payer_id
	, libpayer.description AS payer
	, libpayer.payer_type
	, tx.batch_id
	, 0 as entry_number
	, 0 as distribution_tx_id
	, 0 as transaction_id
	, 0 as reversing_tx_id
	, isnull(tx.auto_generated, 'N') as auto_generated
	, concl.bill_date
	, tx.transaction_date as posting_date
	, max(tx.effective_date)
	, Null as effective_from_date
	, Null as effective_thru_date
	, tx.generated_date
	, '' as charge_code
	, 'O' as frequency
	, tx.revenue_code
	, tx.hcpcs_code
	, tx.mppr_flag
	, tx.description
	, tx.care_level
	, 0 as benefit_days
	, tx.parent_tx_type
	, tx.transaction_type
	, Null as unit_amount
	, Null as number_of_units
	, sum(tx.amount) as amount
	, acct.account_number as gl_account
	, daysacct.account_number as days_account
	, 'Y' as billed
	, tx.comment
	, tx.cheque_number
	, tx.transaction_type as adjusted_tx_type
	, 0 as recurring_tx
	, 0 as reversed
	, tx.transaction_type_group	
	, 0 as ancillary_year
	, 0 as ancillary_month	
	, 0 as balance_due
	, 0 as other_payer
	, NULL as aging_total
	, NULL as aging_current_label
	, NULL as aging_current_amount
	, NULL as aging_30_label
	, NULL as aging_30_amount
	, NULL as aging_60_label
	, NULL as aging_60_amount
	, NULL as aging_90_label
	, NULL as aging_90_amount
	, NULL as aging_120_label
	, NULL as aging_120_amount
	, NULL as aging_150_label
	, NULL as aging_150_amount
	, NULL as aging_180_label
	, NULL as aging_180_amount
	, NULL as aging_210_label
	, NULL as aging_210_amount
	, 0 as detail_order		
FROM #local_transactions tx with (nolock)
inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
where tx.transaction_type = 'TA'
group by concl.invoice_id, tx.fac_id, concl.contact_id, concl.contact_num, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.batch_id
, isnull(tx.auto_generated, 'N'), concl.bill_date, tx.generated_date, tx.transaction_date, tx.effective_date, tx.revenue_code, tx.hcpcs_code, tx.mppr_flag, tx.description, tx.care_level
, tx.parent_tx_type, tx.transaction_type, acct.account_number, daysacct.account_number, tx.comment, tx.cheque_number, tx.transaction_type_group	

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 150
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' removing reversals that have been combined from different invoices ' + convert(varchar(26),getdate(),109)

delete  rev
from #transactions rev
inner join #transactions rev2 on rev.transaction_id = rev2.reversing_tx_id and rev.transaction_id > 0 
	and rev.contact_num = rev2.contact_num and rev.client_id = rev2.client_id

set @vRowCount = @@rowcount

if @debug_me='Y' Print ltrim(rtrim(str(@vRowCount)))+' combined reversing rows removed.'
	

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 160
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' calculating balance forwards ' + convert(varchar(26),getdate(),109)

If @vPrivateStatementsIncluded = 1 -- calculate BF's for private statements as they are included
begin	

	insert into #transactions
	select 
		  min(concl.invoice_id) as invoice_id
		, concl.summary_fac_id
		, concl.contact_id
		, concl.contact_num
		, concl.client_id
		, concl.payer_id
		, '' as payer
		, '' as payer_type
		, Null as batch_id
		, Null as entry_number
		, Null as distribution_tx_id
		, Null as transaction_id
		, Null as reversing_tx_id
		, Null as auto_generated
		, Null as bill_date
		, Null as posting_date	
		, Null as effective_date
		, Null as effective_from_date
		, Null as effective_thru_date	
		, Null as generated_date	
		, Null as charge_code
		, Null as frequency
		, Null as revenue_code
		, Null as hcpcs_code
		, Null as mppr_flag
		, 'BALANCE FORWARD' as tx_description
		, Null as care_level		
		, Null as benefit_days
		, Null as parent_tx_type
		, '00' as transaction_type
		, Null as unit_amount
		, Null as units
		, 0.0 as amount
		, Null as gl_account
		, Null as days_account
		, Null as billed
		, '' as comment
		, '' as cheque_number
		, Null as adjusted_tx_type
		, Null as recurring_tx
		, Null as reversed
		, Null as transaction_type_group
		, 0 as ancillary_year
		, 0 as ancillary_month
		, 0 as balance_due
		, 0 as other_payer
		, NULL as aging_total
		, NULL as aging_current_label
		, NULL as aging_current_amount
		, NULL as aging_30_label
		, NULL as aging_30_amount
		, NULL as aging_60_label
		, NULL as aging_60_amount
		, NULL as aging_90_label
		, NULL as aging_90_amount
		, NULL as aging_120_label
		, NULL as aging_120_amount
		, NULL as aging_150_label
		, NULL as aging_150_amount
		, NULL as aging_180_label
		, NULL as aging_180_amount
		, NULL as aging_210_label
		, NULL as aging_210_amount
		, 0 as detail_order
			
	from #contact_clients concl
	where concl.contact_id > -2.1
	group by  concl.contact_id, concl.contact_num, concl.summary_fac_id, concl.client_id, concl.bill_date, concl.payer_id

	insert into #balance_forward_union 
	SELECT 
		  clientInv.contact_id
		, clientInv.contact_num
		, clientInv.client_id
		, 0--clientInv.invoice_id
		, clientInv.bill_date
		, ''
		, SUM(txn.amount) as amount	
	FROM dbo.ar_transactions txn WITH (NOLOCK)
	inner join (select distinct contact_id, contact_num, client_id, bill_date from #contact_clients where contact_id > -2.1) clientInv
		on clientInv.client_id = txn.client_id
	join dbo.ar_invoice invoice WITH (NOLOCK) ON invoice.invoice_id = txn.invoice_id --and clientInv.invoice_id<>invoice.invoice_id
		and invoice.deleted = 'N'
		and invoice.trial_flag = 'N'
		and invoice.fac_id = txn.fac_id 
		--and invoice.effective_date < (dateadd(mm,-1, clientInv.bill_date))
		--and invoice.effective_date < (dateadd(dd,-1, clientInv.bill_date))
		and invoice.effective_date < clientInv.bill_date
		and txn.deleted = 'N'
	join dbo.ar_lib_payers libpayer WITH (NOLOCK) on libpayer.payer_id=txn.payer_id
			and libpayer.deleted = 'N' and ((libpayer.payer_type = 'Private' and libpayer.bill_form = 'private') or (libpayer.payer_type = 'Outpatient' and libpayer.outpatient_payer_type = 'Private'))
		--	--and libpayer.bill_form = 'private' and (libpayer.payer_type  = 'Private' OR libpayer.payer_type  = 'Outpatient')
	join dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id = libpayer.payer_id and payer.fac_id = txn.fac_id and (@vExportMode = 0 or (@vExportMode = 1 and payer.export_ps_flag = 'Y'))
	where txn.deleted='N' 
		and not (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
		and not (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate')             
	group by clientInv.contact_id, clientInv.contact_num, clientInv.client_id, clientInv.bill_date
	having SUM(txn.amount) <> 0

	union all

	SELECT 
		  clientInv.contact_id
		, clientInv.contact_num
		, clientInv.client_id
		, 0--clientInv.invoice_id
		, clientInv.bill_date
		, ''
		, SUM(txn.amount) as amount	
	FROM #transactions txn WITH (NOLOCK)
	inner join (select distinct contact_id, contact_num, client_id, bill_date,generated_date from #contact_clients where contact_id > -2.1) clientInv
		on clientInv.client_id = txn.client_id and clientInv.contact_id = txn.contact_id and clientInv.bill_date = txn.bill_date and txn.contact_id > -2.1
	inner join dbo.ar_invoice_statement invstat WITH (NOLOCK) ON txn.invoice_id = invstat.invoice_id and convert(varchar(10),invstat.generated_date, 101) < clientInv.generated_date
	left join (select invoice_id from #contact_clients where contact_id > -2.1 group by invoice_id having count(*) > 1) multinv on txn.invoice_id = multinv.invoice_id  
	where multinv.invoice_id is null     
	group by clientInv.contact_id, clientInv.contact_num, clientInv.client_id, clientInv.bill_date
	having SUM(txn.amount) <> 0

	union all

		SELECT 
		  clientInv.contact_id
		, clientInv.contact_num
		, clientInv.client_id
		, 0--clientInv.invoice_id
		, clientInv.bill_date
		, ''
		, SUM(txn.amount) as amount	
	FROM #transactions txn WITH (NOLOCK)
	inner join (select distinct contact_id, contact_num, client_id, bill_date,generated_date from #contact_clients where contact_id > -2.1) clientInv
		on clientInv.client_id = txn.client_id and clientInv.contact_id <> txn.contact_id and clientInv.bill_date = txn.bill_date and txn.contact_id > -2.1
	inner join dbo.ar_invoice_statement invstat WITH (NOLOCK) ON txn.invoice_id = invstat.invoice_id and convert(varchar(10),invstat.generated_date, 101) < clientInv.generated_date
	left join (select invoice_id from #contact_clients where contact_id > -2.1 group by invoice_id having count(*) > 1) multinv on txn.invoice_id = multinv.invoice_id  
	where multinv.invoice_id is null     
	group by clientInv.contact_id, clientInv.contact_num, clientInv.client_id, clientInv.bill_date
	having SUM(txn.amount) <> 0

	union all
--findme
	SELECT 
		  clientInv.contact_id
		, clientInv.contact_num
		, clientInv.client_id
		, 0--clientInv.invoice_id
		, clientInv.bill_date
		, ''
		, SUM(txn.amount) as amount	
	--select txn.*
	FROM #transactions txn WITH (NOLOCK)
	inner join (select distinct contact_id, contact_num, client_id, bill_date,generated_date from #contact_clients where contact_id > -2.1) clientInv
		on clientInv.client_id = txn.client_id and clientInv.contact_id = txn.contact_id and clientInv.bill_date = txn.bill_date and txn.contact_id > -2.1
	inner join dbo.ar_invoice_statement invstat WITH (NOLOCK) ON txn.invoice_id = invstat.invoice_id and convert(varchar(10),invstat.generated_date, 101) < clientInv.generated_date
	left join (select invoice_id from #contact_clients where contact_id > -2.1 group by invoice_id having count(*) > 1) multinv on txn.invoice_id = multinv.invoice_id  
	where multinv.invoice_id is not null     
	group by clientInv.contact_id, clientInv.contact_num, clientInv.client_id, clientInv.bill_date
	having SUM(txn.amount) <> 0

	union all
	
	SELECT 
		  clientInv.contact_id
		, clientInv.contact_num
		, clientInv.client_id
		, 0 
		, clientInv.bill_date
		, ''
		, SUM(txn.amount) as amount
	FROM dbo.ar_transactions txn WITH (NOLOCK)
		inner join (select distinct contact_id, contact_num, client_id, bill_date from #contact_clients where contact_id > -2.1) clientInv
			on clientInv.client_id = txn.client_id
		join dbo.ar_lib_payers libpayer WITH (NOLOCK) on libpayer.payer_id=txn.payer_id
			and libpayer.deleted = 'N' and ((libpayer.payer_type = 'Private' and libpayer.bill_form = 'private') or (libpayer.payer_type = 'Outpatient' and libpayer.outpatient_payer_type = 'Private'))
		--	--and libpayer.bill_form = 'private' and (libpayer.payer_type  = 'Private' OR libpayer.payer_type  = 'Outpatient')
		join dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id = libpayer.payer_id and payer.fac_id = txn.fac_id and (@vExportMode = 0 or (@vExportMode = 1 and payer.export_ps_flag = 'Y'))
	where txn.deleted='N' 
	and txn.invoice_id < 0 -- for 'mark as billed' -999
		and not (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
		and not (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate') 
		--and txn.effective_date < (dateadd(mm,-1, clientInv.bill_date))
	group by clientInv.contact_id, clientInv.contact_num, clientInv.client_id, clientInv.bill_date
	having SUM(txn.amount) <> 0

	if @vInvoiceIdList is not null
		begin

			INSERT INTO #balance_forward_union
			SELECT   
					  t.contact_id
					, t.contact_num
					, t.client_id
					, 0 
					, t.bill_date
					, ''
					, SUM(t.amount) as amount	
			FROM (
					SELECT DISTINCT 
					  txn.transaction_id
					, clientInv.contact_id
					, clientInv.contact_num
					, clientInv.client_id
					, clientInv.bill_date
					, txn.amount 
				FROM #contact_clients payr WITH (NOLOCK) 
				inner join dbo.ar_invoice inv WITH (NOLOCK) ON payr.client_id = inv.client_id and inv.deleted = 'N' and inv.trial_flag = 'N'
					and payr.inv_effective_date = inv.effective_date and payr.contact_id > -2.1
				inner join dbo.ar_invoice_statement invstat WITH (NOLOCK) ON inv.invoice_id = invstat.invoice_id 
				inner join dbo.ar_transactions txn WITH (NOLOCK) ON inv.invoice_id = txn.invoice_id and txn.deleted='N'
				inner join dbo.ar_lib_payers libpayer WITH (NOLOCK) ON txn.payer_id = libpayer.payer_id AND (libpayer.deleted = 'N') 
					and ((libpayer.payer_type = 'Private' and libpayer.bill_form = 'private') or (libpayer.payer_type = 'Outpatient' and libpayer.outpatient_payer_type = 'Private'))	
				join dbo.ar_payers payer WITH (NOLOCK) on inv.payer_id = payer.payer_id and inv.fac_id = payer.fac_id 
				inner join (select distinct contact_id, contact_num, client_id, bill_date,generated_date from #contact_clients where contact_id > -2.1) clientInv
					on payr.contact_id = clientInv.contact_id and payr.contact_num = clientInv.contact_num and payr.client_id = clientInv.client_id and convert(varchar(10),inv.effective_date , 101) = clientInv.bill_date
					and convert(varchar(10),invstat.generated_date,101) < convert(varchar(10),payr.generated_date , 101)
				left join #contact_clients invids on invids.client_id = payr.client_id and invids.payer_id = payr.payer_id and invids.bill_date = payr.bill_date
					and inv.invoice_id = invids.invoice_id
				where invids.invoice_id is null 
					and not (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
					and not (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate') 
				) t    
				group by t.contact_id, t.contact_num, t.client_id, t.bill_date 
				having SUM(t.amount) <> 0;

		end
end

if @vOtherStatementsIncluded = 1 -- calculate BF's for other payer statements as they are included
begin

	insert into #transactions
	select 
		  concl.invoice_id
		, concl.summary_fac_id
		, concl.contact_id
		, concl.contact_num
		, concl.client_id
		, concl.payer_id
		, '' as payer
		, '' as payer_type
		, Null as batch_id
		, Null as entry_number
		, Null as distribution_tx_id
		, Null as transaction_id
		, Null as reversing_tx_id
		, Null as auto_generated
		, Null as bill_date
		, Null as posting_date	
		, Null as effective_date
		, Null as effective_from_date
		, Null as effective_thru_date	
		, Null as generated_date	
		, Null as charge_code
		, Null as frequency
		, Null as revenue_code
		, Null as hcpcs_code
		, Null as mppr_flag
		, 'BALANCE FORWARD' as tx_description
		, Null as care_level		
		, Null as benefit_days
		, Null as parent_tx_type
		, '00' as transaction_type
		, Null as unit_amount
		, Null as units
		, 0.0 as amount
		, Null as gl_account
		, Null as days_account
		, Null as billed
		, '' as comment
		, '' as cheque_number
		, Null as adjusted_tx_type
		, Null as recurring_tx
		, Null as reversed
		, Null as transaction_type_group
		, 0 as ancillary_year
		, 0 as ancillary_month
		, 0 as balance_due
		, 0 as other_payer
		, NULL as aging_total
		, NULL as aging_current_label
		, NULL as aging_current_amount
		, NULL as aging_30_label
		, NULL as aging_30_amount
		, NULL as aging_60_label
		, NULL as aging_60_amount
		, NULL as aging_90_label
		, NULL as aging_90_amount
		, NULL as aging_120_label
		, NULL as aging_120_amount
		, NULL as aging_150_label
		, NULL as aging_150_amount
		, NULL as aging_180_label
		, NULL as aging_180_amount
		, NULL as aging_210_label
		, NULL as aging_210_amount
		, 0 as detail_order
			
	from #contact_clients concl
	where concl.contact_id <= -2.1

	insert into #balance_forward_union 
	SELECT 
		  clientInv.contact_id
		, clientInv.contact_num
		, clientInv.client_id
		, clientInv.payer_id
		, clientInv.bill_date
		, ''
		, SUM(txn.amount) as amount	
	FROM dbo.ar_transactions txn WITH (NOLOCK)
	inner join (select distinct contact_id, contact_num, client_id, payer_id, bill_date from #contact_clients where contact_id <= -2.1) clientInv
		on clientInv.client_id = txn.client_id and clientInv.payer_id = txn.payer_id
	join dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id=txn.payer_id and payer.fac_id=txn.fac_id
	join dbo.ar_invoice invoice WITH (NOLOCK) ON invoice.invoice_id = txn.invoice_id
		and invoice.deleted = 'N'
		and invoice.trial_flag = 'N'
		and invoice.fac_id = txn.fac_id 
		and invoice.effective_date < clientInv.bill_date
	where txn.deleted='N' 
		and not (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
		and not (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate')          
	group by clientInv.contact_id, clientInv.contact_num, clientInv.client_id, clientInv.payer_id, clientInv.bill_date
	having SUM(txn.amount) <> 0

	union all

	SELECT 
		  clientInv.contact_id
		, clientInv.contact_num
		, clientInv.client_id
		, clientInv.payer_id 
		, clientInv.bill_date
		, ''
		, SUM(txn.amount) as amount	
	--select txn.*
	FROM #transactions txn WITH (NOLOCK)
	inner join (select distinct contact_id, contact_num, client_id, payer_id, bill_date, invoice_id from #contact_clients where contact_id <= -2.1) clientInv
		on clientInv.client_id = txn.client_id and clientInv.payer_id = txn.payer_id and clientInv.bill_date = txn.bill_date --and clientInv.contact_id = txn.contact_id 
			and txn.contact_id <= -2.1 
	left join (select invoice_id from #contact_clients where contact_id <= -2.1 group by invoice_id having count(*) > 1) multinv on txn.invoice_id = multinv.invoice_id  
	where txn.invoice_id < clientInv.invoice_id and ((txn.contact_id = clientInv.contact_id and multinv.invoice_id is not null) or multinv.invoice_id is null)    
	--where txn.invoice_id < clientInv.invoice_id --and txn.contact_id = clientInv.contact_id
	group by clientInv.contact_id, clientInv.contact_num, clientInv.client_id, clientInv.payer_id, clientInv.bill_date, clientInv.invoice_id
	having SUM(txn.amount) <> 0

	union all

	SELECT 
		  clientInv.contact_id
		, clientInv.contact_num
		, clientInv.client_id
		, clientInv.payer_id 
		, clientInv.bill_date
		, ''
		, SUM(txn.amount) as amount
	FROM dbo.ar_transactions txn WITH (NOLOCK)
		inner join (select distinct contact_id, contact_num, client_id, payer_id, bill_date from #contact_clients where contact_id <= -2.1) clientInv
			on clientInv.client_id = txn.client_id and clientInv.payer_id = txn.payer_id 
		join dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id=txn.payer_id and payer.fac_id=txn.fac_id
	where txn.deleted='N' 
	and not (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
	and not (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate')    
	and txn.invoice_id < 0 -- for 'mark as billed' -999
	group by clientInv.contact_id, clientInv.contact_num, clientInv.client_id, clientInv.payer_id, clientInv.bill_date
	having SUM(txn.amount) <> 0

	if @vInvoiceIdList is not null
		begin
			INSERT INTO #balance_forward_union
			SELECT   
					  t.contact_id
					, t.contact_num
					, t.client_id
					, 0 
					, t.bill_date
					, ''
					, SUM(t.amount) as amount	
			FROM (
					SELECT DISTINCT 
					  txn.transaction_id
					, clientInv.contact_id
					, clientInv.contact_num
					, clientInv.client_id
					, clientInv.bill_date
					, txn.amount 
				FROM #contact_clients payr WITH (NOLOCK) 
				inner join dbo.ar_invoice inv WITH (NOLOCK) ON payr.client_id = inv.client_id and inv.deleted = 'N' and inv.trial_flag = 'N' 
					and payr.inv_effective_date = inv.effective_date and payr.contact_id <= -2.1
				inner join dbo.ar_transactions txn WITH (NOLOCK) ON inv.invoice_id = txn.invoice_id and txn.deleted='N'
				inner join dbo.ar_lib_payers libpayer WITH (NOLOCK) ON txn.payer_id = libpayer.payer_id AND (libpayer.deleted = 'N') 
					and libpayer.bill_form  = 'private' and libpayer.payer_type <> 'Private' and not( libpayer.payer_type = 'Outpatient' and outpatient_payer_type = 'Private')	
				join dbo.ar_payers payer WITH (NOLOCK) on inv.payer_id = payer.payer_id and inv.fac_id = payer.fac_id 
				inner join (select distinct contact_id, contact_num, client_id, bill_date,generated_date from #contact_clients where contact_id <= -2.1) clientInv
					on payr.contact_id = clientInv.contact_id and payr.contact_num = clientInv.contact_num and payr.client_id = clientInv.client_id and convert(varchar(10),inv.effective_date , 101) = clientInv.bill_date
				left join #contact_clients invids on invids.client_id = payr.client_id and invids.payer_id = payr.payer_id and invids.bill_date = payr.bill_date
					and inv.invoice_id = invids.invoice_id
				where invids.invoice_id is null 
					and not (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
					and not (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate') 
				) t    
				group by t.contact_id, t.contact_num, t.client_id, t.bill_date 
				having SUM(t.amount) <> 0;
		end
end

--------------------------------------------------------------------------------
-- CONSOLIDATE AMOUNT
-------------------------------------------------------------------------------- 

insert into #balance_forward_amount
select contact_id,contact_num,client_id,payer_id,invoice_date,payer_type,sum(amount)
from #balance_forward_union 
group by contact_id,contact_num,client_id,payer_id,invoice_date,payer_type
having sum(amount) <>0
order by contact_id,contact_num,client_id,invoice_date,payer_type

if @debug_me='Y' select * from #balance_forward_union order by contact_num, client_id
if @debug_me='Y' select * from #balance_forward_amount order by contact_num, client_id

update csd set csd.amount = bfttl.ttl
from #transactions csd
inner join (select bf.contact_num,bf.client_id,bf.payer_id,bf.invoice_date,sum(bf.amount) ttl 
	from #balance_forward_amount bf
	group by bf.contact_num,bf.client_id,bf.payer_id,bf.invoice_date) bfttl on csd.contact_num = bfttl.contact_num 
		and csd.client_id = bfttl.client_id and csd.payer_id = bfttl.payer_id
where csd.other_payer <> 1 and csd.transaction_type = '00'

update concl set concl.previous_balance_due = csd.amount
from #contact_clients concl
inner join #transactions csd on concl.contact_num = csd.contact_num and concl.client_id = csd.client_id and csd.transaction_type = '00' 

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 180
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' calculating other payer summary ' + convert(varchar(26),getdate(),109)

--OtherPayers

IF @vOtherPayerSummary = 1
    BEGIN

		SELECT DISTINCT client_id, bill_date INTO #OtherPayerInfo FROM #contact_clients where contact_id <> -2.1 and contact_id <> -3.1;
	    
		insert into #transactions (invoice_id, fac_id, contact_id, contact_num, client_id, transaction_type, tx_description, comment,
		amount, balance_due, other_payer, detail_order, bill_date, payer_type, effective_date)                            
                SELECT 
                            max(concl.invoice_id) as invoice_id
                            , concl.summary_fac_id
                            , concl.contact_id
                            , concl.contact_num
                            , concl.client_id
                            , 'YZ' as transaction_type
                            , libpayer.[description] as [description]
                            , '' as comment
                            , tx.amount as amount
                            , 0 as balance_due
                            , 1 as other_payer
                            --, libpayer.payer_type as payer_type
                            , 0 as detail_order
                            , concl.bill_date
							, libPayer.payer_type 
							, tx.effective_date as effective_date  
                FROM   #contact_clients concl
                INNER JOIN 
                (
				SELECT client_id,payer_id, bill_date, SUM(amount) amount, max(effective_date) as effective_date
                        FROM
                                (SELECT  
                                                t.client_id, 
                                                t.payer_id, 
                                                c.bill_date,
												t.effective_date,
                                                t.amount 
                                    FROM dbo.ar_transactions_rollup_client AS t WITH (NOLOCK)
                                    INNER JOIN #OtherPayerInfo c
                                    ON t.client_id = c.client_id AND t.effective_date < DATEADD(dd,1, c.bill_date)
                                    INNER JOIN dbo.ar_lib_payers libpayer WITH (NOLOCK)  
                                    ON t.payer_id = libpayer.payer_id AND libPayer.deleted = 'N' 
                                    AND isnull(libpayer.informational_payer_flag,0) = 1
									AND (isnull(libpayer.informational_payer_use_standard_rate, 0) = 0 or t.transaction_type <> 'CR')
                                    UNION ALL
                                    SELECT
                                                t.client_id, 
                                                t.payer_id,
                                                c.bill_date,
												t.effective_date,
                                                (CASE WHEN t.transaction_type = 'C' THEN - 1 * h.amount ELSE t .amount END) AS amount 
                                    FROM dbo.ar_transactions AS t WITH (NOLOCK)
                                    INNER JOIN #OtherPayerInfo c
                                    ON t.client_id = c.client_id
                                    INNER JOIN dbo.ar_lib_payers libpayer WITH (NOLOCK)  
                                    ON t.payer_id = libpayer.payer_id AND libPayer.deleted = 'N' 
                                    AND isnull(libpayer.informational_payer_flag,0) = 1 
									AND (isnull(libpayer.informational_payer_use_standard_rate, 0) = 0 or t.transaction_type <> 'CR') 
                                    LEFT JOIN dbo.ar_applied_payment_history AS h WITH (NOLOCK) 
                                    ON h.transaction_id = t.transaction_id 
                                    AND h.fac_id = t.fac_id AND ISNULL(h.deleted, 'N') = 'N' 
                                    AND h.current_period_date IS NOT NULL
                                    WHERE t.deleted = 'N' AND (CASE WHEN t.transaction_type = 'C' THEN h.applied_to_date ELSE t.effective_date END) < DATEADD(dd,1, c.bill_date)
                                                AND t.payer_id > 0 AND t.transaction_date IS NOT NULL 
                                                AND t.OpenClose_Flag = 'O'
                                    UNION ALL
                                    SELECT 
                                                h.client_id, 
                                                h.payer_id,
                                                c.bill_date,
												h.applied_to_date as effective_date,
                                                - (1 * h.amount) AS amount
                                    FROM dbo.ar_applied_payment_history AS h WITH (NOLOCK)
                                    INNER JOIN #OtherPayerInfo c
                                    ON h.client_id = c.client_id and  h.applied_to_date < DATEADD(dd,1,c.bill_date) 
                                    INNER JOIN dbo.ar_lib_payers libpayer WITH (NOLOCK)  
                                    ON h.payer_id = libpayer.payer_id AND libPayer.deleted = 'N' 
                                    AND isnull(libpayer.informational_payer_flag,0) = 1
                                    WHERE h.deleted = 'N' 
                                    AND h.payer_id > 0 AND h.transaction_id = -1 
                                    AND h.OpenClose_Flag = 'O'
                                    ) op
                                GROUP BY client_id, payer_id, bill_date
                                --HAVING SUM(amount) <> 0

                ) tx         
                ON concl.client_id = tx.client_id  AND tx.bill_date= concl.bill_date and concl.contact_id <> -2.1 and concl.contact_id <> -3.1
                INNER JOIN dbo.ar_lib_payers libpayer WITH (NOLOCK)  
                ON tx.payer_id = libpayer.payer_id AND libPayer.deleted = 'N' 
                AND isnull(libpayer.informational_payer_flag,0) = 1
				WHERE tx.amount > 0 
                GROUP BY concl.contact_id, tx.amount,concl.contact_num, concl.summary_fac_id, concl.client_id, libpayer.[description], libPayer.payer_type, concl.bill_date,tx.effective_date

            update csd set csd.balance_due = csdttl.ttl
            from #transactions csd
            inner join (select contact_id, contact_num, invoice_id, bill_date ,sum(amount) ttl from #transactions 
            where other_payer = 1 group by contact_id, contact_num, invoice_id, bill_date) csdttl on 
            csd.invoice_id = csdttl.invoice_id and csd.contact_id = csdttl.contact_id and csd.contact_num = csdttl.contact_num 
            and csd.bill_date = csdttl.bill_date and csd.other_payer = 1;

        END 

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
--select * from #transactions where other_payer = 1
select @vStep = 190
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' gathering current trust balances ' + convert(varchar(26),getdate(),109)

--Trust balances
	    
insert into #transactions (invoice_id, fac_id, contact_id, contact_num, client_id, transaction_type, tx_description, comment,
amount, balance_due, other_payer, detail_order, bill_date)                            
SELECT cc.invoice_id
    , cc.summary_fac_id
    , cc.contact_id
    , cc.contact_num
    , cc.client_id
    , 'YY' as transaction_type
    , stdact.[description] as [description]
    , '' as comment
    , sum(tx.amount) as amount
    , 0 as balance_due
    , 3 as other_payer
    , 0 as detail_order
    , cc.bill_date
from dbo.ta_transaction tx with (nolock)
inner join
	(select max(invoice_id) as invoice_id,summary_fac_id, contact_id, contact_num, client_id, bill_date from #contact_clients where contact_id <> -2.1 and contact_id <> -3.1
		group by summary_fac_id, contact_id, contact_num, client_id, bill_date) cc
	on tx.client_id = cc.client_id and tx.deleted = 'N' and tx.transaction_date is not null
inner join dbo.ta_client_configuration tcc with (nolock) on cc.client_id = tcc.client_id and tcc.deleted = 'N' and isnull(tcc.trust_balance_on_bill,'N') = 'Y'
inner join dbo.ta_std_account stdact with (nolock) on tx.std_account_id = stdact.std_account_id
where cc.contact_id <> -2.1 and contact_id <> -3.1
group by cc.invoice_id, cc.summary_fac_id, cc.contact_id, cc.contact_num, cc.client_id, stdact.[description], cc.bill_date
order by stdact.[description]


update csd set csd.balance_due = csdttl.ttl
from #transactions csd
inner join (select contact_id, contact_num, invoice_id, bill_date ,sum(amount) ttl from #transactions 
where other_payer = 3 group by contact_id, contact_num, invoice_id, bill_date) csdttl on 
csd.invoice_id = csdttl.invoice_id and csd.contact_id = csdttl.contact_id and csd.contact_num = csdttl.contact_num 
and csd.bill_date = csdttl.bill_date and csd.other_payer = 3;

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 195
set @vgsStepStartTime = GETDATE()

if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' calculating various total values ' + convert(varchar(26),getdate(),109)

update csd set csd.balance_due = csdttl.ttl
from #transactions csd
inner join (select contact_id,contact_num,client_id,sum(amount) ttl from #transactions 
		where other_payer = 0
		group by contact_id,contact_num,client_id) csdttl on
	csd.contact_id = csdttl.contact_id and csd.contact_num = csdttl.contact_num and csd.client_id = csdttl.client_id  and csd.other_payer = 0 
--		and csd.other_payer <> 1 and csd.transaction_type <> '00' and csd.transaction_type <> 'C' and csd.tx_charge_code <> 'LateFeeSys'

update concl set concl.summary_client_balance_due = csdttl.ttl
from #contact_clients concl
inner join (select contact_id,contact_num,client_id,sum(amount) ttl from #transactions 
		where other_payer = 0 and transaction_type <> '00' and transaction_type <> 'C' and (charge_code <> 'LateFeeSys' or charge_code is null)
		group by contact_id,contact_num,client_id) csdttl on
	concl.contact_id = csdttl.contact_id and concl.contact_num = csdttl.contact_num and concl.client_id = csdttl.client_id

update concl set concl.payments = csdttl.ttl
from #contact_clients concl
inner join (select contact_id,contact_num,client_id,sum(payments) ttl from #contact_clients 
		group by contact_id,contact_num,client_id) csdttl on
	concl.contact_id = csdttl.contact_id and concl.contact_num = csdttl.contact_num and concl.client_id = csdttl.client_id

update concl set concl.summary_current_balance = bdttl.ttl
from #contact_clients concl
inner join (select contact_id,contact_num,sum(amount) ttl from  #transactions csd
			where other_payer = 0 group by contact_id, contact_num) bdttl 
	on concl.contact_id = bdttl.contact_id and concl.contact_num = bdttl.contact_num
 
update concl set concl.summary_previous_balance_due = bfttl.ttl
from #contact_clients concl
inner join (select contact_id,contact_num,sum(amount) ttl from #transactions  
			where transaction_type = '00' group by contact_id, contact_num) bfttl 
	on concl.contact_id = bfttl.contact_id and concl.contact_num = bfttl.contact_num --and concl.consolidate_statement = 1

update concl set concl.summary_payments = payttl.ttl
from #contact_clients concl
inner join (select contact_id,contact_num,sum(amount) ttl from #transactions 
			where transaction_type = 'C' group by contact_id, contact_num) payttl 
	on concl.contact_id = payttl.contact_id and concl.contact_num = payttl.contact_num --and concl.consolidate_statement = 1

update concl set concl.summary_late_fees = latefee.ttl
from #contact_clients concl
inner join (select contact_id,contact_num,sum(amount) ttl from #transactions 	
			where charge_code = 'LateFeeSys' group by contact_id, contact_num) latefee 
	on concl.contact_id = latefee.contact_id and concl.contact_num = latefee.contact_num 


set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

--Aging
IF @vShowAging = 1
BEGIN
	CREATE TABLE #temp_bucket_sum 
	(
		amount money,
		client_id int, 
		aging_date datetime,
		bill_date datetime,
		payer_id int,
		bucket_index int
	);

	IF @vPrivateStatementsIncluded = 1
	BEGIN
		SET @vStep = 200;
		SET @vgsStepStartTime = GETDATE();
		IF  @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Start aging calculations ' + convert(varchar(26),getdate(),109);
       
		INSERT INTO #transactions (invoice_id, fac_id, contact_id, contact_num, client_id, payer_id, transaction_type, comment
		, balance_due, other_payer, aging_total, aging_current_label, aging_current_amount, aging_30_label, aging_30_amount, aging_60_label, aging_60_amount, aging_90_label
		, aging_90_amount, aging_120_label, aging_120_amount, aging_150_label, aging_150_amount, aging_180_label, aging_180_amount, aging_210_label, aging_210_amount
		, detail_order, bill_date)                           
				SELECT  
									max(concl.invoice_id) as invoice_id
									, concl.summary_fac_id
									, concl.contact_id
									, concl.contact_num
									, concl.client_id
									, concl.payer_id
									, 'ZZ' as transaction_type
									, '' as detail_comment
									, 0 as balance_due
									, 2 as other_payer
									, 0.0 as aging_total
									, convert(varchar(2),datepart(mm,concl.aging_date)) + '/' + convert(varchar(4),datepart(yyyy,concl.aging_date)) as aging_current_label
									, 0.0 as aging_current_amount
									, convert(varchar(2),datepart(mm,(dateadd(mm,-1,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-1,concl.aging_date)))) as aging_30_label
									, 0.0 as aging_30_amount
									, convert(varchar(2),datepart(mm,(dateadd(mm,-2,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-2,concl.aging_date)))) as aging_60_label
									, 0.0 as aging_60_amount
									, convert(varchar(2),datepart(mm,(dateadd(mm,-3,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-3,concl.aging_date)))) as aging_90_label
									, 0.0 as aging_90_amount
									, convert(varchar(2),datepart(mm,(dateadd(mm,-4,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-4,concl.aging_date)))) as aging_120_label
									, 0.0 as aging_120_amount
									, convert(varchar(2),datepart(mm,(dateadd(mm,-5,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-5,concl.aging_date)))) as aging_150_label
									, 0.0 as aging_150_amount
									, convert(varchar(2),datepart(mm,(dateadd(mm,-6,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-6,concl.aging_date)))) as aging_180_label
									, 0.0 as aging_180_amount
									, '+ '+convert(varchar(2),datepart(mm,(dateadd(mm,-7,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-7,concl.aging_date)))) as aging_210_label
									, 0.0 as aging_210_amount
									, 0 as detail_order 
									, concl.bill_date
   					FROM #contact_clients concl
					WHERE concl.payer_id = 0
					GROUP BY concl.contact_id, concl.contact_num,concl.bill_date, concl.aging_date, concl.summary_fac_id, concl.client_id, concl.payer_id;

		SELECT DISTINCT csd.client_id, cc.aging_date,cc.bill_date,cc.payer_id  INTO #aging_clients 
		FROM #transactions csd
		INNER JOIN #contact_clients cc ON csd.client_id = cc.client_id AND cc. payer_id = 0 AND csd.transaction_type='ZZ';

		-- Temp table used to calculate amount for each bucket
		INSERT INTO #temp_bucket_sum (amount, client_id, aging_date, bill_date, payer_id, bucket_index)
			SELECT SUM(s.amount) AS amount, s.client_id, s.aging_date ,s.bill_date, s.payer_id, 
			CASE WHEN s.month_diff < 0 THEN 0 WHEN s.month_diff > 7 THEN 7 ELSE s.month_diff END AS bucket_index 
			FROM (
				SELECT 
						cl.client_id    
						, cl.aging_date 
						, cl.bill_date
						, cl.payer_id
						, CASE WHEN h.transaction_id is null THEN txn.amount ELSE -1*h.amount END AS 'amount'
						, CASE WHEN h.transaction_id is null 
								THEN DATEDIFF(MONTH, txn.effective_date,  DATEADD(dd,1, cl.bill_date)) 
								ELSE DATEDIFF(MONTH, h.applied_to_date,  DATEADD(dd,1, cl.bill_date)) 
							END AS 'month_diff'
				FROM dbo.ar_transactions txn WITH (NOLOCK)
				INNER JOIN #aging_clients cl
				ON cl.client_id = txn.client_id
				INNER JOIN dbo.ar_invoice invoice WITH (NOLOCK) 
				ON invoice.invoice_id = txn.invoice_id  AND invoice.effective_date < DATEADD(dd,1,cl.bill_date)
				AND invoice.deleted = 'N' AND invoice.trial_flag = 'N' AND invoice.fac_id = txn.fac_id 
				AND txn.deleted = 'N'
				INNER JOIN dbo.ar_lib_payers libpayer WITH (NOLOCK) on libpayer.payer_id=txn.payer_id
				AND libpayer.deleted = 'N' and ((libpayer.payer_type = 'Private' and libpayer.bill_form = 'private') or (libpayer.payer_type = 'Outpatient' and libpayer.outpatient_payer_type = 'Private'))
				INNER JOIN dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id = txn.payer_id and payer.fac_id = txn.fac_id 
				LEFT JOIN ar_applied_payment_history h on txn.transaction_id = h.transaction_id AND h.deleted = 'N' 
				WHERE txn.deleted='N' 
				AND NOT (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
				AND NOT (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate')             
				UNION ALL
				SELECT
					  cl.client_id    
					, cl.aging_date 
					, cl.bill_date
					, cl.payer_id
					, CASE WHEN h.transaction_id is null THEN txn.amount ELSE -1*h.amount END AS 'amount'
					, CASE WHEN h.transaction_id is null 
						THEN DATEDIFF(MONTH, txn.effective_date,  DATEADD(dd,1, cl.bill_date)) 
						ELSE DATEDIFF(MONTH, h.applied_to_date,  DATEADD(dd,1, cl.bill_date)) 
					  END AS 'month_diff'
				FROM dbo.ar_transactions txn WITH (NOLOCK)
				INNER JOIN #aging_clients cl ON cl.client_id = txn.client_id
				INNER JOIN dbo.ar_lib_payers libpayer WITH (NOLOCK) on libpayer.payer_id=txn.payer_id
				AND libpayer.deleted = 'N' and ((libpayer.payer_type = 'Private' and libpayer.bill_form = 'private') or (libpayer.payer_type = 'Outpatient' and libpayer.outpatient_payer_type = 'Private'))
				INNER JOIN dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id=txn.payer_id and payer.fac_id=txn.fac_id
				LEFT JOIN ar_applied_payment_history h on txn.transaction_id = h.transaction_id AND h.deleted = 'N' 
				WHERE txn.deleted='N' 
					AND txn.invoice_id < 0 
					AND NOT (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
					AND NOT (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate') 
				)s
				GROUP BY s.client_id, s.aging_date, s.bill_date, s.payer_id, CASE WHEN s.month_diff < 0 THEN 0 WHEN s.month_diff > 7 THEN 7 ELSE s.month_diff END 

		-- --- Update each bucket using #temp_bucket_sum ---

		--Current bucket: bucket_index = 0 
		UPDATE std SET std.aging_current_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id = 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 0
		WHERE std.transaction_type = 'ZZ' and std.payer_id = 0;

		--Bucket 30: bucket_index = 1 
		UPDATE std SET std.aging_30_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id = 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 1
		WHERE std.transaction_type = 'ZZ' and std.payer_id = 0;

		--Bucket 60: bucket_index = 2
		UPDATE std SET std.aging_60_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id = 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 2
		WHERE std.transaction_type = 'ZZ' and std.payer_id = 0;

		--Bucket 90: bucket_index = 3	
		UPDATE std SET std.aging_90_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id = 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 3
		WHERE std.transaction_type = 'ZZ' and std.payer_id = 0;

		--Bucket 120: bucket_index = 4
		UPDATE std SET std.aging_120_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id = 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 4
		WHERE std.transaction_type = 'ZZ' and std.payer_id = 0;

		--Bucket 150: bucket_index = 5
		UPDATE std SET std.aging_150_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id = 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 5
		WHERE std.transaction_type = 'ZZ' and std.payer_id = 0;

		--Bucket 180: bucket_index = 6
		UPDATE std SET std.aging_180_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id = 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 6
		WHERE std.transaction_type = 'ZZ' and std.payer_id = 0;

		--Bucket 210:  bucket_index = 7
		UPDATE std SET std.aging_210_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id = 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 7
		WHERE std.transaction_type = 'ZZ' and std.payer_id = 0;

		SET @vgsStepEndTime = GETDATE();
		IF  @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete aging calculations: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms';
	END

	IF @vOtherStatementsIncluded = 1
	BEGIN
		SET @vStep = 210;
		SET @vgsStepStartTime = GETDATE();
		IF  @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Start other payer aging calculations ' + convert(varchar(26),getdate(),109);
       
		INSERT INTO #transactions (invoice_id, fac_id, contact_id, contact_num, client_id, payer_id, transaction_type, comment
		, balance_due, other_payer, aging_total, aging_current_label, aging_current_amount, aging_30_label, aging_30_amount, aging_60_label, aging_60_amount, aging_90_label
		, aging_90_amount, aging_120_label, aging_120_amount, aging_150_label, aging_150_amount, aging_180_label, aging_180_amount, aging_210_label, aging_210_amount
		, detail_order, bill_date)                           
				SELECT
					max(concl.invoice_id) as invoice_id
					, concl.summary_fac_id
					, concl.contact_id
					, concl.contact_num
					, concl.client_id
					, concl.payer_id
					, 'ZZ' as transaction_type
					, '' as detail_comment
					, 0 as balance_due
					, 2 as other_payer
					, 0.0 as aging_total
					, convert(varchar(2),datepart(mm,concl.aging_date)) + '/' + convert(varchar(4),datepart(yyyy,concl.aging_date)) as aging_current_label
					, 0.0 as aging_current_amount
					, convert(varchar(2),datepart(mm,(dateadd(mm,-1,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-1,concl.aging_date)))) as aging_30_label
					, 0.0 as aging_30_amount
					, convert(varchar(2),datepart(mm,(dateadd(mm,-2,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-2,concl.aging_date)))) as aging_60_label
					, 0.0 as aging_60_amount
					, convert(varchar(2),datepart(mm,(dateadd(mm,-3,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-3,concl.aging_date)))) as aging_90_label
					, 0.0 as aging_90_amount
					, convert(varchar(2),datepart(mm,(dateadd(mm,-4,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-4,concl.aging_date)))) as aging_120_label
					, 0.0 as aging_120_amount
					, convert(varchar(2),datepart(mm,(dateadd(mm,-5,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-5,concl.aging_date)))) as aging_150_label
					, 0.0 as aging_150_amount
					, convert(varchar(2),datepart(mm,(dateadd(mm,-6,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-6,concl.aging_date)))) as aging_180_label
					, 0.0 as aging_180_amount
					, '+ '+convert(varchar(2),datepart(mm,(dateadd(mm,-7,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-7,concl.aging_date)))) as aging_210_label
					, 0.0 as aging_210_amount
					, 0 as detail_order 
					, concl.bill_date
   				FROM #contact_clients concl
				WHERE concl.payer_id <> 0 and concl.contact_id <= -2.1 
				GROUP BY concl.contact_id, concl.contact_num,concl.bill_date, concl.aging_date, concl.summary_fac_id, concl.client_id, concl.payer_id;

		SELECT DISTINCT csd.client_id, cc.aging_date,cc.bill_date,cc.payer_id INTO #aging_clients_other 
		FROM #transactions csd
		INNER JOIN #contact_clients cc ON csd.client_id = cc.client_id AND cc. payer_id <> 0 AND csd.transaction_type='ZZ';

		-- Temp table used to calculate amount for each bucket
		INSERT INTO #temp_bucket_sum (amount, client_id, aging_date, bill_date, payer_id, bucket_index)
			SELECT SUM(s.amount) AS amount, s.client_id, s.aging_date ,s.bill_date, s.payer_id, 
			CASE WHEN s.month_diff < 0 THEN 0 WHEN s.month_diff > 7 THEN 7 ELSE s.month_diff END AS bucket_index 
			FROM (
				SELECT 
						cl.client_id    
						, cl.aging_date 
						, cl.bill_date
						, cl.payer_id
						, CASE WHEN h.transaction_id is null THEN txn.amount ELSE -1*h.amount END AS 'amount'
						, CASE WHEN h.transaction_id is null 
							THEN DATEDIFF(MONTH, txn.effective_date,  DATEADD(dd,1, cl.bill_date)) 
							ELSE DATEDIFF(MONTH, h.applied_to_date,  DATEADD(dd,1, cl.bill_date)) 
						END AS 'month_diff'
				FROM dbo.ar_transactions txn WITH (NOLOCK)
				INNER JOIN #aging_clients_other cl
				ON cl.client_id = txn.client_id and cl.payer_id = txn.payer_id
				INNER JOIN dbo.ar_invoice invoice WITH (NOLOCK) 
				ON cl.client_id = invoice.client_id and invoice.invoice_id = txn.invoice_id  AND invoice.effective_date < DATEADD(dd,1,cl.bill_date)
				AND invoice.deleted = 'N' AND invoice.trial_flag = 'N' AND invoice.fac_id = txn.fac_id 
				AND txn.deleted = 'N'
				INNER JOIN dbo.ar_lib_payers libpayer WITH (NOLOCK) on libpayer.payer_id=txn.payer_id AND libpayer.deleted = 'N'
				INNER JOIN dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id = txn.payer_id and payer.fac_id = txn.fac_id 
				LEFT JOIN ar_applied_payment_history h on txn.transaction_id = h.transaction_id AND h.deleted = 'N'
				WHERE txn.deleted='N' 
				AND NOT (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
				AND NOT (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate')             
				UNION ALL
				SELECT 
						cl.client_id    
						, cl.aging_date 
						, cl.bill_date
						, cl.payer_id
						, CASE WHEN h.transaction_id is null THEN txn.amount ELSE -1*h.amount END AS 'amount'
						, CASE WHEN h.transaction_id is null 
							THEN DATEDIFF(MONTH, txn.effective_date,  DATEADD(dd,1, cl.bill_date)) 
							ELSE DATEDIFF(MONTH, h.applied_to_date,  DATEADD(dd,1, cl.bill_date)) 
						END AS 'month_diff'
			FROM dbo.ar_transactions txn WITH (NOLOCK)
			INNER JOIN #aging_clients_other cl
			ON cl.client_id = txn.client_id and cl.payer_id = txn.payer_id
			INNER JOIN dbo.ar_lib_payers libpayer WITH (NOLOCK) on libpayer.payer_id=txn.payer_id AND libpayer.deleted = 'N'
			INNER JOIN dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id=txn.payer_id and payer.fac_id=txn.fac_id
			LEFT JOIN ar_applied_payment_history h on txn.transaction_id = h.transaction_id AND h.deleted = 'N'
 			WHERE txn.deleted='N' 
			AND txn.invoice_id < 0 
			AND NOT (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
			AND NOT (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate') 
			)s
			GROUP BY s.client_id, s.aging_date, s.bill_date, s.payer_id, CASE WHEN s.month_diff < 0 THEN 0 WHEN s.month_diff > 7 THEN 7 ELSE s.month_diff END 

		-- --- Update each bucket using #temp_bucket_sum ---

		--Current bucket: bucket_index = 0 
		UPDATE std SET std.aging_current_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id <> 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.payer_id = b.payer_id 
			AND concl.bill_date = b.bill_date AND b.bucket_index = 0
		WHERE std.transaction_type = 'ZZ' and std.payer_id <> 0 and concl.payer_id = std.payer_id;

	   --Bucket 30: bucket_index = 1 
		UPDATE std SET std.aging_30_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id <> 0 
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id  AND b.bucket_index = 1
		WHERE std.transaction_type = 'ZZ' and std.payer_id <> 0 and concl.payer_id = std.payer_id;
	
		--Bucket 60: bucket_index = 2
		UPDATE std SET std.aging_60_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id <> 0 
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 2
		WHERE std.transaction_type = 'ZZ' and std.payer_id <> 0 and concl.payer_id = std.payer_id;

		--Bucket 90: bucket_index = 3
		UPDATE std SET std.aging_90_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id <> 0  
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date
			AND concl.payer_id = b.payer_id AND b.bucket_index = 3
		WHERE std.transaction_type = 'ZZ' and std.payer_id <> 0 and concl.payer_id = std.payer_id;

		--Bucket 120: bucket_index = 4
		UPDATE std SET std.aging_120_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id <> 0 
		LEFT OUTER JOIN  #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 4
		WHERE std.transaction_type = 'ZZ' and std.payer_id <> 0 and concl.payer_id = std.payer_id;

		--Bucket 150: bucket_index = 5
		UPDATE std SET std.aging_150_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id <> 0 
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 5
		WHERE std.transaction_type = 'ZZ' and std.payer_id <> 0 and concl.payer_id = std.payer_id;

		--Bucket 180: bucket_index = 6
		UPDATE std SET std.aging_180_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id <> 0 
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 6
		WHERE std.transaction_type = 'ZZ' and std.payer_id <> 0 and concl.payer_id = std.payer_id;

		--Bucket 210:  bucket_index = 7
		UPDATE std SET std.aging_210_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id <> 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id  AND b.bucket_index = 7
		WHERE std.transaction_type = 'ZZ' and std.payer_id <> 0 and concl.payer_id = std.payer_id;

		SET @vgsStepEndTime = GETDATE();
		IF  @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete other payer aging calculations: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms';
	END
END


--Update aging totals 

UPDATE #transactions SET aging_total = 
aging_current_amount + aging_30_amount + aging_60_amount + aging_90_amount 
+ aging_120_amount + aging_150_amount + aging_180_amount + aging_210_amount
WHERE transaction_type = 'ZZ' ;

select @vStep = 220
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' set detail order and update contact data as needed ' + convert(varchar(26),getdate(),109)

update tx set tx.detail_order	= (Case when tx.transaction_type = '00' then 0
									when tx.transaction_type = 'C' and isnull(tx.charge_code,'') <> 'LateFeeSys' then 10
									when tx.transaction_type = 'CR' and isnull(tx.charge_code,'') <> 'LateFeeSys' then 15
									when tx.transaction_type = 'R' and isnull(tx.charge_code,'') <> 'LateFeeSys' then 20
									when tx.transaction_type = 'DR' and isnull(tx.charge_code,'') <> 'LateFeeSys' then 25
									when tx.transaction_type = 'A' and isnull(tx.charge_code,'') <> 'LateFeeSys' then 40
									when tx.transaction_type = 'CA' and isnull(tx.charge_code,'') <> 'LateFeeSys' then 50
									when tx.transaction_type = 'PC' and isnull(tx.charge_code,'') <> 'LateFeeSys' then 55
									when tx.charge_code = 'LateFeeSys' then 60
									when tx.transaction_type = 'TA' and isnull(tx.charge_code,'') <> 'LateFeeSys' then 70	
									when tx.transaction_type = 'YY' then 100								
									when tx.transaction_type = 'YZ' then 150
									when tx.transaction_type = 'ZZ' then 200
									else 30 END)
from #transactions tx

update concl set concl.pre_consolidated_payment_due_date = concl.payment_due_date, concl.payment_due_date = maxddate.duedate 
from #contact_clients concl
inner join (select contact_id,contact_num,max(payment_due_date) duedate from #contact_clients 
		where payment_due_date is not null group by contact_id, contact_num) maxddate 
	on concl.contact_id = maxddate.contact_id and concl.contact_num = maxddate.contact_num

--get most recent contact name and address for each contact, and assign it to all other residents - put here for debug reasons (we can see what the conacts were prior to the update)
update con set 
	con.contact_title = LatestContact.contact_title,
	con.contact_first_name = LatestContact.contact_first_name,
	con.contact_last_name = LatestContact.contact_last_name,
	con.contact_address1 = LatestContact.contact_address1,
	con.contact_address2 = LatestContact.contact_address2,
	con.contact_address3 = LatestContact.contact_address3,
	con.contact_city = LatestContact.contact_city,
	con.contact_prov_state = LatestContact.contact_prov_state,
	con.contact_postal_zip_code = LatestContact.contact_postal_zip_code,
	con.contact_country = LatestContact.contact_country,
	con.contact_county = LatestContact.contact_county,
	con.contact_email = LatestContact.contact_email,	
	con.private_bills_to = Case when con.private_bills_to <> LatestContact.private_bills_to then 'M' else con.private_bills_to end
from #contact_clients con
inner join (select ccl.contact_id,ccl.contact_num,ccl.bill_date,ccl.invoice_id,	ccl.contact_title, ccl.contact_first_name, ccl.contact_last_name, ccl.contact_address1
			, ccl.contact_address2, ccl.contact_address3, ccl.contact_city, ccl.contact_prov_state, ccl.contact_postal_zip_code, ccl.contact_country, ccl.contact_county, contact_email,private_bills_to
			, ROW_NUMBER() OVER ( PARTITION BY ccl.contact_id,ccl.bill_date 
			order by  ccl.contact_id,ccl.contact_num,ccl.bill_date desc, inv.created_date desc) as rwnum
			from #contact_clients ccl
			inner join dbo.ar_invoice inv with (nolock) on ccl.invoice_id = inv.invoice_id
		) LatestContact on con.contact_num = LatestContact.contact_num and con.bill_date = LatestContact.bill_date and LatestContact.rwnum = 1

update con set con.private_bills_to = 'M'
from #contact_clients con
inner join #contact_clients m on con.contact_num = m.contact_num and con.bill_date = m.bill_date  
where m.private_bills_to = 'M' and con.private_bills_to <> 'M' 

insert into #contact_return_to --set return to address info
select distinct
	  ccl.contact_num
	, case when fgi.fac_id is null then NULL else fgi.facility_group_id end as campus_id
	, case when fgi.fac_id is null then hfac.facility_code else fgi.remit_to_group_number end as return_to_group_number
	, case when fgi.fac_id is null then hfac.name else fgi.facility_group_name end as return_to_name
	, case when fgi.fac_id is null then hfac.address1 else fgi.facility_group_address1 end as return_to_address1
	, case when fgi.fac_id is null then hfac.address2 else fgi.facility_group_address2 end as return_to_address2
	, case when fgi.fac_id is null then '' else fgi.facility_group_address3 end as return_to_address3
	, case when fgi.fac_id is null then hfac.city else fgi.facility_group_city end as return_to_city
	, case when fgi.fac_id is null then faccnty.name else fgi.facility_group_county end as return_to_county
	, case when fgi.fac_id is null then hfac.prov else fgi.facility_group_prov_state end as return_to_prov_state
	, case when fgi.fac_id is null then fl.country else fgi.facility_group_country end as return_to_country
	, case when fgi.fac_id is null then hfac.pc else fgi.facility_group_postal_zip_code end as return_to_postal_zip_code
	, case when fgi.fac_id is null then hfac.tel else fgi.facility_group_phone end as return_to_phone
from #contact_clients ccl
inner join (select contact_num,max(invoice_id) as max_invoice_id from #contact_clients group by contact_num) mccl on 
	ccl.contact_num = mccl.contact_num
inner join #facility_list fl on ccl.fac_id = fl.fac_id
inner join dbo.ar_invoice inv with (nolock) on mccl.max_invoice_id = inv.invoice_id
left join #facilty_group_info fgi on ccl.fac_id = fgi.fac_id
inner join dbo.facility_audit hfac with (nolock) on ccl.fac_id = hfac.fac_id
	and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)	
left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id
--select * from #contact_return_to
--select * from #contact_clients
--check for override remit to address info - default private payer takes precident, then most recent invoices payer per contact.
--if @vIsEmc = 0 
update con set 
	con.remit_to_name				= LatestContact.remit_to_name,
	con.remit_to_address1			= LatestContact.remit_to_address1,
	con.remit_to_address2			= LatestContact.remit_to_address2,
	con.remit_to_address3			= LatestContact.remit_to_address3,
	con.remit_to_city				= LatestContact.remit_to_city,
	con.remit_to_prov_state			= LatestContact.remit_to_prov_state,
	con.remit_to_postal_zip_code	= LatestContact.remit_to_postal_zip_code,
	con.remit_to_phone				= LatestContact.remit_to_phone,
	con.remit_to_county				= LatestContact.remit_to_county,
	con.remit_to_country			= LatestContact.remit_to_country
from #contact_clients con
inner join (select 
			ccl.contact_id,
			ccl.contact_num,
			ccl.bill_date,
			ccl.invoice_id,	
			case when isnull(pyraud.provider_override,'N') = 'Y' then pyraud.provider_name else ccl.remit_to_name end as remit_to_name, 
			case when isnull(pyraud.provider_override,'N') = 'Y' then pyraud.provider_address1 else ccl.remit_to_address1 end as remit_to_address1, 
			case when isnull(pyraud.provider_override,'N') = 'Y' then pyraud.provider_address2 else ccl.remit_to_address2 end as remit_to_address2, 
			case when isnull(pyraud.provider_override,'N') = 'Y' then '' else ccl.remit_to_address3 end as remit_to_address3,
			case when isnull(pyraud.provider_override,'N') = 'Y' then pyraud.provider_city else ccl.remit_to_city end as remit_to_city, 
			case when isnull(pyraud.provider_override,'N') = 'Y' then pyraud.provider_prov_state else ccl.remit_to_prov_state end as remit_to_prov_state, 
			case when isnull(pyraud.provider_override,'N') = 'Y' then pyraud.provider_postal_zip_code else ccl.remit_to_postal_zip_code end as remit_to_postal_zip_code, 
			case when isnull(pyraud.provider_override,'N') = 'Y' then pyraud.provider_tel else ccl.remit_to_phone end as remit_to_phone, 
			case when isnull(pyraud.provider_override,'N') = 'Y' then cnty.name else ccl.remit_to_county end as remit_to_county,
			case when isnull(pyraud.provider_override,'N') = 'Y' then country.item_description else ccl.remit_to_country end as remit_to_country, 
			ROW_NUMBER() OVER ( PARTITION BY ccl.contact_id,ccl.contact_num,ccl.bill_date 
			order by  ccl.contact_id,ccl.contact_num,ccl.bill_date desc, case when cfg.default_payer_id = inv.payer_id then dateadd(yyyy, 100, inv.created_date) else inv.created_date end desc, inv.invoice_id desc) as rwnum
			from #contact_clients ccl
			inner join dbo.ar_invoice inv with (nolock) on ccl.invoice_id = inv.invoice_id
			inner join dbo.ar_configuration cfg on ccl.fac_id = cfg.fac_id and cfg.deleted = 'N'
			inner join dbo.ar_payers pyr with (nolock) on inv.payer_id = pyr.payer_id and inv.fac_id = pyr.fac_id 
			inner join dbo.ar_payers_audit pyraud with (nolock) on inv.payer_id = pyraud.payer_id and inv.fac_id = pyraud.fac_id and 
				pyraud.effective_date  <= inv.created_date AND (pyraud.ineffective_date  >= inv.created_date or pyraud.ineffective_date is null)
			left join dbo.county cnty with (nolock) on pyraud.provider_county_id = cnty.county_id
			left join common_code country with (nolock) on pyraud.provider_country_id = country.item_id
			left join #facilty_group_info fgi on ccl.fac_id = fgi.fac_id
			where fgi.fac_id is null
		) LatestContact on con.contact_num = LatestContact.contact_num and con.bill_date = LatestContact.bill_date and LatestContact.rwnum = 1
--select * from #contact_clients

if @debug_me='Y'  select * from #transactions order by contact_id,client_id,invoice_id,other_payer,transaction_type

--select * from ar_payers_audit

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 240
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' $0 suppression updates and other payer Aging and information payer data deletion' + convert(varchar(26),getdate(),109)

delete from #transactions where transaction_type not in ('00', 'YY', 'YZ', 'ZZ') and other_payer = 0 and amount = 0 --remove any detail values that have a $0 total and aren't a balance forward, other payer total or aging

delete from #transactions where transaction_type in ('YY', 'YZ') and other_payer <> 0 and (contact_id = -2.1 or contact_id = -3.1)--remove any detail values that have a $0 total and aren't a balance forward, other payer total or aging

if @vShowResults = 'D' -- suppress charge codes that sum to $0

update csd set csd.detail_order=999
from #transactions csd
inner join (select 	contact_num,contact_id,client_id, charge_code, frequency,dateadd(mm, datediff(mm, 0,effective_date) + 0, 0) as effective_date, sum(amount) as ttl
	from #transactions where charge_code is not null 
	group by contact_num,contact_id,client_id, charge_code, frequency, dateadd(mm, datediff(mm, 0, effective_date) + 0, 0)) supress on 
	csd.contact_num = supress.contact_num and csd.contact_id = supress.contact_id and csd.client_id = supress.client_id and csd.charge_code = supress.charge_code 
	and csd.frequency = supress.frequency and dateadd(mm, datediff(mm, 0, csd.effective_date) + 0, 0) = supress.effective_date and supress.ttl = 0

--suppress other transactions that sum to $0.00
update marked set marked.detail_order=999
from #transactions marked
inner join (
			select contact_num, contact_id, client_id, bill_date, generated_date, effective_date, transaction_type, tx_description, sum(amount) as ttl, count(*) as cnt
			from #transactions 
			where transaction_type <> '00' and other_payer = 0 and detail_order <> 999
			group by contact_num, contact_id, client_id, bill_date, generated_date, effective_date, transaction_type, tx_description having count (*) > 1
			) sum0 on marked.contact_num = sum0.contact_num and marked.contact_id = sum0.contact_id and marked.client_id = sum0.client_id and marked.bill_date = sum0.bill_date
				and marked.generated_date = sum0.generated_date and marked.effective_date = sum0.effective_date and marked.transaction_type = sum0.transaction_type
				and marked.tx_description = sum0.tx_description and sum0.ttl = 0 and marked.detail_order <> 999

--select detail_order,* from #transactions
--delete ccl --remove contact clients that have a single invoice, but one has no 'real' transactions and everything is $0.00
--from #contact_clients ccl
--inner join (select contact_num, contact_id, client_id from #contact_clients where contact_id > -2.1 group by contact_num, contact_id, client_id having count(1) = 1) minv
--	on ccl.contact_num = minv.contact_num and ccl.contact_id = minv.contact_id and ccl.client_id = minv.client_id
--inner join (select contact_num, contact_id, client_id from #transactions 
--	where detail_order <> 999 and other_payer = 0 group by contact_num, contact_id, client_id having count(1) = 1 and contact_id > -2.1) mtx
--	on ccl.contact_num = mtx.contact_num and ccl.contact_id = mtx.contact_id and ccl.client_id = mtx.client_id
--left join #transactions csd on csd.invoice_id = ccl.invoice_id and csd.transaction_type = '00' and csd.amount <> 0.00
--where csd.invoice_id is null

if @debug_me='Y'  select * from #transactions

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 260
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' udpate merged contacts with the most recent statement invoice # ' + convert(varchar(26),getdate(),109)

--remove extra invoices added for Balance Forward Calculations
if @vInvoiceIdList is not null
	begin
		delete rem 
		from #contact_clients rem
		LEFT join 
			(select con.contact_num
			from #contact_clients con
			inner join #invoice_ids_table inv on con.invoice_id = inv.invoice_id) kep on rem.contact_num = kep.contact_num
		where kep.contact_num is null
	end

update con set 
	con.statement_invoice_number = getinvnum.statement_invoice_number
from #contact_clients con
inner join (select cc.contact_num, client_id, max(cc.invoice_id) invoice_id
	from #contact_clients cc
	group by contact_num, client_id) latest on con.contact_num = latest.contact_num and con.client_id = latest.client_id 
inner join #contact_clients getinvnum with (nolock) on latest.invoice_id = getinvnum.invoice_id
		
set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
				
select @vStep = 270;
set @vgsStepStartTime = GETDATE();
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Add contact numbers and client list  ' + convert(varchar(26),getdate(),109);

DECLARE @ContactNums TABLE
				(
					contact_id numeric(18,1), 
					contact_number varchar(86),
					contact_email varchar(75),
					online_id varchar(35),
					fac_id int
				);

if @vExportMode = 0

	INSERT INTO @ContactNums(contact_id, contact_number, contact_email, online_id, fac_id)
				SELECT DISTINCT cont.contact_id, CASE WHEN cont.contact_id = 0 THEN '0'
													ELSE
												(CASE WHEN @vIncludePrefixFacilityCode = 1 THEN 
													(CASE WHEN @vIsEmc = 1 THEN 
															(CASE 
																WHEN fg.facility_group_id IS NULL AND (f.facility_code IS NULL OR LTRIM(f.facility_code)='') THEN c.contact_number
																WHEN fg.facility_group_id IS NULL THEN f.facility_code + '-' +  c.contact_number
																WHEN (fg.facility_group_code IS NULL OR LTRIM (fg.facility_group_code) = '') THEN c.contact_number 
																ELSE fg.facility_group_code  + '-' +  c.contact_number END)
														ELSE -- @vIncludePrefixFacilityCode = 0
															(CASE WHEN (f.facility_code IS NULL OR LTRIM(f.facility_code)='') THEN c.contact_number
																ELSE  
																f.facility_code + '-' +  c.contact_number END)
															END)
												ELSE c.contact_number END)  
												END
												AS contact_number
												,c.email_address
												,c.contact_number as online_id
												,f.fac_id
				FROM (SELECT DISTINCT contact_id, fac_id FROM #contact_clients) cont
				LEFT OUTER JOIN dbo.contact c WITH(NOLOCK)
				ON cont.contact_id = c.contact_id
				INNER JOIN dbo.facility f WITH(NOLOCK)
				ON f.fac_id = cont.fac_id
				LEFT OUTER JOIN (SELECT fgm.fac_id, fg.facility_group_id, fg.facility_group_code 
							FROM dbo.facility_group fg WITH(NOLOCK)
							INNER JOIN dbo.facility_group_mapping fgm WITH(NOLOCK) 
							ON fgm.facility_group_id = fg.facility_group_id 
							WHERE fg.[type_id] = 1 ) fg
				ON f.fac_id = fg.fac_id;
else

	INSERT INTO @ContactNums(contact_id, contact_number, contact_email, online_id, fac_id)
				SELECT DISTINCT cont.contact_id, c.contact_number, c.email_address, c.contact_number, cont.fac_id
				FROM (SELECT DISTINCT contact_id, fac_id FROM #contact_clients) cont
				LEFT OUTER JOIN dbo.contact c WITH(NOLOCK)
				ON cont.contact_id = c.contact_id

update  con set con.client_list = stuff(clients,1,0,'')
FROM #contact_clients con
CROSS APPLY
( 
SELECT top 2 concl.summary_charge_client_name + ' ('+concl.summary_charge_client_number+')| ' --+ ', '
	FROM  #contact_clients concl
	WHERE con.contact_num = concl.contact_num and con.contact_id = concl.contact_id and con.payer_id = concl.payer_id
	group by concl.summary_charge_client_name,concl.summary_charge_client_number 
	ORDER BY concl.summary_charge_client_name,concl.summary_charge_client_number
	FOR XML PATH ('')
) a ( clients )

update #contact_clients set client_list = left(client_list,len(client_list)-1)

update con  set con.client_list = con.client_list +'...'
from
#contact_clients con
inner join (select contact_num, contact_id from (select contact_num, contact_id, client_id from #contact_clients group by contact_num, contact_id, client_id) getcl group by  contact_num, contact_id  having count(*) > 2 ) maxcl
on con.contact_num = maxcl.contact_num and con.contact_id = maxcl.contact_id

set @vgsStepEndTime=GETDATE();
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms';
	
	
select @vStep = 300
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' returning final result ' + convert(varchar(26),getdate(),109)
--*********************************************************************************************************
if @vExportMode = 0
	select 
			ccl.fac_id
		, c.item_description as fac_country
		, ccl.contact_id
		, ccl.contact_num
		, ccl.consolidate_statement
		, cn.online_id
		, ccl.client_id
		, ccl.invoice_id
		, ccl.statement_invoice_number
		, ccl.payer
		, ltrim(rtrim(ccl.remit_to_name)) as remit_to_name
		, ltrim(rtrim(case when isnull(ccl.remit_to_address3,'')<>'' and isnull(ccl.remit_to_address2,'')<>'' and isnull(ccl.remit_to_address1,'')<>''  
				then ccl.remit_to_address1 + @vCflr + ccl.remit_to_address2+ @vCflr + ccl.remit_to_address3
			when isnull(ccl.remit_to_address3,'')='' and isnull(ccl.remit_to_address2,'')<>'' and isnull(ccl.remit_to_address1,'')<>'' 
				then ccl.remit_to_address1 + @vCflr + ccl.remit_to_address2
			when isnull(ccl.remit_to_address3,'')<>'' and isnull(ccl.remit_to_address2,'')='' and isnull(ccl.remit_to_address1,'')<>'' 
				then ccl.remit_to_address1 + @vCflr + ccl.remit_to_address3
			when isnull(ccl.remit_to_address3,'')<>'' and isnull(ccl.remit_to_address2,'')<>'' and isnull(ccl.remit_to_address1,'')='' 
				then ccl.remit_to_address2 + @vCflr + ccl.remit_to_address3
			when isnull(ccl.remit_to_address3,'')='' and isnull(ccl.remit_to_address2,'')<>'' and isnull(ccl.remit_to_address1,'')='' 
				then ccl.remit_to_address2
			when isnull(ccl.remit_to_address3,'')<>'' and isnull(ccl.remit_to_address2,'')='' and isnull(ccl.remit_to_address1,'')='' 
				then ccl.remit_to_address3
			else ccl.remit_to_address1 end)) as remit_to_address
		, ltrim(rtrim(isnull(ccl.remit_to_city, '') + ', ' + isnull(ccl.remit_to_prov_state, '') + ' ' +  isnull(ccl.remit_to_postal_zip_code, ''))) as remit_to_address2
		, isnull(ccl.remit_to_city, '') as remit_to_city
		, isnull(ccl.remit_to_county, '') as remit_to_county
		, isnull(ccl.remit_to_prov_state, '') as remit_to_prov_state
		, isnull(ccl.remit_to_postal_zip_code, '') as remit_to_postal_zip_code
		, ccl.remit_to_phone
		, ltrim(rtrim(return_add.return_to_name)) as return_to_name
		, ltrim(rtrim(case when isnull(return_add.return_to_address3,'')<>'' and isnull(return_add.return_to_address2,'')<>'' and isnull(return_add.return_to_address1,'')<>''  
				then return_add.return_to_address1 + @vCflr + return_add.return_to_address2+ @vCflr + return_add.return_to_address3
			when isnull(return_add.return_to_address3,'')='' and isnull(return_add.return_to_address2,'')<>'' and isnull(return_add.return_to_address1,'')<>'' 
				then return_add.return_to_address1 + @vCflr + return_add.return_to_address2
			when isnull(return_add.return_to_address3,'')<>'' and isnull(return_add.return_to_address2,'')='' and isnull(return_add.return_to_address1,'')<>'' 
				then return_add.return_to_address1 + @vCflr + return_add.return_to_address3
			when isnull(return_add.return_to_address3,'')<>'' and isnull(return_add.return_to_address2,'')<>'' and isnull(return_add.return_to_address1,'')='' 
				then return_add.return_to_address2 + @vCflr + return_add.return_to_address3
			when isnull(return_add.return_to_address3,'')='' and isnull(return_add.return_to_address2,'')<>'' and isnull(return_add.return_to_address1,'')='' 
				then return_add.return_to_address2
			when isnull(return_add.return_to_address3,'')<>'' and isnull(return_add.return_to_address2,'')='' and isnull(return_add.return_to_address1,'')='' 
				then return_add.return_to_address3
			else return_add.return_to_address1 end)) as return_to_address
		, ltrim(rtrim(isnull(return_add.return_to_city, '') + ', ' + isnull(return_add.return_to_prov_state, '') + ' ' +  isnull(return_add.return_to_postal_zip_code, ''))) as return_to_address2
		, isnull(return_add.return_to_city, '') as return_to_city
		, isnull(return_add.return_to_county, '') as return_to_county
		, isnull(return_add.return_to_prov_state, '') as return_to_prov_state
		, isnull(return_add.return_to_postal_zip_code, '') as return_to_postal_zip_code
		, return_add.return_to_phone
		, Case when private_bills_to = 'G' and ccl.contact_id <> 0 and ccl.contact_id <>-3.1 then 
				(ltrim(rtrim(case when isnull(ccl.contact_title,'')<>'' then ccl.contact_title + ' ' + ccl.contact_first_name + ' ' + ccl.contact_last_name 
				else ccl.contact_first_name + ' ' + ccl.contact_last_name end)))
			when ccl.contact_id = 0 or private_bills_to = 'M' or ccl.contact_id = -3.1 then 'No contact information available for:' 
			when ccl.contact_id = -2.1 then ccl.contact_first_name
			else 'No default payer address available for:' end	as contact_name
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0 and ccl.contact_id <> -3.1) or ccl.contact_id = -2.1 then 
				(ltrim(rtrim(case when isnull(ccl.contact_address3,'')<>'' and isnull(ccl.contact_address2,'')<>'' and isnull(ccl.contact_address1,'')<>'' 
				then ccl.contact_address1 + @vCflr + ccl.contact_address2 + @vCflr + ccl.contact_address3
			when isnull(ccl.contact_address3,'')='' and isnull(ccl.contact_address2,'')<>'' and isnull(ccl.contact_address1,'')<>'' 
				then ccl.contact_address1 + @vCflr + ccl.contact_address2
			when isnull(ccl.contact_address3,'')<>'' and isnull(ccl.contact_address2,'')='' and isnull(ccl.contact_address1,'')<>'' 
				then ccl.contact_address1 + @vCflr + ccl.contact_address3
			when isnull(ccl.contact_address3,'')<>'' and isnull(ccl.contact_address2,'')<>'' and isnull(ccl.contact_address1,'')='' 
				then ccl.contact_address2 + @vCflr + ccl.contact_address3
			when isnull(ccl.contact_address3,'')='' and isnull(ccl.contact_address2,'')<>'' and isnull(ccl.contact_address1,'')='' 
				then ccl.contact_address2
			when isnull(ccl.contact_address3,'')<>'' and isnull(ccl.contact_address2,'')='' and isnull(ccl.contact_address1,'')='' 
				then ccl.contact_address3
				else isnull(ccl.contact_address1,'') end)))
			when ccl.contact_id = 0 or private_bills_to = 'M' or ccl.contact_id = -3.1 then ccl.summary_charge_client_name + ' ('+ccl.summary_charge_client_number+')'
			else ccl.payer end as contact_address
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1 then 
				(ltrim(rtrim(case when isnull(ccl.contact_city, '')<>'' and  isnull(ccl.contact_prov_state, '')<>'' then ccl.contact_city + ', ' + ccl.contact_prov_state + ' ' 
					+ isnull(ccl.contact_postal_zip_code, '')
				when isnull(ccl.contact_city, '')<>'' and isnull(ccl.contact_prov_state, '')='' then ccl.contact_city + ', ' + isnull(ccl.contact_postal_zip_code, '')
				when isnull(ccl.contact_city, '')='' and isnull(ccl.contact_prov_state, '')<>'' then ccl.contact_prov_state + ', ' + isnull(ccl.contact_postal_zip_code, '')
				else '' end)))
			else '' end as contact_address2
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_city, '') else '' end as contact_city
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_county, '') else '' end as contact_county
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_prov_state, '') else '' end as contact_prov_state
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_postal_zip_code, '') else '' end as contact_postal_zip_code
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_country, '') else '' end as contact_country
		, Case when private_bills_to = 'G' and ccl.contact_id <> 0 and @vAccountNumberSource = 'C' then cn.contact_number 
			when private_bills_to = 'G' and ccl.contact_id <> 0 and @vAccountNumberSource = 'R' and charindex('|',ccl.client_list,1) > 0 then cn.contact_number
			when private_bills_to = 'G' and @vAccountNumberSource = 'R' and charindex('|',ccl.client_list,1) = 0 and @vIncludePrefixFacilityCode = 0 then ccl.summary_charge_client_number
			when private_bills_to = 'G' and @vAccountNumberSource = 'R' and charindex('|',ccl.client_list,1) = 0 and @vIncludePrefixFacilityCode = 1 and @vIsEmc = 0
				and (f.facility_code IS NULL OR LTRIM(f.facility_code)='') then ccl.summary_charge_client_number
			when private_bills_to = 'G' and @vAccountNumberSource = 'R' and charindex('|',ccl.client_list,1) = 0 and @vIncludePrefixFacilityCode = 1 and @vIsEmc = 0
				and (f.facility_code IS NOT NULL OR LTRIM(f.facility_code)<>'') then f.facility_code + '-' + ccl.summary_charge_client_number
			when private_bills_to = 'G' and @vAccountNumberSource = 'R' and charindex('|',ccl.client_list,1) = 0 and @vIncludePrefixFacilityCode = 1 and @vIsEmc = 1
				and return_add.return_to_group_number IS NOT NULL then return_add.return_to_group_number + '-' + ccl.summary_charge_client_number 
			when private_bills_to = 'G' and @vAccountNumberSource = 'R' and charindex('|',ccl.client_list,1) = 0 and @vIncludePrefixFacilityCode = 1 and @vIsEmc = 1
				and return_add.return_to_group_number IS NULL and (f.facility_code IS NOT NULL OR LTRIM(f.facility_code)<>'') then f.facility_code  + '-' + ccl.summary_charge_client_number 
			when private_bills_to = 'G' and @vAccountNumberSource = 'R' and charindex('|',ccl.client_list,1) = 0 and @vIncludePrefixFacilityCode = 1 and @vIsEmc = 1
				and return_add.return_to_group_number IS NULL and (f.facility_code IS NULL OR LTRIM(f.facility_code)='') then ccl.summary_charge_client_number 
			else Null end as account_number
		, Case when @vUseEffectiveDateAsBillDate = 1 then ccl.bill_date else dateadd(mm, datediff(mm, 0, ccl.bill_date) + 1, 0) end as bill_date
		, ccl.inv_effective_date as effective_date
		, ccl.generated_date
		, Case when fac.show_payment_due_date = 1 then ccl.payment_due_date else Null end as payment_due_date
		, Case when fac.show_payment_due_date = 1 then ccl.pre_consolidated_payment_due_date else Null end as pre_consolidated_payment_due_date
		, coalesce(convert(datetime,convert(varchar(10),ccl.statement_through_date, 101)),ccl.bill_date) as statement_through_date
		, ccl.amount_due
		, case when ccl.contact_id <> -2.1 then ccl.eft_message else '' end as eft_message
		, replace(ccl.client_list,'|',';') as client_list
		, case when ccl.contact_id <> -2.1 then ccl.client_message else '' end as client_message
		, case when ccl.contact_id <> -2.1 then ccl.group_message else '' end as group_message
		, case when ccl.contact_id <> -2.1 then ccl.global_message else '' end as global_message
		, case when ccl.contact_id <> -2.1 then @vStatementMessage else '' end as statement_message
		, fac.gst_hst
		, fac.gst_number
		, ccl.previous_balance_due
		, ccl.payments
		, ltrim(rtrim(ccl.summary_charge_center)) as summary_charge_center
		, ccl.summary_charge_client_name
		, ccl.summary_charge_client_number
		, ccl.summary_charge_client_location
		, case when @vDisplayAdmitDate = 1 then ccl.summary_charge_client_admission else Null end as summary_charge_client_admission
		, case when @vDisplayDischargeDate = 1 then  ccl.summary_charge_client_discharge else Null end as summary_charge_client_discharge
		, ccl.summary_current_balance
		, ccl.summary_previous_balance_due
		, ccl.summary_payments
		, ccl.summary_late_fees	
		, ccl.summary_client_balance_due
		, csd.transaction_type
		, csd.detail_order
		, csd.effective_date as detail_effective_date
		, case when csd.effective_thru_date <> csd.effective_date then 'thru' else '' end as detail_thru
		, csd.effective_thru_date as detail_effective_thru_date
		, Case when isnull(csd.units,0) < 0 or (csd.transaction_type = 'C' and csd.reversed = 1 and csd.amount > 0) THEN '** ' +
				(case when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') <> '' 
					and isnull(csd.cheque_number,'') = '' then isnull(csd.tx_description,'') + ' - ' + csd.comment
				when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') = '' 
					and isnull(csd.cheque_number,'') <> '' then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number
				when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') <> '' 
					and isnull(csd.cheque_number,'') <> '' then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number + ' - ' + csd.comment
				when csd.transaction_type = 'C' and @vCashReceiptComments = 0 and isnull(csd.cheque_number,'') <> '' 
					then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number
				when csd.transaction_type = 'A' and @vAncillaryComments = 1 and @vShowResults = 'D' and isnull(csd.comment,'') <> ''  then isnull(csd.tx_description,'') + ' - ' + csd.comment
				when csd.transaction_type = 'X' and @vAdjustmentComments = 1 and isnull(csd.comment,'') <> '' then isnull(csd.tx_description,'') + ' - ' + csd.comment
				else isnull(csd.tx_description,'') end
				) +' **'
			else (case when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') <> '' 
					and isnull(csd.cheque_number,'') = '' then isnull(csd.tx_description,'') + ' - ' + csd.comment
				when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') = '' 
					and isnull(csd.cheque_number,'') <> '' then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number
				when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') <> '' 
					and isnull(csd.cheque_number,'') <> '' then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number + ' - ' + csd.comment
				when csd.transaction_type = 'C' and @vCashReceiptComments = 0 and isnull(csd.cheque_number,'') <> '' 
					then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number
				when csd.transaction_type = 'A' and @vAncillaryComments = 1 and @vShowResults = 'D' and isnull(csd.comment,'') <> ''  then isnull(csd.tx_description,'') + ' - ' + csd.comment
				when csd.transaction_type = 'X' and @vAdjustmentComments = 1 and isnull(csd.comment,'') <> '' then isnull(csd.tx_description,'') + ' - ' + csd.comment
				else isnull(csd.tx_description,'') end	
				)
			end as detail_description
		, csd.comment as detail_comment
		, Case when isnull(csd.units,0) < 0 or (csd.transaction_type = 'C' and csd.reversed = 1 and csd.amount > 0)then 1 else 0 end as reversed_tx
		, Case when csd.transaction_type = 'R' and csd.unit_amount is null then Null 
			when csd.transaction_type = 'XR' and isnull(csd.units,0) = 0 then Null
			when csd.transaction_type = 'D' then Null  
			when csd.transaction_type not in('R','XR','CO','CR','D') and isnull(csd.unit_amount,0) = 0 then Null 
			else csd.units end as detail_units
		, Case when csd.transaction_type = 'D' then Null 
			when isnull(csd.unit_amount,0) = 0 then Null 
			when round((csd.units * csd.unit_amount),2) <> round(csd.amount, 2) then Null else round(csd.unit_amount, 2) end as detail_unit_amount
		, round(csd.amount, 2) as detail_amount
		, csd.balance_due
		, csd.other_payer
		, csd.payer_type
		, csd.aging_total
		, csd.aging_current_label
		, csd.aging_current_amount
		, csd.aging_30_label
		, csd.aging_30_amount
		, csd.aging_60_label
		, csd.aging_60_amount
		, csd.aging_90_label
		, csd.aging_90_amount
		, csd.aging_120_label
		, csd.aging_120_amount
		, csd.aging_150_label
		, csd.aging_150_amount
		, csd.aging_180_label
		, csd.aging_180_amount
		, csd.aging_210_label
		, csd.aging_210_amount
		, fac.cheques_payable_to
		, Case when (@vShowResults = 'C' or @vShowResults = 'CC') and csd.transaction_type = 'A' then Dense_rank() over 
			(ORDER BY ccl.contact_num, csd.detail_order, csd.tx_description) else 0 end ccorder
		, Case when @vTransactionOrder = 'P' then Dense_rank() over (ORDER BY ccl.contact_num, csd.detail_order, FORMAT(csd.effective_date,'YYYY'), FORMAT(csd.effective_date,'MM'),
			Case when isnull(csd.units,0) < 0 or (csd.transaction_type = 'C' and csd.reversed = 1 and csd.amount > 0)then 1 else 0 end desc, csd.effective_date, csd.tx_description)
			when @vTransactionOrder = 'D' then Dense_rank() over (ORDER BY ccl.contact_num, 
			 (case when csd.transaction_type = '00' then '1/1/1900'
				when csd.transaction_type in ('YY','YZ','ZZ') then dateadd(yyyy,100,ccl.bill_date)
				else csd.effective_date end), csd.detail_order, Case when isnull(csd.units,0) < 0 or (csd.transaction_type = 'C' and csd.reversed = 1 and csd.amount > 0)then 1 else 0 end desc, csd.tx_description) 
			else 0 end txsort
		, Dense_rank() over (ORDER BY ccl.contact_num, ccl.non_consolidated_contact_num	, ccl.remit_to_name) statement_num
		, Case when csd.transaction_type = 'PC' then Dense_rank() over 
				(ORDER BY Left(csd.tx_description,charindex(':', csd.tx_description)), csd.effective_date, csd.transaction_type)
				else Dense_rank() over 
				(ORDER BY csd.effective_date, csd.transaction_type, csd.tx_description)
				end txtypeorder
		, @status_code status_code
		, @status_text status_text
	 
	from #contact_clients ccl
	left join #facility_list fac on ccl.fac_id = fac.fac_id
	inner join #transactions csd on ccl.invoice_id= csd.invoice_id and ccl.client_id = csd.client_id and ccl.contact_id = csd.contact_id
			and ccl.contact_num = csd.contact_num --and (ccl.contact_id = @vReceiverIds or @vReceiverIds = -1)
	inner join dbo.facility f with (nolock) on ccl.fac_id = f.fac_id
	inner join dbo.common_code c with (nolock) on f.country_id = c.item_id
	inner join #contact_return_to return_add on ccl.contact_num = return_add.contact_num
	LEFT OUTER JOIN @ContactNums cn
	ON ccl.contact_id = cn.contact_id and ccl.fac_id = cn.fac_id
	where csd.detail_order <> 999 --and csd.detail_amount is not null
		and (csd.amount is not null or csd.other_payer > 0)
		and (@vMinimumBalance is null or ccl.summary_current_balance >= @vMinimumBalance)
		and (@vSuppress0value = 0 or (@vSuppress0value = 1 and  (csd.amount <> 0.00 or csd.transaction_type in('00','YY','YZ','ZZ'))) or csd.payer_id = 0)
	order by statement_num, ccl.summary_charge_center, ccl.summary_charge_client_name, ccl.summary_charge_client_number, ccl.bill_date, 
		Case when ccl.contact_id <= -2.1 then ccl.invoice_id else 0 end, ccl.generated_date, txsort, ccorder, txtypeorder
else
	select 
		 
		  ccl.contact_num
		, Dense_rank() over (ORDER BY ccl.contact_num, ccl.non_consolidated_contact_num	, ccl.remit_to_name) statement_num
		, return_add.campus_id as campus_id
		, ltrim(rtrim(return_add.return_to_group_number)) as facility_group_number
		, ltrim(rtrim(return_add.return_to_name)) as facility_group_name
		, isnull(return_add.return_to_address1,'') as facility_group_address_1
		, isnull(return_add.return_to_address2,'') as facility_group_address_2
		, isnull(return_add.return_to_address3,'') as facility_group_address_3
		, isnull(return_add.return_to_county, '') as facility_group_county
		, isnull(return_add.return_to_city, '') as facility_group_city
		, isnull(return_add.return_to_prov_state, '') as facility_group_state
		, isnull(return_add.return_to_country, '') as facility_group_country
		, isnull(return_add.return_to_postal_zip_code, '') as facility_group_zip_code
		, isnull(return_add.return_to_phone,'') as facility_group_telephone	
		--, ltrim(rtrim(str(abs(ccl.contact_id)))) as contact_id
		, Case when private_bills_to = 'G' and ccl.contact_id <> 0 then cn.contact_number else '' end as guarantor_id 
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0 and ccl.contact_id <>-3.1) or private_bills_to = 'D' then ccl.contact_first_name else '' end as guarantor_first_name
		, Case when private_bills_to = 'G' and ccl.contact_id <> 0 and ccl.contact_id <>-3.1 then ccl.contact_last_name
			when ccl.contact_id = 0 or private_bills_to = 'M' or ccl.contact_id = -3.1 then 'No contact information available for:' 
			when ccl.contact_id = -2.1 then ccl.contact_last_name
			else 'No default payer address available for:' end	as guarantor_last_name
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0 and ccl.contact_id <> -3.1) or ccl.contact_id = -2.1 then isnull(ccl.contact_address1,'')
			when ccl.contact_id = 0 or private_bills_to = 'M' or ccl.contact_id = -3.1 then ccl.summary_charge_client_name + ' ('+ccl.summary_charge_client_number+')'
			else ccl.payer end as guarantor_address_1
		, isnull(ccl.contact_address2,'') as guarantor_address_2
		, isnull(ccl.contact_address3,'') as guarantor_address_3
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_county, '') else '' end as guarantor_county
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_city, '') else '' end as guarantor_city
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_prov_state, '') else '' end as guarantor_state		
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_country, '') else '' end as guarantor_country
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_postal_zip_code, '') else '' end as guarantor_zip_code
		, isnull(cn.contact_email,'') as guarantor_email_address
		, ltrim(rtrim(ccl.remit_to_name)) as remit_to_name
		, isnull(ccl.remit_to_address1,'') as remit_to_address_1
		, isnull(ccl.remit_to_address2,'') as remit_to_address_2
		, isnull(ccl.remit_to_address3,'') as remit_to_address_3
		, isnull(ccl.remit_to_county, '') as remit_to_county
		, isnull(ccl.remit_to_city, '') as remit_to_city
		, isnull(ccl.remit_to_prov_state, '') as remit_to_state
		, isnull(ccl.remit_to_country, '') as remit_to_country
		, isnull(ccl.remit_to_postal_zip_code, '') as remit_to_zip_code
		, isnull(ccl.remit_to_phone, '') as remit_to_phone_number
		, ccl.summary_current_balance as grand_total
		, ccl.summary_late_fees	as late_fees
		, ccl.summary_previous_balance_due as balance_forward_amount
		, ccl.summary_payments as cash_payments_received
		, cn.online_id
		, @vTermClient as term_used_for_patient
		, @vTermAdmission as term_used_for_admission
		, @vTermDischarge as term_used_for_discharge
		--, @vTermRoom as term_used_for_room
		--, @vTermFacility as term_used_for_facility
		, case when @vShowInvoiceNumber = 1 then 'Y' else 'N' end as show_invoice_number
		, case when @vShowLocation = 1 then 'Y' else 'N' end as show_location
		, case when @vDisplayAdmitDate = 1 then 'Y' else 'N' end as show_admit_date
		, case when @vDisplayDischargeDate = 1 then 'Y' else 'N' end as show_discharge_date
		, case when @vShowResidentNumber = 1 then 'Y' else 'N' end as show_patient_number
		, case when @vShowTransactionWarningMessage = 1 then 'Y' else 'N' end as show_transaction_warning_message
		, case when @vIncludePrefixFacilityCode = 1 then 'Y' else 'N' end as prefix_fac_code_to_acct_no
		--, @vDisplayUnitAndAmountFlag as display_unit_and_amount_flag
		, Case when isnull(fac.cheques_payable_to,'') <> '' and isnull(eftconfig.enabled,0) <> 1 and ccl.summary_current_balance > 0
			then 'Please make ' + (case when c.item_description = 'United States' then 'checks' else 'cheques' end) + ' payable to: ' + fac.cheques_payable_to else '' end as checks_payable_to		
		, isnull(@vPaymentInstructions,'') as payment_instruction
		, isnull(replace(@vTransactionWarningMessage, '<<stmt_thru_date>>', convert(varchar(10),coalesce(convert(datetime,convert(varchar(10),ccl.statement_through_date, 101)),ccl.bill_date), 101)),'') as transaction_warning_message
		, @vAccountNumberLabel as account_number_label
		, Case when @vAccountNumberSource = 'R' and charindex('|',ccl.client_list,1) > 0 then 'C' else @vAccountNumberSource end as account_number_source
		, ccl.fac_id as facility_id
		, ltrim(rtrim(isnull(ccl.summary_charge_center_code,''))) as facility_code
		, ltrim(rtrim(ccl.summary_charge_center)) as facility_name
		, ccl.client_id
		, convert(varchar(10),ccl.summary_charge_client_admission, 101) as patient_admit_date
		, convert(varchar(10),ccl.summary_charge_client_discharge, 101) as patient_discharge_date
		, ccl.summary_charge_client_number as patient_number
		, ccl.summary_charge_client_first_name as patient_first_name
		, ccl.summary_charge_client_last_name as patient_last_name
		, ccl.summary_charge_client_name as patient_name
		, convert(varchar(10),ccl.summary_charge_client_dob, 101) as patient_dob
		, isnull(ccl.summary_charge_client_location,'') as patient_location	
		, case when isnull(eftconfig.enabled,0) = 1 then 'Y' else 'N' end as eft_enabled
		, case when ccl.contact_id <> -2.1 then isnull(ccl.client_message,'') else '' end as patient_invoice_message
		, case when ccl.contact_id <> -2.1 then isnull(ccl.group_message,'') else '' end as patient_group_message
		, case when ccl.contact_id <> -2.1 then isnull(ccl.eft_message,'') else '' end as eft_message
		--, case when ccl.contact_id <> -2.1 then ccl.global_message else '' end as global_message
		--, case when ccl.contact_id <> -2.1 then @vStatementMessage else '' end as statement_message
		, ccl.statement_invoice_number as invoice_number
		, Case when @vUseEffectiveDateAsBillDate = 1 then convert(varchar(10),ccl.bill_date, 101) else convert(varchar(10),dateadd(mm, datediff(mm, 0, ccl.bill_date) + 1, 0), 101) end as invoice_date
		, convert(varchar(10),ccl.payment_due_date, 101) as invoice_due_date
		--, convert(varchar(10),ccl.inv_effective_date, 101) as effective_date
		--, convert(varchar(10),ccl.generated_date, 101) as generated_date
		, ccl.summary_client_balance_due as current_invoice_charges
		, csd.balance_due as total_amount_due
		, convert(varchar(10),csd.effective_date, 101) as date_of_service
		--, case when csd.effective_thru_date <> csd.effective_date then 'thru' else '' end as detail_thru
		--, convert(varchar(10),csd.effective_thru_date, 101) as detail_effective_thru_date
		, csd.transaction_type
		, Case when isnull(csd.units,0) < 0 or (csd.transaction_type = 'C' and csd.reversed = 1 and csd.amount > 0) THEN '** ' +
				(case when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') <> '' 
					and isnull(csd.cheque_number,'') = '' then isnull(csd.tx_description,'') + ' - ' + csd.comment
				when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') = '' 
					and isnull(csd.cheque_number,'') <> '' then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number
				when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') <> '' 
					and isnull(csd.cheque_number,'') <> '' then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number + ' - ' + csd.comment
				when csd.transaction_type = 'C' and @vCashReceiptComments = 0 and isnull(csd.cheque_number,'') <> '' 
					then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number
				when csd.transaction_type = 'A' and @vAncillaryComments = 1 and @vShowResults = 'D' and isnull(csd.comment,'') <> ''  then isnull(csd.tx_description,'') + ' - ' + csd.comment
					+ (case when @vDisplayUnitAndAmountFlag = 1 and isnull(csd.units,0) <> 0 and csd.unit_amount is not null and round((csd.units * csd.unit_amount),2) = round(csd.amount, 2) 
					then ' (' + ltrim(rtrim(str(csd.units))) + '@' + convert(varchar(10),convert(Money,csd.unit_amount)) + ')' else '' end)
				when csd.transaction_type = 'X' and @vAdjustmentComments = 1 and isnull(csd.comment,'') <> '' then isnull(csd.tx_description,'') + ' - ' + csd.comment
					+ (case when @vDisplayUnitAndAmountFlag = 1 and isnull(csd.units,0) <> 0 and csd.unit_amount is not null and round((csd.units * csd.unit_amount),2) = round(csd.amount, 2) 
					then ' (' + ltrim(rtrim(str(csd.units))) + '@' + convert(varchar(10),convert(Money,csd.unit_amount)) + ')' else '' end)
				else isnull(csd.tx_description,'') 
					+ (case when @vDisplayUnitAndAmountFlag = 1 and isnull(csd.units,0) <> 0 and csd.unit_amount is not null and round((csd.units * csd.unit_amount),2) = round(csd.amount, 2) 
					then ' (' + ltrim(rtrim(str(csd.units))) + '@' + convert(varchar(10),convert(Money,csd.unit_amount)) + ')' else '' end)
				end
				) +' **'
			else (case when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') <> '' 
					and isnull(csd.cheque_number,'') = '' then isnull(csd.tx_description,'') + ' - ' + csd.comment
				when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') = '' 
					and isnull(csd.cheque_number,'') <> '' then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number
				when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') <> '' 
					and isnull(csd.cheque_number,'') <> '' then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number + ' - ' + csd.comment
				when csd.transaction_type = 'C' and @vCashReceiptComments = 0 and isnull(csd.cheque_number,'') <> '' 
					then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number
				when csd.transaction_type = 'A' and @vAncillaryComments = 1 and @vShowResults = 'D' and isnull(csd.comment,'') <> ''  then isnull(csd.tx_description,'') + ' - ' + csd.comment
					+ (case when @vDisplayUnitAndAmountFlag = 1 and isnull(csd.units,0) <> 0 and csd.unit_amount is not null and round((csd.units * csd.unit_amount),2) = round(csd.amount, 2) 
					then ' (' + ltrim(rtrim(str(csd.units))) + '@' + convert(varchar(10),convert(Money,csd.unit_amount)) + ')' else '' end)
				when csd.transaction_type = 'X' and @vAdjustmentComments = 1 and isnull(csd.comment,'') <> '' then isnull(csd.tx_description,'') + ' - ' + csd.comment
					+ (case when @vDisplayUnitAndAmountFlag = 1 and isnull(csd.units,0) <> 0 and csd.unit_amount is not null and round((csd.units * csd.unit_amount),2) = round(csd.amount, 2) 
					then ' (' + ltrim(rtrim(str(csd.units))) + '@' + convert(varchar(10),convert(Money,csd.unit_amount)) + ')' else '' end)
				else isnull(csd.tx_description,'') 
					+ (case when @vDisplayUnitAndAmountFlag = 1 and isnull(csd.units,0) <> 0 and csd.unit_amount is not null and round((csd.units * csd.unit_amount),2) = round(csd.amount, 2) 
					then ' (' + ltrim(rtrim(str(csd.units))) + '@' + convert(varchar(10),convert(Money,csd.unit_amount)) + ')' else '' end)
				end	
				)
			end as transaction_description
		--, csd.comment as detail_comment
		--, Case when isnull(csd.units,0) < 0 or (csd.transaction_type = 'C' and csd.reversed = 1 and csd.amount > 0)then 1 else 0 end as reversed_tx
		, Case when csd.transaction_type = 'R' and csd.unit_amount is null then Null 
			when csd.transaction_type = 'XR' and isnull(csd.units,0) = 0 then Null
			when csd.transaction_type = 'D' then Null  
			when csd.transaction_type not in('R','XR','CO','CR','D') and isnull(csd.unit_amount,0) = 0 then Null 
			else csd.units end as quantity
		, Case when csd.transaction_type = 'D' then Null 
			when isnull(csd.unit_amount,0) = 0 then Null 
			when round((csd.units * csd.unit_amount),2) <> round(csd.amount, 2) then Null else round(csd.unit_amount, 2) end as unit_amount
		, round(csd.amount, 2) as transaction_total_amount
		, Case when fac.show_payment_due_date = 1 then 'Y' else 'N' end as show_payment_due_date
		, convert(varchar(10),ccl.pre_consolidated_payment_due_date, 101) as pre_consolidated_payment_due_date
		, convert(varchar(10),coalesce(convert(datetime,convert(varchar(10),ccl.statement_through_date, 101)),ccl.bill_date), 101) as statement_through_date			
		--, ccl.client_list
		--, fac.gst_hst
		--, fac.gst_number
		, csd.detail_order
		, csd.other_payer
		, csd.payer_type
		, Case when (@vShowResults = 'C' or @vShowResults = 'CC') and csd.transaction_type = 'A' then Dense_rank() over 
			(ORDER BY ccl.contact_num, csd.detail_order, csd.tx_description) else 0 end ccorder
		, Case when @vTransactionOrder = 'P' then Dense_rank() over (ORDER BY ccl.contact_num, csd.detail_order, FORMAT(csd.effective_date,'YYYY'), FORMAT(csd.effective_date,'MM'),
			Case when isnull(csd.units,0) < 0 or (csd.transaction_type = 'C' and csd.reversed = 1 and csd.amount > 0)then 1 else 0 end desc, csd.effective_date, csd.tx_description)
			when @vTransactionOrder = 'D' then Dense_rank() over (ORDER BY ccl.contact_num, 
			 (case when csd.transaction_type = '00' then '1/1/1900'
				when csd.transaction_type in ('YY','YZ','ZZ') then dateadd(yyyy,100,ccl.bill_date)
				else csd.effective_date end), csd.detail_order, Case when isnull(csd.units,0) < 0 or (csd.transaction_type = 'C' and csd.reversed = 1 and csd.amount > 0)then 1 else 0 end desc, csd.tx_description) 
			else 0 end txsort
		--, Dense_rank() over (ORDER BY ccl.contact_num, ccl.non_consolidated_contact_num	, ccl.remit_to_name) statement_num
		, Case when csd.transaction_type = 'PC' then Dense_rank() over 
				(ORDER BY Left(csd.tx_description,charindex(':', csd.tx_description)), csd.effective_date, csd.transaction_type)
				else Dense_rank() over 
				(ORDER BY csd.effective_date, csd.transaction_type, csd.tx_description)
				end txtypeorder
		, @status_code status_code
		, @status_text status_text
	 
	from #contact_clients ccl
	left join #facility_list fac on ccl.fac_id = fac.fac_id
	inner join #transactions csd on ccl.invoice_id= csd.invoice_id and ccl.client_id = csd.client_id and ccl.contact_id = csd.contact_id
			and ccl.contact_num = csd.contact_num --and (ccl.contact_id = @vReceiverIds or @vReceiverIds = -1)
	inner join dbo.facility f with (nolock) on ccl.fac_id = f.fac_id
	inner join dbo.common_code c with (nolock) on f.country_id = c.item_id
	inner join #contact_return_to return_add on ccl.contact_num = return_add.contact_num
	left join #invoices inv on ccl.invoice_id = inv.invoice_id
	left join dbo.ar_eft_client_configuration_history eftconfig with (nolock) on ccl.client_id = eftconfig.client_id
		and eftconfig.effective_date  <= inv.created_date AND (eftconfig.ineffective_date  >= inv.created_date or eftconfig.ineffective_date is null)	
	LEFT OUTER JOIN @ContactNums cn
	ON ccl.contact_id = cn.contact_id and ccl.fac_id = cn.fac_id
	where csd.detail_order <> 999 --and csd.detail_amount is not null
		and (csd.amount is not null or csd.other_payer > 0)
		and (@vMinimumBalance is null or ccl.summary_current_balance >= @vMinimumBalance)
		and (@vSuppress0value = 0 or (@vSuppress0value = 1 and  (csd.amount <> 0.00 or csd.transaction_type in('00','YY','YZ','ZZ'))) or csd.payer_id = 0)
	order by statement_num, ccl.summary_charge_center, ccl.summary_charge_client_name, ccl.summary_charge_client_number, ccl.bill_date, 
		Case when ccl.contact_id <= -2.1 then ccl.invoice_id else 0 end, ccl.generated_date, txsort, ccorder, txtypeorder

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
if @debug_me='Y' Print 'Successful execution of stored procedure ' + Object_name(@@ProcID) + convert(varchar(26),getdate(),109);

	if @sprocParamLogEnable > 0
	BEGIN
		BEGIN TRY
			set @endTime = GETDATE()

			update ar_sproc_params_log set end_time = @endTime, elapsed_time_in_ms = DATEDIFF(MILLISECOND,@startTime, @endTime)
			where sproc_log_id = @sprocExecId

		END TRY
		BEGIN CATCH
			--we do not want to break the execution of this stored procedure, do nothing here.
		END CATCH
	END

END TRY 

BEGIN CATCH 

	if @sprocParamLogEnable > 0
	BEGIN
		BEGIN TRY
			set @endTime = GETDATE()

			update ar_sproc_params_log set end_time = @endTime, elapsed_time_in_ms = DATEDIFF(MILLISECOND,@startTime, @endTime),
				error_code = Error_number(), error_message = Error_message()
				where sproc_log_id = @sprocExecId

		END TRY
		BEGIN CATCH
			--we do not want to break the execution of this stored procedure, do nothing here.
		END CATCH
	END

	if @status_code = 0 Set @Status_Code = 1 else set @status_code = 2  --- convert 3 to 2
	if @status_code = 1
	BEGIN
		select @Status_Text = Rtrim(Left('Stored Procedure Failed with error Code : ' +   Cast(@@error as Varchar(10)) +  ' Line Number : ' +  Cast(ERROR_LINE() as Varchar(5)) + ' ' +  ERROR_MESSAGE(),3000))

		if @debug_me='Y' Print 'Stored procedure failure in step:'+ convert(varchar(3),@vstep) + '	' + convert(varchar(26),getdate())
		if @debug_me='Y' Print 'Error code: '+convert(varchar(3),@vStep) + '; Error description:	' + @Status_Text
	END
	
	if @vExportMode = 0
	 
		Select 
			  NULL as fac_id
			, NULL as fac_country
			, NULL as contact_id
			, NULL as contact_num
			, NULL as consolidate_statement
			, NULL as online_id
			, NULL as client_id 
			, NULL as invoice_id
			, NULL as statement_invoice_number
			, NULL as remit_to_name
			, NULL as remit_to_address
			, NULL as remit_to_address2
			, NULL as remit_to_city
			, NULL as remit_to_county
			, NULL as remit_to_prov_state
			, NULL as remit_to_postal_zip_code
			, NULL as remit_to_phone
			, NULL as return_to_name
			, NULL as return_to_address
			, NULL as return_to_address2
			, NULL as return_to_city
			, NULL as return_to_county
			, NULL as return_to_prov_state
			, NULL as return_to_postal_zip_code
			, NULL as return_to_phone
			, NULL as contact_name
			, NULL as contact_address
			, NULL as contact_address2
			, NULL as contact_city
			, NULL as contact_county
			, NULL as contact_prov_state
			, NULL as contact_postal_zip_code
			, NULL as contact_country
			, NULL as account_number
			, NULL as bill_date
			, NULL as effective_date
			, NULL as generated_date
			, NULL as payment_due_date
			, NULL as pre_consolidated_payment_due_date
			, NULL as statement_through_date
			, NULL as amount_due
			, NULL as eft_message
			, NULL as client_list
			, NULL as client_message
			, NULL as group_message
			, NULL as global_message
			, NULL as statement_message
			, NULL as gst_hst
			, NULL as gst_number
			, NULL as previous_balance_due
			, NULL as payments
			, NULL as summary_charge_center	
			, NULL as summary_charge_client_name
			, NULL as summary_charge_client_number
			, NULL as summary_charge_client_location
			, NULL as summary_charge_client_admission
			, NULL as summary_charge_client_discharge
			, NULL as summary_current_balance
			, NULL as summary_previous_balance_due
			, NULL as summary_payments
			, NULL as summary_late_fees	
			, NULL as summary_client_balance_due
			, NULL as transaction_type
			, NULL as detail_effective_date 
			, NULL as detail_thru
			, NULL as detail_effective_thru_date
			, NULL as detail_description
			, NULL as detail_comment
			, NULL as reversed_tx
			, NULL as detail_units
			, NULL as detail_unit_amount
			, NULL as detail_amount
			, NULL as balance_due
			, NULL as other_payer
			, NULL as payer_type
			, NULL as aging_total
			, NULL as aging_current_label
			, NULL as aging_current_amount
			, NULL as aging_30_label
			, NULL as aging_30_amount
			, NULL as aging_60_label
			, NULL as aging_60_amount
			, NULL as aging_90_label
			, NULL as aging_90_amount
			, NULL as aging_120_label
			, NULL as aging_120_amount
			, NULL as aging_150_label
			, NULL as aging_150_amount
			, NULL as aging_180_label
			, NULL as aging_180_amount
			, NULL as aging_210_label
			, NULL as aging_210_amount
			, NULL as cheques_payable_to
			, NULL as ccorder
			, Null as statement_num
			, NULL as txtypeorder
			, NULL as status_code
			, NULL as status_text

	else

		select
			  NULL as contact_num
			, NULL as statement_num
			, NULL as campus_id
			, NULL as facility_group_number
			, NULL as facility_group_name
			, NULL as facility_group_address_1
			, NULL as facility_group_address_2
			, NULL as facility_group_address_3
			, NULL as facility_group_county
			, NULL as facility_group_city
			, NULL as facility_group_state
			, NULL as facility_group_country
			, NULL as facility_group_zip_code
			, NULL as facility_group_telephone
			, NULL as facility_group_county
			, NULL as guarantor_id 
			, NULL as guarantor_first_name
			, NULL as guarantor_last_name
			, NULL as guarantor_address_1
			, NULL as guarantor_address_2
			, NULL as guarantor_address_3
			, NULL as guarantor_county
			, NULL as guarantor_city
			, NULL as guarantor_state
			, NULL as guarantor_country
			, NULL as guarantor_zip_code
			, NULL as guarantor_email_address
			, NULL as guarantor_county
			, NULL as remit_to_name
			, NULL as remit_to_address_1
			, NULL as remit_to_address_2
			, NULL as remit_to_address_3
			, NULL as remit_to_county
			, NULL as remit_to_city
			, NULL as remit_to_state
			, NULL as remit_to_country
			, NULL as remit_to_zip_code
			, NULL as remit_to_phone_number
			, NULL as remit_to_county
			, NULL as grand_total
			, NULL as late_fees
			, NULL as balance_forward_amount
			, NULL as cash_payments_received
			, NULL as online_id
			, NULL as term_used_for_patient
			, NULL as term_used_for_admission
			, NULL as term_used_for_discharge
			, NULL as show_invoice_number
			, NULL as show_location
			, NULL as show_admit_date
			, NULL as show_discharge_date
			, NULL as show_patient_number
			, NULL as show_transaction_warning_message
			, NULL as prefix_fac_code_to_acct_no
			, NULL as checks_payable_to		
			, NULL as payment_instruction
			, NULL as transaction_warning_message
			, NULL as account_number_label
			, NULL as account_number_source	
			, NULL as facility_id
			, NULL as facility_code
			, NULL as facility_name
			, NULL as client_id
			, NULL as patient_admit_date
			, NULL as patient_discharge_date
			, NULL as patient_number
			, NULL as patient_first_name
			, NULL as patient_last_name
			, NULL as patient_name
			, NULL as patient_dob
			, NULL as patient_location	
			, NULL as eft_enabled
			, NULL as patient_invoice_message
			, NULL as patient_group_message
			, NULL as eft_message
			, NULL as invoice_number
			, NULL as invoice_date
			, NULL as invoice_due_date
			, NULL as current_invoice_charges
			, NULL as total_amount_due
			, NULL as date_of_service
			, NULL as transaction_type
			, NULL as transaction_description
			, NULL as quantity
			, NULL as unit_amount
			, NULL as transaction_total_amount
			, NULL as show_payment_due_date
			, NULL as pre_consolidated_payment_due_date
			, NULL as statement_through_date			
			, NULL as detail_order
			, NULL as other_payer
			, NULL as payer_type
			, NULL as ccorder
			, NULL as txsort
			, NULL as txtypeorder
			, NULL as status_code
			, NULL as status_text

		
END CATCH 

RETURN 

END
GO
GRANT EXECUTE ON  dbo.sproc_prp_rl_statements   to PUBLIC
GO

GO

print 'C_Branch/04_StoredProcedures/sproc_prp_rl_statements.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_statements.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_scrm_list_getActivity.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- Purpose: This procedure is used to return a paged, sorted list of Activities in CRM
--             
-- Written By:          Nick Kuin
--
--Parameters
--     @activityId              
--     @activityTypeId          
--     @activitySubTypeId         
--     @includeEmptySubType       - flag to search for explicit nulls for subtypes
--     @entityId                  
--     @userId                    
--     @priorityId                
--     @statusId                   
--     @categoryId                - entity type id search, ignored if null 
--     @minSchedDate              - activities after this date will displayed, ignored if null 
--     @maxSchedDate              - activities up to this date will be displayed, ignored if null
--     @sortCol                   
--     @sortOrder                
--     @offset                   
--     @limit                     
--     @accessibleLeadFacIds      -  A list of facilities in which the user has lead access to 
--     @accessibleAccountFacIds   - A list of facilities in which the user has account access to
--     @includeProxyLeads         - flag to include activities attached to proxy leads in result
--     @includeOnlySchedAndInProg - flag to include to only return scheduled and in progress activities
--  
--
--
-- Returns three result sets:
--   1. An activity or a list of activities matching the given criteria.
--   2. A list of entities (view_scrm_entity) participating in that entity.
--   3. A list of users (sec_user) participating in that entity.
--
-- Revision History:
-- 2018-05-22  Thanuja Punna  - Re-write to optimize query plan (CORE-15348)
-- 2018-06-11  Michael Dickey - Add activity owner login name to returned columns (CORE-15389)
-- 2018-06-13  Thanuja Punna  - removed count(*) to avoid table spool and introduced a single table to split integers from input parameters(CORE-17043)
-- 2019-02-04  Thanuja Punna  - added input parameter to include only scheduled activities and returning primary contact email(CORE-14172)
-- 2020-08-26  Iurie Blagodarenco - Changed FOR XML PATH to FOR JSON PATH to improve performance (CORE-69626)

IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_scrm_list_getActivity' and ROUTINE_TYPE = 'PROCEDURE' )
   DROP PROCEDURE dbo.sproc_scrm_list_getActivity

GO
CREATE PROCEDURE [dbo].[sproc_scrm_list_getActivity]
   @activityId                 INT =  NULL
  ,@activityTypeId             VARCHAR(MAX) =  NULL
  ,@activitySubTypeId          VARCHAR(MAX) =  NULL
  ,@includeEmptySubType        BIT = 0
  ,@entityId                   BIGINT =  NULL
  ,@userId                     VARCHAR(MAX) =  NULL
  ,@priorityId                 VARCHAR(MAX) =  NULL
  ,@statusId                   VARCHAR(MAX) =  NULL
  ,@categoryId                 VARCHAR(MAX) =  NULL
  ,@minSchedDate               DATETIME =  NULL
  ,@maxSchedDate               DATETIME =  NULL
  ,@sortCol                    VARCHAR(25) =  'activity_id'
  ,@sortOrder                  VARCHAR(4) =   'ASC'
  ,@offset                     INT = 0
  ,@limit                      INT = NULL
  ,@accessibleLeadFacIds       VARCHAR(MAX) = NULL
  ,@accessibleAccountFacIds    VARCHAR(MAX)  = NULL
  ,@includeProxyLeads          BIT = 1
  ,@includeOnlyOpenLeads	   BIT = 0
  ,@includeEmptyFacility	   BIT = 1
  ,@includeOnlySchedAndInProg  BIT = 0
  ,@createdDate                DATETIME = NULL
  ,@leadId                     BIGINT = NULL
  ,@accountId                  BIGINT = NULL
  ,@DebugMe                    CHAR(1) = 'N'
  ,@status_code                INT OUT
  ,@status_text                VARCHAR(3000) OUT
AS

SET NOCOUNT ON;

----Local Variables
DECLARE  @vStep INT
		,@vActivityId					INT
		,@vActivityTypeId				VARCHAR(MAX)
		,@vActivitySubTypeId			VARCHAR(MAX)
		,@vIncludeEmptySubType			BIT
		,@vEntityId						BIGINT
		,@vUserId						VARCHAR(MAX)
		,@vPriorityId					VARCHAR(MAX)
		,@vStatusId						VARCHAR(MAX)
		,@vCategoryId					VARCHAR(MAX)
		,@vMinSchedDate					DATETIME
		,@vMaxSchedDate					DATETIME
		,@vSortCol						VARCHAR(25)
		,@vSortOrder					VARCHAR(4)
		,@vOffset						INT
		,@vLimit						INT
		,@vUserAccessibleLeadFacIds		VARCHAR(MAX)
		,@vUserAccessibleAccountFacIds	VARCHAR(MAX)
		,@vIncludeProxyLeads			BIT
		,@vIncludeOnlyOpenLeads			BIT
		,@vParticipantRoleRegId			INT
		,@vLeadExists					BIT
		,@vPlacementExists				BIT
		,@vIncludeEmptyFacility			BIT
		,@vIncludeOnlySchedAndInProg	BIT
        ,@vCreatedDate                  DATETIME
        ,@vLeadId                       BIGINT
        ,@vAccountId                    BIGINT

SET @vActivityId					= @activityId
SET @vActivityTypeId				= @activityTypeId
SET @vActivitySubTypeId				= @activitySubTypeId
SET @vIncludeEmptySubType			= @includeEmptySubType
SET @vEntityId						= @entityId
SET @vUserId						= @userId
SET @vPriorityId					= @priorityId
SET @vStatusId						= @statusId
SET @vCategoryId					= @categoryId
SET @vMinSchedDate					= @minSchedDate
SET @vMaxSchedDate					= @maxSchedDate
SET @vSortCol						= @sortCol
SET @vSortOrder						= @sortOrder
SET @vOffset						= @offset
SET @vLimit							= @limit
SET @vUserAccessibleLeadFacIds		= @accessibleLeadFacIds
SET @vUserAccessibleAccountFacIds	= @accessibleAccountFacIds
SET @vIncludeProxyLeads				= @includeProxyLeads
SET @vIncludeOnlyOpenLeads			= @includeOnlyOpenLeads
SET @vIncludeEmptyFacility			= @includeEmptyFacility
SET @vIncludeOnlySchedAndInProg		= @includeOnlySchedAndInProg
SET @vCreatedDate                   = @createdDate
SET @vLeadId                        = @leadId
SET @vAccountId                     = @accountId

CREATE TABLE #useraccessibleaccntandleads 
(
		 [entity_id] INT
		,entity_type CHAR(1)
		,mpi_id INT
		,display_name varchar (150)
		,primary_contact_id BIGINT
		,entity_state INT
		,facilities nvarchar(max)
)
CREATE NONCLUSTERED INDEX #useraccessibleaccntandleads__entityId_CL_IX ON #useraccessibleaccntandleads ([entity_id])
INCLUDE ([entity_type],[mpi_id],[display_name],[primary_contact_id],[entity_state]);

CREATE TABLE #useraccessibleaccounts
(
		[entity_id]			BIGINT,
		description			varchar(375)
);
CREATE CLUSTERED INDEX #useraccessibleaccounts__entityId_CL_IX ON #useraccessibleaccounts ([entity_id]);

CREATE TABLE #category
(		
		category_id CHAR(1)
);
CREATE CLUSTERED INDEX #category_CL_IX ON #category ([category_id]);

--holds final result set to send to client
CREATE TABLE #activity (
    total_count int,
	activity_id int,
	std_activity_type_id int,
	std_activity_status_id int,
	std_activity_priority_id int,
	std_activity_result_id int,
	subject varchar(60),
	description varchar(1000),
	scheduled_start datetime,
	scheduled_end datetime,
	direction char(1),
	activity_class char(1),
	activity_type varchar(60),
	activity_status varchar(60),
	activity_priority varchar(60), 
	priority_rank int, 
	activity_result varchar(60),
	owner_id int ,
	activity_owner varchar(50),
	activity_owner_login varchar(60),
	created_by varchar(60),
	created_date datetime,
	revision_by varchar(60),
	revision_date datetime,
	deleted char(1),
	deleted_by varchar(60),
	deleted_date datetime,
	location varchar(100),
	code char(3),
	std_activity_sub_type_id int,
	activity_subtype varchar(50),
	related_entity_name varchar (150),
	category_id CHAR(1),
	related_entity_id int,
	primary_contact_display_name varchar (102),
	facilities nvarchar(max),
	primary_contact_email varchar (75)
);

--split int table
CREATE TABLE #splitINT(
	IdType CHAR(1) NOT NULL, 
	Id INT NOT NULL, 
	PRIMARY KEY ( IdType, Id) 

)

CREATE TABLE #partitioned_facs(
       entity_id BIGINT NOT NULL,
       facility varchar(375),
       PRIMARY KEY (entity_id,facility)
);
CREATE NONCLUSTERED INDEX #partitioned_facs__entityId_CL_IX ON #partitioned_facs ([entity_id]);


--handle the input parameters in temp tables

--user accessible facs for leads (L)
--#useraccessibleleadfacs
INSERT into #splitINT SELECT 'L',  Cast(items as INT) FROM dbo.Split(@vUserAccessibleLeadFacIds,',')

--user accessible facs for accounts
--#useraccessibleaccntfacs
INSERT into #splitINT SELECT 'A', Cast(items as INT) FROM dbo.Split(@vUserAccessibleAccountFacIds,',')

--#activitytype
INSERT into #splitINT SELECT 'T', Cast(items as INT) from dbo.Split(@vActivityTypeId,',')

--#activitysubtype
INSERT into #splitINT SELECT 'S', Cast(items as INT) from dbo.Split(@vActivitySubTypeId,',')

--Lead or Account entity ids
--#entity
INSERT into #splitINT SELECT 'E', Cast(items as INT) from dbo.Split(@vEntityId,',')

--#users
INSERT into #splitINT SELECT 'U', Cast(items as INT) from dbo.Split(@vUserId,',')

--#priority
INSERT into #splitINT SELECT 'P', Cast(items as INT) from dbo.Split(@vPriorityId,',')

--#status 
INSERT into #splitINT SELECT 'I', Cast(items as INT) from dbo.Split(@vStatusId,',')

INSERT into #category SELECT items from dbo.Split(@vCategoryId,',')

--all the facilities user has permission to view accounts
;WITH accessibleFacs_CTE (fac_id, regional_id, prov, name, lob)
AS 
(
	SELECT fac.fac_id, fac.regional_id, fac.prov , fac.name,null--, r.description as lob
	FROM dbo.facility fac with (nolock)
	  INNER JOIN #splitINT fl on fac.fac_id = fl.id AND fl.IdType='A'
	  --INNER JOIN regions r with (nolock) ON fac.regional_id = r.regional_id
),
crm_account_facilities
AS
(
	SELECT sa.[entity_id], eef.ext_fac_id,eef.state_code, eef.reg_id, eef.fac_id
	FROM scrm_account sa with (nolock)
		INNER JOIN dbo.emc_ext_facilities eef with (nolock) on sa.ext_fac_id = eef.ext_fac_id
)
INSERT INTO #useraccessibleaccounts ([entity_id], description) --accounts entities with user permissions
	SELECT crm.[entity_id], NULL --reg.lob--, NULL, NULL
	FROM crm_account_facilities crm
	INNER JOIN accessibleFacs_CTE reg ON crm.reg_id = reg.regional_id AND reg.regional_id IS NOT NULL
UNION
	SELECT crm.[entity_id], NULL --ISNULL (sc.lob,sc.prov) --NULL, sc.prov, NULL
	FROM crm_account_facilities crm
		INNER JOIN accessibleFacs_CTE sc ON crm.state_code = sc.prov  AND sc.prov IS NOT NULL
UNION
	SELECT crm.[entity_id], NULL --fac.name --NULL, NULL, fac.name
	FROM crm_account_facilities crm
		INNER JOIN accessibleFacs_CTE fac ON crm.fac_id = fac.fac_id 
UNION
	SELECT crm.[entity_id], NULL --'corp', NULL, NULL, NULL
	FROM crm_account_facilities crm
	WHERE crm.fac_id = -1 AND crm.state_code IS NULL AND (crm.reg_id IS NULL OR crm.reg_id = -1)

--select * from #useraccessibleaccounts

-- generated comma separated facilities for the lead's Possible Placements
INSERT INTO #partitioned_facs (entity_id, facility)
   	SELECT l.entity_id, f.name as facility
  	FROM scrm_lead l 
    	INNER JOIN dbo.scrm_possible_placement pp with (nolock) ON l.[entity_id]= pp.lead_id 
        INNER JOIN #splitINT input ON pp.fac_id = input.id AND input.IdType='L'
        INNER JOIN dbo.facility f ON pp.fac_id = f.fac_id
    WHERE (@vLeadId IS NULL OR l.entity_id = @vleadId)

;WITH useraccessibleleads
AS(
		SELECT p2.entity_id,
			facilities = JSON_VALUE(
				REPLACE((SELECT _ = p1.facility 
						FROM #partitioned_facs p1 
						WHERE p1.entity_id = p2.entity_id FOR JSON PATH)
						,'"},{"_":"',','), '$[0]._'
			)
		FROM #partitioned_facs as p2
		GROUP BY p2.entity_id
	UNION
		SELECT l.[entity_id], NULL -- leads with no possible placements (so viewed by everyone)
	  	FROM dbo.scrm_lead l with (nolock) LEFT JOIN dbo.scrm_possible_placement pp with (nolock) ON l.[entity_id] = pp.lead_id
	  	WHERE @vIncludeEmptyFacility = 1 AND pp.lead_id IS NULL
)

INSERT INTO #useraccessibleaccntandleads ([entity_id], entity_type, mpi_id,  display_name, primary_contact_id, entity_state, facilities )
SELECT accessibleEntities.[entity_id], accessibleEntities.entity_type, accessibleEntities.mpi_id, accessibleEntities.display_name, e.primary_contact_id, accessibleEntities.entity_state, accessibleEntities.facilities
FROM (
		SELECT l.[entity_id], 'L' as entity_type, mpi.mpi_id,  ISNULL(mpi.last_name + ', ' + mpi.first_name, '') as display_name, l.std_lead_state_id as entity_state, useraccessibleleads.facilities as facilities
		FROM dbo.scrm_lead l with (nolock) 
			LEFT JOIN dbo.mpi mpi with (nolock) on l.mpi_id = mpi.mpi_id
			INNER JOIN useraccessibleleads ON l.[entity_id]= useraccessibleleads.[entity_id]
    UNION
		SELECT sa.[entity_id], 'A' as entity_type, NULL, eef.name as display_name, NULL as entity_state, #useraccessibleaccounts.description as facilities
		FROM dbo.emc_ext_facilities eef with (nolock)
			LEFT JOIN dbo.scrm_account sa with (nolock) ON eef.ext_fac_id = sa.ext_fac_id
			INNER JOIN #useraccessibleaccounts ON sa.[entity_id]=#useraccessibleaccounts.[entity_id]
		WHERE eef.deleted = 'N' AND sa.[entity_id] IS NOT NULL 
	 ) accessibleEntities
INNER JOIN scrm_entity e ON accessibleEntities.[entity_id]=e.[entity_id]

--select * from #useraccessibleaccntandleads


SELECT @vParticipantRoleRegId= participant_role_id FROM scrm_std_participant_role WHERE code = 'REG'

IF(@vLimit IS NULL)
	SET @vLimit= (SELECT count(1)+1 FROM scrm_activity)

 BEGIN TRY
 
 SET @vStep=1 

 --CTE to select result set and the the total count before pagination
 ;WITH activity_data_CTE (	row_num,
						activity_id ,
						std_activity_type_id,
						std_activity_status_id,
						std_activity_priority_id,
						std_activity_result_id,
						subject,
						description,
						scheduled_start,
						scheduled_end,
						direction,
						activity_class,
						activity_type,
						activity_status,
						activity_priority,
						priority_rank,
						activity_result,
						owner_id ,
						activity_owner,
						activity_owner_login,
						created_by,
						created_date,
						revision_by,
						revision_date,
						deleted,
						deleted_by,
						deleted_date,
						location,
						code,
						std_activity_sub_type_id,
						activity_subtype,
						related_entity_name,
						category_id,
						related_entity_id,
						primary_contact_display_name,
						facilities,
						primary_contact_email)
					  
 AS 
 (
    SELECT 
        ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) row_num,
        a.activity_id  as activity_id,
        a.std_activity_type_id,
        a.std_activity_status_id,
        a.std_activity_priority_id,
        a.std_activity_result_id,
        a.subject,
        a.description,
        a.scheduled_start,
        a.scheduled_end,
        a.direction,
        t.class AS activity_class,
        t.description AS activity_type,
        s.description AS activity_status,
        p.description AS activity_priority,
        p.priority_rank,
        r.description AS activity_result,
        a.owner_id ,
        u.long_username AS activity_owner,
        u.loginname AS activity_owner_login,
        a.created_by,
        a.created_date,
        a.revision_by,
        a.revision_date,
        a.deleted,
        a.deleted_by,
        a.deleted_date,
        a.location,
        t.code,
        a.std_activity_sub_type_id,
        st.description AS activity_subtype,
        entities.display_name AS related_entity_name,
        entities.entity_type AS category_id,
        entities.[entity_id] AS related_entity_id,
		primary_contact_display_name = [contact].[last_name] + ', ' + [contact].[first_name],
		entities.facilities,
		[contact].[email_address] AS primary_contact_email

      FROM dbo.scrm_activity a with (nolock)
        INNER JOIN dbo.scrm_entity_activity sea with (nolock) ON sea.activity_id = a.activity_id
            AND (@vLeadId IS NULL OR sea.entity_id = @vleadId)
            AND (@vAccountId IS NULL OR sea.entity_id = @vAccountId)
            AND sea.participant_role_id = @vParticipantRoleRegId
        INNER JOIN #useraccessibleaccntandleads entities with (nolock) ON sea.[entity_id]=entities.[entity_id]
        INNER JOIN dbo.scrm_std_activity_type t with (nolock) ON a.std_activity_type_id = t.std_activity_type_id
        INNER JOIN dbo.scrm_std_activity_status s with (nolock) ON a.std_activity_status_id = s.std_activity_status_id
        INNER JOIN dbo.scrm_std_activity_priority p with (nolock) ON a.std_activity_priority_id = p.std_activity_priority_id
        INNER JOIN dbo.sec_user u with (nolock) ON a.owner_id = u.userId
		LEFT JOIN dbo.scrm_contact contact_view with (nolock) ON contact_view.[entity_id] = entities.primary_contact_id
		LEFT JOIN dbo.contact with (nolock) ON contact_view.[contact_id] = [contact].[contact_id]
		LEFT JOIN dbo.scrm_std_activity_result r with (nolock) ON a.std_activity_result_id = r.std_activity_result_id
		LEFT JOIN dbo.scrm_std_activity_sub_type st with (nolock) ON a.std_activity_sub_type_id = st.std_activity_sub_type_id
		LEFT JOIN #splitINT atyp on a.std_activity_type_id  = atyp.id AND atyp.IdType = 'T'
		LEFT JOIN #splitINT astyp on st.std_activity_sub_type_id  = astyp.id AND astyp.IdType = 'S'
		LEFT JOIN #splitINT ent on entities.[entity_id] = ent.[id] AND ent.IdType = 'E'
		LEFT JOIN #splitINT owners on u.userid = owners.id AND owners.IdType = 'U'
		LEFT JOIN #splitINT pr on a.std_activity_priority_id = pr.id AND pr.IdType = 'P'
		LEFT JOIN #splitINT sts on a.std_activity_status_id  = sts.id AND sts.IdType = 'I'
		LEFT JOIN #category cat on  entities.entity_type = cat.category_id	

      WHERE (@vActivityId IS NULL OR a.activity_id = @vActivityId)
        AND (@vCreatedDate IS NULL OR a.created_date > @vCreatedDate)
        AND (@vIncludeProxyLeads = 1 OR entities.mpi_id IS NOT NULL OR entities.entity_type = 'A')
		AND (@vIncludeOnlyOpenLeads = 0 OR (entities.entity_state IS NULL OR entities.entity_state = 1))
		AND (@vActivityTypeId IS NULL OR atyp.id IS NOT NULL)
		AND ((@vActivitySubTypeId IS NULL AND @vIncludeEmptySubType = 0) OR (astyp.id IS NOT NULL OR (@vIncludeEmptySubType = 1 AND st.std_activity_sub_type_id IS NULL)))				 
	    AND (@vEntityId IS NULL OR ent.[id] IS NOT NULL)
		AND (@vUserId IS NULL OR owners.id IS NOT NULL)
		AND (@vPriorityId IS NULL OR pr.id IS NOT NULL)
        AND (@vStatusId IS NULL OR sts.id IS NOT NULL)
		AND (@vCategoryId IS NULL OR cat.category_id = entities.entity_type )
        AND (@vMinSchedDate IS NULL OR a.scheduled_start >= @minSchedDate)
        AND (@vMaxSchedDate IS NULL OR a.scheduled_start < @maxSchedDate)
        AND (@vIncludeOnlySchedAndInProg = 0 OR s.description='Scheduled' OR s.description='In Progress')
    ),
	activity_count_CTE
	AS
	(
	SELECT TOP (1) row_num as total_count
		FROM  activity_data_CTE
		ORDER BY row_num DESC
	)
	-- paginated list
	INSERT INTO #activity (	total_count,	
							activity_id,
							std_activity_type_id,
							std_activity_status_id,
							std_activity_priority_id,
							std_activity_result_id,
							subject,
							description,
							scheduled_start,
							scheduled_end,
							direction,
							activity_class,
							activity_type,
							activity_status,
							activity_priority,
							priority_rank,
							activity_result,
							owner_id ,
							activity_owner,
							activity_owner_login,
							created_by,
							created_date,
							revision_by,
							revision_date,
							deleted,
							deleted_by,
							deleted_date,
							location,
							code,
							std_activity_sub_type_id,
							activity_subtype,
							related_entity_name,
							category_id,
							related_entity_id,
							primary_contact_display_name,
							facilities,
							primary_contact_email
					)

		SELECT				c.total_count, 
							rs.activity_id,
							rs.std_activity_type_id,
							rs.std_activity_status_id,
							rs.std_activity_priority_id,
							rs.std_activity_result_id,
							rs.subject,
							rs.description,
							rs.scheduled_start,
							rs.scheduled_end,
							rs.direction,
							rs.activity_class,
							rs.activity_type,
							rs.activity_status,
							rs.activity_priority,
							rs.priority_rank,
							rs.activity_result,
							rs.owner_id,
							rs.activity_owner,
							rs.activity_owner_login,
							rs.created_by,
							rs.created_date,
							rs.revision_by,
							rs.revision_date,
							rs.deleted,
							rs.deleted_by,
							rs.deleted_date,
							rs.location,
							rs.code,
							rs.std_activity_sub_type_id,
							rs.activity_subtype,
							rs.related_entity_name,
							rs.category_id,
							rs.related_entity_id,
							rs.primary_contact_display_name,
							rs.facilities,
							rs.primary_contact_email
		FROM activity_data_CTE as rs 
		CROSS JOIN activity_count_CTE as c
		ORDER BY
        -- Handle Sorting
        CASE WHEN (@vSortCol = 'type' AND @vSortOrder = 'ASC')
            THEN rs.activity_type END ASC,

        CASE WHEN (@vSortCol = 'type' AND @vSortOrder = 'DESC')
            THEN rs.activity_type END DESC,
            
        CASE WHEN (@vSortCol = 'activity_id' AND @vSortOrder = 'ASC')
            THEN rs.activity_id END ASC,
        CASE WHEN (@vSortCol = 'activity_id' AND @vSortOrder = 'DESC')
            THEN rs.activity_id END DESC,
            
        CASE WHEN (@vSortCol = 'activity_owner' AND @vSortOrder = 'ASC')
            THEN rs.activity_owner END ASC,
        CASE WHEN (@vSortCol = 'activity_owner' AND @vSortOrder = 'DESC')
            THEN rs.activity_owner END DESC,
            
        CASE WHEN (@vSortCol = 'subject' AND @vSortOrder = 'ASC')
            THEN rs.subject END ASC,
        CASE WHEN (@vSortCol = 'subject' AND @vSortOrder = 'DESC')
            THEN rs.subject END DESC,
            
        CASE WHEN (@vSortCol = 'sub_type' AND @vSortOrder = 'ASC')
            THEN rs.activity_subtype END ASC,
        CASE WHEN (@vSortCol = 'sub_type' AND @vSortOrder = 'DESC')
            THEN rs.activity_subtype END DESC,
            
        CASE WHEN (@vSortCol = 'date' AND @vSortOrder = 'ASC')
            THEN rs.scheduled_start END ASC,
        CASE WHEN (@vSortCol = 'date' AND @vSortOrder = 'DESC')
            THEN rs.scheduled_start END DESC,
            
        CASE WHEN (@vSortCol = 'priority' AND @vSortOrder = 'ASC')
            THEN rs.activity_priority END ASC,
        CASE WHEN (@vSortCol = 'priority' AND @vSortOrder = 'DESC')
            THEN rs.activity_priority END DESC,
            
        CASE WHEN (@vSortCol = 'status' AND @vSortOrder = 'ASC')
            THEN rs.activity_status END ASC,
        CASE WHEN (@vSortCol = 'status' AND @vSortOrder = 'DESC')
            THEN rs.activity_status END DESC,
            
        CASE WHEN (@vSortCol = 'related_entity' AND @vSortOrder = 'ASC')
            THEN rs.related_entity_name END ASC,
        CASE WHEN (@vSortCol = 'related_entity' AND @vSortOrder = 'DESC')
            THEN rs.related_entity_name END DESC,
            
        CASE WHEN (@vSortCol = 'description' AND @vSortOrder = 'ASC')
            THEN rs.description END ASC,
        CASE WHEN (@vSortCol = 'description' AND @vSortOrder = 'DESC')
            THEN rs.description END DESC,
            
        CASE WHEN (@vSortCol = 'category' AND @vSortOrder = 'ASC')
            THEN rs.category_id END ASC,
        CASE WHEN (@vSortCol = 'category' AND @vSortOrder = 'DESC')
            THEN rs.category_id END DESC,
            
        CASE WHEN (@vSortCol = 'related_entity_id' AND @vSortOrder = 'ASC')
            THEN rs.related_entity_id END ASC,
        CASE WHEN (@vSortCol = 'related_entity_id' AND @vSortOrder = 'DESC')
            THEN rs.related_entity_id END DESC,

        CASE WHEN (@vSortCol = 'report_activity')
            THEN rs.activity_owner END ASC,
        CASE WHEN (@vSortCol = 'report_activity')
            THEN rs.created_date END ASC,
        CASE WHEN (@vSortCol = 'report_activity')
            THEN rs.subject END ASC,
			
        CASE WHEN (@vSortCol = 'lead_contact' AND @vSortOrder = 'ASC')
            THEN rs.primary_contact_display_name END ASC,
        CASE WHEN (@vSortCol = 'lead_contact' AND @vSortOrder = 'DESC')
            THEN rs.primary_contact_display_name END DESC,
			
        rs.activity_id ASC
        
		OFFSET @vOffset ROWS FETCH NEXT @vLimit ROWS ONLY

  -- Result Set 1: All activities as specified by filter parameters
  SELECT * FROM #activity

  SET @vStep=2
  -- Result Set 2: All entities associated to any of the activities in #activity
  -- The associatied entities(Leads/Contacts/Accounts) will be added to the Entity Participant field in the ActivityVo with the corresponding entityType/ids set
  -- For the entities with the role "Regarding" a primary contact with a display name
 SELECT a.activity_id,
     e.entity_id,
     e.entity_type,
     e.display_name,
     ea.response,
     ea.participant_role_id,
     r.code,
     r.description,
     a.primary_contact_display_name primary_contact_display_name,
     a.primary_contact_email primary_contact_email
  FROM #activity a
    INNER JOIN scrm_entity_activity ea ON a.activity_id = ea.activity_id
    INNER JOIN view_scrm_entity e ON ea.entity_id = e.entity_id
    LEFT JOIN scrm_std_participant_role r ON ea.participant_role_id = r.participant_role_id
  ORDER BY activity_id

  SET @vStep=3
  -- Result Set 3: All users associated to any of the activities in #activity
  SELECT a.activity_id,
     u.userId,
     u.long_username,
     ua.response
  FROM #activity a
    INNER JOIN scrm_user_activity ua ON a.activity_id = ua.activity_id
    INNER JOIN sec_user u ON ua.user_id = u.userId
  ORDER BY activity_id
  
  SET @status_code = 0

END TRY
BEGIN CATCH
  SELECT @status_text = ERROR_MESSAGE()
  SET @status_code = 1
  GOTO PgmAbend
END CATCH

--program success return
IF @status_code = 0
BEGIN
  IF @DebugMe='Y' Print 'Successful execution of stored procedure'
  RETURN
END

--program failure return
PgmAbend:
  IF @DebugMe='Y' Print 'Stored procedure failure in step:'+ CONVERT(VARCHAR(3),@vStep) + '  ' + CONVERT(VARCHAR(26),GETDATE())
  IF @DebugMe='Y' Print 'Error code: '+CONVERT(VARCHAR(3),@vStep) + '; Error description:  ' +@status_text
  RETURN @status_code  

GO

GRANT EXECUTE ON dbo.sproc_scrm_list_getActivity TO PUBLIC

GO


GO

print 'C_Branch/04_StoredProcedures/sproc_scrm_list_getActivity.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_scrm_list_getActivity.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_sprt_order_list.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- =========================================================================================================================
--
--  Script Type: user defined store procedure
--  Target DB Type:  Client
--  Target Database:  Both
--
--  Re-Runable:  Yes
--
--  Description :  Return a list of Physician Orders and other dependent data such as schedules.
--
--	Params:			
--			@facUUIdCSV
--			@clientId
--			@facilityDateTime
--			@orderCategoryIdsCSV
--			@orderStatusCSV
--			@clientStatus
--			@changesetTypesCSV
--			@changesetStatusesCSV
--			@changesetSourceId
--			@physOrderId
--			@pageSize
--			@pageNumber
--			@sortByColumn
--			@sortByOrder
--			@includeOrders
--			@includeSchedules
--			@includeChangesets
--			@debug          - Debug param, 'Y' or 'N'
--			@status_code    - SP execution flag, 0 for success.
--			@status_text    - SP error text if error occurs.
--
-- Change History:
--   Date			Jira				Team		Author				Comment
-- -----------------------------------------------------------------------------------------------------------------------------------
--   09/28/2021     SPRT-740			Coda	    Elias Ghanem  		Created.
-- =========================================================================================================================

IF EXISTS (SELECT *
               FROM
                   dbo.sysobjects
               WHERE
                   id = object_id(N'[dbo].[sproc_sprt_order_list]')
                   AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
    DROP PROCEDURE [dbo].[sproc_sprt_order_list]

SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[sproc_sprt_order_list]			@facUUIdCSV             VARCHAR(MAX),-- Required: CSV list of fac uuids to filter on
														@clientId				INT,-- Optional: client Id to filter on
                                                        @facilityDateTime       DATETIME,-- Required: facility date time
                                                        @orderCategoryIdsCSV	VARCHAR(100),-- Required CSV list of categegory ids to filter n
                                                        @orderStatusCSV         VARCHAR(100),-- Required: CSV list of order status ids to filter on
                                                        @clientStatus 			INT,-- Required: flag to filter on client status: -1: ALL, 0: Discharged, 1:Current(not discharged)
														@changesetTypesCSV		VARCHAR(100),-- Optional: changeset types to filter on and return
														@changesetStatusesCSV	VARCHAR(100),-- Optional: changeset statuses to filter on and return
														@changesetSourceId		INT,-- Optional: changeset sourece to filter on
                                                        @physOrderId 			INT,-- Optional: physOrderId to filter on
                                                        @pageSize 				INT,-- Required: number of phys orders per page
                                                        @pageNumber 			INT,-- Required: page number	
                                                        @sortByColumn 			VARCHAR(100),-- Required: column to sort on.
                                                        @sortByOrder  			VARCHAR(10),-- Required sort order
														@includeOrders 			INT,-- Required: flag to indicate whether orders data is returned or not: 1: orders summary, 2:orders details, 0:orders data not to be returned
														@includeSchedules 		INT,-- Required: flag to indicate whether schedules data is returned or not: 1: schedules summary, 2:schedules details, 0:schedules data not to be returned
														@includeChangesets 		INT,-- Required: flag to indicate whether changeset data is returned or not: 1: changeset summary, 2:changeset details, 0:changeset data not to be returned
														@debug              	CHAR(1)  = 'N',-- Required: flag to indicate whether to print debug data or not
														@status_code        	INT  = 0 OUT,
                                                        @status_text        	VARCHAR(3000) OUT



AS
BEGIN TRY
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

DECLARE @step                       			int,
		@step_label								varchar(100),
        @error_code                 			int,
		@num_records							int

SET @step = 0
SET @step_label = 'Starting...'
SET @error_code = 0

/*
DECLARE @facIds TABLE
(
	fac_id int  not null
)
*/

DECLARE @orderCategoryIds TABLE
(
	order_category_id INT  NOT NULL
)

DECLARE @orderStatus TABLE
(
	status INT NOT NULL
)

DECLARE @changesetTypes TABLE
(
	changeset_type_id INT NOT NULL
)

DECLARE @changesetStatuses TABLE
(
	status_id INT NOT NULL
)

DECLARE @facInfo TABLE
(
	fac_id INT,
	fac_uuid UNIQUEIDENTIFIER,
	facility_time datetime,
	IsDischargeEnabled  BIT
)

CREATE TABLE #orders_data
  ( 
	phys_order_id             	INT, 
	fac_id                    	INT, 
	client_id                 	INT, 
	order_verified            	VARCHAR(1),
	order_status				INT,
	active_flag               	CHAR(1), 
	draft                     	BIT, 
	hold_date                 	DATETIME, 
	hold_date_end             	DATETIME, 
	end_date                  	DATETIME, 
	discontinued_date         	DATETIME, 
	order_category_id         	INT, 
	controlled_substance_code 	VARCHAR(50),

    order_type_id INT,
	physician_id INT,
	alter_med_src INT,
	pharmacy_id INT,
	route_of_admin INT,
	created_by VARCHAR(60),
	created_date DATETIME,
	revision_by VARCHAR(60),
	revision_date DATETIME,
	start_date DATETIME,
	strength VARCHAR(30),
	form VARCHAR(50),
	description VARCHAR(500),
	directions VARCHAR(1000),
	nurse_pharm_notes VARCHAR(512),
	related_generic VARCHAR(250),
	communication_method INT,
	prescription VARCHAR(50),
	disp_package_identifier VARCHAR(50),
	order_date DATETIME,
	completed_date DATETIME,
	origin_id INT,
	drug_strength VARCHAR(100),
	drug_strength_uom VARCHAR(10),
	drug_name VARCHAR(500),
	order_class_id INT,
	resident_last_name varchar(50),
	resident_first_name varchar(50)	 
  ) ;

CREATE TABLE #tempresult 
  ( 
	phys_order_id             INT, 
	fac_id                    INT, 
	client_id                 INT, 
	order_verified            VARCHAR(1), 
	active_flag               CHAR(1), 
	draft                     BIT, 
	hold_date                 DATETIME, 
	hold_date_end             DATETIME, 
	end_date                  DATETIME, 
	discontinued_date         DATETIME, 
	order_category_id         INT, 
	controlled_substance_code VARCHAR(50),
	facility_time datetime,
	IsDischargeEnabled  BIT,

    order_type_id INT,
	physician_id INT,
	alter_med_src INT,
	pharmacy_id INT,
	route_of_admin INT,
	created_by VARCHAR(60),
	created_date DATETIME,
	revision_by VARCHAR(60),
	revision_date DATETIME,
	start_date DATETIME,
	strength VARCHAR(30),
	form VARCHAR(50),
	description VARCHAR(500),
	directions VARCHAR(1000),
	nurse_pharm_notes VARCHAR(512),
	related_generic VARCHAR(250),
	communication_method INT,
	prescription VARCHAR(50),
	disp_package_identifier VARCHAR(50),
	order_date DATETIME,
	completed_date DATETIME,
	origin_id INT,
	drug_strength VARCHAR(100),
	drug_strength_uom VARCHAR(10),
	drug_name VARCHAR(500),
	order_class_id INT,
	resident_last_name varchar(50),
	resident_first_name varchar(50)
  ) ;
CREATE CLUSTERED INDEX _tempresult_order_id ON #tempresult( phys_order_id );  

CREATE TABLE #vpos
	(
	phys_order_id int NOT NULL,
	fac_id int NOT NULL,
	order_status int NOT NULL,
	order_relationship int NULL,
	status_reason int NULL
	)

SET @step = @step + 1	
SET @step_label = 'Parse CSV parameters into table vairables'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
	
--INSERT INTO @facIds (fac_id)
--SELECT f.fac_id FROM facility f INNER JOIN dbo.Split(@facUUIdCSV, ',') uuids ON uuids.items = f.fac_uuid
INSERT INTO @facInfo
	(fac_id,
	fac_uuid,
	facility_time,
	IsDischargeEnabled
	)
	SELECT f.fac_id,
	f.fac_uuid,
	dbo.fn_facility_getCurrentTime(f.fac_id),
	CASE WHEN cp.value = 'Y' THEN 1 ELSE 0 END
	FROM facility f
	INNER JOIN dbo.Split(@facUUIdCSV, ',') uuids ON uuids.items = f.fac_uuid
	LEFT JOIN configuration_parameter cp ON cp.fac_id = f.fac_id AND cp.name='discharge_order_enable'


INSERT INTO @orderCategoryIds (order_category_id)
SELECT * FROM dbo.Split(@orderCategoryIdsCSV, ',')	
DELETE FROM @orderCategoryIds where order_category_id=1 or order_category_id=3030

INSERT INTO @orderStatus (status)
SELECT * FROM dbo.Split(@orderStatusCSV, ',');

INSERT INTO @changesetTypes (changeset_type_id)
SELECT * FROM dbo.Split(@changesetTypesCSV, ',');

INSERT INTO @changesetStatuses (status_id)
SELECT * FROM dbo.Split(@changesetStatusesCSV, ',');

	
SET @step = @step + 1	
SET @step_label = 'Check for required parameters...'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
IF NOT EXISTS(SELECT 1 FROM @facInfo)
BEGIN
	raiserror ('facUUIdCSV is required. At least one facUUId must be provided.', 16, 1)
END
IF NOT EXISTS(SELECT 1 FROM @orderCategoryIds)
BEGIN
	raiserror ('orderCategoryIdsCSV is required. At least one orderCategoryId must be provided.', 16, 1)
END
IF NOT EXISTS(SELECT 1 FROM @orderStatus)
BEGIN
	raiserror ('orderStatusCSV is required. At least one orderStatus must be provided.', 16, 1)
END	
IF @facilityDateTime IS NULL
BEGIN
	raiserror ('facilityDateTime is required.', 16, 1)
END
IF @clientStatus IS NULL OR @clientStatus NOT IN (-1, 0, 1)
BEGIN
	raiserror ('clientStatus is required. Allowed values are: -1, 0, 1.', 16, 1)
END	
IF @pageSize IS NULL OR @pageSize <= 0
BEGIN
	raiserror ('pageSize is required and should be a positive number.', 16, 1)
END	
IF @pageNumber IS NULL or @pageNumber <= 0
BEGIN
	raiserror ('pageNumber is required and should be a positive number.', 16, 1)
END	
IF @sortByColumn IS NULL
BEGIN
	raiserror ('sortByColumn is required.', 16, 1)
END	
IF @sortByOrder IS NULL
BEGIN
	raiserror ('sortByOrder is required.', 16, 1)
END
IF (( EXISTS(SELECT 1 FROM @changesetTypes) OR EXISTS(SELECT 1 FROM @changesetStatuses)) AND
	(NOT EXISTS(SELECT 1 FROM @changesetTypes) OR NOT EXISTS(SELECT 1 FROM @changesetStatuses)))
BEGIN
	raiserror ('changesetTypesCSV and changesetStatusesCSV should be both set or both empty', 16, 1)
END
IF @changesetSourceId IS NOT NULL AND (NOT EXISTS(SELECT 1 FROM @changesetTypes) OR NOT EXISTS(SELECT 1 FROM @changesetStatuses))
BEGIN
	raiserror ('If changesetSourceId is set, both changesetTypesCSV and changesetStatusesCSV should be set', 16, 1)
END
IF @includeOrders IS NULL OR @includeOrders NOT IN (0, 1, 2)
BEGIN
	raiserror ('includeOrders is required. Allowed values are: 0, 1, 2', 16, 1)
END	
IF @includeSchedules IS NULL OR @includeSchedules NOT IN (0, 1, 2)
BEGIN
	raiserror ('includeSchedules is required. Allowed values are: 0, 1, 2', 16, 1)
END
IF @includeChangesets IS NULL OR @includeSchedules NOT IN (0, 1, 2)
BEGIN
	raiserror ('includeChangesets is required. Allowed values are: 0, 1, 2', 16, 1)
END
IF @includeChangesets IN (1, 2) AND (NOT EXISTS(SELECT 1 FROM @changesetTypes) OR NOT EXISTS(SELECT 1 FROM @changesetStatuses))
BEGIN
	raiserror ('If includeChangesets value is 1 or 2, both changesetTypesCSV and changesetStatusesCSV should be set', 16, 1)
END
		
/*
SET @step = @step + 1
SET @step_label = 'Prepare facility info'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
INSERT INTO @facInfo	
	(fac_id,
	facility_time,
	IsDischargeEnabled
	)
	SELECT f.fac_id, 
	dbo.fn_facility_getCurrentTime(f.fac_id),
	CASE WHEN cp.value = 'Y' THEN 1 ELSE 0 END
	FROM @facIds f	
	LEFT JOIN configuration_parameter cp ON cp.fac_id = f.fac_id AND cp.name='discharge_order_enable'
*/	
	
SET @step = @step + 1
SET @step_label = 'Insert into #tempresult'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text

INSERT INTO #tempresult
	( 
	phys_order_id, 
	fac_id, 
	client_id, 
	order_verified, 
	active_flag, 
	draft, 
	hold_date, 
	hold_date_end, 
	end_date, 
	discontinued_date, 
	order_category_id, 
	controlled_substance_code,
	facility_time,
	IsDischargeEnabled,

    order_type_id,
	physician_id,
	alter_med_src,
	pharmacy_id,
	route_of_admin,
	created_by,
	created_date,
	revision_by,
	revision_date,
	start_date,
	strength,
	form,
	description,
	directions,
	nurse_pharm_notes,
	related_generic,
	communication_method,
	prescription,
	disp_package_identifier,
	order_date,
	completed_date,
	origin_id,
	drug_strength,
	drug_strength_uom,
	drug_name,
	order_class_id,
	resident_last_name,
	resident_first_name
	)
	SELECT
		o.phys_order_id, 
		o.fac_id, 
		o.client_id, 
		o.order_verified, 
		o.active_flag, 
		o.draft, 
		o.hold_date, 
		o.hold_date_end, 
		o.end_date, 
		o.discontinued_date, 
		o.order_category_id, 
		o.controlled_substance_code,
		fi.facility_time,
		fi.IsDischargeEnabled,
	    o.order_type_id,
		o.physician_id,
		o.alter_med_src,
		o.pharmacy_id,
		o.route_of_admin,
		o.created_by,
		o.created_date,
		o.revision_by,
		o.revision_date,
		o.start_date,
		o.strength,
		o.form,
		o.description,
		o.directions,
		o.nurse_pharm_notes,
		o.related_generic,
		o.communication_method,
		o.prescription,
		o.disp_package_identifier,
		o.order_date,
		o.completed_date,
		o.origin_id,
		o.drug_strength,
		o.drug_strength_uom,
		o.drug_name,
		o.order_class_id,
		m.last_name,
		m.first_name
	FROM pho_phys_order o
	--INNER JOIN @facIds f ON f.fac_id = o.fac_id
	INNER JOIN @facInfo fi ON fi.fac_id = o.fac_id
	INNER JOIN @orderCategoryIds cat ON cat.order_category_id = o.order_category_id
	INNER JOIN clients c ON c.client_id = o.client_id
	INNER JOIN mpi m ON m.mpi_id = c.mpi_id
	WHERE (@physOrderId IS NULL OR o.phys_order_id = @physOrderId) AND ISNULL(o.active_flag, 'Y') = 'Y'
	AND (@clientId IS NULL OR o.client_id = @clientId)
	AND (@clientStatus = -1 OR (@clientStatus = 1 AND (c.discharge_date IS NULL OR c.discharge_date > @facilityDateTime)) OR (@clientStatus = 0 AND c.discharge_date <= @facilityDateTime))

SET @step = @step + 1	
SET @step_label = 'Applying changeset filtering if needed'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text

IF EXISTS(SELECT 1 FROM @changesetTypes) OR EXISTS (SELECT 1 FROM @changesetStatuses) OR @changesetSourceId IS NOT NULL
	BEGIN
	MERGE #tempresult AS TARGET
	USING (select o.phys_order_id
	FROM #tempresult o	
	INNER JOIN pho_phys_order_changeset cs ON cs.phys_order_id = o.phys_order_id
	INNER JOIN @changesetTypes cst ON cst.changeset_type_id = cs.changeset_type_id
	INNER JOIN changeset_status csstat ON csstat.changeset_status_id = cs.current_status_id
	INNER JOIN @changesetStatuses csstats ON csstats.status_id = csstat.status_id
	WHERE @changesetSourceId IS NULL OR cs.changeset_source_id = @changesetSourceId
	) AS SOURCE
	ON (TARGET.phys_order_id = SOURCE.phys_order_id) 
	WHEN NOT MATCHED BY SOURCE 
	THEN DELETE; 
END

SET @step = @step + 1	
SET @step_label = 'Calculating orders statuses'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
insert into #vpos
exec sproc_sprt_pho_getOrderStatus  @debug,@status_code out,@status_text out


SET @step = @step + 1	
SET @step_label = 'Insert into #orders_data'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
INSERT INTO #orders_data
	( 
	phys_order_id, 
	fac_id, 
	client_id, 
	order_verified,
	order_status,
	active_flag, 
	draft, 
	hold_date, 
	hold_date_end, 
	end_date, 
	discontinued_date, 
	order_category_id, 
	controlled_substance_code,
    order_type_id,
	physician_id,
	alter_med_src,
	pharmacy_id,
	route_of_admin,
	created_by,
	created_date,
	revision_by,
	revision_date,
	start_date,
	strength,
	form,
	description,
	directions,
	nurse_pharm_notes,
	related_generic,
	communication_method,
	prescription,
	disp_package_identifier,
	order_date,
	completed_date,
	origin_id,
	drug_strength,
	drug_strength_uom,
	drug_name,
	order_class_id,
	resident_last_name,
	resident_first_name
	)
	SELECT
		temp.phys_order_id, 
		temp.fac_id, 
		temp.client_id, 
		temp.order_verified,
		vpos.order_status,
		temp.active_flag, 
		temp.draft, 
		temp.hold_date, 
		temp.hold_date_end, 
		temp.end_date, 
		temp.discontinued_date, 
		temp.order_category_id, 
		temp.controlled_substance_code,
	    temp.order_type_id,
		temp.physician_id,
		temp.alter_med_src,
		temp.pharmacy_id,
		temp.route_of_admin,
		temp.created_by,
		temp.created_date,
		temp.revision_by,
		temp.revision_date,
		temp.start_date,
		temp.strength,
		temp.form,
		temp.description,
		temp.directions,
		temp.nurse_pharm_notes,
		temp.related_generic,
		temp.communication_method,
		temp.prescription,
		temp.disp_package_identifier,
		temp.order_date,
		temp.completed_date,
		temp.origin_id,
		temp.drug_strength,
		temp.drug_strength_uom,
		temp.drug_name,
		temp.order_class_id,
		temp.resident_last_name,
		temp.resident_first_name
	FROM @orderStatus stat
	INNER JOIN #vpos vpos ON vpos.order_status = stat.status
	INNER JOIN #tempresult temp ON temp.phys_order_id = vpos.phys_order_id	


SET @step = @step + 1
SET @step_label = 'Apply pagination'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
select @num_records = count(1) from #orders_data
IF @sortByOrder='desc'
BEGIN
	;WITH TMP AS
	(
		SELECT ROW_NUMBER() OVER(ORDER BY
									 CASE
										WHEN @sortByColumn = 'fac_id' THEN CONVERT(VARCHAR(50), o.fac_id)
										WHEN @sortByColumn = 'description' THEN o.description
										WHEN @sortByColumn = 'client_id' THEN CONVERT(VARCHAR(50), o.resident_first_name)
										ELSE CONVERT(VARCHAR(50), o.phys_order_id)
									END
									DESC,
									CASE
										WHEN @sortByColumn = 'client_id' THEN CONVERT(VARCHAR(50), o.resident_last_name)
										ELSE CONVERT(VARCHAR(50), o.phys_order_id)
									END
									DESC,
									o.phys_order_id DESC) AS rn FROM #orders_data o
	)
	DELETE FROM TMP WHERE @pageSize > 0 AND (rn <= (@pageSize * (@pageNumber-1)) OR rn > (@pageSize * @pageNumber))
END
ELSE
BEGIN
	;WITH TMP AS
	(
		SELECT ROW_NUMBER() OVER(ORDER BY
										CASE
										WHEN @sortByColumn = 'fac_id' THEN CONVERT(varchar(50), o.fac_id)
										WHEN @sortByColumn = 'description' THEN o.description										
										WHEN @sortByColumn = 'client_id' THEN CONVERT(VARCHAR(50), o.resident_first_name)
										ELSE CONVERT(VARCHAR(50), o.phys_order_id)
									END
									ASC,
									CASE
										WHEN @sortByColumn = 'client_id' THEN CONVERT(VARCHAR(50), o.resident_last_name)
										ELSE CONVERT(VARCHAR(50), o.phys_order_id)
									END
									ASC,
									o.phys_order_id DESC) AS rn FROM #orders_data o
	)
	DELETE FROM TMP WHERE @pageSize > 0 AND (rn <= (@pageSize * (@pageNumber-1)) OR rn > (@pageSize * @pageNumber))

END


    /****************************************
    return final result
    ****************************************/
SET @step = @step + 1	
SET @step_label = 'Return final results...'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text

SET @step = @step + 1	
SET @step_label = 'Return orders'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
IF @includeOrders = 1
BEGIN
	SELECT
	o.phys_order_id,
	o.fac_id,
	f.fac_uuid,
	o.client_id,
	o.order_status,
	o.description,
	lib.pho_ext_lib_id,
	lib.pho_ext_lib_med_id,
	lib.pho_ext_lib_med_ddid,
	o.resident_first_name,
	o.resident_last_name,
	o.created_date,
	o.revision_date
	FROM #orders_data o
	INNER JOIN @facInfo f ON f.fac_id = o.fac_id
	LEFT JOIN pho_order_ext_lib_med_ref lib ON lib.phys_order_id = o.phys_order_id
	ORDER BY o.fac_id, o.phys_order_id ASC
END
ELSE
BEGIN
	IF @includeOrders = 2
	BEGIN
		SELECT
		o.phys_order_id,
		o.fac_id,
		f.fac_uuid,
		o.client_id,
		o.order_type_id,
        ot.description AS order_type_desc,
		o.physician_id,
		s.identifier_npi,
		c.first_name AS physician_first_name,
		c.last_name AS physician_last_name,
		c.title AS physician_title,
		o.order_category_id,
		o.communication_method,
		o.order_date,
		o.start_date,
		o.end_date,
		o.directions,
		o.nurse_pharm_notes,
		o.route_of_admin,
		roa.pcc_route_of_admin AS route_of_admin_desc,
		o.order_status,
		o.description,
		o.form,
		o.drug_strength,
		o.drug_strength_uom,
		o.prescription,
		o.disp_package_identifier,
		qi.no_of_refills,
		lib.pho_ext_lib_id,
		lib.pho_ext_lib_med_id,
		lib.pho_ext_lib_med_ddid,
		lib.pho_ext_lib_generic_id,
		lib.pho_ext_lib_generic_desc,
		lib.ext_lib_rxnorm_id,
		o.resident_first_name,
		o.resident_last_name,
		o.controlled_substance_code,
		o.alter_med_src,
		o.pharmacy_id,
		ext_facs.name AS pharmacy_name,
		o.created_by,
		o.created_date,
		o.revision_by,
		o.revision_date
		FROM #orders_data o
		INNER JOIN @facInfo f ON f.fac_id = o.fac_id
		LEFT JOIN wesreference.dbo.pho_std_route_of_admin roa ON roa.route_of_admin_id = o.route_of_admin
		LEFT JOIN pho_phys_order_quantity_info qi ON qi.phys_order_id = o.phys_order_id
		LEFT JOIN contact c ON c.contact_id = o.physician_id
		LEFT JOIN staff s ON s.contact_id = c.contact_id AND (s.fac_id = o.fac_id OR s.fac_id = -1)
		LEFT JOIN pho_order_ext_lib_med_ref lib ON lib.phys_order_id = o.phys_order_id
		LEFT JOIN emc_ext_facilities ext_facs ON ext_facs.ext_fac_id = o.pharmacy_id
        LEFT JOIN pho_order_type ot ON ot.order_type_id = o.order_type_id
		ORDER BY o.fac_id, o.phys_order_id ASC
	END
	ELSE
		SELECT 'ORDER DATA NOT REQUESTED'
END

SET @step = @step + 1	
SET @step_label = 'Return schedules'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
IF @includeSchedules = 1
BEGIN
	SELECT
	o.phys_order_id,
	s.order_schedule_id,
	s.schedule_directions
	FROM #orders_data o
	INNER JOIN PHO_ORDER_SCHEDULE s ON s.phys_order_id = o.phys_order_id
	WHERE s.deleted = 'N'
	ORDER BY o.fac_id, o.phys_order_id, s.order_schedule_id
END
ELSE
BEGIN
	IF @includeSchedules = 2	
	BEGIN	
		SELECT
		os.phys_order_id,
		os.order_schedule_id,
		os.schedule_template,
		os.dose_value,
		os.dose_uom_id,
		os.alternate_dose_value,
		os.dose_low,
		os.quantity_per_dose,
		os.quantity_uom_id,
		os.need_location_of_admin,
		os.sliding_scale_id,
		os.apply_to,
		os.apply_remove_flag,
		os.std_freq_id,
		os.schedule_type,
		sched_type.description AS schedule_type_desc,
		os.repeat_week,
		os.mon,
		os.tues,
		os.wed,
		os.thurs,
		os.fri,
		os.sat,
		os.sun,
		os.xxdays,
		os.xxmonths,
		os.xxhours,
		os.date_of_month,
		os.date_start,
		os.date_stop,
		os.days_on,
		os.days_off,
		os.pho_std_time_id,
		os.related_diagnosis,
		os.indications_for_use,
		os.additional_directions,
		os.administered_by_id,
		admined_by.description AS administered_by_desc,
		os.schedule_start_date,
		os.schedule_end_date,
		os.schedule_end_date_type_id,
		sched_end_date_type.name AS schedule_end_date_type_name,
		os.schedule_duration,
		os.schedule_duration_type_id,
		sched_duration_type.name AS schedule_duration_type_name,
		os.schedule_dose_duration,
		os.prn_admin,
		os.prn_admin_value,
		os.prn_admin_units,
		os.schedule_directions,
		os.created_by,
		os.created_date,
		os.revision_by,
		os.revision_date,		
		--os.std_freq_time_label,
		--os.until_finished,
		--os.order_type_id,
		--os.extended_end_date,
		--os.extended_count,
		--os.prescriber_schedule_start_date,
		ps.schedule_id,
		ps.start_time,
		ps.end_time,
		ps.std_shift_id,
		ps.remove_time,
		ps.remove_duration,
		ps.nurse_action_notes,
        ssr.low_value,
        ssr.high_value,
        ssr.dose AS sliding_scale_dose,
        ssr.directions AS sliding_scale_directions
		FROM #orders_data o
		INNER JOIN PHO_ORDER_SCHEDULE os ON os.phys_order_id = o.phys_order_id
		INNER JOIN PHO_SCHEDULE ps ON ps.order_schedule_id = os.order_schedule_id
		INNER JOIN pho_schedule_type sched_type ON sched_type.schedule_type_id = os.schedule_type
		INNER JOIN pho_std_administered_by admined_by ON admined_by.administered_by_id = os.administered_by_id
		INNER JOIN pho_schedule_end_date_type sched_end_date_type ON sched_end_date_type.schedule_end_date_type_id = os.schedule_end_date_type_id
		LEFT JOIN pho_schedule_duration_type sched_duration_type ON sched_duration_type.schedule_duration_type_id = os.schedule_duration_type_id
        LEFT JOIN pho_order_sliding_scale_range ssr ON ssr.order_schedule_id = os.order_schedule_id
		WHERE os.deleted = 'N' and ps.deleted = 'N'
		ORDER BY o.fac_id, o.phys_order_id, os.order_schedule_id		
	END
	ELSE
		SELECT 'SCHEDULES DATA NOT REQUESTED'
END

SET @step = @step + 1	
SET @step_label = 'Return changeset'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
IF @includeChangesets = 1
BEGIN
	SELECT
	o.phys_order_id,
	cs.changeset_id,
	cs.changeset_type_id,
	cs.changeset_source_id,
	csstat.status_id
	FROM #orders_data o
	INNER JOIN pho_phys_order_changeset cs ON cs.phys_order_id = o.phys_order_id
	INNER JOIN @changesetTypes cst ON cst.changeset_type_id = cs.changeset_type_id
	INNER JOIN changeset_status csstat ON csstat.changeset_status_id = cs.current_status_id
	INNER JOIN @changesetStatuses csstats ON csstats.status_id = csstat.status_id
	WHERE @changesetSourceId IS NULL OR cs.changeset_source_id = @changesetSourceId	
END
ELSE
BEGIN
	IF @includeChangesets = 2
	BEGIN
		SELECT
		o.phys_order_id,
		cs.changeset_id,
		cs.changeset_type_id,
		cs.changeset_source_id,
		cs.changeset_data,
		cs.resulting_phys_order_id,
		cs.aggregate_changeset_id,
		cs.created_by,
		cs.created_date,		
		csstat.status_id,
		csstat.status_source,
		csstat.status_reason,
		csstat.notes,
		csstat.status_by,
		csstat.status_date
		FROM #orders_data o
		INNER JOIN pho_phys_order_changeset cs ON cs.phys_order_id = o.phys_order_id
		INNER JOIN @changesetTypes cst ON cst.changeset_type_id = cs.changeset_type_id
		INNER JOIN changeset_status csstat ON csstat.changeset_status_id = cs.current_status_id
		INNER JOIN @changesetStatuses csstats ON csstats.status_id = csstat.status_id
		WHERE @changesetSourceId IS NULL OR cs.changeset_source_id = @changesetSourceId	
	END
	ELSE
		SELECT 'CHANGESET DATA NOT REQUESTED'
END
SET @step = @step + 1	
SET @step_label = 'Return total record number'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text

select @num_records as total_record_number

    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Done'
    IF @debug='Y'
        PRINT @status_text
    SET @status_code = 0
    GOTO PgmSuccess
END TRY
--error trapping
BEGIN CATCH
    --SELECT @error_code = @@error, @status_text = 'Error at step:'+convert(varchar(3),@step)+', '+ERROR_MESSAGE()
	SELECT @error_code = @@error, @status_text = 'Error at step:' + convert(varchar(3),@step) + ' <' + @step_label + '>, '+ERROR_MESSAGE()

    SET @status_code = 1

    GOTO PgmAbend

END CATCH

--program success return
PgmSuccess:

IF @status_code = 0
BEGIN
    IF @debug='Y' PRINT 'Successfull execution of stored procedure'
    RETURN @status_code
END

--program failure return
PgmAbend:

--IF @debug='Y' PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '   ' + convert(varchar(26),getdate())
IF @debug='Y' PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + ' <' + @step_label + '>   ' + convert(varchar(26),getdate())
    IF @debug='Y' PRINT 'Error code: '+convert(varchar(3),@error_code) + '; Error description:    ' +@status_text
    RETURN @status_code

GO
GRANT EXECUTE ON sproc_sprt_order_list TO public
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_sprt_order_list.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_sprt_order_list.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking (script, timestamp, upload) values ('..\Update db version.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO
SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


insert into pcc_db_version (db_version_code, db_upload_by)
values ('4.4.10_C', 'upload_history')


GO

print '..\Update db version.sql --****SCRIPT DONE****'

GO

insert into upload_tracking (script, timestamp, upload) values ('..\Update db version.sql',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking (script,timestamp,upload) values ('UPLOAD END',getdate(),'4.4.10_06_CLIENT_C_Branch_US.sql')
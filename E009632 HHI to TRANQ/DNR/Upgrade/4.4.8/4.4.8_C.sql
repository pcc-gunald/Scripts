SET NOCOUNT ON
GO

SET DEADLOCK_PRIORITY HIGH
GO


insert into upload_tracking (script, timestamp, upload) values ('UPLOAD_START',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/01_Triggers/US_Only/tp_ar_configuration_del.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


if exists (select name from sysobjects where name = 'tp_ar_configuration_del')
begin
	drop trigger tp_ar_configuration_del
end
GO
	
CREATE TRIGGER tp_ar_configuration_del ON dbo.ar_configuration FOR DELETE NOT FOR REPLICATION
/****************************************************
Purpose: audits all columns from ar_configuration table

Revision History:
2010-03-29  Ritch Moore  #PCC-??? Initial creation of this trigger
2010-10-14  Jimmy Zhang  #PCC-17921 drop std_state_payer_id column
2010-12-22  Patryk Golabek #PCC-19509 droped locality added locality_id
*****************************************************/
AS
  
SET NOCOUNT ON

Insert into dbo.ar_configuration_audit
	(audit_date
	,audit_action_type
	,fac_id
	,deleted
	,created_by
	,created_date
	,revision_by
	,revision_date
	,posting_year
	,posting_month
	,contact_type_id
	,auto_calc_subsidy
	,avg_days_per_month
	,next_batch_number
	,next_cash_receipt_number
	,physician
	,census_revision_window
	,rate_revision_window
	,beds_as_number
	,billing_session_token
	,hc_no_id
	,ssn_id
	,hospital_mrn
	,nsf_ref_account_id
	,medicaid_id
	,medicare_id
	,next_eft_number
	,carrier_no
	,facility_nonfacility
	,ar_start_date
	,fed_tax_no
	,unit_of_measure
	,account_no_prefix
	,statement_message
	,DELETED_BY
	,DELETED_DATE
	,allow_outpatient
	,employer_no
	,term_client
	,anc_import_type
	,anc_import_session_token
	,default_payer_id
	,show_facility
	,show_client
	,diag_principal
	,diag_admission
	,next_adj_number
	,bill_unk_care_level
	,census_time_format
	,ub_facility_type
	,auto_generate_txs_flag
	,auto_retro_anc_flag
	,census_past_months
	,aging_bucket_count
	,auto_retro_start_date
	,auto_create_census
	,use_gl_ext
	,show_cash_receipt_type_summary
	,cash_receipt_comment_flag
	,batch_report_comment_flag
	,use_rent_increase_notif_flag
	,identifier_npi
	,allow_future_post_recurr_flag
	,combine_room_charges_flag
	,show_plans
	,medicare_no_pay_flag
	,transaction_check_flag
	,statement_header_image_id
	,statement_footer_image_id
	,ta_contact_type_id
	,ps_export_flag
	,admission_type_entry_flag
	,admission_source_entry_flag
	,trust_clearing_account_id
	,trust_statement_message
	,admit_fields_on_ti_flag
	,adj_post_date_flag
	,anc_post_date_flag
	,ndc_batch_number_flag
	,display_admit_fields_on_ti
	,signature_image_id
	,sale_date
	,allow_future_census_flag
	,statement_type_id
	,cheques_payable_to
	,days_before_closing_month
	,clearinghouse_statement_export_enabled
	,clearinghouse_nightly_statement_export_enabled
	,clearinghouse_realtime_eligibility_check_enabled
	,clearinghouse_batch_eligibility_check_enabled
	,tofrom_location_entry_flag
	,tofrom_type_entry_flag
	,tofrom_hospital_location_entry_flag
	,agency_id
	,use_py_consolidation_accounts
	,month_of_fiscal_year_end
	,automated_cash_account_id
	,default_medicare_address_id
	,default_medicaid_address_id
	,clearinghouse_loginname
	,clearinghouse_password
	,statement_export_balance_threshold
	,auto_post_retro_ancillary_batch
	,auto_post_writeoff_batch
	,disallow_future_cash_entry_flag
	,disallow_future_adjustment_entry_flag
	,disallow_future_ancillaries_entry_flag
	,locality_id
	,clearinghouse_eligibility_partner 
	,edit_check_template_id
	,default_security_deposit_payer_id
	,default_medicaid_payer_id
	,enforce_max_weight_entry_flag
	,show_payment_due_date
	,default_payment_due_date
	,payment_due_date_type
	,disallow_future_eft_entry_flag
	,end_eft_on_discharged
	,end_eft_on_deceased
	,medicare_beneficiary_id
	,force_room_selection_flag
	,next_eft_export_number
	,next_eft_export_number_reset_flag
	,next_eft_export_number_flag
	,recurring_charges_by_day_start_date
	)
Select 	getdate()--audit_date
	,'delete' --audit_action_type
	,fac_id
	,deleted
	,created_by
	,created_date
	,revision_by
	,revision_date
	,posting_year
	,posting_month
	,contact_type_id
	,auto_calc_subsidy
	,avg_days_per_month
	,next_batch_number
	,next_cash_receipt_number
	,physician
	,census_revision_window
	,rate_revision_window
	,beds_as_number
	,billing_session_token
	,hc_no_id
	,ssn_id
	,hospital_mrn
	,nsf_ref_account_id
	,medicaid_id
	,medicare_id
	,next_eft_number
	,carrier_no
	,facility_nonfacility
	,ar_start_date
	,fed_tax_no
	,unit_of_measure
	,account_no_prefix
	,statement_message
	,DELETED_BY
	,DELETED_DATE
	,allow_outpatient
	,employer_no
	,term_client
	,anc_import_type
	,anc_import_session_token
	,default_payer_id
	,show_facility
	,show_client
	,diag_principal
	,diag_admission
	,next_adj_number
	,bill_unk_care_level
	,census_time_format
	,ub_facility_type
	,auto_generate_txs_flag
	,auto_retro_anc_flag
	,census_past_months
	,aging_bucket_count
	,auto_retro_start_date
	,auto_create_census
	,use_gl_ext
	,show_cash_receipt_type_summary
	,cash_receipt_comment_flag
	,batch_report_comment_flag
	,use_rent_increase_notif_flag
	,identifier_npi
	,allow_future_post_recurr_flag
	,combine_room_charges_flag
	,show_plans
	,medicare_no_pay_flag
	,transaction_check_flag
	,statement_header_image_id
	,statement_footer_image_id
	,ta_contact_type_id
	,ps_export_flag
	,admission_type_entry_flag
	,admission_source_entry_flag
	,trust_clearing_account_id
	,trust_statement_message
	,admit_fields_on_ti_flag
	,adj_post_date_flag
	,anc_post_date_flag
	,ndc_batch_number_flag
	,display_admit_fields_on_ti
	,signature_image_id
	,sale_date
	,allow_future_census_flag
	,statement_type_id
	,cheques_payable_to
	,days_before_closing_month
	,clearinghouse_statement_export_enabled
	,clearinghouse_nightly_statement_export_enabled
	,clearinghouse_realtime_eligibility_check_enabled
	,clearinghouse_batch_eligibility_check_enabled
	,tofrom_location_entry_flag
	,tofrom_type_entry_flag
	,tofrom_hospital_location_entry_flag
	,agency_id
	,use_py_consolidation_accounts
	,month_of_fiscal_year_end
	,automated_cash_account_id
	,default_medicare_address_id
	,default_medicaid_address_id
	,clearinghouse_loginname
	,clearinghouse_password
	,statement_export_balance_threshold
	,auto_post_retro_ancillary_batch
	,auto_post_writeoff_batch
	,disallow_future_cash_entry_flag
	,disallow_future_adjustment_entry_flag
	,disallow_future_ancillaries_entry_flag
	,locality_id
	,clearinghouse_eligibility_partner
	,edit_check_template_id
	,default_security_deposit_payer_id
	,default_medicaid_payer_id
	,enforce_max_weight_entry_flag
	,show_payment_due_date
	,default_payment_due_date
	,payment_due_date_type
	,disallow_future_eft_entry_flag
	,end_eft_on_discharged
	,end_eft_on_deceased
	,medicare_beneficiary_id
	,force_room_selection_flag
	,next_eft_export_number
	,next_eft_export_number_reset_flag
	,next_eft_export_number_flag
	,recurring_charges_by_day_start_date
From deleted

Go

GO

print 'C_Branch/01_Triggers/US_Only/tp_ar_configuration_del.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/01_Triggers/US_Only/tp_ar_configuration_del.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/01_Triggers/US_Only/tp_ar_configuration_upd.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


if exists (select name from sysobjects where name = 'tp_ar_configuration_upd')
begin
	drop trigger tp_ar_configuration_upd
end
GO
	
CREATE TRIGGER tp_ar_configuration_upd ON dbo.ar_configuration FOR UPDATE NOT FOR REPLICATION
/****************************************************
Purpose: audits all columns from ar_configuration table

Revision History:
2010-03-29  Ritch Moore  #PCC-??? Initial creation of this trigger
2010-10-14  Jimmy Zhang  #PCC-17921 drop std_state_payer_id column
2010-12-22  Patryk Golabek #PCC-19509 droped locality added locality_id
2015-10-21  Thomas Kim and #PCC-83499 added condition and add #targetContact to reduce locking time.
2016-11-02  Richard Alam   #PCC-104074 added enable_market_rate_mgmt
2017-03-09  Eric Kloc      #PCC-110652 dropped enable_market_rate_mgmt
*****************************************************/
AS
BEGIN
	SET NOCOUNT ON
	
	Insert into dbo.ar_configuration_audit
		(audit_date
		,audit_action_type
		,fac_id
		,deleted
		,created_by
		,created_date
		,revision_by
		,revision_date
		,posting_year
		,posting_month
		,contact_type_id
		,auto_calc_subsidy
		,avg_days_per_month
		,next_batch_number
		,next_cash_receipt_number
		,physician
		,census_revision_window
		,rate_revision_window
		,beds_as_number
		,billing_session_token
		,hc_no_id
		,ssn_id
		,hospital_mrn
		,nsf_ref_account_id
		,medicaid_id
		,medicare_id
		,next_eft_number
		,carrier_no
		,facility_nonfacility
		,ar_start_date
		,fed_tax_no
		,unit_of_measure
		,account_no_prefix
		,statement_message
		,DELETED_BY
		,DELETED_DATE
		,allow_outpatient
		,employer_no
		,term_client
		,anc_import_type
		,anc_import_session_token
		,default_payer_id
		,show_facility
		,show_client
		,diag_principal
		,diag_admission
		,next_adj_number
		,bill_unk_care_level
		,census_time_format
		,ub_facility_type
		,auto_generate_txs_flag
		,auto_retro_anc_flag
		,census_past_months
		,aging_bucket_count
		,auto_retro_start_date
		,auto_create_census
		,use_gl_ext
		,show_cash_receipt_type_summary
		,cash_receipt_comment_flag
		,batch_report_comment_flag
		,use_rent_increase_notif_flag
		,identifier_npi
		,allow_future_post_recurr_flag
		,combine_room_charges_flag
		,show_plans
		,medicare_no_pay_flag
		,transaction_check_flag
		,statement_header_image_id
		,statement_footer_image_id
		,ta_contact_type_id
		,ps_export_flag
		,admission_type_entry_flag
		,admission_source_entry_flag
		,trust_clearing_account_id
		,trust_statement_message
		,admit_fields_on_ti_flag
		,adj_post_date_flag
		,anc_post_date_flag
		,ndc_batch_number_flag
		,display_admit_fields_on_ti
		,signature_image_id
		,sale_date
		,allow_future_census_flag
		,statement_type_id
		,cheques_payable_to
		,days_before_closing_month
		,clearinghouse_statement_export_enabled
		,clearinghouse_nightly_statement_export_enabled
		,clearinghouse_realtime_eligibility_check_enabled
		,clearinghouse_batch_eligibility_check_enabled
		,tofrom_location_entry_flag
		,tofrom_type_entry_flag
		,tofrom_hospital_location_entry_flag
		,agency_id
		,use_py_consolidation_accounts
		,month_of_fiscal_year_end
		,automated_cash_account_id
		,default_medicare_address_id
		,default_medicaid_address_id
		,clearinghouse_loginname
		,clearinghouse_password
		,statement_export_balance_threshold
		,auto_post_retro_ancillary_batch
		,auto_post_writeoff_batch
		,disallow_future_cash_entry_flag
		,disallow_future_adjustment_entry_flag
		,disallow_future_ancillaries_entry_flag
		,locality_id
		,clearinghouse_eligibility_partner
		,edit_check_template_id
		,default_security_deposit_payer_id
		,default_medicaid_payer_id
		,enforce_max_weight_entry_flag
		,show_payment_due_date
		,default_payment_due_date
		,payment_due_date_type
		,disallow_future_eft_entry_flag
		,end_eft_on_discharged
		,end_eft_on_deceased
		,medicare_beneficiary_id
		,force_room_selection_flag
		,next_eft_export_number
		,next_eft_export_number_reset_flag
		,next_eft_export_number_flag
		,recurring_charges_by_day_start_date
		)
	Select 	getdate()--audit_date
		,'update' --audit_action_type
		,fac_id
		,deleted
		,created_by
		,created_date
		,revision_by
		,revision_date
		,posting_year
		,posting_month
		,contact_type_id
		,auto_calc_subsidy
		,avg_days_per_month
		,next_batch_number
		,next_cash_receipt_number
		,physician
		,census_revision_window
		,rate_revision_window
		,beds_as_number
		,billing_session_token
		,hc_no_id
		,ssn_id
		,hospital_mrn
		,nsf_ref_account_id
		,medicaid_id
		,medicare_id
		,next_eft_number
		,carrier_no
		,facility_nonfacility
		,ar_start_date
		,fed_tax_no
		,unit_of_measure
		,account_no_prefix
		,statement_message
		,DELETED_BY
		,DELETED_DATE
		,allow_outpatient
		,employer_no
		,term_client
		,anc_import_type
		,anc_import_session_token
		,default_payer_id
		,show_facility
		,show_client
		,diag_principal
		,diag_admission
		,next_adj_number
		,bill_unk_care_level
		,census_time_format
		,ub_facility_type
		,auto_generate_txs_flag
		,auto_retro_anc_flag
		,census_past_months
		,aging_bucket_count
		,auto_retro_start_date
		,auto_create_census
		,use_gl_ext
		,show_cash_receipt_type_summary
		,cash_receipt_comment_flag
		,batch_report_comment_flag
		,use_rent_increase_notif_flag
		,identifier_npi
		,allow_future_post_recurr_flag
		,combine_room_charges_flag
		,show_plans
		,medicare_no_pay_flag
		,transaction_check_flag
		,statement_header_image_id
		,statement_footer_image_id
		,ta_contact_type_id
		,ps_export_flag
		,admission_type_entry_flag
		,admission_source_entry_flag
		,trust_clearing_account_id
		,trust_statement_message
		,admit_fields_on_ti_flag
		,adj_post_date_flag
		,anc_post_date_flag
		,ndc_batch_number_flag
		,display_admit_fields_on_ti
		,signature_image_id
		,sale_date
		,allow_future_census_flag
		,statement_type_id
		,cheques_payable_to
		,days_before_closing_month
		,clearinghouse_statement_export_enabled
		,clearinghouse_nightly_statement_export_enabled
		,clearinghouse_realtime_eligibility_check_enabled
		,clearinghouse_batch_eligibility_check_enabled
		,tofrom_location_entry_flag
		,tofrom_type_entry_flag
		,tofrom_hospital_location_entry_flag
		,agency_id
		,use_py_consolidation_accounts
		,month_of_fiscal_year_end
		,automated_cash_account_id
		,default_medicare_address_id
		,default_medicaid_address_id
		,clearinghouse_loginname
		,clearinghouse_password
		,statement_export_balance_threshold
		,auto_post_retro_ancillary_batch
		,auto_post_writeoff_batch
		,disallow_future_cash_entry_flag
		,disallow_future_adjustment_entry_flag
		,disallow_future_ancillaries_entry_flag
		,locality_id
		,clearinghouse_eligibility_partner
		,edit_check_template_id
		,default_security_deposit_payer_id
		,default_medicaid_payer_id
		,enforce_max_weight_entry_flag
		,show_payment_due_date
		,default_payment_due_date
		,payment_due_date_type
		,disallow_future_eft_entry_flag
		,end_eft_on_discharged
		,end_eft_on_deceased
		,medicare_beneficiary_id
		,force_room_selection_flag
		,next_eft_export_number
		,next_eft_export_number_reset_flag
		,next_eft_export_number_flag
		,recurring_charges_by_day_start_date
	From deleted
	
	DECLARE @totalCount INT
	Set @totalCount = (select COUNT(contact_type_id) from inserted)
	IF  @totalCount = 1
	BEGIN
		DECLARE @revisionBy varchar(10)
		SET @revisionBy = 'PCC-66520'
		
		DECLARE @revisionDate datetime
		SET @revisionDate = GETDATE()
		
		-- 1. get new billing contact type id
		declare @oldBillingContactTypeId int
		select @oldBillingContactTypeId=contact_type_id from deleted
		
		declare @newBillingContactTypeId int, @facId int
		select @newBillingContactTypeId=contact_type_id, @facid=fac_id from inserted
		
		-- 2. get residents with single billing contact
		IF (@newBillingContactTypeId <> @oldBillingContactTypeId) 
			OR (@oldBillingContactTypeId IS NOT NULL and @newBillingContactTypeId IS NULL) 
			OR (@newBillingContactTypeId IS NOT NULL and @oldBillingContactTypeId IS NULL)
		BEGIN
			-- 2. get residents with single billing contact	
			CREATE TABLE #resident_with_single_billing_contact
			 (
					   reference_id INT,
					   subclass_id int,
					   type_id int,
					   fac_id int,
					   item_count int
			 )

			insert into #resident_with_single_billing_contact
			select con_type.reference_id, con_type.subclass_id, con_type.type_id, con_type.fac_id, count(*) as item_count
			from contact_type con_type inner join common_code cc 
				on cc.item_id=con_type.subclass_id and cc.item_description='Resident' -- resident contacts only
			where con_type.fac_id = @facId and con_type.type_id = @newBillingContactTypeId  and @newBillingContactTypeId <> -1
			group by con_type.reference_id, con_type.subclass_id, con_type.type_id, con_type.fac_id
			having count(*)=1
			order by con_type.reference_id
			
			 -- 3. update primaru_contact field
			 create table #targetContact
			 (
				contact_id int  PRIMARY KEY
			 )

			 insert into #targetContact (contact_id) 
			 select distinct con_type.contact_id
			 from contact_type con_type with ( nolock)
			 inner join #resident_with_single_billing_contact single_contact
			 on con_type.reference_id=single_contact.reference_id
				and con_type.subclass_id=single_contact.subclass_id
				and con_type.type_id=single_contact.type_id
				and con_type.fac_id=single_contact.fac_id
				and con_type.primary_contact != 1

			 update con_type set con_type.primary_contact=1
			 from contact_type con_type
			 join #targetContact res on con_type.contact_id= res.contact_id

			-- 4. clean up
			drop table #targetContact
			drop table #resident_with_single_billing_contact
		END
	END
END
GO

GO

print 'C_Branch/01_Triggers/US_Only/tp_ar_configuration_upd.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/01_Triggers/US_Only/tp_ar_configuration_upd.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/02_Functions/fn_ar_censusAllRates.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


--==================================================================================================
-- Revision History
----------------------------------------------------------------------------------------------------
--  2015-07-17 DB  PCC-79618  3.7.8  Added market rates calculations 
----------------------------------------------------------------------------------------------------
-- WARNING!!!
-- This function is also used by RRDB(Data Relay), so if there is a any change, please notify them.
--==================================================================================================
set ansi_nulls on
go
set quoted_identifier on
go

if exists (select 1 from sysobjects where name = 'fn_ar_censusAllRates') 
	drop function fn_ar_censusAllRates
go


create function fn_ar_censusAllRates(@censusInfoXml xml) 
returns @censusRates table (daily_rate money, 
                            monthly_rate money, 
                            daily_pay_rate money, 
                            monthly_pay_rate money,
							is_flexible_pay_rate  bit,
							is_pdpm bit)
as 
/*
 * 
declare @censusId int = 34273;
declare @effScheduleId int ;
declare @careLevel varchar(MAX);
declare @altCareLevel varchar(MAX);

select @effScheduleId = ci.eff_schedule_id, @careLevel = ci.rugs_code, @altCareLevel=alternate_care_level 
from census_item ci where ci.census_id = @censusId

declare @censusInfoXml xml = 
    '<row> 
  		<effScheduleId>'+ cast(@effScheduleId as varchar)+'</effScheduleId>
		<careLevel>'+@careLevel+'</careLevel>
		<altCareLevel>'+isnull(@altCareLevel,'')+'</altCareLevel>
		<censusId>' +cast(@censusId as varchar)+'</censusId>
		<additionalLocation>0</additionalLocation>
	</row> 
	'

 select @censusInfoXml, * from dbo.fn_ar_censusAllRates( @censusInfoXml)

 * returned table has one row for each row given in the same order they were given.
 * Note: returns no rows on empty or null xml input.
 */
begin

    declare @censusInfo table (order_given int,
                               eff_schedule_id int, 
                               care_level varchar(5), 
                               alt_care_level varchar(5), 
                               is_custom_rate bit,
                               is_manual_rate bit,
                               is_manual_pay_rate bit,
							   is_market_rate bit,
							   is_reimbursement_market_rate bit,
                               daily_rate money, 
                               monthly_rate money, 
                               daily_pay_rate money, 
                               monthly_pay_rate money,
							   census_id int,
							   is_flexible_pay_rate  bit default 0,
							   contract_census_id int,
							   flexible_rate_id int,
							   flexible_rate_rule_id int,
							   no_of_days int ,
							   additional_location bit default 0,
							   is_pdpm bit default 0,
							   is_reimb_basedon_hipps_flag bit default 0,
							   is_reimbursement_use_hipps bit default 0,
							   rugs_code varchar(5),
							   
							   rate_template_id int,
							   payer_id int,
							   eff_date_from datetime ,
							   ci_effective_date date,
							    rate_template_pct	decimal (7,4),
							    fac_id int,
							    client_id int
							   )

    insert into @censusInfo (order_given, eff_schedule_id, care_level, alt_care_level, census_id, additional_location)
    select row_number() over (order by (select 1)) as order_given,
           ParamValues.ID.query('effScheduleId').value('.','int'),
           ParamValues.ID.query('careLevel').value('.','varchar(5)'),
		   ParamValues.ID.query('altCareLevel').value('.','varchar(5)'),
		   ParamValues.ID.query('censusId').value('.','int'),
		   ParamValues.ID.query('additionalLocation').value('.','int')
    from @censusInfoXml.nodes('/row') as ParamValues(ID)

	UPDATE i 
	SET  is_market_rate =  COALESCE(s.is_market_rate, 0) 
		,is_reimbursement_market_rate = COALESCE(s.is_reimbursement_market_rate, 0)
	FROM @censusInfo i 
		JOIN ar_eff_rate_schedule s on i.eff_schedule_id = s.eff_schedule_id

	
		
	-- get is_flexible_pay_rate information from eff_schedule of contract census
	UPDATE i 
	SET is_flexible_pay_rate = COALESCE(s.is_flexible_pay_rate, 0)
	FROM @censusInfo i
		JOIN census_item ci on i.census_id = ci.census_id
		JOIN census_item cc on cc.census_id = ci.contract_census_id
		JOIN ar_eff_rate_schedule s on s.eff_schedule_id = cc.eff_schedule_id  
	

    -- Get rate from a templates first if possible
    -- for SQL Performance old Query that use left join are splited to 3 query
    update i
    set 
        -- Note: Use a left join after ar_eff_rate_schedule so that we can determine whether rate is 
        -- custom, manual or a template is used.
        -- This will avoid the situation where we have ar_rate_detail records
        -- that point to an eff_schedule_id even though it uses a template so they should not exist,
        -- and then the care level is not found in the template, and so we use erroneosly use the 
        -- record in ar_rate_detail to get the rate when it should be null.
       is_custom_rate = s.is_custom_rate
       ,is_manual_rate = s.is_manual_rate
       ,is_manual_pay_rate = s.is_manual_pay_rate

	   ,rate_template_id = s.rate_template_id
	   ,eff_date_from = s.eff_date_from
	   ,rate_template_pct = s.rate_template_pct
	   ,payer_id = s.payer_id
	   ,fac_id = s.fac_id
	   ,is_pdpm = case  s.pdpm_flag when 'Y' then 1 else 0 end
	   ,is_reimb_basedon_hipps_flag = case  s.reimb_basedon_hipps_flag when 'Y' then 1 else 0 end
	   ,is_reimbursement_use_hipps = case  s.is_reimbursement_use_hipps when 1 then 1 else 0 end
	from @censusInfo i
         join view_ar_eff_rate_schedule s on (i.eff_schedule_id = s.eff_schedule_id)


    update i
    set eff_date_from = ISNULL(i.eff_date_from, ci.effective_date)
	   ,rate_template_pct = i.rate_template_pct
	   ,payer_id = isnull(i.payer_id, ci.primary_payer_id) 
	from @censusInfo i
		  JOIN census_item ci ON  i.census_id = ci.census_id
	where i.is_custom_rate = 1 


    -- Note: Use a left join after ar_eff_rate_schedule so that we can determine whether rate is 
    -- custom, manual or a template is used.
    -- This will avoid the situation where we have ar_rate_detail records
    -- that point to an eff_schedule_id even though it uses a template so they should not exist,
    -- and then the care level is not found in the template, and so we use erroneosly use the 
    -- record in ar_rate_detail to get the rate when it should be null.
	update i
    set daily_rate = convert(money, round((rt.daily_rate*i.rate_template_pct) / 100, 2))
       ,monthly_rate = convert(money, round((rt.monthly_rate*i.rate_template_pct) / 100, 2))
	from @censusInfo i
		  join ar_date_range date_range 
				on date_range.payer_id = i.payer_id and date_range.deleted ='N' and date_range.fac_id = i.fac_id
				   and ( date_range.eff_date_from <= i.eff_date_from 
						and (i.eff_date_from  < date_range.eff_date_to or date_range.eff_date_to is null) )
						
          join view_ar_lib_rate_template_rate rt on (
                   i.rate_template_id = rt.rate_template_id
                   AND rt.is_accepted = 1
                   and i.eff_date_from >= rt.effective_date
                   and (i.eff_date_from < rt.ineffective_date or rt.ineffective_date is null)
					and rt.care_level_code = case when date_range.alt_care_level_template_id = rt.care_level_template_id
                                            then i.alt_care_level else i.care_level end)



    -- Get pay rate from a template if possible.        
    update i
    set daily_pay_rate = convert(money, round((pt.daily_rate*s.pay_rate_template_pct) / 100, 2))
       ,monthly_pay_rate = convert(money, round((pt.monthly_rate*s.pay_rate_template_pct) / 100, 2))
	from @censusInfo i
         join view_ar_eff_rate_schedule s on (i.eff_schedule_id = s.eff_schedule_id)
         join view_ar_lib_rate_template_rate pt on (
                   s.pay_rate_template_id = pt.rate_template_id
                   AND pt.is_accepted = 1
                   and s.eff_date_from >= pt.effective_date
                   and (s.eff_date_from < pt.ineffective_date or pt.ineffective_date is null))
    where s.eff_schedule_id = i.eff_schedule_id
          and pt.care_level_code = i.care_level
		  and i.is_flexible_pay_rate = 0
          
    -- Get pay rate from a template for a custom rate
    update i
    set daily_pay_rate = convert(money, round((pt.daily_rate*s.pay_rate_template_pct) / 100, 2))
       ,monthly_pay_rate = convert(money, round((pt.monthly_rate*s.pay_rate_template_pct) / 100, 2))
	from @censusInfo i
         join view_ar_eff_rate_schedule s on (i.eff_schedule_id = s.eff_schedule_id AND s.is_custom_rate = 1 AND s.pay_rate_template_id IS NOT NULL)
		 join census_item ci ON i.census_id = ci.census_id
         join view_ar_lib_rate_template_rate pt on (
                   s.pay_rate_template_id = pt.rate_template_id
                   AND pt.is_accepted = 1
                   and ci.effective_date >= pt.effective_date
                   and (ci.effective_date < pt.ineffective_date or pt.ineffective_date is null))
    where s.eff_schedule_id = i.eff_schedule_id
          and pt.care_level_code = i.care_level
		  and i.is_flexible_pay_rate = 0

	if exists(select 1 from @censusInfo i where i.is_market_rate = 1 or i.is_reimbursement_market_rate = 1) 
	begin
		update t 
		set 
			t.daily_rate = case when t.is_market_rate = 1 then fnt.daily_rate else t.daily_rate end, 
			t.monthly_rate = case when t.is_market_rate = 1 then fnt.monthly_rate else t.monthly_rate end,
			t.daily_pay_rate = case when t.is_reimbursement_market_rate = 1 then fnt.daily_pay_rate else t.daily_pay_rate end,
			t.monthly_pay_rate = case when t.is_reimbursement_market_rate = 1 then fnt.monthly_pay_rate else t.monthly_pay_rate end
		from @censusInfo t 
			CROSS APPLY dbo.fn_ar_getCensusAllMarketRates(t.census_id, t.eff_schedule_id, t.additional_location) AS fnt
		where t.is_market_rate = 1 or t.is_reimbursement_market_rate = 1			
	end		  
		  
    -- Get it from ar_rate_detail if they are not specifying templates. 
    update i
    set daily_rate = case when i.is_manual_rate = 1 then d.daily_rate else i.daily_rate end
       ,monthly_rate = case when i.is_manual_rate = 1 then d.monthly_rate else i.monthly_rate end
       ,daily_pay_rate = case when i.is_manual_pay_rate = 1 then d.daily_pay_rate else i.daily_pay_rate end
       ,monthly_pay_rate = case when i.is_manual_pay_rate = 1 then d.monthly_pay_rate else i.monthly_pay_rate end
	from @censusInfo i
         join ar_rate_detail d on (i.eff_schedule_id = d.eff_schedule_id 
                                   and (i.care_level = d.care_level or i.is_custom_rate = 1))
	
	---------------------------------------------------------------------------------------------
	-- update flexible rate infor
	update @censusInfo set daily_pay_rate = null, monthly_pay_rate = null
	where is_flexible_pay_rate = 1

   	update i
		set 
			daily_pay_rate	=	case when frr.flexible_rate_type_id = 1 then frr.pay_rate else null end, 
 	 	 	monthly_pay_rate =	case when frr.flexible_rate_type_id = 0 then frr.pay_rate else null end
	from @censusInfo i
		join census_item ci on i.census_id = ci.census_id
		join census_item_flexible_rate cfr on ci.contract_census_id = cfr.contract_census_id
		join ar_flexible_rate_rule frr on frr.flexible_rate_rule_id = ci.flexible_rate_rule_id
	
		
	if exists(select * from @censusInfo where is_pdpm = 1) 
	begin
		update @censusInfo set daily_pay_rate = null, monthly_pay_rate = null 
		where is_pdpm = 1
		
		UPDATE i 
		SET client_id = ci.client_id,
			ci_effective_date = ci.effective_date
		FROM @censusInfo i
			JOIN census_item ci on i.census_id = ci.census_id

		update c set daily_pay_rate	=	 rate.dailyPayrate, monthly_pay_rate =	 null 
		from ar_configuration_pdpm_locality  pl
		join WESREFERENCE.dbo.pdpm_cms_wageindex cw on pl.pdpm_locality_id = cw.pdpm_locality_id		
		join WESREFERENCE.dbo.pdpm_schedule  sch on cw.pdpm_schedule_id = sch.pdpm_schedule_id		
		join @censusInfo c on c.fac_id = pl.fac_id
		--join census_item ci on c.census_id = ci.census_id
		left join census_item_assessment_info cia on c.census_id = cia.census_id
		 cross apply dbo.fn_ar_getPdpmAllRates(c.client_id, c.ci_effective_date, c.eff_schedule_id, cia.pps_assess_id, cia.hipps_code, null, null, cw.pdpm_wageindex_id, 0) rate 
		where c.is_pdpm = 1
			and pl.eff_date_from <= c.ci_effective_date and (pl.eff_date_to is null or pl.eff_date_to >= c.ci_effective_date)
			and sch.eff_date_from <= c.ci_effective_date and (sch.eff_date_to is null or sch.eff_date_to >= c.ci_effective_date)
			
	
	end

	if exists(select * from @censusInfo where is_reimb_basedon_hipps_flag = 1 and is_reimbursement_use_hipps = 1) 
	begin
		update c set daily_pay_rate	= rate.daily_pay_rate, monthly_pay_rate =	 rate.monthly_pay_rate 
		from @censusInfo c 
		join census_item ci on c.census_id = ci.census_id
		left join census_item_assessment_info cia on c.census_id = cia.census_id
		 cross apply dbo.fn_ar_getRateFromHipps(cia.hipps_code, ci.effective_date, c.eff_schedule_id, 0 ) rate 
		where c.is_reimb_basedon_hipps_flag = 1
			and c.is_reimbursement_use_hipps = 1

	end

    -- Return results in same order they were asked for (Note: the order by clause gaurantees 
    -- ordering even though it would probably work without it) 
    insert into @censusRates ( daily_rate , monthly_rate , daily_pay_rate , monthly_pay_rate , is_flexible_pay_rate , is_pdpm )
    select daily_rate, monthly_rate, daily_pay_rate, monthly_pay_rate, is_flexible_pay_rate, is_pdpm
    from @censusInfo 
    order by order_given

	return
    
end
go

grant select on dbo.fn_ar_censusAllRates to public
go


GO

print 'C_Branch/02_Functions/fn_ar_censusAllRates.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/02_Functions/fn_ar_censusAllRates.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/02_Functions/fn_ar_getRateFromHipps.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


--==================================================================================================
-- WARNING!!!
-- This function is also used by RRDB(Data Relay), so if there is a any change, please notify them.
--  Warning!! 
-- it will return 0 if the IS_REIMBURSEMENT_USE_HIPPS of AR_EFF_RATE_SCHEDULE is not 1.	it means, this function can only get pay rate based on HIPPS
	
/**
use DEV_US_Patronus_agrd
fac_3,
Duran, Jaylon J. (93085ATL) client_id = 7697096,
Kim, Thomas (93482ATL) ESOLclientid=10119648
	update ar_eff_rate_schedule 
		set 
			is_reimbursement_use_hipps = 1,
			base_nursing_rate=87.34,
			base_nta_rate=16.46, 
			total_other_daily_reimb_amount = 77.37,
			default_pt_value = null, 
			default_ot_value = 0, 
			default_slp_value = 0, 
			default_nta_value = 0.72, 
			default_nursing_value = 0.66
		where eff_schedule_id= 34424


declare @HIPPScode varchar(5) ='ABMD1' -- 'UNK','ZZZZZ'
declare @effScheduleId int = 34424
declare @effDate date = '2021-10-01'

select 'ABMD1' H, * from fn_ar_getRateFromHipps('ABMD1' , @effDate, @effScheduleId, 1 )
union all 
select 'UNK' H, * from fn_ar_getRateFromHipps('UNK' , @effDate, @effScheduleId, 1 )
union all 
select 'ZZZZZ' H, * from fn_ar_getRateFromHipps('ZZZZZ' , @effDate, @effScheduleId, 1 )
union all 
select 'STD' H, * from fn_ar_getRateFromHipps('STD' , @effDate, @effScheduleId, 0 )


select client_id, rugs_code, *
from census_item ci where ci.eff_schedule_id = 34273

update census_item set rugs_code = 'ABMD1' where census_id = 615856

use DEV_US_Patronus_agrd


-- Medicaid - Skilled, Standard, Private
select lp.payer_type, lp.description payer_name, lp.pps_flag, dr.pdpm_flag
	,dr.reimb_basedon_hipps_flag, dr.* 
from ar_date_range dr
join ar_lib_payers lp on dr.payer_id = lp.payer_id
where dr.deleted ='N' and dr.eff_date_from >= '2021-01-01' and lp.deleted='N' and lp.payer_type='Medicaid'

-- update  ar_date_range  set reimb_basedon_hipps_flag = 'Y' where eff_date_range_id = 5515
select sch.description Schedule, rt.long_description
	,ers.* 
from ar_eff_rate_schedule ers
join ar_lib_rate_schedule sch on ers.schedule_id = sch.schedule_id
join ar_lib_rate_type rt on ers.rate_type_id = rt.rate_type_id
where ers.eff_date_range_id = 5515
	and sch.deleted='N'
	and ers.schedule_id = 1 
	and ers.rate_type_id = 1
*/

set ansi_nulls on
go
set quoted_identifier on
go

if exists (select 1 from sysobjects where name = 'fn_ar_getRateFromHipps') 
	drop function fn_ar_getRateFromHipps
go



create function fn_ar_getRateFromHipps(@HIPPScode varchar(5),  @effDate date, @effScheduleId int, @debug bit ) 
returns @censusRates table (
	HIPPS_CODE  varchar(5),
	daily_pay_rate money, 
	monthly_pay_rate money, 
	has_error bit default 0, 
	debug_info varchar(MAX))
as 
begin 
	declare @pdpmModelId int
	declare @dailyRate money
	declare @cmiNursing numeric(20,8)
	declare @cmiNTA numeric(20,8)
	declare @cmiPT numeric(20,8)
	declare @cmiOT numeric(20,8)
	declare @cmiSLP numeric(20,8)
	declare @reimbPercent numeric(30,12)

	declare @baseNursingRate money
	declare @baseNTARate money
	declare @basePTRate money
	declare @baseOTRate money
	declare @baseSLPRate money
	declare @totalOtherDailyReimbAmount money
	declare @isReimbursementUseHipps bit

	declare @debugText varchar(MAX) = '';

	

	select @basePTRate =  isnull(base_pt_rate, 0) ,
			@baseOTRate =   isnull(ers.base_ot_rate, 0),
			@baseSLPRate =   isnull(ers.base_slp_rate, 0), 
			@baseNTARate =   isnull(ers.base_nta_rate, 0), 
			@baseNursingRate =  isnull(ers.base_nursing_rate, 0),
			@totalOtherDailyReimbAmount = isnull(ers.total_other_daily_reimb_amount, 0),
			@cmiPT= isnull(ers.default_pt_value, 0), 
			@cmiOT = isnull(ers.default_ot_value, 0), 
			@cmiSLP = isnull(ers.default_slp_value, 0), 
			@cmiNTA = isnull(ers.default_nta_value, 0), 
			@cmiNursing = isnull(ers.default_nursing_value, 0),
			@isReimbursementUseHipps = ers.is_reimbursement_use_hipps, 
			@reimbPercent = ers.pdpm_pay_pct
	from ar_eff_rate_schedule ers 
	left join ar_date_range  r on (ers.eff_date_range_id = r.eff_date_range_id 
                                   and r.deleted = 'N' and r.reimb_basedon_hipps_flag ='Y')
	where ers.eff_schedule_id	 = @effScheduleId

	if ( @reimbPercent is null )	
	begin
	 set @reimbPercent = 1.0
	end 
	else 
	begin
	 set @reimbPercent = @reimbPercent / 100
	end
	
	if (@isReimbursementUseHipps <> 1 )
	begin
		if(@debug = 1)
		begin
			set @debugText =  'The isReimbursementUseHipps of eff_rate_schedule is not set to using HIPPS!'
		end
		GOTO HAS_ERROR
	end


	if( @HIPPScode is null or @HIPPScode = 'UNK') 
	begin 
		if(@debug = 1)
		begin
			set @debugText =  'used default CMI : ( ' + format (@cmiPT , 'N4') +', ' + format (@cmiOT , 'N4')  +', ' + format (@cmiSLP , 'N4')  
								+', ' + format (@cmiNTA , 'N4') +', ' + format (@cmiNursing , 'N4') +') '
		end
	end
	else if (@HIPPScode != 'ZZZZZ' )
	begin
			select @cmiPT = isnull(ptcmi, 0 ), @cmiOT= isnull(otcmi, 0), @cmiSLP = isnull(slpcmi, 0) ,@cmiNTA = isnull(ntacmi, 0), @cmiNursing = isnull(Nursingcmi, 0)
			from (
			select 
				max(case component_name when 'PT'  then cmi  end) ptcmi,
				max(case component_name when 'OT'  then cmi  end) otcmi,
				max(case component_name when 'SLP' then cmi  end) slpcmi,
				max(case component_name when 'NTA' then cmi  end) ntacmi,
				max(case component_name when 'Nursing' then cmi  end) Nursingcmi
			  from fn_ar_getCMIfromHIPPS(@HIPPScode, @effDate) ) r
		if(@debug = 1)
		begin
			set @debugText =  'Regular: ( ' + format (@cmiPT , 'N4') +', ' + format (@cmiOT , 'N4')  +', ' + format (@cmiSLP , 'N4')  
								+', ' + format (@cmiNTA , 'N4') +', ' + format (@cmiNursing , 'N4') +') '
		end 
	end
	else if (@HIPPScode = 'ZZZZZ' )
	begin
			set @pdpmModelId = dbo.fn_ar_getPdpmModlId(@effDate)

			select @cmiPT=[PT], @cmiOT=[OT], @cmiSLP=[SLP],@cmiNTA=[NTA],@cmiNursing=[Nursing]
			from (select cat.description, cmi.cmi
				from WESREFERENCE.dbo.as_std_pdpm_cmi cmi
				join WESREFERENCE.dbo.as_std_pdpm_code cat on cmi.cat_id = cat.cat_id
				where cat.deleted = 'N' and cat.model_id = @pdpmModelId
			) r
			pivot (
				min(r.cmi)
				for r.description in ([PT], [OT],[SLP],[NTA],[Nursing])
			) as p
		if(@debug = 1)
		begin
			set @debugText =  ' minumum CMI: ( ' + format (@cmiPT , 'N4') +', ' + format (@cmiOT , 'N4')  +', ' + format (@cmiSLP , 'N4')  
								+', ' + format (@cmiNTA , 'N4') +', ' + format (@cmiNursing , 'N4') +') '
		end
	end


	set @dailyRate = round( ( @cmiPT * @basePTRate
							+ @cmiOT * @baseOTRate
							+ @cmiSLP * @baseSLPRate
							+ @cmiNTA * @baseNTARate
							+ @cmiNursing * @baseNursingRate
							+ @totalOtherDailyReimbAmount) * @reimbPercent , 2) 
	
	insert into @censusRates(hipps_code, daily_pay_rate, monthly_pay_rate, debug_info)
	select @HIPPScode, @dailyRate , null, @debugText




	GOTO FINAL
	
	HAS_ERROR:	
		if(@debug = 1)
		begin
			insert into @censusRates (has_error, debug_info) values(1, @debugText)
		end
		
    
	FINAL:
		return

	return



end
go

grant select on dbo.fn_ar_getRateFromHipps to public
go


GO

print 'C_Branch/02_Functions/fn_ar_getRateFromHipps.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/02_Functions/fn_ar_getRateFromHipps.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/02_Functions/fn_clinical_get_icd10cm_implementation_date.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- =================================================================================
-- Jira #:               PCC-52426
--
-- Written By:           Martyn Gilmore
-- Recreated By:		 Brian Young
--
-- Script Type:          DDL
-- Target DB Type:       CLIENTDB
-- Target ENVIRONMENT:   BOTH
--
--
-- Re-Runable:           YES
--
-- Special Instruction:
--	2021-11-01 - BCY - SQL function definition was missing
-- =================================================================================

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'[dbo].[fn_clinical_get_icd10cm_implementation_date]'))
	DROP FUNCTION [dbo].[fn_clinical_get_icd10cm_implementation_date]
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE FUNCTION [dbo].[fn_clinical_get_icd10cm_implementation_date] ()
RETURNS datetime
AS
BEGIN
	DECLARE @icd10ImplDate datetime

	SET @icd10ImplDate = (SELECT TOP 1 [value] FROM configuration_parameter WHERE fac_id = -1 AND [name] = 'icd10cm_implementation_date');

	IF @icd10ImplDate IS NULL
		SET @icd10ImplDate = {ts '9999-12-31 00:00:00'}

	RETURN @icd10ImplDate
END
GO

GRANT EXECUTE ON [dbo].[fn_clinical_get_icd10cm_implementation_date] TO PUBLIC
GO


GO

print 'C_Branch/02_Functions/fn_clinical_get_icd10cm_implementation_date.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/02_Functions/fn_clinical_get_icd10cm_implementation_date.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/03_Views/view_ar_eff_rate_schedule.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


--=======================================================================================================================
-- PCC-72224
--
-- Written By:       Dan Bucur
-- Reviewed By: 	 Lasantha Ranawana
-- Script Type:      DDL
-- Target DB Type:   Client
-- Target Database:  Both
--
-- Re-Runnable:      YES
--
-- Staging Recommendations/Warnings: None
--
--=======================================================================================================================
-- WARNING !!! it is used in some functions, 
-- when you change it, you need to check it in B_Upload folder too to avoid sequence of build issue!
--=======================================================================================================================

set ansi_nulls on
go
set quoted_identifier on
go

if exists (select 1 from sysobjects where name = 'view_ar_eff_rate_schedule')
    drop view view_ar_eff_rate_schedule
go

create view view_ar_eff_rate_schedule as
/*
 * Primary key is eff_schedule_id
 * Business key is rate_type_id, eff_date_range_id, schedule_id
 */

select s.eff_schedule_id
      ,s.fac_id
      ,s.rate_type_id
      ,s.eff_date_range_id
      -- Note: For custom rates these values will be null. Also sometimes 
      -- payer_id = -1 on ar_date_range.
      ,r.payer_id
      ,r.eff_date_from
      ,r.eff_date_to
      ,s.bill_in_advance
      ,s.schedule_id
      ,s.default_rate
      ,s.max_days
      ,s.dollars_account_id
      ,s.days_account_id
      ,s.adj_account_id
      ,s.coverage_account_id
      ,s.use_fixed_room_charge
      ,case when s.use_fixed_room_charge = 'Y' then s.fixed_room_charge_amount else 0 
       end as fixed_room_charge_amount
      ,r.fixed_room_charge_account_id
      ,s.fixed_room_charge_revenue_code
      ,s.is_custom_rate
      ,s.rate_template_id
      ,s.rate_template_pct
      ,s.is_manual_rate
      ,s.pay_rate_template_id
      ,s.pay_rate_template_pct
      ,s.is_manual_pay_rate
      ,s.is_allow_adj
      ,s.revenue_code
      ,r.reimbursement_type
	  ,s.is_revenue_code_by_care_level
	  ,schedule.description as schedule_desc
      ,rate.long_description as rate_desc
	  ,s.market_date_range_id as market_date_range_id
	  ,s.market_rate_type_id as market_rate_type_id
	  ,s.percentage_of_market_rates as percentage_of_market_rates
	  ,s.is_market_rate as is_market_rate
	  ,s.is_reimbursement_market_rate as is_reimbursement_market_rate
	  ,s.is_flexible_pay_rate as is_flexible_pay_rate
	  -- below two care_level_template_id value can nulll 
	  -- since eff_date_range_id of ar_eff_rate_schedule can be null
	  ,r.care_level_template_id 
	  ,r.alt_care_level_template_id
	  ,r.pdpm_flag
	  ,r.reimb_basedon_hipps_flag
	  ,case when r.reimb_basedon_hipps_flag = 'Y' then s.is_reimbursement_use_hipps else 0 end is_reimbursement_use_hipps
from ar_eff_rate_schedule s
     left join ar_date_range r on (s.eff_date_range_id = r.eff_date_range_id 
                                   and r.deleted = 'N')
     left join ar_lib_rate_schedule schedule
               on (s.schedule_id = schedule.schedule_id and schedule.deleted = 'N' and schedule.version_flag = 1)
     left join ar_lib_rate_type rate
               on (s.rate_type_id = rate.rate_type_id and rate.deleted = 'N' and rate.version_flag = 1)



go



GO

print 'C_Branch/03_Views/view_ar_eff_rate_schedule.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/03_Views/view_ar_eff_rate_schedule.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/03_Views/view_ar_rate_detail.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


--==================================================================================================
-- Written By:      Josh Allen
-- Script Type:     DDL
-- Target DB Type:  Client
-- Target Database: BOTH
-- Re-Runable:      Yes
--==================================================================================================

set ansi_nulls on
go
set quoted_identifier on
go

if exists (select 1 from sysobjects where name = 'view_ar_rate_detail')
    drop view view_ar_rate_detail
go


create view view_ar_rate_detail as
/*
 * Primary key is eff_schedule_id, is_care_level_alternate, care_level
 * Business key is rate_type_id, eff_date_range_id|is_custom_rate, schedule_id, is_care_level_alternate, care_level
 */
select s.eff_schedule_id
      ,r.rate_detail_id  -- null when both rate templates are used
      ,s.fac_id
         -- Whether the care level that is displayed in this row is from the payers
      -- regular care level template, or from the alternate care level template.
         ,convert(bit, alt.is_alt) as is_care_level_alternate
      -- Whether to look at the census_item.rugs_code or census_item.alternate_care_level
         -- to get the daily_rate and monthly_rate.
         ,convert(bit, case when basetemplate.care_level_template_id = s.alt_care_level_template_id 
                    then 1 else 0 end) as join_std_using_alternate_care_level
         -- Whether to look at the census_item.rugs_code or census_item.alternate_care_level
         -- to get the daily_pay_rate and monthly_pay_rate.
         ,convert(bit, 0) as join_pay_using_alternate_care_level
      ,s.rate_type_id
         ,s.rate_desc
      ,s.eff_date_range_id
      ,s.payer_id
      ,s.eff_date_from
      ,s.eff_date_to
      ,s.bill_in_advance
      ,s.schedule_id
      ,s.schedule_desc
      ,s.default_rate
      ,s.max_days
      ,s.dollars_account_id
      ,dollars.description as dollars_account_desc
         ,dollars.account_number as dollars_account_number
      ,s.days_account_id
         ,days.description as days_account_desc
         ,days.account_number as days_account_number
      ,s.adj_account_id
      ,adj.description as adj_account_desc
         ,adj.account_number as adj_account_number
      ,s.coverage_account_id
      ,coverage.description as coverage_account_desc
         ,coverage.account_number as coverage_account_number
      ,s.reimbursement_type
      ,s.use_fixed_room_charge
      ,s.fixed_room_charge_amount
      ,s.fixed_room_charge_account_id
      ,s.fixed_room_charge_revenue_code
      ,s.is_custom_rate
      ,s.rate_template_id
      ,s.rate_template_pct
      ,s.is_manual_rate
      ,s.pay_rate_template_id
      ,s.pay_rate_template_pct
      ,s.is_manual_pay_rate
         ,s.is_market_rate 
		 ,s.is_reimbursement_market_rate   
         ,s.percentage_of_market_rates 
         ,s.market_rate_type_id
         ,s.market_date_range_id
         ,mrt.long_description as market_rate_type_description
      ,(case when s.is_manual_rate = 1 then r.monthly_rate 
			 when s.is_market_rate = 1 then null 
        else convert(money, round((rt.monthly_rate*s.rate_template_pct) / 100, 2)) end) as monthly_rate
      ,(case when s.is_manual_rate = 1 then r.daily_rate  
			 when s.is_market_rate = 1 then null                   
        else convert(money, round((rt.daily_rate*s.rate_template_pct) / 100, 2)) end) as daily_rate
      ,(case when s.is_manual_pay_rate = 1 then r.monthly_pay_rate 
	  		 when s.is_reimbursement_market_rate = 1 then null  
        else convert(money, round((pt.monthly_rate*s.pay_rate_template_pct) / 100, 2)) end) as monthly_pay_rate
      ,(case when s.is_manual_pay_rate = 1 then r.daily_pay_rate 
			 when s.is_reimbursement_market_rate = 1 then null 
        else convert(money, round((pt.daily_rate*s.pay_rate_template_pct) / 100, 2)) end) as daily_pay_rate
         -- Which revenue code to use:
         -- [x] Use adjustment account | standard template or manual | reimbursement template or manual
         -- [ ] T   = Standard template revenue code (only if by care level chosen).
         -- [ ] M   = Manual revenue code.
         -- [x] T T = Reimbursement template revenue code (only if by care level chosen).
         -- [x] T M = Manual revenue code.
         -- [x] M T = Reimbursement template revenue code (only if by care level chosen).
         -- [x] M M = Manual revenue code.
      ,case when (s.is_revenue_code_by_care_level = 0 or s.is_custom_rate = 1) then s.revenue_code 
               else case when s.is_allow_adj = 0 and s.is_manual_rate = 0 then rt.revenue_short_desc
                        when s.is_allow_adj = 0 and s.is_manual_rate = 1 then r.revenue_code
                                 when s.is_allow_adj = 1 and s.is_manual_rate = 0 and s.is_manual_pay_rate = 0 then pt.revenue_short_desc
                                 when s.is_allow_adj = 1 and s.is_manual_rate = 0 and s.is_manual_pay_rate = 1 then r.revenue_code
                                 when s.is_allow_adj = 1 and s.is_manual_rate = 1 and s.is_manual_pay_rate = 0 then pt.revenue_short_desc
                                 when s.is_allow_adj = 1 and s.is_manual_rate = 1 and s.is_manual_pay_rate = 1 then r.revenue_code
                          end
       end as revenue_code
          ,code.item_description as revenue_code_description
          -- Note that care_level will be null if they are using templates that both use reimbursement templates.	
      ,coalesce(r.care_level, rt.care_level_code, pt.care_level_code) as care_level
          -- Note: care_level_sequence_no will be NULL for custom rates because the 
          -- payer_id for custom rates comes from the census, however this is okay 
          -- because care_level_sequence_no is not used for custom rates.
          -- It will also be null when you are using templates for both standard and 
          -- reimbursment and they are both using an alternate care level template.
         ,i.sequence_no as care_level_sequence_no
      ,case when alt.is_alt = 0 then s.care_level_template_id 
            else s.alt_care_level_template_id 
       end as care_level_template_id
      ,r.item_type_id
         ,s.is_revenue_code_by_care_level
        ,s.reimb_basedon_hipps_flag
        ,s.is_reimbursement_use_hipps
from -- Use this inline view to duplicate the rows, one for alternate and 
     -- one for regular care level. is_alt = 1 means we are on an alternate 
     -- care level row, otherwise we are on a regular care level row.
     (select 0 as is_alt union all select 1) alt 
     -- Use 1=1 to do a cartsian product with the alt inline view.
     join view_ar_eff_rate_schedule s on (1=1)
     left join view_ar_revenue_code code on code.short_description = s.revenue_code 
     left join ar_lib_care_level_template_item i on (
                           (alt.is_alt = 1 and s.alt_care_level_template_id = i.care_level_template_id
                           or alt.is_alt = 0 and s.care_level_template_id = i.care_level_template_id)
                and i.effective_date <= s.eff_date_from
                and (i.ineffective_date >= s.eff_date_from or i.ineffective_date is null)
                           and i.deleted = 'N')
     -- Join to ar_rate_detail to get the rate if we are using a manual rate.
     left join ar_rate_detail r -- Manual rate.
                  on ((s.is_manual_rate = 1 or s.is_manual_pay_rate = 1 or s.is_custom_rate = 1)
                             and alt.is_alt = 0
                    and r.eff_schedule_id = s.eff_schedule_id
                                  and (r.care_level = i.care_level_code or s.is_custom_rate = 1))
     left join ar_lib_rate_template basetemplate on (basetemplate.rate_template_id = s.rate_template_id)
     -- Join to templates to get the rate if we are not using a manual rate.                                   
     left join view_ar_lib_rate_template_rate rt -- Standard template
               on (s.is_manual_rate = 0
                              and i.care_level_template_id = rt.care_level_template_id
                              and i.care_level_code = rt.care_level_code
                         and rt.is_accepted = 1
                   and s.rate_template_id = rt.rate_template_id
                   and s.eff_date_from >= rt.effective_date
                   and (s.eff_date_from < rt.ineffective_date or rt.ineffective_date is null))
     left join view_ar_lib_rate_template_rate pt -- Reimbursement Template
               on (s.is_manual_pay_rate = 0
                            and i.care_level_template_id = pt.care_level_template_id
                              and i.care_level_code = pt.care_level_code
                   and pt.is_accepted = 1
                   and s.pay_rate_template_id = pt.rate_template_id
                              and s.eff_date_from >= pt.effective_date
                   and (s.eff_date_from < pt.ineffective_date or pt.ineffective_date is null))
     left join ar_lib_accounts days
               on (s.days_account_id = days.account_id
                   and days.deleted = 'N')
     left join ar_lib_accounts dollars
               on (s.dollars_account_id = dollars.account_id
                   and dollars.deleted = 'N')
     left join ar_lib_accounts adj
               on (s.adj_account_Id = adj.account_id
                   and adj.deleted = 'N')
     left join ar_lib_accounts coverage
               on (s.coverage_account_id = coverage.account_id
                   and coverage.deleted = 'N')
     left join ar_lib_rate_type mrt on (s.market_rate_type_id = mrt.rate_type_id and mrt.version_flag = 1) 
where coalesce(r.care_level, rt.care_level_code, pt.care_level_code) is not null 

go


GO

print 'C_Branch/03_Views/view_ar_rate_detail.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/03_Views/view_ar_rate_detail.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_admin_dml_reverseOpenCashPayments.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


  -- =================================================================================
-- Jira #:              CORE-21832 (Open Cash: update collection activity)
--
-- Written By:          Naomi Martel
-- Reviewed By:
-- Script Type:         DML
-- Target DB Type:      Client
-- Target ENVIRONMENT:  BOTH (US/CA)
-- Re-Runnable:         YES
--
-- Description of Script Function:
--      Insert to ar_transactions_payment and ar_unapplied_cash equal and opposite payments whenever the cash
--      batch is reversed.
--
-- =================================================================================
-- Sample execution:
-- DECLARE @status_code int,  @status_text varchar(3000)
-- EXEC sproc_admin_dml_reverseOpenCashPayments 192481, 'PCC-marten', 'Y', @status_code, @status_text
--
-- Params:
--                    @batchId - the reversal batch
--                    @revisionBy  - user initiating the action
--
-- Return:            NONE
-- =================================================================================

SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO

IF EXISTS (
    SELECT 1
    FROM dbo.sysobjects
    WHERE id = object_id(N'dbo.sproc_admin_dml_reverseOpenCashPayments')
        AND objectproperty(id, N'IsProcedure') = 1
    )
BEGIN
    DROP PROCEDURE dbo.sproc_admin_dml_reverseOpenCashPayments
END
GO

CREATE PROCEDURE sproc_admin_dml_reverseOpenCashPayments
(
  @batchId int,
  @revisionBy varchar(60),
  @debug char(1) = 'N',
  @status_code int = 0 out,
  @status_text varchar(3000) out
)
AS

SET NOCOUNT ON

DECLARE @error_code int
DECLARE @now datetime
SET @now = getdate()

DECLARE @theAuditDetails TABLE
(
    fac_id INT NOT NULL,
    client_id INT NOT NULL,
    invoice_id INT NULL,
    payment_transaction_id INT,
    changing_desc VARCHAR(max),
    action VARCHAR(10),
    record_amount DECIMAL(20,2)
)

DECLARE @charge_payment TABLE
(
    fac_id INT NOT NULL,
    client_id INT NOT NULL,
    invoice_id INT NULL,
    charge_transaction_id INT NOT NULL,
    payment_transaction_id INT NOT NULL,
    amount DECIMAL(20,2) NULL DEFAULT (0),
    amount_for_auto_writeoff DECIMAL(20,2) NULL DEFAULT (0),
    is_created_from_auto_writeoff BIT NULL
)

DECLARE @unapplied TABLE
(
    fac_id INT NOT NULL,
    client_id INT NOT NULL,
    invoice_id INT NULL,
    payment_transaction_id INT NOT NULL,
    effective_date DATETIME NOT NULL,
    amount DECIMAL(20,2) NULL DEFAULT (0),
	is_post_transition bit
)

BEGIN TRY

    IF @batchId is null OR @batchId < 0
    BEGIN
        SET @status_text = 'Invalid batchId!'
        SET @status_code = 1
        GOTO PgmAbend
    END

    BEGIN TRAN


        INSERT INTO @charge_payment (fac_id, client_id, invoice_id, charge_transaction_id, payment_transaction_id, amount, amount_for_auto_writeoff,is_created_from_auto_writeoff)
        SELECT newCsh.fac_id, newCsh.client_id, chg.invoice_id, tp.charge_transaction_id, newCsh.transaction_id, (-1) * tp.amount, (-1) * tp.amount_for_auto_writeoff, is_created_from_auto_writeoff
        FROM ar_batch b
        INNER JOIN ar_transactions newCsh
          ON b.batch_id = newCsh.batch_id
          AND b.fac_id = newCsh.fac_id
          AND newCsh.deleted = 'N'
        INNER JOIN ar_transactions_payment tp
          ON tp.payment_transaction_id = newCsh.reversing_tx_id
        INNER JOIN ar_transactions chg
          ON tp.charge_transaction_id = chg.transaction_id
          AND b.fac_id = chg.fac_id
          AND chg.deleted = 'N'
        WHERE b.batch_id = @batchId

        INSERT INTO ar_transactions_payment (charge_transaction_id, payment_transaction_id, amount, amount_for_auto_writeoff, is_created_from_auto_writeoff,
                    created_by, created_date, revision_by, revision_date)
        SELECT charge_transaction_id, payment_transaction_id, amount, amount_for_auto_writeoff, is_created_from_auto_writeoff, @revisionBy, @now, @revisionBy, @now
        FROM @charge_payment

        INSERT INTO @theAuditDetails (fac_id, client_id, invoice_id, payment_transaction_id, changing_desc, action, record_amount)
        SELECT fac_id, client_id, invoice_id, payment_transaction_id, 'reverseOpenCashPayments:insert new payment mapping.', 'CREATE', SUM(amount)
        FROM @charge_payment
        GROUP BY fac_id, client_id, invoice_id, payment_transaction_id

        INSERT INTO @unapplied (fac_id, client_id, invoice_id, payment_transaction_id, amount, effective_date, is_post_transition)
        SELECT newCsh.fac_id, newCsh.client_id, -1, newCsh.transaction_id, (-1) * uc.amount, newCsh.effective_date, uc.is_post_transition
        FROM ar_batch b
        INNER JOIN ar_transactions newCsh
          ON b.batch_id = newCsh.batch_id
          AND b.fac_id = newCsh.fac_id
          AND newCsh.deleted = 'N'
        INNER JOIN ar_unapplied_cash uc
          ON uc.transaction_id = newCsh.reversing_tx_id
        WHERE b.batch_id = @batchId

        INSERT INTO ar_unapplied_cash (transaction_id, amount, effective_date, created_by, created_date, revision_by, revision_date, is_post_transition)
        SELECT payment_transaction_id, amount, effective_date, @revisionBy, @now, @revisionBy, @now, is_post_transition
        FROM @unapplied

        INSERT INTO @theAuditDetails (fac_id, client_id, invoice_id, payment_transaction_id, changing_desc, action, record_amount)
        SELECT fac_id, client_id, invoice_id, payment_transaction_id, 'reverseOpenCashPayments:insert new unapplied cash.', 'CREATE', amount
        FROM @unapplied

        -- Create audit records for saving
        declare @touchedRecords TouchedRecordTableType
        INSERT into @touchedRecords
            (fac_id, client_or_mpi_id, item_id, description, action, field_detail)
        SELECT fac_id, client_id, payment_transaction_id, changing_desc, action,
            (SELECT * FROM (SELECT CONVERT(VARCHAR(10), invoice_id) AS newValue, 'invoice_id' AS name
                UNION
                SELECT CONVERT(VARCHAR(10), payment_transaction_id) AS newValue, 'payment_transaction_id' AS name
                UNION
                SELECT CONVERT(VARCHAR(20), record_amount) AS newValue, 'amount' AS name) tmp_fld_detail
                FOR XML RAW('field')) AS field_detail
        FROM  @theAuditDetails

        -- CORE-79750: Commenting out auditing as a workaround to the deadlock issue
        -- exec sproc_core_audit_client_set_field_details @touchedRecords
    COMMIT TRAN
END TRY
BEGIN CATCH
 IF @@trancount > 0
  BEGIN
    ROLLBACK TRAN
  END

  SELECT @error_code = @@error, @status_text = ERROR_MESSAGE()
  SELECT @status_code = 1
  GOTO PgmAbend
END CATCH

--program success return
PgmSuccess:
BEGIN
  IF @status_code = 0 AND @debug='Y'
    PRINT 'Successful execution of stored procedure'
END
  
--program failure return
PgmAbend:
BEGIN
  IF @status_code = 1 AND @debug='Y'
  BEGIN
    PRINT 'Error code: '+ CAST(@error_code AS VARCHAR) + '; Error description:  ' +@status_text
  END
END
GO

GRANT EXECUTE ON dbo.sproc_admin_dml_reverseOpenCashPayments TO PUBLIC
GO

SET ANSI_NULLS OFF
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_admin_dml_reverseOpenCashPayments.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_admin_dml_reverseOpenCashPayments.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_apply_payments_to_invoice.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


	-- =================================================================================
-- Jira #:
--
-- Written By:           David Bretzlaff
-- Reviewed By:
--
-- Script Type:          Stored Procedure
-- Target DB Type:       CLIENT
-- Target ENVIRONMENT:   BOTH
--
--
-- Re-Runable:           YES
--
-- Where tested:         172.16.10.119,1689 (Avengers DEV DB)
--						 ORG: agrd
--
-- Staging Recommendations/Warnings:
--
-- Description of Script Function:
-- Distribute the specified cash transaction against charges associated with the specified invoice

-- Steps:
---------------------------------------------------------------
-- 010: populate charges
--		get all charges with the specified invoice_id (exclude adjustment of type writeoff or refund)
---------------------------------------------------------------
-- 020: populate cash
--		get the amount from the specified payment transaction
--		get all amounts from negative charges
---------------------------------------------------------------
-- 030: populate #charge_payment applying cash from #cash table
--		only apply against positive charges (negative charges will be handled later in the process)
---------------------------------------------------------------
-- 040: populate #charge_payment for negative charges
--		take the total negative charges that was applied against positive charges,
--		and distribute it among the negative charges (these will be the entries against the
--		negative charges in the charge_payment table)
---------------------------------------------------------------
-- 050. remaining cash after applying to charges (cash > charges)
--		Pay all remaining cash to the last transaction
---------------------------------------------------------------
-- 060: creating charge payment for all fully paid or partially paid charges:
---------------------------------------------------------------
-- Execution sample:
--Org: abhow

--DECLARE @TableVar ArInvoicePaymentTableType
--INSERT INTO @TableVar
--VALUES
--(1421693,		-1,			null,			null,			null,		25.00),
--(1439286,		-1,			null,			null,			null,		75.00);

--DECLARE @status_code int, @status_text varchar(3000)
--EXEC dbo.sproc_ar_apply_payments_to_invoice 32, 21783806, @TableVar, 'test user', 'N', @status_code, @status_text
-- =================================================================================

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF EXISTS (SELECT 1 FROM sysobjects WHERE id = object_id(N'sproc_ar_apply_payments_to_invoice'))
BEGIN
    DROP PROCEDURE sproc_ar_apply_payments_to_invoice;
END
GO

IF EXISTS (SELECT * FROM sys.types WHERE is_table_type = 1 AND name = 'ArInvoicePaymentTableType')
BEGIN
	DROP TYPE [dbo].[ArInvoicePaymentTableType]
END
GO

CREATE TYPE [dbo].[ArInvoicePaymentTableType] AS TABLE(
		[invoice_id] [int] NOT NULL,
		[payer_id] [int] NOT NULL,
		[claim_effective_from_date] [datetime] NULL,
		[claim_effective_to_date] [datetime] NULL,
		[care_level] [varchar](5) NULL,
		[amount] [decimal](20,2) NULL DEFAULT ((0)),
		[amount_for_auto_writeoff] [decimal](20,2) NULL DEFAULT ((0)),
		[apply_to_year_month] [datetime] NULL
	)

GRANT EXEC ON TYPE::[dbo].[ArInvoicePaymentTableType] TO [public]
GO

CREATE PROCEDURE sproc_ar_apply_payments_to_invoice
	( @facId INT
	, @paymentTransactionId int
	, @InvoicePaymentTable ArInvoicePaymentTableType READONLY
	, @user varchar(60)
	, @appliedPaymentId_CSV varchar(max)
	, @writeOffFlag bit = 0
	, @chargesExcludeId_CSV varchar(max)
	, @zeroTransactionsFlag bit = 0
	, @DebugMe CHAR(1) = 'N'
	, @status_code int  out
	, @status_text varchar(3000) out
    )
AS
DECLARE @error_code INT
       ,@manual BIT = 0
       ,@clientId INT = NULL
       ,@payerId INT = NULL
	   ,@result_message varchar(200) = NULL
       ,@postingDate DATETIME = NULL
       ,@cashAppTransitionDate DATE = NULL

SET NOCOUNT ON

DECLARE @curDate DATETIME = getDate()
DECLARE @step VARCHAR(5) = '0'
DECLARE @totalCash TABLE (invoice_id int not null, payer_id int not null,apply_to_year_month datetime not null, total_cash decimal(20,2) not null)
DECLARE @effectiveDate DATETIME
DECLARE @appliedPaymentId INT
DECLARE @appliedPaymentReservedIdsTmp TABLE (id int identity(1,1), applied_payment_id int)
DECLARE @chargeTransactionsExcludeIdsTmp TABLE (transaction_id int)
DECLARE @blockSize int
DECLARE @excludedTxTotalAmount [decimal](20,2) = 0

--------------------------------------------------------------
-- temp tables
--------------------------------------------------------------


CREATE TABLE #charge
(
  id int identity,
  transaction_id INT NOT NULL,
  client_id INT NOT NULL,
  payer_id INT NOT NULL,
  amount DECIMAL(20, 2) NOT NULL,
  effective_date DATETIME NOT NULL,
  charge_paid_status CHAR(1) NOT NULL DEFAULT 'N',
  invoice_id int not null,
  apply_to_year_month datetime NOT NULL DEFAULT 0
)

CREATE CLUSTERED INDEX #charge__id_IDX on #charge(id)

CREATE TABLE #cashTxDistribution
(
	transaction_id int,
	distribution_tx_id int,
	payer_id int,
	effective_date DATETIME NULL
)

CREATE TABLE #cash
(
  id int identity,
  transaction_id int NOT NULL,
  client_id int NOT NULL,
  payer_id int NOT NULL,
  amount decimal(20, 2) NOT NULL,
  effective_date DATETIME NULL,
  invoice_id int not null,
  apply_to_year_month datetime NOT NULL DEFAULT 0
)

CREATE CLUSTERED INDEX #cash__id_IDX on #cash(id)

CREATE TABLE #charge_payment
(
   invoice_id int not null,
  effective_date datetime not null,
  client_id int not null,
  transaction_id bigint not null,
  payer_id int not null,
  total_cash DECIMAL(20, 2) not null,
  charge_rank int not null,
  cumulative_applied_amount DECIMAL(20, 2) not null,
  cumulative_charge_amount DECIMAL(20, 2) not null,
  charge_amount DECIMAL(20, 2) not null,
  cash_remaining DECIMAL(20, 2) not null,
  cash_applied DECIMAL(20, 2) not null,
  cash_tx_id int not null,
  charge_paid_status char(1) NOT NULL DEFAULT 'N',
  apply_to_year_month datetime NOT NULL DEFAULT 0
)

CREATE TABLE #invoicePayment (
	invoice_id int NOT NULL,
	client_id int NOT NULL,
	payer_id int NOT NULL,
	claim_from_date datetime NULL,
	claim_to_date datetime NULL,
	care_level varchar(5) NULL,
	amount decimal(20,2) NULL DEFAULT (0),
	manual_flag char(1) NOT NULL DEFAULT(0)
	)
-- TODO Test with index and without; CREATE CLUSTERED INDEX #invoice_id__IDX on #invoicePayment(invoice_id)

CREATE TABLE #transactionsPaymentTmp
	(
	  id INT IDENTITY(1,1) NOT NULL,
	  charge_transaction_id INT NOT NULL,
	  payment_transaction_id INT NOT NULL,
	  amount DECIMAL(20,2) NULL DEFAULT (0),
	  amount_for_auto_writeoff [decimal](20,2) NULL
	)

CREATE TABLE #newUnappliedCashTx (
	payer_id int NOT NULL,
	effective_date datetime NULL,
	amount DECIMAL(20,2) NULL DEFAULT (0),
	transaction_id int not null
	)

CREATE TABLE #arUnappliedCashTmp (
	transaction_id INT NOT NULL
	, payer_id int NOT NULL
	, amount DECIMAL(20, 2) NOT NULL
	, effective_date DATETIME NOT NULL
	)

CREATE TABLE #arUnappliedCashPaymentTmp
   (
	payer_id int NOT NULL,
	effective_date datetime NULL,
	transaction_id int not null,
	amount DECIMAL(20, 2) not null,
	total_payment DECIMAL(20, 2) not null,
	charge_rank int not null,
	cumulative_payment_amount DECIMAL(20, 2) not null,
	payment_remaining DECIMAL(20, 2) not null,
	payment_applied DECIMAL(20, 2) not null,
	cash_tx_id int not null
   )

CREATE TABLE #appliedPaymentHistoryTmp (
	ident int identity(1,1), -- addtional field to take increment
	applied_payment_id int NOT NULL,
	fac_id int NOT NULL,
	deleted char(1) NOT NULL,
	created_by varchar(60) NOT NULL,
	created_date datetime NOT NULL,
	revision_by varchar(60) NULL,
	revision_date datetime NULL,
	deleted_by varchar(60) NULL,
	deleted_date datetime NULL,
	transaction_id int NOT NULL,
	client_id int NOT NULL,
	payer_id int NOT NULL,
	current_period_date datetime NULL,
	applied_to_date datetime NOT NULL,
	applied_date datetime NULL,
	distribution_id int NOT NULL,
	amount money NOT NULL,
	OpenClose_Flag char(1) NOT NULL,
	writeoff_amount money NULL,
	include_transaction_payment BIT NULL -- bit value 1 represent payment is against post-transition charges and added in ar_transactions_payment
	)

CREATE TABLE #chargeStatus(
	transaction_id INT NOT NULL, 
	effective_date DATETIME,
	client_id INT NOT NULL,
	payer_id INT NOT NULL,
	invoice_id INT NULL,
	amount DECIMAL(20,2) DEFAULT(0.00),
	paid_status_code CHAR(1),
	apply_to_year_month datetime NOT NULL DEFAULT 0
)

CREATE TABLE #chargeStatus2(
	transaction_id INT NOT NULL, 
	effective_date DATETIME,
	client_id INT NOT NULL,
	payer_id INT NOT NULL,
	invoice_id INT NULL,
	amount DECIMAL(20,2) DEFAULT(0.00),
	paid_status_code CHAR(1),
	care_level varchar(5),
	apply_to_year_month datetime NOT NULL DEFAULT 0
)

CREATE TABLE #partiallyPaidCharge(
	transaction_id INT NOT NULL, 
	amount DECIMAL(20,2) DEFAULT(0.00)
)

CREATE TABLE #unappliedCashAvailable(
	transaction_id INT NOT NULL, 
	payer_id INT NOT NULL,
	amount DECIMAL(20,2) DEFAULT(0.00),
	effective_date DATETIME
)

CREATE TABLE #unappliedCashPaymentMap(
	transaction_id INT NOT NULL, 
	payer_id INT NOT NULL,
	amount DECIMAL(20,2) DEFAULT(0.00),
	effective_date DATETIME,
	OrderPerPayerId INT NOT NULL,
	TotalAvailableCashAmountForPayerId DECIMAL(20,2) DEFAULT(0.00),
	TotalPayment DECIMAL(20,2) DEFAULT(0.00),
	cash_tx_effective_date DATETIME,
	cash_tx_id INT
)

CREATE TABLE #unappliedCashPayment(
	payer_id INT NOT NULL,
	effective_date DATETIME,
	transaction_id INT NOT NULL,
	amount DECIMAL(20,2) DEFAULT(0.00),
	TotalAvailableCashAmountForPayerId DECIMAL(20,2) DEFAULT(0.00),
	total_payment DECIMAL(20,2) DEFAULT(0.00),
	charge_rank INT NOT NULL,
	cumulative_applied_amount DECIMAL(20,2) DEFAULT(0.00),
	cumulative_payment_amount DECIMAL(20,2) DEFAULT(0.00),
	payment_remaining DECIMAL(20,2) DEFAULT(0.00),
	paymentApplied DECIMAL(20,2) DEFAULT(0.00),
	cash_tx_effective_date DATETIME,
	cash_tx_id INT NOT NULL
)

CREATE TABLE #unappliedCashPaymentByChargeRank(
	payer_id int NOT NULL,
	effective_date datetime NULL,
	transaction_id int not null,
	amount DECIMAL(20, 2) not null,
	total_payment DECIMAL(20, 2) not null,
	charge_rank int not null,
	cumulative_payment_amount DECIMAL(20, 2) not null,
	payment_remaining DECIMAL(20, 2) not null,
	payment_applied DECIMAL(20, 2) not null,
	cash_tx_id int not null,
	row_num INT NOT NULL
)

CREATE TABLE #remainingUnappliedCash(
	payer_id INT NOT NULL,
	transaction_id INT NOT NULL, 
	effective_date DATETIME,
	charge_rank INT NOT NULL,
	cr DECIMAL(20,2) DEFAULT(0.00),
	cash_tx_id INT NOT NULL,
	mr INT 
)

CREATE TABLE #chargeCashMap(
	id int,
	transaction_id INT NOT NULL,
	client_id INT NOT NULL,
	payer_id INT NOT NULL,
	amount DECIMAL(20, 2) NOT NULL,
	effective_date DATETIME NOT NULL,
	charge_paid_status CHAR(1) NOT NULL DEFAULT 'N',
	invoice_id int not null,
	OrderPerInvoiceId INT NOT NULL,
	TotalChargeAmountForInvoiceId  DECIMAL(20,2) DEFAULT(0.00),
	TotalCash DECIMAL(20,2) DEFAULT(0.00),
	cash_tx_id INT NOT NULL,
	apply_to_year_month datetime NOT NULL DEFAULT 0
)

CREATE TABLE #chargeCashPayment(
	invoice_id INT NOT NULL,
	effective_date DATETIME,
	client_id INT NOT NULL,
	transaction_id INT NOT NULL,
	payer_id INT NOT NULL,
	TotalChargeAmountForInvoiceId DECIMAL(20,2) DEFAULT(0.00),
	total_cash DECIMAL(20,2) DEFAULT(0.00),
	charge_rank INT NOT NULL,
	cumulative_applied_amount DECIMAL(20,2) DEFAULT(0.00),
	cumulative_charge_amount DECIMAL(20,2) DEFAULT(0.00),
	charge_amount DECIMAL(20,2) DEFAULT(0.00),
	cash_remaining DECIMAL(20,2) DEFAULT(0.00),
	CashApplied DECIMAL(20,2) DEFAULT(0.00),
	cash_tx_id INT NOT NULL,
	apply_to_year_month datetime NOT NULL DEFAULT 0
)

CREATE TABLE #paymentByChargeRank(
	invoice_id int not null,
	effective_date datetime not null,
	client_id int not null,
	transaction_id INT not null,
	payer_id int not null,
	total_cash DECIMAL(20, 2) not null,
	charge_rank int not null,
	cumulative_applied_amount DECIMAL(20, 2) not null,
	cumulative_charge_amount DECIMAL(20, 2) not null,
	charge_amount DECIMAL(20, 2) not null,
	cash_remaining DECIMAL(20, 2) not null,
	cash_applied DECIMAL(20, 2) not null,
	cash_tx_id int not null,
	charge_paid_status char(1) NOT NULL DEFAULT 'N',
	row_num INT,
	apply_to_year_month datetime NOT NULL DEFAULT 0
)

CREATE TABLE #unappliedCashFromPaymentByChargeRank(
	invoice_id INT NOT NULL,
	transaction_id INT NOT NULL,
	client_id INT NOT NULL, 
	payer_id INT NOT NULL,
	charge_rank INT NOT NULL,
	cr DECIMAL(20,2) DEFAULT(0.00),
	cash_tx_id INT NOT NULL,
	mr INT NOT NULL,
	apply_to_year_month datetime NOT NULL DEFAULT 0
)

CREATE TABLE #remainingCashByRank(
	transaction_id INT NOT NULL, 
	effective_date datetime, 
	invoice_id INT NOT NULL, 
	payer_id INT NOT NULL, 
	row_num INT NOT NULL,
	apply_to_year_month datetime NOT NULL DEFAULT 0
)

CREATE TABLE #aphTmp(
	applied_payment_id INT NOT NULL,
	fac_id INT NOT NULL,
	deleted CHAR(1),
	created_by VARCHAR(60),
	created_date DATETIME,
	revision_by VARCHAR(60),
	revision_date DATETIME,
	transaction_id INT NOT NULL,
	client_id INT NOT NULL,
	payer_id INT NOT NULL,
	applied_to_date DATETIME,
	distribution_id INT NOT NULL,
	amount DECIMAL(20,2) DEFAULT(0.00),
	OpenClose_flag CHAR(1),
	writeoff_amount DECIMAL(20,2) NULL,
	include_transaction_payment BIT NULL
)

CREATE TABLE #manualClaims
(
	invoice_id int not null,
	client_id int not null,
	payer_id int not null,
	claim_from_date datetime not null,
	claim_to_date datetime not null
)

	BEGIN TRY

		-- Create table with invoice and payment information
		INSERT INTO #invoicePayment (invoice_id, client_id, claim_from_date, claim_to_date, care_level, amount, manual_flag, payer_id)
		SELECT p.invoice_id, i.client_id, p.claim_effective_from_date, claim_effective_to_date, p.care_level, p.amount * -1, i.manual_flag,
			CASE	WHEN c.claim_responsible_payer_code = 'a' THEN COALESCE(c.pcc_primary_payer_id, i.payer_id)
				WHEN c.claim_responsible_payer_code = 'b' THEN c.pcc_secondary_payer_id
				WHEN c.claim_responsible_payer_code = 'c' THEN c.pcc_tertiary_payer_id
				ELSE i.payer_id END as payer_id
		FROM @InvoicePaymentTable p
		JOIN ar_invoice i on i.invoice_id = p.invoice_id and i.deleted='N'
		LEFT JOIN ar_invoice_claim c on c.invoice_id = i.invoice_id

		INSERT INTO #manualClaims
		SELECT i.invoice_id, i.client_id, i.payer_id, p.claim_effective_from_date, p.claim_effective_to_date
		FROM ar_invoice i
		JOIN @InvoicePaymentTable p ON i.invoice_id = p.invoice_id
		WHERE  i.fac_id = @facId
		AND i.deleted = 'N'
		AND i.manual_flag = 'Y'
		AND i.client_id IS NOT NULL
		AND i.payer_id IS NOT NULL


		select top 1 @clientId = client_id from ar_transactions where transaction_id = @paymentTransactionId

		INSERT INTO #cashTxDistribution
		select transaction_id, distribution_tx_id, payer_id, effective_date
		from ar_transactions
		where fac_id=@facId AND client_id = @clientId AND deleted = 'N'
			AND COALESCE(distribution_tx_id,transaction_id) = @paymentTransactionId

		select top 1 @effectiveDate = effective_date from #cashTxDistribution where transaction_id = @paymentTransactionId

		-- Create cash transaction for unapplied cash if applicable
		DECLARE @recordCount int = 0
		DECLARE @createdUnappliedCashNumber int = 0

		SET  @recordCount = (SELECT COUNT(*) FROM @InvoicePaymentTable WHERE invoice_id=-1)
		IF  @DebugMe = 'Y'
		BEGIN
			SELECT 'unapplied cash distributing records', @recordCount
		END

		IF @recordCount > 0
		BEGIN

			INSERT INTO #newUnappliedCashTx(
				payer_id
				,effective_date
				,amount
				,transaction_id
				)
			SELECT t.payer_id
				, t.effective_date
				, p.amount * -1
				, t.transaction_id
			FROM #cashTxDistribution t
			JOIN @InvoicePaymentTable p ON p.payer_id=t.payer_id
			WHERE p.invoice_id=-1

			IF  @DebugMe = 'Y'
			BEGIN
				SELECT 'unapplied cash transaction', * FROM #newUnappliedCashTx
			END

		END

		-- If coinsurance, do not split. Coinsurance claims are never split in cases of
		-- Medicare or Other payers on a Medicaid claim (ex. NY Medicaid)
		; WITH claimInfo AS (
			SELECT new_care_level =
					(CASE WHEN c.claim_responsible_payer_code IN ('b','c')
							AND i.original_invoice_id IS NOT NULL
							AND i.transaction_flag = 'N'
					THEN NULL ELSE p.care_level END)
					, c.claim_responsible_payer_code, i.transaction_flag, i.original_invoice_id, p.invoice_id
					FROM ar_invoice_claim c
					JOIN ar_invoice i on i.invoice_id = c.invoice_id
					JOIN #invoicePayment p on p.invoice_id = c.invoice_id
		),
		invoicesWithCareLevels AS (
			SELECT invoice_id =
				(CASE WHEN ci.original_invoice_id IS NOT NULL THEN ci.original_invoice_id ELSE ci.invoice_id END)
			FROM claimInfo ci
			WHERE ci.new_care_level IS NOT NULL
		)
		UPDATE i
		SET i.invoice_id = icl.invoice_id
		FROM invoicesWithCareLevels icl
		JOIN #invoicePayment i on i.invoice_id = icl.invoice_id

		---------------------------------------------------------------
		-- 010: populate charges
		-- get all charges with the specified invoice_id
		---------------------------------------------------------------
		SET @step = '10'

        -- Get posting date
        SELECT @postingDate = DATEFROMPARTS(posting_year,posting_month,1)
        FROM ar_configuration
        WHERE fac_id = @facId
        
        -- Get cash application transition date
        SELECT @cashAppTransitionDate = 
               (SELECT CONVERT(DATE, value, 23)
                FROM configuration_parameter
                WHERE fac_id = -1 AND name = 'cash_application_transition_date')

		-- if null then default the date so all charges will be included
		IF @cashAppTransitionDate is null
		BEGIN
			SET @cashAppTransitionDate = '1900-01-01'
		END


		INSERT INTO @chargeTransactionsExcludeIdsTmp(transaction_id) SELECT value FROM pcc__csvToTableOfIntMax(@chargesExcludeId_CSV)

		INSERT INTO #chargeStatus2 (transaction_id, effective_date, client_id, payer_id, invoice_id, amount, paid_status_code, care_level, apply_to_year_month)
			-- Include transactions on claims
			SELECT t.transaction_id, t.effective_date,t.client_id,t.payer_id, t.invoice_id, t.amount, t.paid_status_code, t.care_level, 0 as apply_to_year_month
			FROM ar_transactions t
			LEFT JOIN #invoicePayment i on i.invoice_id = t.invoice_id
			WHERE t.deleted = 'N' AND t.client_id > 0 AND t.payer_id > 0
			AND t.transaction_date is not NULL
			AND t.fac_id = @facId
			AND t.transaction_type <> 'C'
			AND t.invoice_id = i.invoice_id
			union all
			-- Include manual cash from 835 imports
			SELECT distinct t.transaction_id, t.effective_date,t.client_id,t.payer_id, i.invoice_id, t.amount, t.paid_status_code, t.care_level,0 as apply_to_year_month
			FROM ar_transactions t
			JOIN #manualClaims i on i.client_id = t.client_id and i.payer_id = t.payer_id
			WHERE t.deleted = 'N' AND t.client_id > 0 AND t.payer_id > 0
			AND t.transaction_date is not NULL
			AND t.transaction_date < @postingDate
			AND t.fac_id = @facId
			AND t.transaction_type <> 'C'
			AND t.invoice_id = -999
			AND t.effective_date >= i.claim_from_date
			AND t.effective_date <= i.claim_to_date
			union all
			-- Include Balance Forward transactions
			SELECT t.transaction_id, t.effective_date,t.client_id,t.payer_id, t.invoice_id, t.amount, t.paid_status_code, t.care_level, tvp.apply_to_year_month
			FROM ar_transactions t
			LEFT JOIN @InvoicePaymentTable tvp on tvp.payer_id = t.payer_id and tvp.invoice_id = -999
			WHERE t.deleted = 'N' AND t.client_id > 0 AND t.payer_id > 0
			AND t.transaction_date is not NULL
            AND t.transaction_date < @postingDate
			AND t.fac_id = @facId
			AND t.transaction_type <> 'C'
			AND t.invoice_id = -999
			AND t.client_id = @clientId AND t.payer_id = tvp.payer_id
			and t.effective_date >= tvp.apply_to_year_month and t.effective_date < DATEADD(MONTH,1,tvp.apply_to_year_month)
            AND t.effective_date >= @cashAppTransitionDate
			union ALL
			-- Include unbilled transactions
			SELECT t.transaction_id, t.effective_date,t.client_id,t.payer_id, -2 as invoice_id, t.amount, t.paid_status_code, t.care_level, tvp.apply_to_year_month
			FROM ar_transactions t
			LEFT JOIN @InvoicePaymentTable tvp 
				on tvp.payer_id = t.payer_id
			WHERE t.deleted = 'N' AND t.client_id > 0 AND t.payer_id > 0
			AND t.transaction_date is not NULL
            AND t.transaction_date < @postingDate
			AND t.fac_id = @facId
			AND t.transaction_type <> 'C'
			AND t.invoice_id is null
			AND t.client_id = @clientId 
			AND t.payer_id = tvp.payer_id
			and tvp.invoice_id = -2
			and t.effective_date >= tvp.apply_to_year_month and t.effective_date < DATEADD(MONTH,1,tvp.apply_to_year_month)
            AND t.effective_date >= @cashAppTransitionDate
		
		INSERT INTO #chargeStatus (transaction_id, effective_date, client_id, payer_id, invoice_id, amount, paid_status_code, apply_to_year_month)
			SELECT t.transaction_id, t.effective_date,t.client_id,t.payer_id, t.invoice_id, t.amount, t.paid_status_code, t.apply_to_year_month
			FROM #chargeStatus2 t
			LEFT JOIN #invoicePayment i on i.invoice_id = t.invoice_id
			LEFT JOIN @chargeTransactionsExcludeIdsTmp ce on ce.transaction_id = t.transaction_id
			WHERE (i.care_level IS NULL OR t.care_level=i.care_level)
			AND ce.transaction_id IS NULL

		INSERT INTO #partiallyPaidCharge (transaction_id, amount)
			SELECT p.charge_transaction_id as transaction_id, SUM(COALESCE(p.amount,0)) as amount
			FROM ar_transactions_payment p
			JOIN #chargeStatus c ON c.transaction_id = p.charge_transaction_id
			WHERE ISNULL(c.paid_status_code,'N') <> 'F'
			GROUP BY charge_transaction_id
			HAVING SUM(COALESCE(p.amount,0)) <> 0

		INSERT INTO #charge
		(
			transaction_id, client_id, payer_id, amount, effective_date, invoice_id, charge_paid_status, apply_to_year_month
		)
		SELECT c.transaction_id,c.client_id,c.payer_id,
			CASE
			WHEN c.paid_status_code = 'F' THEN 0.0
			ELSE isnull(c.amount,0) + isnull(p.amount,0) 
			END AS amount,
			c.effective_date,
			c.invoice_id,
			isnull(c.paid_status_code,'N'),
			c.apply_to_year_month
		FROM #chargeStatus c
		LEFT JOIN #partiallyPaidCharge p ON c.transaction_id = p.transaction_id
		ORDER by effective_date, transaction_id

		IF  @DebugMe = 'Y'
		BEGIN
			select '#charge', * from #charge
		END

		IF EXISTS(select 1 from #invoicePayment WHERE invoice_id NOT IN (SELECT DISTINCT(invoice_id) FROM #charge ))
		OR EXISTS(SELECT 1 FROM #newUnappliedCashTx WHERE amount<0)
		OR EXISTS(SELECT 1 from @InvoicePaymentTable t 
				JOIN #cashTxDistribution d ON t.payer_id=d.payer_id
				LEFT JOIN #charge c ON c.invoice_id = t.invoice_id AND t.apply_to_year_month = c.apply_to_year_month AND t.payer_id = c.payer_id
				WHERE t.invoice_id = -2 AND c.invoice_id IS NULL)
		OR EXISTS(SELECT 1 from @InvoicePaymentTable t
				JOIN #cashTxDistribution d ON t.payer_id=d.payer_id
				LEFT JOIN #charge c ON c.invoice_id = t.invoice_id AND t.apply_to_year_month = c.apply_to_year_month AND t.payer_id = c.payer_id
				WHERE t.invoice_id = -999 AND c.invoice_id IS NULL AND t.apply_to_year_month IS NOT NULL) -- exclude -999 charges from manual claims

		BEGIN
			IF  @DebugMe = 'Y'
			BEGIN
				select 'no charges found, applying to unapplied cash'
			END
			-- If there are no charges to be paid, then put it all towards unapplied cash

			DECLARE @unappliedCashFromNoChargesFound TABLE
			(
			    transaction_id INT
			    ,payer_id INT
			    ,amount MONEY
			    ,effective_date DATETIME
			)

			-- Create unapplied cash records for Invoices where there are no valid charges to pay
			INSERT INTO @unappliedCashFromNoChargesFound
			    ([transaction_id]
			    ,[payer_id]
			    ,[amount]
			    ,[effective_date]
			    )
			SELECT t.transaction_id, p.payer_id, p.amount, t.effective_date
				FROM #invoicePayment p
				JOIN #cashTxDistribution t ON t.payer_id=p.payer_id
				WHERE invoice_id NOT IN (SELECT DISTINCT(invoice_id) FROM #charge )
                
			-- Create unapplied cash record for Unbilled months where there are no valid charges to pay
			INSERT INTO @unappliedCashFromNoChargesFound
			    ([transaction_id]
			    ,[payer_id]
			    ,[amount]
			    ,[effective_date]
			    )
			SELECT t.transaction_id, p.payer_id, -1 * p.amount, t.effective_date
			FROM @InvoicePaymentTable p
			JOIN #cashTxDistribution t ON t.payer_id=p.payer_id
			LEFT JOIN #charge c ON c.invoice_id = p.invoice_id AND p.apply_to_year_month = c.apply_to_year_month AND p.payer_id = c.payer_id
			WHERE p.invoice_id = -2 AND c.invoice_id IS NULL

			-- Create unapplied cash record for Marked As Billed months where there are no valid charges to pay
			INSERT INTO @unappliedCashFromNoChargesFound
			    ([transaction_id]
			    ,[payer_id]
			    ,[amount]
			    ,[effective_date]
			    )
			SELECT t.transaction_id, p.payer_id, -1 * p.amount, t.effective_date
			FROM @InvoicePaymentTable p
			JOIN #cashTxDistribution t ON t.payer_id=p.payer_id
			LEFT JOIN #charge c ON c.invoice_id = p.invoice_id AND p.apply_to_year_month = c.apply_to_year_month AND p.payer_id = c.payer_id
			WHERE p.invoice_id = -999 AND c.invoice_id IS NULL AND p.apply_to_year_month IS NOT NULL

			;WITH x AS 
			(
			    SELECT transaction_id, payer_id, amount, effective_date
			    FROM #newUnappliedCashTx
			    WHERE amount<0
			    UNION ALL
			    SELECT transaction_id, payer_id, amount, effective_date
			    FROM @unappliedCashFromNoChargesFound
			)
			INSERT INTO #arUnappliedCashTmp
			    ([transaction_id]
			    ,[payer_id]
			    ,[amount]
			    ,[effective_date]
			    )
			SELECT transaction_id, payer_id, SUM(amount), effective_date
			FROM x
			GROUP BY transaction_id, payer_id, effective_date

			IF EXISTS(SELECT 1 FROM @unappliedCashFromNoChargesFound)
			BEGIN
			    SELECT @result_message = '1' --'Payment processed, however there were no payable charges found.'
			END
		END

		IF EXISTS(SELECT 1 FROM #charge) OR EXISTS(SELECT 1 FROM #newUnappliedCashTx WHERE amount>0)
		BEGIN

			---------------------------------------------------------------
			-- 020: populate cash
			-- get the amount from the specified payment transaction
			-- get all amounts from negative charges
			---------------------------------------------------------------
			SET @step = '20'

			-- Create unapplied cash entries for new unapplied cash transactions
			IF EXISTS(SELECT 1 FROM #newUnappliedCashTx WHERE amount>0)
			BEGIN
				INSERT INTO #unappliedCashAvailable (transaction_id, payer_id, amount, effective_date)
					SELECT max(t.transaction_id) as transaction_id
						, t.payer_id
						, (sum(t.amount)*-1) amount
						, t.effective_year_month as effective_date
					FROM dbo.view_ar_unapplied_cash t
					JOIN #newUnappliedCashTx p ON t.payer_id = p.payer_id
					WHERE t.fac_id = @facId AND t.client_id=@clientId AND t.posting_date IS NOT NULL AND p.amount>0
					group by t.payer_id, t.effective_year_month 

				INSERT INTO #unappliedCashPaymentMap 
					(transaction_id, payer_id, amount, effective_date, OrderPerPayerId, 
						TotalAvailableCashAmountForPayerId, TotalPayment, cash_tx_effective_date, cash_tx_id)
					SELECT  a.transaction_id, a.payer_id, a.amount, a.effective_date,
							ROW_NUMBER() OVER
								(PARTITION BY a.payer_id ORDER BY a.effective_date asc)
								OrderPerPayerId,
							SUM(a.amount) OVER
								(PARTITION BY a.payer_id)
								TotalAvailableCashAmountForPayerId
							,b.amount TotalPayment
							,b.effective_date cash_tx_effective_date
							,b.transaction_id cash_tx_id
					FROM #unappliedCashAvailable a
					JOIN #newUnappliedCashTx b ON b.payer_id = a.payer_id
					WHERE a.amount>0 AND b.amount>0

				INSERT INTO #unappliedCashPayment 
					(payer_id, effective_date, transaction_id, amount, TotalAvailableCashAmountForPayerId, total_payment, charge_rank, 
						cumulative_applied_amount, cumulative_payment_amount, payment_remaining, paymentApplied, cash_tx_effective_date, cash_tx_id)
					SELECT
						x.payer_id,
						min(x.effective_date) as effective_date,
						min(y.transaction_id) as transaction_id,
						min(y.amount) as amount,
						y.TotalAvailableCashAmountForPayerId,
						y.TotalPayment as total_payment,
						y.OrderPerPayerId as charge_rank,
						CASE WHEN y.TotalPayment < SUM(x.amount) THEN y.TotalPayment
							ELSE SUM(x.amount)
							END cumulative_applied_amount,
							SUM(x.amount) as cumulative_payment_amount,
						(y.TotalPayment - SUM(x.amount)) as payment_remaining,
						MIN(y.amount) -
						CASE WHEN y.TotalPayment - SUM(x.amount) < 0 THEN
							   ABS(y.TotalPayment - SUM(x.amount))
							ELSE 0
							END paymentApplied,
						min(x.cash_tx_effective_date) cash_tx_effective_date,
						min(x.cash_tx_id) as cash_tx_id
					FROM    #unappliedCashPaymentMap y
					  JOIN    #unappliedCashPaymentMap x ON x.payer_id = y.payer_id
							AND x.OrderPerPayerId <= y.OrderPerPayerId
					GROUP   BY
						x.payer_id,
						y.OrderPerPayerId,
						y.TotalAvailableCashAmountForPayerId,
						y.TotalPayment

				INSERT INTO #arUnappliedCashPaymentTmp
				   (
					payer_id,
					effective_date,
					transaction_id,
					amount,
					total_payment,
					charge_rank,
					cumulative_payment_amount,
					payment_remaining,
					payment_applied,
					cash_tx_id
				   )
				SELECT cp.payer_id
					, ca.effective_date
					, cp.transaction_id
					, cp.amount
					, cp.total_payment
					, cp.charge_rank
					, cp.cumulative_payment_amount
					, cp.payment_remaining
					, CASE WHEN cp.paymentApplied < 0 THEN 0
						ELSE cp.paymentApplied
						END AS payment_applied
					, cp.cash_tx_id
					FROM #unappliedCashPayment cp
					JOIN #unappliedCashAvailable ca ON ca.transaction_id=cp.transaction_id AND ca.amount=cp.amount

				IF  @DebugMe = 'Y'
				BEGIN
					SELECT 'unapplied cash #arUnappliedCashPaymentTmp', * FROM #arUnappliedCashPaymentTmp
				END

				INSERT INTO #arUnappliedCashTmp
				   ([transaction_id]
				   ,[payer_id]
				   ,[amount]
				   ,[effective_date]
				   )
				SELECT cash_tx_id, payer_id, payment_applied, effective_date
					FROM #arUnappliedCashPaymentTmp
					WHERE payment_applied>0

				IF  @DebugMe = 'Y'
				BEGIN
					SELECT 'unapplied cash transaction temp table', * FROM #arUnappliedCashTmp
				END

				INSERT INTO #unappliedCashPaymentByChargeRank 
					(payer_id, effective_date, transaction_id, amount, total_payment, charge_rank, 
						cumulative_payment_amount, payment_remaining, payment_applied, cash_tx_id, row_num)
					SELECT payer_id, effective_date, transaction_id, amount, total_payment, charge_rank, 
						cumulative_payment_amount, payment_remaining, payment_applied, cash_tx_id, 
						ROW_NUMBER() over (partition by payer_id order by charge_rank desc,payment_remaining desc) AS row_num
					FROM #arUnappliedCashPaymentTmp
				
				INSERT INTO #remainingUnappliedCash (payer_id, transaction_id, effective_date, charge_rank, cr, cash_tx_id, mr)
					SELECT payer_id, max(transaction_id) as transaction_id, effective_date,
						charge_rank, sum(payment_remaining) as cr, min(cash_tx_id) as cash_tx_id, min(row_num) as mr
						from #unappliedCashPaymentByChargeRank
						WHERE payment_remaining > 0
							and payment_applied > 0
					group by payer_id, charge_rank, effective_date

				INSERT INTO #arUnappliedCashTmp
				(
				   [transaction_id]
				   ,[payer_id]
				   ,[amount]
				   ,[effective_date]
				)
					SELECT cash_tx_id, payer_id, cr, @effectiveDate
					FROM #remainingUnappliedCash  
					WHERE mr = 1

				-- insert only if taking money out and there is no money to take out
				INSERT INTO #arUnappliedCashTmp
				(
				   [transaction_id]
				   ,[payer_id]
				   ,[amount]
				   ,[effective_date]
				)
					SELECT p.transaction_id
					, p.payer_id
					, p.amount
					, p.effective_date
					FROM #newUnappliedCashTx p
					LEFT JOIN #unappliedCashPaymentMap t 
					   ON t.payer_id = p.payer_id 
					   and t.cash_tx_id = p.transaction_id
					WHERE t.payer_id IS NULL AND p.amount > 0
	
				IF  @DebugMe = 'Y'
				BEGIN
					SELECT 'unapplied cash transaction-with remaining', * FROM #arUnappliedCashTmp
				END
			END

			INSERT INTO #cash
			(
				transaction_id, client_id, payer_id, amount, invoice_id, effective_date
			)
			select dist.transaction_id, i.client_id, i.payer_id, i.amount * -1, i.invoice_id, @effectiveDate
			from #invoicePayment i
			join #cashTxDistribution dist on dist.payer_id = i.payer_id

			IF  @DebugMe = 'Y'
			BEGIN
				select '#cash after adding payment transaction', * from #cash
			END

			INSERT INTO #cash
			(
				transaction_id, client_id, payer_id, amount, invoice_id, effective_date, apply_to_year_month
			)
			select dist.transaction_id, @clientId, i.payer_id, i.amount, i.invoice_id, @effectiveDate, apply_to_year_month
			from @InvoicePaymentTable i
			join #cashTxDistribution dist on dist.payer_id = i.payer_id
			where i.invoice_id = -999

			IF  @DebugMe = 'Y'
			BEGIN
				select '#cash after adding balance forwards', * from #cash
			END

			INSERT INTO #cash
			(
				transaction_id, client_id, payer_id, amount, invoice_id, effective_date, apply_to_year_month
			)
			select dist.transaction_id, @clientId, i.payer_id, i.amount, i.invoice_id, @effectiveDate, apply_to_year_month
			from @InvoicePaymentTable i
			join #cashTxDistribution dist on dist.payer_id = i.payer_id
			where i.invoice_id = -2

			IF  @DebugMe = 'Y'
			BEGIN
				select '#cash after adding unbilled', * from #cash
			END

			INSERT INTO #cash
			(
				transaction_id, client_id, payer_id, amount, effective_date, invoice_id, apply_to_year_month
			)
			SELECT dist.transaction_id, client_id, c.payer_id, amount * -1, c.effective_date, invoice_id, c.apply_to_year_month
			FROM #charge c
			JOIN #cashTxDistribution dist on dist.payer_id = c.payer_id
			WHERE amount < 0

			IF  @DebugMe = 'Y'
			BEGIN
				select '#cash after adding negative charges', * from #cash
			END

			---------------------------------------------------------------
			-- 030: populate #charge_payment for negative charges
			-- take the total negative charges that is to be applied against positive charges,
			-- and distribute it among the negative charges (these will be the entries against the
			-- negative charges in the charge_payment table)
			---------------------------------------------------------------
			SET @step = '030'

			-- insert payments for negative charges
			INSERT INTO #charge_payment (
			  invoice_id,
			  effective_date,
			  client_id,
			  transaction_id,
			  payer_id,
			  total_cash,
			  charge_rank,
			  cumulative_applied_amount,
			  cumulative_charge_amount,
			  charge_amount,
			  cash_remaining,
			  cash_applied,
			  cash_tx_id,
			  charge_paid_status
			)
			SELECT invoice_id,
					c.effective_date,
					client_id,
					c.transaction_id,
					c.payer_id,
					amount ,
					1,
					amount,
					amount,
					amount,
					0,
					amount,
					dist.transaction_id,
					'F'
			FROM #charge c
			JOIN #cashTxDistribution dist on dist.payer_id = c.payer_id
			WHERE amount < 0

			IF  @DebugMe = 'Y'
			BEGIN
				select '#charge_payment after negative charges',* from #charge_payment
			END

			INSERT INTO @totalCash(invoice_id, payer_id,apply_to_year_month, total_cash)
			SELECT invoice_id, payer_id,apply_to_year_month, sum(amount) as total_cash
			FROM #cash
			GROUP BY invoice_id, payer_id, apply_to_year_month

			IF  @DebugMe = 'Y'
			BEGIN
				select 'total cash per invoice per payer per apply month', * from @totalCash
			END

			-----------------------------
			-- 034: populate #charge_payment applying cash from #cash table
			-- only apply against positive charges (negative charges were handled earlier in the process)
			---------------------------------------------------------------
			SET @step = '040'

				INSERT INTO #chargeCashMap 
					(id, transaction_id, client_id, payer_id, amount, effective_date, charge_paid_status, invoice_id, 
						OrderPerInvoiceId, TotalChargeAmountForInvoiceId, TotalCash, cash_tx_id, apply_to_year_month)
				SELECT  a.id, a.transaction_id, a.client_id, a.payer_id, a.amount, a.effective_date, a.charge_paid_status, a.invoice_id,
						ROW_NUMBER() OVER
							(PARTITION BY a.invoice_id, a.payer_id, a.apply_to_year_month ORDER BY a.effective_date asc, a.transaction_id asc)
							OrderPerInvoiceId,
						SUM(a.amount) OVER
							(PARTITION BY a.invoice_id, a.payer_id, a.apply_to_year_month)
							TotalChargeAmountForInvoiceId,
						isnull(b.amount,0) TotalCash,
						b.transaction_id as cash_tx_id,
						isnull(a.apply_to_year_month,-1) as apply_to_year_month
				FROM    #charge a
				JOIN    (	select min(transaction_id) as transaction_id, min(client_id) as client_id, min(payer_id) as payer_id, sum(amount) as amount, invoice_id, apply_to_year_month
							from #cash
							group by invoice_id, payer_id, apply_to_year_month)
						b ON
						b.invoice_id = a.invoice_id 
							and b.payer_id = a.payer_id
							and b.apply_to_year_month = a.apply_to_year_month
				JOIN @totalCash tc ON
						tc.invoice_id = a.invoice_id
						 and tc.payer_id = a.payer_id
						 and tc.apply_to_year_month = a.apply_to_year_month
				WHERE tc.total_cash > 0	-- only apply when there is cash to apply
				AND a.amount > 0	-- only apply against positive charges

				INSERT INTO #chargeCashPayment 
					(invoice_id, effective_date, client_id, transaction_id, payer_id, TotalChargeAmountForInvoiceId, total_cash,	
						charge_rank, cumulative_applied_amount, cumulative_charge_amount, charge_amount, cash_remaining, CashApplied, cash_tx_id, apply_to_year_month)
				SELECT
						x.invoice_id,
						min(x.effective_date) as effective_date,
						min(x.client_id) as client_id,
						min(y.transaction_id) as transaction_id,
						x.payer_id,
						y.TotalChargeAmountForInvoiceId,
						y.TotalCash as total_cash,
						y.OrderPerInvoiceId as charge_rank,
						CASE WHEN y.TotalCash < SUM(x.amount) THEN y.TotalCash
							ELSE SUM(x.amount)
							END cumulative_applied_amount,
							SUM(x.amount) as cumulative_charge_amount,
						MIN(y.amount) as charge_amount,
						(y.TotalCash - SUM(x.amount)) as cash_remaining,
						MIN(y.amount) -
						CASE WHEN y.TotalCash - SUM(x.amount) < 0 THEN
							   ABS(y.TotalCash - SUM(x.amount))
							ELSE 0
							END CashApplied,
						min(x.cash_tx_id) as cash_tx_id,
						x.apply_to_year_month
				FROM    #chargeCashMap y
				JOIN	#chargeCashMap x
					ON  x.invoice_id = y.invoice_id
					AND x.payer_id = y.payer_id
					AND x.apply_to_year_month = y.apply_to_year_month
						AND x.OrderPerInvoiceId <= y.OrderPerInvoiceId
				GROUP   BY
						x.invoice_id,
						x.payer_id,
						x.apply_to_year_month,
						y.OrderPerInvoiceId,
						y.TotalChargeAmountForInvoiceId,
						y.TotalCash

				INSERT INTO #charge_payment (
				  invoice_id,
				  effective_date,
				  client_id,
				  transaction_id,
				  payer_id,
				  total_cash,
				  charge_rank,
				  cumulative_applied_amount,
				  cumulative_charge_amount,
				  charge_amount,
				  cash_remaining,
				  cash_applied,
				  cash_tx_id,
				  charge_paid_status,
				  apply_to_year_month
				)
				SELECT  invoice_id,
				  effective_date,
				  client_id,
				  transaction_id,
				  payer_id,
				  total_cash,
				  charge_rank,
				  cumulative_applied_amount,
				  cumulative_charge_amount,
				  charge_amount,
				  cash_remaining,
				  CASE WHEN CashApplied < 0 THEN 0
						ELSE CashApplied
						END AS CashApplied,
				  cash_tx_id,
				  CASE WHEN CashApplied >= charge_amount THEN 'F'
					   WHEN CashApplied > 0 AND CashApplied < charge_amount THEN 'P'
						ELSE 'N'
						END AS charge_paid_status,
					apply_to_year_month
				FROM #chargeCashPayment

				-- To indicate that this invoice/payer has been applied
				-- so that it is not picked up when applying remaining cash
				UPDATE tc
				SET total_cash = 0
				FROM @totalCash tc
				JOIN #charge_payment c 
					on c.invoice_id = tc.invoice_id 
					and c.payer_id = tc.payer_id
					and c.apply_to_year_month =tc.apply_to_year_month
				WHERE tc.total_cash > 0 and c.charge_amount > 0

				IF  @DebugMe = 'Y'
				BEGIN
					select '#charge_payment after cash',* from #charge_payment
					select '#charge_payment rank for cash remaining', * , ROW_NUMBER() over (partition by invoice_id, payer_id, apply_to_year_month order by charge_rank desc, cash_remaining desc) AS row_num
				FROM #charge_payment
				END

				SET @step = '050'
				---------------------------------------------------------------
				-- 050. remaining cash after applying to charges (cash > charges)
				-- Pay all remaining cash to the last positive charge transaction
				---------------------------------------------------------------

				INSERT INTO #paymentByChargeRank 
					(invoice_id,effective_date, client_id, transaction_id, payer_id, total_cash, charge_rank, cumulative_applied_amount,
						cumulative_charge_amount, charge_amount, cash_remaining, cash_applied, cash_tx_id, charge_paid_status, row_num, apply_to_year_month)
				SELECT invoice_id,effective_date, client_id, transaction_id, payer_id, total_cash, charge_rank, cumulative_applied_amount,
						cumulative_charge_amount, charge_amount, cash_remaining, cash_applied, cash_tx_id, charge_paid_status, 
						ROW_NUMBER() over (partition by invoice_id, payer_id, apply_to_year_month order by charge_rank desc,cash_remaining desc) AS row_num,
						apply_to_year_month
				FROM #charge_payment

				INSERT INTO #unappliedCashFromPaymentByChargeRank 
					(invoice_id, transaction_id, client_id, payer_id, charge_rank, cr, cash_tx_id, mr, apply_to_year_month)
					SELECT invoice_id, max(transaction_id) as transaction_id, min(client_id) as client_id, payer_id,
							charge_rank, sum(cash_remaining) as cr, min(cash_tx_id) as cash_tx_id, min(row_num) as mr, apply_to_year_month
					FROM #paymentByChargeRank
					WHERE cash_remaining > 0
						and charge_paid_status = 'F'
						and cash_applied > 0
						and charge_amount <> 0
					GROUP BY invoice_id, payer_id, apply_to_year_month, charge_rank

				INSERT INTO #transactionsPaymentTmp
				(
				  charge_transaction_id,
				  payment_transaction_id,
				  amount
				)
				SELECT transaction_id, cash_tx_id, cr * -1
				FROM #unappliedCashFromPaymentByChargeRank where mr = 1

				SET @step = '055'
				---------------------------------------------------------------
				-- 055. remaining cash
				-- either no positive charges to apply against,
				-- or applying negative cash.
				-- In either case, apply to the most recent charge
				--
				-- If no postive charges, this will either be a fully paid charge (amount = 0), or a negative charge
				-- If applying negative cash, the charge could be positive, fully paid, or negative
				---------------------------------------------------------------
				-- Create payment of total cash remaining for most recent charge for each invoice/payer
				INSERT INTO #remainingCashByRank (transaction_id, effective_date, invoice_id, payer_id, row_num, apply_to_year_month)
				SELECT transaction_id, effective_date, invoice_id, payer_id, ROW_NUMBER() over (partition by invoice_id, payer_id, apply_to_year_month order by ch.effective_date desc) AS row_num,
				apply_to_year_month
				FROM #charge ch
				group by invoice_id, payer_id, apply_to_year_month, transaction_id, effective_date

				INSERT INTO #transactionsPaymentTmp
				(
					charge_transaction_id,
					payment_transaction_id,
					amount
				)
				select c.transaction_id, dist.transaction_id, tc.total_cash * -1
				from #remainingCashByRank c
				JOIN @totalCash tc 
					on tc.invoice_id = c.invoice_id 
						and tc.payer_id = c.payer_id
						and tc.apply_to_year_month = c.apply_to_year_month
				JOIN #cashTxDistribution dist on dist.payer_id = c.payer_id
				WHERE tc.total_cash <> 0
				and c.row_num = 1

			---------------------------------------------------------------
			-- 060: creating charge payment for all fully paid or partially paid charges:
			---------------------------------------------------------------
			SET @step = '060'

			INSERT INTO #transactionsPaymentTmp
			(
			  charge_transaction_id,
			  payment_transaction_id,
			  amount
			)
			SELECT c.transaction_id, dist.transaction_id, cash_applied * -1
			FROM #charge_payment c
			JOIN #cashTxDistribution dist on dist.payer_id = c.payer_id
			WHERE charge_paid_status <> 'N'

		END

		---------------------------------------------------------------
		-- 070: insert applied payment history records:
		---------------------------------------------------------------

		declare @appliedPaymentReserveIdsExists bit = 0

		INSERT INTO @appliedPaymentReservedIdsTmp(applied_payment_id) SELECT value FROM pcc__csvToTableOfIntMax(@appliedPaymentId_CSV)

		IF EXISTS (SELECT TOP 1 1 FROM @appliedPaymentReservedIdsTmp WHERE applied_payment_id <> '')
		BEGIN
			SET @appliedPaymentReserveIdsExists = 1
		END
		
		/*
			To determine if this payment is for paying invoices with an auto writeoff amount, you need to check @zeroTransactionsFlag and appliedPaymentReserveIdsExists
			If @zeroTransactionsFlag =1 and @appliedPaymentReserveIdsExists =1 then this payment is for invoices with auto writeoff.
			In which case, we will need to insert records in to ar_applied_payment_history
		*/
		IF (@zeroTransactionsFlag = 0 or @appliedPaymentReserveIdsExists = 1) 
			AND (EXISTS (SELECT TOP 1 1 FROM #transactionsPaymentTmp) OR EXISTS (SELECT TOP 1 1 FROM #arUnappliedCashTmp) OR EXISTS (SELECT TOP 1 1 FROM @InvoicePaymentTable WHERE invoice_id = -3))
		BEGIN
			SET @step = '070'
			
			if(@DebugMe='Y') begin Print 'Create applied payment history' + ' ' + convert(varchar(26),getdate(),109) end
			
			SELECT @excludedTxTotalAmount = SUM(ISNULL(p.amount * -1, 0))
			FROM @chargeTransactionsExcludeIdsTmp ex
			JOIN ar_transactions_payment p on p.charge_transaction_id = ex.transaction_id
			JOIN #cashTxDistribution c on c.transaction_id = p.payment_transaction_id
			
			INSERT INTO #aphTmp 
				(applied_payment_id,fac_id,deleted,created_by,created_date,revision_by,revision_date,transaction_id,
					client_id,payer_id,applied_to_date,distribution_id,amount,OpenClose_flag,writeoff_amount,include_transaction_payment) 
				SELECT 
				0,cash.fac_id,'N',@user,getDate(),@user,getDate(),cash.transaction_id,cash.client_id,cash.payer_id,
				(DATEFROMPARTS(YEAR(charge.effective_date),MONTH(charge.effective_date),1)),0,map.amount,'O',0,1
				FROM #transactionsPaymentTmp map
				JOIN ar_transactions charge on charge.transaction_id = map.charge_transaction_id and charge.fac_id = @facId
				JOIN ar_transactions cash on cash.transaction_id = map.payment_transaction_id and cash.fac_id = @facId
				WHERE cash.distribution_tx_id=@paymentTransactionId OR cash.transaction_id=@paymentTransactionId
				UNION ALL
				-- setting bit value to 1 assuming it's Post-transition only. Pre-transition unapplied cash is not considered in this stored procedure
				SELECT 0,@facId,'N',@user,getDate(),@user,getDate(),uc.transaction_id,@clientId,t.payer_id,
				(DATEFROMPARTS(YEAR(uc.effective_date),MONTH(uc.effective_date),1)),0,uc.amount,'O',0,1
				FROM #arUnappliedCashTmp uc
				JOIN ar_transactions t ON t.transaction_id = uc.transaction_id and t.fac_id = @facId
				UNION ALL
				SELECT 
				0,aph.fac_id,'N',@user,getDate(),@user,getDate(),aph.transaction_id,aph.client_id,aph.payer_id,
				aph.applied_to_date,0,aph.amount * -1,'O',0,1  
				FROM @chargeTransactionsExcludeIdsTmp ex
				JOIN ar_transactions_payment p on p.charge_transaction_id = ex.transaction_id
				JOIN ar_applied_payment_history aph on aph.transaction_id = p.payment_transaction_id and aph.fac_id = @facId
				JOIN #cashTxDistribution c on c.transaction_id = aph.transaction_id
				GROUP BY aph.fac_id, aph.client_id, aph.payer_id, aph.transaction_id, aph.applied_to_date, aph.amount
                UNION ALL
                SELECT 
		        0,@facId,'N',@user,getDate(),@user,getDate(),c.transaction_id,@clientId,tvp.payer_id,
		        (DATEFROMPARTS(YEAR(tvp.apply_to_year_month),MONTH(tvp.apply_to_year_month),1)),0,tvp.amount * -1,'O',tvp.amount_for_auto_writeoff,0
		        FROM @InvoicePaymentTable tvp
		        JOIN #cashTxDistribution c on c.payer_id = tvp.payer_id
                WHERE tvp.invoice_id = -3

			INSERT INTO #appliedPaymentHistoryTmp
			(applied_payment_id,fac_id,deleted,created_by,created_date,revision_by,revision_date,transaction_id,client_id,payer_id,applied_to_date,distribution_id,amount,OpenClose_flag,writeoff_amount, include_transaction_payment) 
			SELECT 
			applied_payment_id,fac_id,deleted,created_by,created_date,revision_by,revision_date,transaction_id,client_id,payer_id,applied_to_date,distribution_id,sum(amount)*-1,OpenClose_flag,writeoff_amount,include_transaction_payment
			FROM #aphTmp a
			GROUP BY applied_payment_id,fac_id,deleted,created_by,created_date,revision_by,revision_date,transaction_id,client_id,payer_id,applied_to_date,include_transaction_payment,distribution_id,OpenClose_flag,writeoff_amount
			
			
			IF (@appliedPaymentReserveIdsExists = 1)
			BEGIN
				-- Called by 835 Imports
				IF (SELECT COUNT(*) from #appliedPaymentHistoryTmp) > (SELECT COUNT(*) FROM @appliedPaymentReservedIdsTmp) 
				BEGIN
					SELECT @result_message = 'The number of applied payments records to create is greater than the number of blocks reserved.'
					RAISERROR (@result_message, 16, 1)
				END

				SET @appliedPaymentId = (SELECT MIN(applied_payment_id) FROM @appliedPaymentReservedIdsTmp)

				declare @distributionId int = @appliedPaymentId

				IF (@zeroTransactionsFlag = 1) -- when adding autowriteoff payments use the existing distribution_id
				BEGIN
					select @distributionId = min(distribution_id)
					from ar_applied_payment_history 
					where transaction_id = @paymentTransactionId
						and fac_id = @facId
						and deleted = 'N'
				END

				update aph
				set applied_payment_id = x.applied_payment_id, distribution_id = @distributionId
				from #appliedPaymentHistoryTmp aph
				join @appliedPaymentReservedIdsTmp x on x.id = aph.ident
			END
			ELSE BEGIN
				-- Called by applying cash via UI
				select @blockSize = count(*) from #appliedPaymentHistoryTmp
				execute get_next_primary_key 'ar_applied_payment_history', 'applied_payment_id', @appliedPaymentId OUTPUT,@blockSize

				update aph
				set applied_payment_id = @appliedPaymentId + aph.ident - 1, distribution_id = @appliedPaymentId
				from #appliedPaymentHistoryTmp aph
			END
			
			IF ((SELECT SUM(amount) - ISNULL(@excludedTxTotalAmount,0) from #appliedPaymentHistoryTmp) > (SELECT SUM(amount) from @InvoicePaymentTable))
			BEGIN
				SELECT @result_message = 'Applied total exceeds available payment.'
				RAISERROR (@result_message, 16, 1)
			END
			
			if(@DebugMe='Y') 
			begin
				select '#appliedPaymentHistoryTmp', * from #appliedPaymentHistoryTmp
			end

		END

		IF @zeroTransactionsFlag = 0 
		  AND EXISTS(SELECT transaction_id FROM ar_transactions WHERE fac_id=@facId AND transaction_id=@paymentTransactionId AND (transaction_date IS NOT NULL OR deleted='Y'))
		BEGIN
			SELECT @result_message = '2' --Payment was not processed, cash transaction was deleted or posted.
		END
		ELSE
		BEGIN
			BEGIN TRAN
				declare @theAuditDetails table 
				(
					invoice_id int, 
					apply_to_year_month datetime,
					payment_transaction_id int, 
					changing_desc varchar(max), 
					action varchar(10), 
					record_amount decimal(20,2)
				)

				-- Delete existing payments before applying the new ones
				-- except payments previously created (e.g. mcd deductibles)
				IF (@zeroTransactionsFlag = 0)
				BEGIN
					DELETE p
					FROM ar_transactions_payment p
					JOIN ar_transactions t ON t.transaction_id = p.payment_transaction_id
					LEFT JOIN @chargeTransactionsExcludeIdsTmp ex on p.charge_transaction_id = ex.transaction_id
					WHERE t.distribution_tx_id = @paymentTransactionId
						AND ex.transaction_id IS NULL
					
					DELETE u
					FROM ar_unapplied_cash u
					JOIN #cashTxDistribution t ON t.transaction_id = u.transaction_id
					WHERE t.distribution_tx_id = @paymentTransactionId AND u.posting_date IS NULL
				END
				
				INSERT INTO [ar_unapplied_cash]
					   ([transaction_id]
					   ,[amount]
					   ,[effective_date]
					   ,[created_by]
					   ,[created_date]
					   ,[revision_by]
					   ,[revision_date]
					   ,[is_post_transition])
				OUTPUT -1, null, INSERTED.transaction_id, 'apply_payment_by_invoice:insert unapplied cash ', 'CREATE', INSERTED.amount
				INTO @theAuditDetails
				SELECT transaction_id, sum(amount), datefromparts(year(effective_date), month(effective_date), 1) as effective_year_month, @user, @curDate, @user, @curDate, 1
				FROM #arUnappliedCashTmp
				group by transaction_id, datefromparts(year(effective_date), month(effective_date), 1)
				having sum(amount) <> 0

				DECLARE @writeOffTemp table 
				(
					id int,
					invoice_id int, 
					apply_to_year_month datetime, 
					amount_for_auto_writeoff decimal(20,2)
				)

				IF @writeOffFlag = 1
				BEGIN
					;with bill_balance as 
					(
						select invoice_id, payer_id, sum(amount) as balance
						from #charge c
						group by invoice_id, payer_id
					),
					writeOffPerInvoice as
					(
						select  p.wrt_off_max_amt, p.payer_id, tvp.invoice_id
						, b.balance - tvp.amount as amount_for_auto_writeoff
						, CASE	WHEN (abs(b.balance - tvp.amount) <= abs(p.wrt_off_max_amt)) 
								THEN 1 ELSE 0 END
								AS write_off_flag
						from bill_balance b
						join @InvoicePaymentTable tvp on tvp.invoice_id = b.invoice_id
						join ar_lib_payers p on p.payer_id = b.payer_id
					)
					INSERT INTO	@writeOffTemp
					(
						id,
						invoice_id,
						amount_for_auto_writeoff
					)
					SELECT MAX(tp.id), wo.invoice_id, MAX(wo.amount_for_auto_writeoff)
					FROM #transactionsPaymentTmp tp
					JOIN #charge c ON c.transaction_id=tp.charge_transaction_id
					JOIN writeOffPerInvoice wo ON wo.invoice_id = c.invoice_id
					WHERE wo.amount_for_auto_writeoff<>0 and wo.write_off_flag = 1
					GROUP BY wo.invoice_id
				END
				ELSE
				BEGIN
					IF EXISTS (SELECT TOP 1 1 FROM @InvoicePaymentTable  WHERE amount_for_auto_writeoff<>0)
					BEGIN
						INSERT INTO	@writeOffTemp
						(
							id,
							invoice_id,
							apply_to_year_month,
							amount_for_auto_writeoff
						)
						SELECT MAX(tp.id), ipt.invoice_id,ipt.apply_to_year_month, MAX(ipt.amount_for_auto_writeoff)
						FROM #transactionsPaymentTmp tp
						JOIN #charge c ON c.transaction_id=tp.charge_transaction_id
						JOIN @InvoicePaymentTable  ipt 
							ON c.invoice_id=ipt.invoice_id
								and c.apply_to_year_month = isnull(ipt.apply_to_year_month,0)
								and c.payer_id = ipt.payer_id
						WHERE ipt.amount_for_auto_writeoff<>0
						GROUP BY ipt.invoice_id, ipt.payer_id, ipt.apply_to_year_month
					END
				END

				UPDATE tp SET tp.amount_for_auto_writeoff=wt.amount_for_auto_writeoff * -1
				FROM #transactionsPaymentTmp tp
				JOIN @writeOffTemp wt ON tp.id=wt.id

				INSERT INTO ar_transactions_payment
				(
				  charge_transaction_id,
				  payment_transaction_id,
				  amount,
				  amount_for_auto_writeoff,
				  created_by,
				  created_date,
				  revision_by,
				  revision_date
				)
				SELECT charge_transaction_id, payment_transaction_id,
					amount, amount_for_auto_writeoff, @user, @curDate, @user, @curDate
				FROM #transactionsPaymentTmp

				INSERT INTO @theAuditDetails(
					invoice_id,
					apply_to_year_month,
					payment_transaction_id,
					changing_desc,
					action,
					record_amount
				)
				SELECT invoice_id, apply_to_year_month,  @paymentTransactionId, 'apply_payment_by_invoice:insert new payment mapping.', 'CREATE', amount
				FROM @InvoicePaymentTable
				WHERE invoice_id<>-1

				IF (@zeroTransactionsFlag = 0 or @appliedPaymentReserveIdsExists =1)
				BEGIN

				IF (@zeroTransactionsFlag = 0)
				BEGIN
					EXEC sproc_ar_deleteAppliedPaymentHistoryByTransactionId @paymentTransactionId, @facId, @user
					END

 					INSERT INTO ar_applied_payment_history 
					(applied_payment_id,fac_id,deleted,created_by,created_date,revision_by,revision_date,transaction_id,client_id,payer_id,applied_to_date,distribution_id,amount,OpenClose_flag,writeoff_amount,include_transaction_payment) 
					SELECT applied_payment_id,fac_id,deleted,created_by,created_date,revision_by,revision_date,transaction_id,client_id,payer_id,applied_to_date,distribution_id,amount,OpenClose_flag,writeoff_amount,include_transaction_payment
					FROM #appliedPaymentHistoryTmp
				END
								
				-- Create audit records for saving
				declare @touchedRecords TouchedRecordTableType
				INSERT into @touchedRecords
					(fac_id, client_or_mpi_id, item_id, description, action, field_detail)
				SELECT @facId, @clientId, @paymentTransactionId, changing_desc, action, 
					(SELECT * FROM (SELECT CONVERT(VARCHAR(10), invoice_id) AS newValue, 'invoice_id' AS name
						UNION
						SELECT LEFT(CONVERT(VARCHAR, apply_to_year_month,120),10) AS newValue, 'apply_to_year_month' AS name
						UNION
						SELECT CONVERT(VARCHAR(10), payment_transaction_id) AS newValue, 'payment_transaction_id' AS name
						UNION
						SELECT CONVERT(VARCHAR(20), record_amount) AS newValue, 'amount' AS name) tmp_fld_detail
						FOR XML RAW('field')) AS field_detail
				FROM  @theAuditDetails
				
				-- TODO: the audit entry is incorrect if paying a non payable charge (ie. unbilled in current or future posting month)
				--		 in this case, the audit entry still shows the amount going towards the unbilled month, even though it has been applied to unapplied cash instead
				-- CORE-79750: Commenting out auditing as a workaround to the deadlock issue
				-- exec sproc_core_audit_client_set_field_details @touchedRecords
			COMMIT TRAN
		END

		SELECT @result_message as result_message

		-- only return this when posting cash with autowriteoffs
		IF (@zeroTransactionsFlag = 1 and @appliedPaymentReserveIdsExists =1)
		BEGIN
			SELECT applied_payment_id, transaction_id, payer_id, applied_to_date, amount from #appliedPaymentHistoryTmp where include_transaction_payment = 1
		END

		SELECT @status_code = 0
	END TRY

	BEGIN CATCH
		IF @@trancount > 0
		begin
			ROLLBACK TRAN
		End

		SELECT @error_code = @@error, @status_text = ERROR_MESSAGE()
		SELECT @status_code = 1

	END CATCH

--program success return
PgmSuccess:
IF @status_code = 0 AND @DebugMe = 'Y'
BEGIN
   PRINT 'Successful execution of stored procedure'
END

--program failure return
PgmAbend:
BEGIN
    IF @status_code = 1 AND @DebugMe = 'Y'
	BEGIN
            PRINT 'Stored procedure failure:   ' + convert(varchar(26),getdate(),109)
            PRINT 'Error code: '+convert(varchar(10),@error_code) + '; Error description:   ' +@status_text
    END
END
GO

GRANT EXECUTE ON dbo.sproc_ar_apply_payments_to_invoice TO PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_apply_payments_to_invoice.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_apply_payments_to_invoice.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_apply_payments_to_transaction.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ====================================================================================================================================
-- Jira #:              CORE-46308 Cash Application: NDC/RFMS - Current MCD patient liability first, then Oldest to Current import rule
--
-- Written By:          Naomi Martel
-- Reviewed By:
-- Script Type:         DML
-- Target DB Type:      Client
-- Target ENVIRONMENT:  BOTH (US/CA)
-- Re-Runnable:         YES
--
-- Description of Script Function: Apply payments to transactions. Used by MCD and EFT.
--                                 Steps:
--                                 - insert to ar_transactions_payment
--                                 - insert to ar_applied_payment_history
--                                 - insert to ar_unapplied_cash
--                                 - audit
-- =====================================================================================================================================
-- Execution sample:
--
--DECLARE @TableVar TransactionPaymentTableType
--INSERT INTO @TableVar
--VALUES
--	  (497208, 6853741, 35, -962.00, null),
--	  (497208, 6853742, 35, 962.00, null),
--	  (497208, 6853746, 35, 962.00, null),
--	  (497293, 6845604, 89, 50.00, null);

--DECLARE @status_code int, @status_text varchar(3000)
--EXEC dbo.sproc_ar_apply_payments_to_transaction 32, 21783806, @TableVar, 'test user', 'N', @status_code, @status_text
-- ======================================================================================================================================

SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO

IF EXISTS (
    SELECT 1
    FROM dbo.sysobjects
    WHERE id = object_id(N'dbo.sproc_ar_apply_payments_to_transaction')
        AND objectproperty(id, N'IsProcedure') = 1
    )
BEGIN
    DROP PROCEDURE dbo.sproc_ar_apply_payments_to_transaction
END
GO

IF EXISTS (SELECT * FROM sys.types WHERE is_table_type = 1 AND name = 'TransactionPaymentTableType')
BEGIN
	DROP TYPE [dbo].[TransactionPaymentTableType]
END
GO

CREATE TYPE [dbo].[TransactionPaymentTableType] AS TABLE(
		[invoice_id] [int] NOT NULL,
		[transaction_id] [int] NOT NULL,
		[payer_id] [int] NOT NULL,
		[amount] [decimal](20,2) NOT NULL DEFAULT ((0)),
		[effective_date] [DATETIME] NULL
	)
	
GRANT EXEC ON TYPE::[dbo].[TransactionPaymentTableType] TO [public]
GO

CREATE PROCEDURE sproc_ar_apply_payments_to_transaction
(
  @facId INT
  , @paymentTransactionId int
  , @TransactionPaymentTable TransactionPaymentTableType READONLY
  , @appliedPaymentId_CSV varchar(max)
  , @user varchar(60)
  , @writeOffAdjustmentTxFlag bit = 0
  , @debug CHAR(1) = 'N'
  , @status_code int out
  , @status_text varchar(3000) out
)
AS

SET NOCOUNT ON

DECLARE @error_msg varchar(255)
       ,@error_code int
       ,@step VARCHAR(5)
	   ,@clientId INT = NULL
       ,@result_message varchar(200)

DECLARE @curDate DATETIME = getDate()
       ,@postingDate DATETIME = NULL

DECLARE @appliedPaymentReservedIdsTmp TABLE (id int identity(1,1), applied_payment_id int)
DECLARE @appliedPaymentId INT
DECLARE @blockSize int

--------------------------------------------------------------
-- temp tables
--------------------------------------------------------------
CREATE TABLE #transactionsPaymentTmp
(
	id INT IDENTITY(1,1) NOT NULL,
	invoice_id INT NOT NULL,
	payer_id INT NOT NULL,
	charge_transaction_id INT NOT NULL,
	payment_transaction_id INT NOT NULL,
	amount DECIMAL(20,2) NULL DEFAULT (0),
	effective_date DATETIME NULL
)

CREATE TABLE #cashTxDistribution
(
  transaction_id int,
  distribution_tx_id int,
  payer_id int,
  effective_date DATETIME NULL
)

CREATE TABLE #appliedPaymentHistoryTmp (
	ident int identity(1,1),
	applied_payment_id int NOT NULL,
	fac_id int NOT NULL,
	deleted char(1) NOT NULL,
	created_by varchar(60) NOT NULL,
	created_date datetime NOT NULL,
	revision_by varchar(60) NULL,
	revision_date datetime NULL,
	deleted_by varchar(60) NULL,
	deleted_date datetime NULL,
	transaction_id int NOT NULL,
	client_id int NOT NULL,
	payer_id int NOT NULL,
	current_period_date datetime NULL,
	applied_to_date datetime NOT NULL,
	applied_date datetime NULL,
	distribution_id int NOT NULL,
	amount money NOT NULL,
	OpenClose_Flag char(1) NOT NULL,
    include_transaction_payment bit NOT NULL
)

BEGIN TRY
	-- Get posting date
	SELECT @postingDate = posting_date FROM ar_configuration WHERE fac_id = @facId
	
	SET @step = '010'
	
	select top 1 @clientId = client_id from ar_transactions where transaction_id = @paymentTransactionId
	
	INSERT INTO #cashTxDistribution
	SELECT transaction_id, distribution_tx_id, payer_id, effective_date
	FROM ar_transactions
	WHERE fac_id=@facId AND client_id = @clientId AND deleted = 'N'
		AND COALESCE(distribution_tx_id,transaction_id) = @paymentTransactionId
		AND transaction_type = 'C'

	if @debug='Y'
    select '#cashTxDistribution', * from #cashTxDistribution

	SET @step = '020'
	INSERT INTO #transactionsPaymentTmp
	(
		invoice_id,
		charge_transaction_id,
		payment_transaction_id,
		amount,
		payer_id,
		effective_date
	)
	SELECT c.invoice_id, c.transaction_id, dist.transaction_id, c.amount * -1, c.payer_id, c.effective_date
	FROM @TransactionPaymentTable c
	JOIN #cashTxDistribution dist on dist.payer_id = c.payer_id
	WHERE c.invoice_id <> -3

	-- prevent applying payments to charges unbilled and marked as billed that were posted
	-- in the current or future posting months; goes to unapplied cash
	UPDATE tp
	SET tp.invoice_id = -1, tp.effective_date = t.effective_date
	FROM #transactionsPaymentTmp tp
	INNER JOIN ar_transactions t 
		ON t.transaction_id = tp.charge_transaction_id
		AND t.client_id = @clientId
		AND t.payer_id = tp.payer_id
	    AND t.fac_id = @facId
		AND t.deleted = 'N'
	WHERE t.transaction_date >= @postingDate
		AND tp.invoice_id IN (0, -999) AND isnull(@writeOffAdjustmentTxFlag,0) = 0
		
	if @debug='Y'
    select '#transactionsPaymentTmp', * from #transactionsPaymentTmp

	IF EXISTS (SELECT TOP 1 1 FROM @TransactionPaymentTable)
	BEGIN
		
		if @debug='Y'
		Print 'Create applied payment history' + ' ' + convert(varchar(26),getdate(),109)
			
        SET @step = '030'
		
		;WITH aphTmp (applied_payment_id,fac_id,deleted,created_by,created_date,revision_by,revision_date,transaction_id,client_id,payer_id,applied_to_date,distribution_id,amount,OpenClose_flag,include_transaction_payment)
		AS
		(
			SELECT 
			0,@facId,'N',@user,@curDate,@user,@curDate,map.payment_transaction_id,@clientId,map.payer_id,
			(DATEFROMPARTS(YEAR(charge.effective_date),MONTH(charge.effective_date),1)),0,map.amount,'O',1
			FROM #transactionsPaymentTmp map
			JOIN ar_transactions charge 
				ON charge.transaction_id = map.charge_transaction_id AND charge.fac_id = @facId
			WHERE map.invoice_id <> -1
			UNION ALL
			SELECT
			0,@facId,'N',@user,@curDate,@user,@curDate,dist.transaction_id,@clientId,t.payer_id,
			(DATEFROMPARTS(YEAR(t.effective_date),MONTH(t.effective_date),1)),0,t.amount,'O',1
			FROM #transactionsPaymentTmp t
				JOIN #cashTxDistribution dist ON dist.payer_id = t.payer_id
			WHERE t.invoice_id=-1
			-- include pre-transition buckets
			UNION ALL
			SELECT 
				  applied_payment_id = 0
				, fac_id = @facId
				, deleted = 'N'
				, created_by = @user
				, created_date = @curDate
				, revision_by = @user
				, revision_date = @curDate
				, dist.transaction_id
				, client_id = @clientId
				, t.payer_id
				, applied_to_date = (DATEFROMPARTS(YEAR(t.effective_date),MONTH(t.effective_date),1))
				, distribution_id = 0
				, amount * -1
				, OpenClose_flag = 'O'
                , 0
			FROM @TransactionPaymentTable t
			JOIN #cashTxDistribution dist on dist.payer_id = t.payer_id
            
			WHERE invoice_id = -3
		)
		INSERT INTO #appliedPaymentHistoryTmp
		(applied_payment_id,fac_id,deleted,created_by,created_date,revision_by,revision_date,transaction_id,client_id,payer_id,applied_to_date,distribution_id,amount,OpenClose_flag,include_transaction_payment)
		SELECT 
		applied_payment_id,fac_id,deleted,created_by,created_date,revision_by,revision_date,transaction_id,client_id,payer_id,applied_to_date,distribution_id,sum(amount)*-1,OpenClose_flag,include_transaction_payment
		FROM aphTmp a
		GROUP BY applied_payment_id,fac_id,deleted,created_by,created_date,revision_by,revision_date,transaction_id,client_id,payer_id,applied_to_date,distribution_id,OpenClose_flag,include_transaction_payment
		HAVING SUM(amount) <> 0 
					


		INSERT INTO @appliedPaymentReservedIdsTmp(applied_payment_id) SELECT value FROM pcc__csvToTableOfIntMax(@appliedPaymentId_CSV)
		if @debug='Y' 
		begin
			select '@appliedPaymentReservedIdsTmp', * from @appliedPaymentReservedIdsTmp
		end

		IF EXISTS (SELECT TOP 1 1 FROM @appliedPaymentReservedIdsTmp WHERE applied_payment_id <> '')
		BEGIN
			-- Called by EFT
			IF (SELECT COUNT(*) from #appliedPaymentHistoryTmp) > (SELECT COUNT(*) FROM @appliedPaymentReservedIdsTmp) 
			BEGIN
				SELECT @result_message = 'The number of applied payments records to create is greater than the number of blocks reserved.'
				RAISERROR (@result_message, 16, 1)
			END

			SET @appliedPaymentId = (SELECT MIN(applied_payment_id) FROM @appliedPaymentReservedIdsTmp)

			update aph
			set applied_payment_id = x.applied_payment_id, distribution_id = @appliedPaymentId
			from #appliedPaymentHistoryTmp aph
			join @appliedPaymentReservedIdsTmp x on x.id = aph.ident

		END
		ELSE
		BEGIN
			select @blockSize = count(*) from #appliedPaymentHistoryTmp
			execute get_next_primary_key 'ar_applied_payment_history', 'applied_payment_id', @appliedPaymentId OUTPUT,@blockSize

			update aph
			set applied_payment_id = @appliedPaymentId + aph.ident - 1, distribution_id = @appliedPaymentId
			from #appliedPaymentHistoryTmp aph
		END

				
		IF ((SELECT SUM(amount) from #appliedPaymentHistoryTmp) > (SELECT SUM(amount) from @TransactionPaymentTable))
		BEGIN
			SELECT @result_message = 'Applied total exceeds available payment.'
			RAISERROR (@result_message, 16, 1)
		END
				
		if @debug='Y' 
		begin
			select '#appliedPaymentHistoryTmp', * from #appliedPaymentHistoryTmp
		end

	END

	IF @writeOffAdjustmentTxFlag=0 AND EXISTS(SELECT transaction_id FROM ar_transactions WHERE fac_id=@facId AND transaction_id=@paymentTransactionId AND (transaction_date IS NOT NULL OR deleted='Y'))
	BEGIN
		SELECT @result_message = 'Payment was not processed, cash transaction was deleted or posted.'
	END
	ELSE
	BEGIN
		BEGIN TRAN

			declare @theAuditDetails table 
			(
				invoice_id int,
				charge_transaction_id int null, 
				payment_transaction_id int, 
				changing_desc varchar(max), 
				action varchar(10), 
				record_amount decimal(20,2)
			)

			SET @step = '040'
			
			INSERT INTO ar_transactions_payment
			(
				charge_transaction_id,
				payment_transaction_id,
				amount,
				created_by,
				created_date,
				revision_by,
				revision_date,
				is_created_from_auto_writeoff
			)
			SELECT charge_transaction_id, payment_transaction_id, amount, @user, @curDate, @user, @curDate, @writeOffAdjustmentTxFlag
			FROM #transactionsPaymentTmp
			WHERE invoice_id <> -1

			INSERT INTO @theAuditDetails(
				invoice_id,
				charge_transaction_id,
				payment_transaction_id,
				changing_desc,
				action,
				record_amount
			)
			SELECT invoice_id, charge_transaction_id, payment_transaction_id, 'apply_payment_by_transaction:insert new payment mapping.', 'CREATE', amount
			FROM #transactionsPaymentTmp
			WHERE invoice_id <> -1

			INSERT INTO [ar_unapplied_cash]
				   ([transaction_id]
				   ,[amount]
				   ,[effective_date]
				   ,[created_by]
				   ,[created_date]
				   ,[revision_by]
				   ,[revision_date]
                   ,[is_post_transition])
			OUTPUT -1, null, INSERTED.transaction_id, 'apply_payment_by_transaction:insert unapplied cash ', 'CREATE', INSERTED.amount
			INTO @theAuditDetails
			SELECT payment_transaction_id, sum(amount), effective_date, @user, @curDate, @user, @curDate, 1
			FROM #transactionsPaymentTmp
			WHERE invoice_id=-1
			GROUP BY payment_transaction_id, payer_id, effective_date
			HAVING sum(amount) <> 0

			SET @step = '050'
			INSERT INTO ar_applied_payment_history 
				(applied_payment_id,fac_id,deleted,created_by,created_date,revision_by,revision_date,transaction_id,client_id,payer_id,applied_to_date,distribution_id,amount,OpenClose_flag,include_transaction_payment) 
			SELECT applied_payment_id,fac_id,deleted,created_by,created_date,revision_by,revision_date,transaction_id,client_id,payer_id,applied_to_date,distribution_id,amount,OpenClose_flag,include_transaction_payment
			FROM #appliedPaymentHistoryTmp
					
			-- Create audit records for saving
			declare @touchedRecords TouchedRecordTableType
			INSERT into @touchedRecords
				(fac_id, client_or_mpi_id, item_id, description, action, field_detail)
			SELECT @facId, @clientId, @paymentTransactionId, changing_desc, action, 
				(SELECT * FROM (SELECT CONVERT(VARCHAR(10), invoice_id) AS newValue, 'invoice_id' AS name
					UNION
					SELECT CONVERT(VARCHAR(10), charge_transaction_id) AS newValue, 'charge_transaction_id' AS name
					UNION
					SELECT CONVERT(VARCHAR(10), payment_transaction_id) AS newValue, 'payment_transaction_id' AS name
					UNION
					SELECT CONVERT(VARCHAR(20), record_amount) AS newValue, 'amount' AS name) tmp_fld_detail
					FOR XML RAW('field')) AS field_detail
			FROM  @theAuditDetails
			
			if @debug='Y'
			select '@touchedRecords', * from @touchedRecords

			-- CORE-79750: Commenting out auditing as a workaround to the deadlock issue
			-- exec sproc_core_audit_client_set_field_details @touchedRecords
		COMMIT TRAN
	END

	SELECT @result_message as result_message
	SELECT @status_code = 0

END TRY
BEGIN CATCH
	IF @@trancount > 0
	begin
		ROLLBACK TRAN
	End

	SELECT @error_code = @@error, @status_text = ERROR_MESSAGE()
	SELECT @status_code = 1

	GOTO PgmAbend
END CATCH

--program success return
PgmSuccess:
BEGIN
  IF @status_code = 0 AND @debug='Y'
    PRINT 'Successful execution of stored procedure'
END

--program failure return
PgmAbend:
BEGIN
  IF @status_code = 1 AND @debug='Y'
  BEGIN
    PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '     ' + convert(varchar(26),getdate())
    PRINT 'Error code: '+convert(varchar(3),@step) + '; Error description:      ' + @status_text
  END
END
GO

GRANT EXECUTE ON dbo.sproc_ar_apply_payments_to_transaction TO PUBLIC
GO

SET ANSI_NULLS OFF
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_apply_payments_to_transaction.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_apply_payments_to_transaction.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_get_invoice_writeoff_by_batch.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


	-- =================================================================================
-- Jira #:
--
-- Written By:           Shawn Song
-- Reviewed By:
--
-- Script Type:          Stored Procedure
-- Target DB Type:       CLIENT
-- Target ENVIRONMENT:   BOTH
--
-- Re-Runable:           YES
--
-- Where tested:         172.16.10.119,1689 (Avengers DEV DB)
--						 ORG: agrd
--
-- Staging Recommendations/Warnings:
--
-- Description of Script Function:
-- Get list of writeoffs that will be used to create adjustment transactions for the auto-writeoff functionality.
-- Write offs are grouped either: billed (by invoice_id) or unbilled (by the unbilled year month).
--
-- Sample execution (agrd):
-- DECLARE @status_code int, @status_text varchar(3000)
-- EXEC sproc_ar_get_invoice_writeoff_by_batch 492820, 1, 'N', @status_code, @status_text
-- =================================================================================

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

IF EXISTS (SELECT 1 FROM sysobjects WHERE id = object_id(N'sproc_ar_get_invoice_writeoff_by_batch'))
BEGIN
    DROP PROCEDURE sproc_ar_get_invoice_writeoff_by_batch;
END
GO

CREATE PROCEDURE sproc_ar_get_invoice_writeoff_by_batch
	( @batchId INT
	, @facId INT
	, @DebugMe CHAR(1) = 'N'
	, @status_code int  out
	, @status_text varchar(3000) out
    )
AS
BEGIN
	DECLARE @error_code INT
		   ,@result_message varchar(200)

	SET NOCOUNT ON
	
	CREATE TABLE #invoiceWriteOff (
		client_id INT NOT NULL,
		payer_id int NOT NULL,
		invoice_id int NULL,
		transaction_id int NOT NULL,
		distribution_tx_id int not null,
		writeoff_amount decimal(20,2) NULL DEFAULT (0),
		payer_wrt_charge_code_id int NULL,
		payer_wrt_account_id int NULL,
		effective_date datetime NULL
	)

	INSERT INTO #invoiceWriteOff
	(
		client_id,
		payer_id,
		invoice_id,
		transaction_id,
		distribution_tx_id,
		writeoff_amount,
		payer_wrt_charge_code_id,
		payer_wrt_account_id,
		effective_date
	)
    SELECT t.client_id, t.payer_id, ct.invoice_id, t.transaction_id, isnull(t.distribution_tx_id, t.transaction_id) as distribution_tx_id, SUM(p.amount_for_auto_writeoff)*-1 AS writeoff_amount, 
		MIN(lp.wrt_charge_code_id) AS payer_wrt_charge_code_id, MIN(cc.dollar_account_id) AS payer_wrt_account_id, MIN(ct.effective_date) AS effective_date 
	FROM ar_transactions t 
	JOIN ar_transactions_payment p ON p.payment_transaction_id=t.transaction_id 
	JOIN ar_transactions ct ON ct.transaction_id=p.charge_transaction_id 
	JOIN ar_lib_payers lp ON lp.payer_id=t.payer_id 
	LEFT JOIN ar_lib_charge_codes cc ON cc.charge_code_id=lp.wrt_charge_code_id 
	WHERE t.fac_id=@facId and t.deleted='N' AND ct.deleted='N' AND t.batch_id=@batchId
	    AND p.posting_date IS NOT NULL
		AND p.amount_for_auto_writeoff is not null AND p.amount_for_auto_writeoff<>0.0 
	GROUP BY t.client_id, t.payer_id, ct.invoice_id, t.transaction_id, t.distribution_tx_id,
	         CASE WHEN isnull(ct.invoice_id,-999) <> -999 THEN NULL 
			      ELSE DATEFROMPARTS(year(ct.effective_date), month(ct.effective_date), 1) END
	UNION ALL
    SELECT t.client_id, t.payer_id, -3, t.transaction_id,isnull(t.distribution_tx_id, t.transaction_id) as distribution_tx_id, SUM(p.writeoff_amount) AS writeoff_amount, 
		MIN(lp.wrt_charge_code_id) AS payer_wrt_charge_code_id, MIN(cc.dollar_account_id) AS payer_wrt_account_id, p.applied_to_date AS effective_date 
	FROM ar_transactions t 
	JOIN ar_applied_payment_history p ON p.transaction_id=t.transaction_id AND p.deleted = 'N'
	JOIN ar_lib_payers lp ON lp.payer_id=t.payer_id 
	LEFT JOIN ar_lib_charge_codes cc ON cc.charge_code_id=lp.wrt_charge_code_id 
	WHERE t.fac_id=@facId and t.deleted='N' AND t.batch_id=@batchId
	    AND p.applied_date IS NOT NULL
		AND p.writeoff_amount is not null AND p.writeoff_amount<>0.0 
	GROUP BY t.client_id, t.payer_id, t.transaction_id, t.distribution_tx_id, p.applied_to_date

	SELECT client_id, payer_id, invoice_id, transaction_id,distribution_tx_id, writeoff_amount, payer_wrt_charge_code_id, payer_wrt_account_id, effective_date
	FROM #invoiceWriteOff
	
	SELECT SUM(writeoff_amount) AS total_writeoff_amount FROM #invoiceWriteOff
	
	-- return transactions payment created from auto writeoff:
	SELECT p.payment_transaction_id, ct.transaction_id, ct.effective_date, p.amount AS amount
	FROM ar_transactions t 
	JOIN ar_transactions_payment p ON p.payment_transaction_id=t.transaction_id 
	JOIN ar_transactions ct ON ct.transaction_id=p.charge_transaction_id 
	WHERE t.fac_id=@facId and t.deleted='N' AND ct.deleted='N' AND t.batch_id=@batchId
	    AND p.posting_date IS NOT NULL
		AND isnull(p.is_created_from_auto_writeoff, 0) = 1
  
END
GO

GRANT EXECUTE ON dbo.sproc_ar_get_invoice_writeoff_by_batch TO PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_get_invoice_writeoff_by_batch.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_get_invoice_writeoff_by_batch.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_get_reserved_applied_payment_ids_by_batch.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


	-- =================================================================================
-- Jira #:
--
-- Written By:           Shawn Song
-- Reviewed By:
--
-- Script Type:          Stored Procedure
-- Target DB Type:       CLIENT
-- Target ENVIRONMENT:   BOTH
--
-- Re-Runable:           YES
--
-- Where tested:         172.16.10.119,1689 (Avengers DEV DB)
--						 ORG: agrd
--
-- Staging Recommendations/Warnings:
--
-- Description of Script Function:
-- Get list of reserved applied payment ids to be used for creating applied payment history when paying bills
--
-- Sample execution (agrd):
-- DECLARE @status_code int, @status_text varchar(3000)
-- EXEC sproc_ar_get_reserved_applied_payment_ids_by_batch 492820, 1,1, 'N', @status_code, @status_text
-- =================================================================================

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

IF EXISTS (SELECT 1 FROM sysobjects WHERE id = object_id(N'sproc_ar_get_reserved_applied_payment_ids_by_batch'))
BEGIN
    DROP PROCEDURE sproc_ar_get_reserved_applied_payment_ids_by_batch;
END
GO

CREATE PROCEDURE sproc_ar_get_reserved_applied_payment_ids_by_batch
	( @batchId INT
	, @facId INT
	, @includeWriteOff bit
	, @DebugMe CHAR(1) = 'N'
	, @status_code int  out
	, @status_text varchar(3000) out
    )
AS
BEGIN
	DECLARE @error_code INT
		   ,@result_message varchar(200)

	SET NOCOUNT ON

	CREATE TABLE #clientPayerInvoice
	(
	  ident int identity(0,1),
	  transaction_id INT NOT NULL,
	  distribution_tx_id INT NOT NULL,
	  unique_month date not null
	)
	
	DECLARE @appliedPaymentId int
	DECLARE	@numUniqueEffectiveMonths int

	;with transactionsAndInvoices AS
	(
		select t.transaction_id, isnull(t.distribution_tx_id, t.transaction_id) as distribution_tx_id, ct.invoice_id
		from ar_transactions t
		JOIN ar_transactions_payment p ON p.payment_transaction_id=t.transaction_id 
		JOIN ar_transactions ct ON ct.transaction_id=p.charge_transaction_id 
		WHERE t.fac_id=@facId and t.deleted='N' AND t.batch_id=@batchId 
			and ct.invoice_id > 0
			AND (@includeWriteOff=0 OR (p.amount_for_auto_writeoff is not null AND p.amount_for_auto_writeoff<>0.0 )) 
		GROUP BY t.transaction_id, t.distribution_tx_id, ct.invoice_id
	)
	INSERT INTO #clientPayerInvoice
	(
	  transaction_id,
	  distribution_tx_id,
	  unique_month
	)
	select ti.transaction_id, ti.distribution_tx_id, (DATEFROMPARTS(YEAR(ct.effective_date),MONTH(ct.effective_date),1)) as unique_month
	from ar_transactions ct
		join transactionsAndInvoices ti
			on ti.invoice_id = ct.invoice_id
				and ct.fac_id = @facId
				and ct.deleted = 'N'
	group by ti.transaction_id, ti.distribution_tx_id, (DATEFROMPARTS(YEAR(ct.effective_date),MONTH(ct.effective_date),1))
	union
	select t.transaction_id, isnull(t.distribution_tx_id, t.transaction_id) as distribution_tx_id,   DATEFROMPARTS(year(ct.effective_date), month(ct.effective_date), 1)  as effective_date_month
		from ar_transactions t
		JOIN ar_transactions_payment p ON p.payment_transaction_id=t.transaction_id 
		JOIN ar_transactions ct ON ct.transaction_id=p.charge_transaction_id 
		WHERE t.fac_id=@facId and t.deleted='N' AND t.batch_id=@batchId 
			AND (@includeWriteOff=0 OR (p.amount_for_auto_writeoff is not null AND p.amount_for_auto_writeoff<>0.0 )) 
			and isnull(ct.invoice_id,-999) = -999
		GROUP BY t.transaction_id, t.distribution_tx_id, DATEFROMPARTS(year(ct.effective_date), month(ct.effective_date), 1) 
	order by ti.transaction_id

	SELECT @numUniqueEffectiveMonths = count(*) from #clientPayerInvoice

	IF @numUniqueEffectiveMonths > 0 
	BEGIN 
		SELECT @numUniqueEffectiveMonths = @numUniqueEffectiveMonths * 2
		execute get_next_primary_key 'ar_applied_payment_history', 'applied_payment_id', @appliedPaymentId OUTPUT, @numUniqueEffectiveMonths
	END

	select distribution_tx_id, count(unique_month)*2 as reserved_num, @appliedPaymentId + MIN(ident)*2  AS applied_payment_id 
	from #clientPayerInvoice
	group by distribution_tx_id
END
GO

GRANT EXECUTE ON dbo.sproc_ar_get_reserved_applied_payment_ids_by_batch TO PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_get_reserved_applied_payment_ids_by_batch.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_get_reserved_applied_payment_ids_by_batch.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_getAffectedCOTransactions_byBatchID_isReversing.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*****************************************************************************************************
  Created By:		   Jorge Santos
  Created Date:	       2018-11-16

  Reviewed By:

  Target DB Type:      CLIENT
  Target ENVIRONMENT:  BOTH

  Description:         Get transactions affected by Coinsurance that
                       we need to recalculate on posting by batch id.

  Revision History:

*****************************************************************************************************/
/*
  exec sproc_ar_getAffectedCOTransactions_byBatchID_isReversing @batchID = 3388,
																@isReversing = 1,
																@debug = 'Y'

 */
IF EXISTS (
		select *
		from sys.procedures
		where name = 'sproc_ar_getAffectedCOTransactions_byBatchID_isReversing'
		)
	drop procedure sproc_ar_getAffectedCOTransactions_byBatchID_isReversing
GO

CREATE PROCEDURE sproc_ar_getAffectedCOTransactions_byBatchID_isReversing (
	@batchID int
	,@isReversing bit = 0
	,@debug char(1) = 'N'
	)
AS
BEGIN
	SET NOCOUNT ON

	BEGIN TRY

		declare @transactions table (
			transaction_id int,
			client_id int,
			effective_date datetime,
			payer_id int,
			eff_date_range_id int,
			prt_id int,
			fac_id int,
			entry_number int,
			item_type_id int,
			amount money,
			transaction_type varchar(2),
			is_posted bit,
			batch_id int,
			transaction_date datetime,
			created_date datetime,
			revision_date datetime,
			deleted varchar(1),
			payer_rules_coinsurance bit, -- if 1, the coinsurance is set at the payer rules (in other words, date range) level so we need to group by payer_id.
			recalculate varchar(1),
			reimbursement varchar(1)
		)

		declare @selector table (
			client_id int,
			effective_date datetime,
			payer_id int,
			fac_id int
		)

		declare @posted_transactions table (
			client_id int,
			effective_date datetime,
			payer_id int,
			prt_id int,
			fac_id int,
			item_type_id int,
			actual_posting_date datetime,
			batch_status varchar(20),
			payer_rules_coinsurance bit
		)

		declare @max_actual_posting_date table (
			client_id int,
			effective_date datetime,
			payer_id int,
			prt_id int,
			fac_id int,
			actual_posting_date datetime,
			batch_status varchar(20),
			payer_rules_coinsurance bit
		)

		declare @selector_to_recalculate table (
			client_id int,
			effective_date datetime,
			payer_id int,
			prt_id int,
			fac_id int,
			payer_rules_coinsurance bit
		)

		insert into @transactions
		select t.transaction_id, t.client_id, t.effective_date, t.payer_id, null as eff_date_range_id, null as prt_id, t.fac_id, t.entry_number, t.item_type_id,
			t.amount, t.transaction_type, t.is_posted, t.batch_id, t.transaction_date, t.created_date, t.revision_date, t.deleted, null,
			case when t.deleted = 'Y' then 'N' else 'Y' end as recalculate, --do not recalculate deleted transactions
			'Y' as reimbursement
		from ar_transactions t
			join ar_batch b
				on t.batch_id = b.batch_id
		where
			t.batch_id = @batchID
			and t.transaction_id = t.distribution_tx_id --only recalculate root transactions.
			and t.item_type_id is not null --Only recalculate ancillary transactions with a charge code.
			and ((@isReversing = 1 AND t.reversing_tx_id IS NOT NULL AND b.description not like 'Auto Retro - %')
				 OR (@isReversing = 0 AND t.reversing_tx_id IS NULL))


		if (@debug = 'Y')
			select * from @transactions

		--populate prt_id
		update t set
			t.eff_date_range_id = dr.eff_date_range_id,
			t.prt_id = prt.prt_id,
			t. payer_rules_coinsurance = case when ltrim(isnull(prt.co_pay_type, '')) = '' then 1 else 0 end,
			t.reimbursement = case when prt.revision_date < t.created_date --the ancillary payer rules template hasn't been changed since transaction creation
									  and prt.ancillary_reimbursement_type = 0
									  and prt.anc_percent_writeoff = 100.0 --there is no reimbursement so there won't be coinsurance
								 then 'N'
								 else 'Y'
							end
		from ar_payer_rules_template prt
			JOIN ar_date_range dr
				ON prt.eff_date_range_id = dr.eff_date_range_id
					AND dr.deleted = 'N'
			JOIN view_ar_item_prt iprt
				ON prt.prt_id = iprt.prt_id
					AND dr.eff_date_range_id = iprt.eff_date_range_id
			JOIN @transactions t
				ON iprt.item_type_id = t.item_type_id
					AND dr.payer_id = t.payer_id
					AND dr.fac_id = t.fac_id
					AND (dr.eff_date_to >= t.effective_date OR dr.eff_date_to IS NULL)
					AND dr.eff_date_from <= t.effective_date
		where prt.covered = 'Y'
			--Has daily coinsurance either at the payer rules level or is overridden at the Ancillary Template Rule level (i.e. this takes precedence)
			and (prt.co_pay_type = 'D' or (ltrim(isnull(prt.co_pay_type, '')) = '' and dr.co_pay_type  = 'D'))

		--do not recalculate if no reimbursement
		update t
		set t.recalculate = t.reimbursement
		from @transactions t
		where t.deleted = 'N' --but only if it's not deleted

		if (@debug = 'Y')
			select transaction_id, eff_date_range_id, prt_id, payer_rules_coinsurance from @transactions

		--don't recalculate transactions whose charge codes are not configured with daily coinsurance.
		update @transactions
		set recalculate = 'N'
		where prt_id is null

		if (@debug = 'Y')
			select * from @transactions


		--extract selectors to find transactions with the same selector that have been posted before the ones in @batchID
		insert into @selector
		select distinct client_id, effective_date, payer_id, fac_id
		from @transactions t

		if (@debug = 'Y')
			select * from @selector

		--Get fac_id from selector. It should be unique as batches are only for transactions within a single facility.
		--We will use it in the next query to prevent SQL Server from producing a bad plan for smaller orgs.
		declare @facId int = (select fac_id from ar_batch where batch_id = @batchID)

		--Posted transactions for the same client/payer/effective date
		insert into @posted_transactions
		select t.client_id, t.effective_date, t.payer_id, null as prt_id, t.fac_id, t.item_type_id, b.actual_posting_date, b.status as batch_status, null as payer_rules_coinsurance
			from ar_transactions t
			join ar_batch b
				on t.batch_id = b.batch_id
				and t.fac_id = b.fac_id
			join @selector s
				on t.fac_id = s.fac_id
				and t.effective_date = s.effective_date
				and t.client_id = s.client_id
				and t.payer_id = s.payer_id
		where b.deleted = 'N'
			and t.deleted = 'N'
			and b.actual_posting_date is not null
			and b.batch_id <> @batchID
			and t.fac_id = @facId

		if (@debug = 'Y')
			select '@posted_transactions', * from @posted_transactions

		--populate prt_id
		update t set t.prt_id = prt.prt_id,
			payer_rules_coinsurance = case when ltrim(isnull(prt.co_pay_type, '')) = '' then 1 else 0 end
		from ar_payer_rules_template prt
			JOIN ar_date_range dr
				ON prt.eff_date_range_id = dr.eff_date_range_id
					AND dr.deleted = 'N'
			JOIN view_ar_item_prt iprt
				ON prt.prt_id = iprt.prt_id
					AND dr.eff_date_range_id = iprt.eff_date_range_id
			JOIN @posted_transactions t
				ON iprt.item_type_id = t.item_type_id
					AND dr.payer_id = t.payer_id
					AND dr.fac_id = t.fac_id
					AND (dr.eff_date_to >= t.effective_date OR dr.eff_date_to IS NULL)
					AND dr.eff_date_from <= t.effective_date
		where prt.covered = 'Y'
			--Has daily coinsurance ether at the payer rules level or is overridden at the Ancillary Template Rule level (i.e. this takes precedence)
			and (prt.co_pay_type = 'D' or (ltrim(isnull(prt.co_pay_type, '')) = '' and dr.co_pay_type  = 'D'))

		if (@debug = 'Y')
			select prt_id, * from @posted_transactions

		--only look at posted transactions that are configured with daily coinsurance.
		delete from @posted_transactions
		where prt_id is null

		if (@debug = 'Y')
			select * from @posted_transactions

		--we only need the max posted date for each bucket.
		insert into @max_actual_posting_date
		select pt.client_id, pt.effective_date, pt.payer_id, (case when pt.payer_rules_coinsurance = 1 then -1 else pt.prt_id end),
			pt.fac_id, max(pt.actual_posting_date) as actual_posting_date, pt.batch_status, payer_rules_coinsurance
		from @posted_transactions pt
		group by pt.client_id, pt.effective_date, pt.payer_id, (case when pt.payer_rules_coinsurance = 1 then -1 else pt.prt_id end),
			pt.fac_id, pt.batch_status, payer_rules_coinsurance

		if (@debug = 'Y')
			select * from @max_actual_posting_date

		--We don't need to re-evaluate transactions when no other batch with the same client/effective date/payer has been posted
		--nor when it was posted before the transactions were created:
		update t set recalculate = 'N' --first posted batch for bucket
		from @transactions t
		left join @max_actual_posting_date mpd
			ON t.client_id = mpd.client_id
				and t.effective_date = mpd.effective_date
				and t.payer_id = mpd.payer_id
				and ((t.payer_rules_coinsurance = 1 and mpd.payer_rules_coinsurance = 1) or t.prt_id = mpd.prt_id)
				and t.fac_id = mpd.fac_id
		--This transaction was created after all (if any) other transactions in the same batch had already been posted:
		where (mpd.actual_posting_date is NULL
				or t.created_date > mpd.actual_posting_date)
			and t.recalculate = 'Y'

		--Recalculate if a batch that had been posted when the transaction was created was later unposted.
		update t set recalculate = 'Y'
		from @transactions t
		join @max_actual_posting_date mpd
			ON t.client_id = mpd.client_id
				and t.effective_date = mpd.effective_date
				and t.payer_id = mpd.payer_id
				and ((t.payer_rules_coinsurance = 1 and mpd.payer_rules_coinsurance = 1) or t.prt_id = mpd.prt_id)
				and t.fac_id = mpd.fac_id
				and t.recalculate = 'N'
				and t.reimbursement = 'Y' --but only if they actually have reimbursement
				and t.deleted = 'N' --and it's not deleted
		where
			mpd.batch_status <> 'Posted' and t.created_date > mpd.actual_posting_date

		insert into @selector_to_recalculate
		select distinct client_id, effective_date, payer_id, prt_id, fac_id, payer_rules_coinsurance
		from @transactions ot
		--transactions that have been edited or that have been deleted in the batch:
		where (DATEDIFF(SECOND, ot.created_date, ot.revision_date) > 3) or (deleted = 'Y')

		update t
		set recalculate = 'Y' --recalculate because of changes in batch
		from @transactions t
			join @selector_to_recalculate r
			ON t.client_id = r.client_id
				and t.effective_date = r.effective_date
				and t.payer_id = r.payer_id
				and ((t.payer_rules_coinsurance = 1 and r.payer_rules_coinsurance = 1) or t.prt_id = r.prt_id)
				and t.fac_id = r.fac_id
				and t.recalculate = 'N'
				and t.reimbursement = 'Y' --but only if they actually have reimbursement
				and t.deleted = 'N' --and it's not deleted

		select distinct
			t.fac_id,
			t.client_id,
			t.effective_date,
			t.batch_id,
			t.payer_id,
			t.transaction_id as distribution_tx_id,
			t.item_type_id,
			t.amount,
			t.transaction_type,
			t.is_posted,
			t.prt_id,
			t.eff_date_range_id,
			min(t.effective_date) over (partition by t.client_id) min_effective_date,
			convert( varchar, t.client_id) + '_'+convert( varchar, t.prt_id) +'_'+ convert( varchar(8), t.effective_date, 112) drkey
		from @transactions t
		where recalculate = 'Y'

	END TRY

	BEGIN CATCH
		DECLARE @ErrorMessage NVARCHAR(3000)
		SET @ErrorMessage = ERROR_MESSAGE()
		RAISERROR (@ErrorMessage,16,1)
	END CATCH
END
GO

GRANT EXECUTE
	ON sproc_ar_getAffectedCOTransactions_byBatchID_isReversing
	TO PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_getAffectedCOTransactions_byBatchID_isReversing.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_getAffectedCOTransactions_byBatchID_isReversing.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_getScheduleRates.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*
============================================================================================== 
Purpose:             Get rates by Schedules and Care level or Market Rates 

Params:	             @effScheduleId ar_eff_rate_schedule.eff_schedule_id
                     @careLevel     census_item.rugs_code, ar_rate_detail.care_level, 
                                    ar_lib_care_level_template_item.care_level_code
                     @altCareLevel  census_item.alternate_care_level, ar_rate_detail.care_level, 
                                    ar_lib_care_level_template_item.care_level_code. Ignored if the rates do not use 
                                    an alternate care level.
                     @effScheduleIdForSecondBed
                                    ar_eff_rate_schedule.eff_schedule_id for secondary bed
					 @censusId - used to determine the room id when the client is located				

Return:              Returns first row with the rate for the given schedule_id and care levels,
                     second row with the rate for the given @effScheduleIdForSecondBed and care levels ("additional" flag field is 1 in result output)
                     If there is no rate for the care level given then no row is returned.

Target ENVIRONMENT:  BOTH
Target DB Type:      Client Database
Re-Runable:          YES 

PCC-18397:           Created for Transactions not generating when payer has alt care level but its not used in rates
Written By:          
Reviewed By:         

Sample executions:
	select ci.eff_schedule_id, ci.effective_date, ci.record_type, ci.rugs_code , ci.alternate_care_level , ci.census_id
		, ci.* 
	from census_item ci
	where ci.deleted='N'
		and ci.client_id= 461264
	order by ci.effective_date, ci.record_type

	DECLARE @status_code int,@status_text varchar(3000)

	EXEC dbo.sproc_ar_getScheduleRates 488, 'UNK', '', 589, 10545, 'Y', @status_code OUTPUT, @status_text OUTPUT
==============================================================================================
*/

SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO

IF EXISTS (
	SELECT 1 
	FROM sysobjects 
	WHERE NAME = 'sproc_ar_getScheduleRates'
) 
	DROP PROCEDURE dbo.sproc_ar_getScheduleRates
GO

CREATE PROCEDURE dbo.sproc_ar_getScheduleRates (
	  @effScheduleId INT
	, @careLevel VARCHAR(5)
	, @altCareLevel VARCHAR(5)
	, @effScheduleIdForSecondBed INT
	, @censusId INT
	, @DebugMe CHAR(1) = 'N'
	, @status_code INT OUT
	, @status_text VARCHAR(3000) OUT
	) 
AS 
BEGIN
	SET NOCOUNT ON

	SET @status_code = 0
	DECLARE @error_code int
	
	DECLARE @dailyRate MONEY
	DECLARE @dailyPayRate MONEY
	DECLARE @monthlyRate MONEY
	DECLARE @monthlyPayRate MONEY
	DECLARE @dailyHippsPayRate MONEY
	DECLARE @dailyFlexPayRate MONEY
	DECLARE @monthlyFlexPayRate MONEY

	DECLARE @dailyRateSecondBed MONEY
	DECLARE @dailyPayRateSecondBed MONEY
	DECLARE @monthlyRateSecondBed MONEY
	DECLARE @monthlyPayRateSecondBed MONEY
	
	DECLARE @rateType varchar(30);
	DECLARE @payRateType varchar(30);
	DECLARE @censusInfoXml varchar(MAX) 

	IF EXISTS (SELECT 1 FROM ar_eff_rate_schedule WHERE eff_schedule_id = @effScheduleId AND (is_market_rate = 1 OR is_reimbursement_market_rate = 1))
	BEGIN
		SELECT @dailyRate = fnt.daily_rate,
			   @monthlyRate = fnt.monthly_rate,
			   @dailyPayRate = fnt.daily_pay_rate,
			   @monthlyPayRate = fnt.monthly_pay_rate
	    FROM dbo.fn_ar_getCensusAllMarketRates(@censusId, @effScheduleId, 0) AS fnt	
	END

	IF EXISTS (SELECT 1 FROM ar_eff_rate_schedule WHERE eff_schedule_id = @effScheduleIdForSecondBed AND (is_market_rate = 1 OR is_reimbursement_market_rate = 1))
	BEGIN
		SELECT @dailyRateSecondBed = fnt.daily_rate,
			   @monthlyRateSecondBed  = fnt.monthly_rate,
			   @dailyPayRateSecondBed  = fnt.daily_pay_rate,
			   @monthlyPayRateSecondBed  = fnt.monthly_pay_rate
	    FROM dbo.fn_ar_getCensusAllMarketRates(@censusId, @effScheduleIdForSecondBed, 1) AS fnt	
	END
	
	IF EXISTS (SELECT 1 FROM ar_eff_rate_schedule 
				WHERE eff_schedule_id = @effScheduleId 
						AND (is_custom_rate = 1 AND rate_template_id IS NOT NULL))
	BEGIN
		SELECT 	@dailyRate = convert(money, round((rt.daily_rate*s.rate_template_pct) / 100, 2)), 
				@monthlyRate = convert(money, round((rt.monthly_rate*s.rate_template_pct) / 100, 2))
		from view_ar_eff_rate_schedule s 
			 JOIN census_item ci ON s.eff_schedule_id = ci.eff_schedule_id and ci.deleted <> 'Y'
--			 join ar_payer_care_level paycare on (paycare.payer_id = ci.primary_payer_id)
			 join ar_date_range date_range 
			 		on	date_range.payer_id = isnull(s.payer_id, ci.primary_payer_id)
			 			and date_range.deleted ='N' and date_range.fac_id = s.fac_id
						and ( date_range.eff_date_from <= ISNULL(s.eff_date_from, ci.effective_date) 
							and (ISNULL(s.eff_date_from, ci.effective_date)  < date_range.eff_date_to or date_range.eff_date_to is null) ) 	
			 join view_ar_lib_rate_template_rate rt on s.rate_template_id = rt.rate_template_id
					   AND rt.is_accepted = 1
					   and ci.effective_date >= rt.effective_date
					   and (ci.effective_date < rt.ineffective_date or rt.ineffective_date is null)			  
					   and rt.care_level_code = case when date_range.alt_care_level_template_id = rt.care_level_template_id
												then @altCareLevel else @careLevel end
		where s.eff_schedule_id = @effScheduleId 
	END

	IF EXISTS (SELECT 1 FROM ar_eff_rate_schedule WHERE eff_schedule_id = @effScheduleId AND (is_custom_rate = 1 AND pay_rate_template_id IS NOT NULL))
	BEGIN

	    SELECT @dailyPayRate = convert(money, round((pt.daily_rate*s.pay_rate_template_pct) / 100, 2)), @monthlyPayRate = convert(money, round((pt.monthly_rate*s.pay_rate_template_pct) / 100, 2))	
		from view_ar_eff_rate_schedule s 
		JOIN census_item ci ON s.eff_schedule_id = ci.eff_schedule_id and ci.deleted <> 'Y' 
		join view_ar_lib_rate_template_rate pt on (
                   s.pay_rate_template_id = pt.rate_template_id
                   AND pt.is_accepted = 1
                   and ci.effective_date >= pt.effective_date
                   and (ci.effective_date < pt.ineffective_date or pt.ineffective_date is null)) 
		 where s.eff_schedule_id = @effScheduleId and pt.care_level_code = @careLevel
	END

	IF EXISTS (SELECT 1 FROM ar_eff_rate_schedule 
				WHERE eff_schedule_id = @effScheduleIdForSecondBed 
						AND (is_custom_rate = 1 AND rate_template_id IS NOT NULL))
	BEGIN
		SELECT 	@dailyRateSecondBed = convert(money, round((rt.daily_rate*s.rate_template_pct) / 100, 2)), 
				@monthlyRateSecondBed = convert(money, round((rt.monthly_rate*s.rate_template_pct) / 100, 2))
		from view_ar_eff_rate_schedule s 
			join census_item_secondary_rate cis ON s.eff_schedule_id = cis.eff_schedule_id
			 JOIN census_item ci ON cis.census_id = ci.census_id and ci.deleted <> 'Y'
			 --join ar_payer_care_level paycare on (paycare.payer_id = ci.primary_payer_id)
			 join ar_date_range date_range on 
					date_range.payer_id = isnull(s.payer_id, ci.primary_payer_id) 
					and ( date_range.eff_date_from <= ISNULL(s.eff_date_from, ci.effective_date) 
						and (ISNULL(s.eff_date_from, ci.effective_date)  < date_range.eff_date_to or date_range.eff_date_to is null) ) 			 
			 join view_ar_lib_rate_template_rate rt on s.rate_template_id = rt.rate_template_id
					   AND rt.is_accepted = 1
					   and ci.effective_date >= rt.effective_date
					   and (ci.effective_date < rt.ineffective_date or rt.ineffective_date is null)			  
					   and rt.care_level_code = case when date_range.alt_care_level_template_id = rt.care_level_template_id
												then @altCareLevel else @careLevel end
		where s.eff_schedule_id = @effScheduleIdForSecondBed 
	END

	IF EXISTS (SELECT 1 FROM ar_eff_rate_schedule WHERE eff_schedule_id = @effScheduleIdForSecondBed AND (is_custom_rate = 1 AND pay_rate_template_id IS NOT NULL))
	BEGIN

	    SELECT @dailyPayRateSecondBed = convert(money, round((pt.daily_rate*s.pay_rate_template_pct) / 100, 2)), @monthlyPayRateSecondBed = convert(money, round((pt.monthly_rate*s.pay_rate_template_pct) / 100, 2))	
		from view_ar_eff_rate_schedule s 
			join census_item_secondary_rate cis ON s.eff_schedule_id = cis.eff_schedule_id
			 JOIN census_item ci ON cis.census_id = ci.census_id and ci.deleted <> 'Y' 
			 join view_ar_lib_rate_template_rate pt on (
                   s.pay_rate_template_id = pt.rate_template_id
                   AND pt.is_accepted = 1
                   and ci.effective_date >= pt.effective_date
                   and (ci.effective_date < pt.ineffective_date or pt.ineffective_date is null)) 
		 where s.eff_schedule_id = @effScheduleIdForSecondBed and pt.care_level_code = @careLevel
	END
	
	IF EXISTS (select 1 from census_item where census_id = @censusId and contract_census_id is not null and deleted <> 'Y' ) 
	begin
	  set @censusInfoXml = 
		'<row> <effScheduleId>'+CAST(@effScheduleId as varchar)+'</effScheduleId>' +
		'<careLevel>'+@careLevel+'</careLevel><altCareLevel></altCareLevel>'+
		'<censusId>'+CAST(@censusId as varchar)+'</censusId>' +
		'<additionalLocation>0</additionalLocation></row>'

	 select  @dailyFlexPayRate = daily_pay_rate, @monthlyFlexPayRate = monthly_pay_rate from dbo.fn_ar_censusAllRates( @censusInfoXml)
	 set @payRateType = 'FLEXIBLE_RATE';
	end 	

	IF EXISTS (SELECT 1 FROM ar_eff_rate_schedule WHERE eff_schedule_id = @effScheduleId AND (is_reimbursement_use_hipps=1))
	begin
	  set @censusInfoXml  = 
		'<row> <effScheduleId>'+CAST(@effScheduleId as varchar)+'</effScheduleId>' +
		'<careLevel>'+@careLevel+'</careLevel><altCareLevel></altCareLevel>'+
		'<censusId>'+CAST(@censusId as varchar)+'</censusId>' +
		'<additionalLocation>0</additionalLocation></row>'

	 select  @dailyHippsPayRate = daily_pay_rate, @monthlyPayRate = null from dbo.fn_ar_censusAllRates( @censusInfoXml)
	 set @payRateType = 'REIMBURSEMENT_USE_HIPPS';
	end 
	
	BEGIN TRY
		SELECT TOP 1
			  s.eff_schedule_id
			, s.payer_id
			, s.dollars_account_id
			, s.days_account_id
			, s.eff_date_range_id
			, s.eff_schedule_id
			, s.adj_account_id
			, s.fixed_room_charge_amount
			, s.fixed_room_charge_account_id
			, s.fixed_room_charge_revenue_code

			-- If revenue code is by care level then get the revenue code from the rate line. PCC-18759
			, CASE
				WHEN s.is_revenue_code_by_care_level = 1 
				THEN ISNULL(p.revenue_code, r.revenue_code)
				ELSE s.revenue_code
				END AS revenue_code
			, s.rate_type_id
			, s.coverage_account_id
			, s.eff_date_from
			, s.eff_date_to
			, CASE
				WHEN (s.is_market_rate = 1 or (s.is_custom_rate = 1 AND s.rate_template_id IS NOT NULL))
				THEN @dailyRate
				ELSE r.daily_rate
				END AS daily_rate
			, CASE
				WHEN (s.is_market_rate = 1 or (s.is_custom_rate = 1 AND s.rate_template_id IS NOT NULL))
				THEN @monthlyRate
				ELSE r.monthly_rate
				END AS monthly_rate
			, CASE
				WHEN (s.is_reimbursement_market_rate = 1 OR (s.is_custom_rate = 1 AND s.pay_rate_template_id IS NOT NULL))
					THEN @dailyPayRate
				WHEN (s.is_reimbursement_use_hipps = 1)
					THEN @dailyHippsPayRate
				WHEN (s.is_flexible_pay_rate = 1 )
					THEN @dailyFlexPayRate
				ELSE p.daily_pay_rate
				END AS daily_pay_rate
			, CASE
				WHEN (s.is_reimbursement_market_rate = 1 OR (s.is_custom_rate = 1 AND s.pay_rate_template_id IS NOT NULL))
					THEN @monthlyPayRate
				WHEN (s.is_flexible_pay_rate = 1 )
					THEN @monthlyFlexPayRate
				ELSE p.monthly_pay_rate
				END AS monthly_pay_rate
			, ISNULL(p.item_type_id, r.item_type_id)
			, CONVERT(BIT, 0) AS additional
			, CASE
				WHEN s.is_custom_rate = 1 THEN 'CUSTOM_RATE'
				WHEN s.rate_template_id is not null  THEN 'RATE_TEMPLATE'
				WHEN s.is_market_rate = 1 THEN 'MARKET_RATE'
				ELSE 'MANUAL_RATE'
				END  AS std_rate_type
			, @payRateType pay_rate_type
		FROM view_ar_eff_rate_schedule s
			LEFT JOIN view_ar_rate_detail r
				ON (s.eff_schedule_id = r.eff_schedule_id
					AND r.is_care_level_alternate = r.join_std_using_alternate_care_level
					AND r.care_level =
						CASE
							WHEN r.join_std_using_alternate_care_level = 1 THEN @altCareLevel
							ELSE @careLevel
						END)
			LEFT JOIN view_ar_rate_detail p
				ON (s.eff_schedule_id = p.eff_schedule_id
					AND p.is_care_level_alternate = p.join_pay_using_alternate_care_level
					AND p.care_level =
						CASE
							WHEN p.join_pay_using_alternate_care_level = 1 THEN @altCareLevel
							ELSE @careLevel
						END)
		WHERE
			s.eff_schedule_id = @effScheduleId
			-- Return no row if there are no rates.
			AND (r.care_level IS NOT NULL OR p.care_level IS NOT NULL OR s.is_market_rate = 1 OR s.is_reimbursement_market_rate = 1)		
		UNION ALL
		SELECT TOP 1
			  s.eff_schedule_id
			, s.payer_id
			, s.dollars_account_id
			, s.days_account_id
			, s.eff_date_range_id
			, s.eff_schedule_id
			, s.adj_account_id
			, s.fixed_room_charge_amount
			, s.fixed_room_charge_account_id
			, s.fixed_room_charge_revenue_code

			-- If revenue code is by care level then get the revenue code from the rate line. PCC-18759
			, CASE
				WHEN s.is_revenue_code_by_care_level = 1 
				THEN ISNULL(p.revenue_code, r.revenue_code)
				ELSE s.revenue_code
				END AS revenue_code
			, s.rate_type_id
			, s.coverage_account_id
			, s.eff_date_from
			, s.eff_date_to
			, CASE
				WHEN (s.is_market_rate = 1 or (s.is_custom_rate = 1 AND s.rate_template_id IS NOT NULL))
				THEN @dailyRateSecondBed
				ELSE r.daily_rate
				END AS daily_rate
			, CASE
				WHEN (s.is_market_rate = 1 or (s.is_custom_rate = 1 AND s.rate_template_id IS NOT NULL))
				THEN @monthlyRateSecondBed
				ELSE r.monthly_rate
				END AS monthly_rate
			, CASE
				WHEN (s.is_reimbursement_market_rate = 1 OR (s.is_custom_rate = 1 AND s.pay_rate_template_id IS NOT NULL))
				THEN @dailyPayRateSecondBed
				ELSE p.daily_pay_rate
				END AS daily_pay_rate
			, CASE
				WHEN (s.is_reimbursement_market_rate = 1 OR (s.is_custom_rate = 1 AND s.pay_rate_template_id IS NOT NULL))
				THEN @monthlyPayRateSecondBed
				ELSE p.monthly_pay_rate
				END AS monthly_pay_rate
			, ISNULL(p.item_type_id, r.item_type_id)
			, CONVERT(BIT, 1) AS additional
			, @rateType std_rate_type
			, @payRateType pay_rate_type
		FROM view_ar_eff_rate_schedule s
			LEFT JOIN view_ar_rate_detail r
				ON (s.eff_schedule_id = r.eff_schedule_id
					AND r.is_care_level_alternate = r.join_std_using_alternate_care_level
					AND r.care_level =
						CASE
							WHEN r.join_std_using_alternate_care_level = 1 THEN @altCareLevel
							ELSE @careLevel
						END)
			LEFT JOIN view_ar_rate_detail p
				ON (s.eff_schedule_id = p.eff_schedule_id
					AND p.is_care_level_alternate = p.join_pay_using_alternate_care_level
					AND p.care_level =
						CASE
							WHEN p.join_pay_using_alternate_care_level = 1 THEN @altCareLevel
							ELSE @careLevel
						END)
		WHERE
			s.eff_schedule_id = @effScheduleIdForSecondBed
			-- Return no row if there are no rates.
			AND (r.care_level IS NOT NULL OR p.care_level IS NOT NULL OR s.is_market_rate = 1 OR s.is_reimbursement_market_rate = 1)

	END TRY

	BEGIN CATCH
		SET @error_code = @@error
		SET @status_text = ERROR_MESSAGE()
		SET @status_code = 1

		GOTO PgmAbend
	END CATCH

	PgmSuccess:
	IF @status_code = 0
	BEGIN
		IF @DebugMe='Y' 
			PRINT 'Successful execution of stored procedure'
		
		RETURN
	END
		
	PgmAbend:
	IF @DebugMe='Y'
	BEGIN
		PRINT 'Stored procedure failure: ' + convert(varchar(26),getdate(),109)
		PRINT 'Error code: ' + convert(varchar(3),@error_code) + '; Error description:' + @status_text
	END
	RAISERROR (@status_text, 16, 1)
END
GO

GRANT EXECUTE ON dbo.sproc_ar_getScheduleRates TO PUBLIC
GO

SET ANSI_NULLS OFF
SET QUOTED_IDENTIFIER OFF
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_getScheduleRates.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_getScheduleRates.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_getTransactionsByInvoice.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*
================================================================================= 
Purpose:             
                     
Target ENVIRONMENT:  BOTH
Target DB Type:      Client Database
Re-Runable:          YES 

Return:              

Sample executions:   
DECLARE @status_code int, @status_text varchar(3000) 
EXEC dbo.sproc_ar_getTransactionsByInvoice 
  @invoiceId = 46391317 
  , @trialFlag = 'Y' 
  , @facId = 97 
  , @debugFlag = 'N' 
  , @statusCode = @status_code 
  , @statusText = @status_text
=================================================================================
*/

SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO

IF EXISTS (SELECT 1 FROM sysobjects WHERE name = 'sproc_ar_getTransactionsByInvoice')
    DROP procedure sproc_ar_getTransactionsByInvoice
GO

CREATE PROCEDURE dbo.sproc_ar_getTransactionsByInvoice
(
  @invoiceId          INT,
  @trialFlag          VARCHAR(1),
  @facId              INT,
  @debug              CHAR(1) = 'N',
  @status_code        INT = 0       OUT,
  @status_text        VARCHAR(3000) OUT
)
AS

BEGIN
  SET NOCOUNT ON
  
  DECLARE @vInvoiceId          INT,
          @vTrialFlag          VARCHAR(1),
          @vFacId              INT,
          @step                CHAR(1),
          @errorCode           INT

  SET @vInvoiceId = @invoiceId
  SET @vTrialFlag = @trialFlag
  SET @vFacId = @facId
  SET @step = '1' 
  
  CREATE TABLE #tmpTrans 
  (
    transaction_id int
  )  
  
  BEGIN TRY     
    IF(@debug='Y') 
    BEGIN 
      PRINT 'BEGIN STEP ' + @step + ': get all trainsation_id and store into temp table ' + CONVERT(varchar(26), getdate(), 109) 
    END

    INSERT INTO #tmpTrans
    (transaction_id)
    SELECT t.transaction_id
    FROM ar_transactions t
    WHERE (
           (@vTrialFlag <> 'Y' AND t.invoice_id = @vInvoiceId) 
    	 OR
           (@vTrialFlag = 'Y' AND t.invoice_id IS NULL AND t.trial_invoice_id = @vInvoiceId)
          ) 
      AND case 
            when exists (select 1
                         from ar_batch_errors 
                         where ar_batch_errors.transaction_id=t.transaction_id
                           and ((warning_flag='N' and field_code like 'IE%') 
                                 or 
                                (warning_flag='Y' and field_code like 'IW%'))
                         ) 
              then 1 
            else 0 
          end = 0
      AND (@vFacId = -1 OR t.fac_id = @vFacId) 
      AND t.deleted = 'N'
      
    SET @step = '2'   
    IF(@debug='Y') 
    BEGIN 
      PRINT 'BEGIN STEP ' + @step + ': select all required columns and return the result ' + CONVERT(varchar(26), getdate(), 109) 
    END
      
    SELECT isnull(t.distribution_tx_id, t.transaction_id) AS distribution_tx_id,
           t.transaction_id,
           CASE 
             WHEN txnAssess2.pdpm_flag = 1 OR rateSchedule.is_reimbursement_use_hipps = 1
               THEN txnAssess2.hipps_code
             ELSE t.care_level
           END AS care_level,
           CASE 
             WHEN ISNULL(txnAssess2.pdpm_flag, 0) = 0 OR arConfig.financial_only = 'Y' OR txnAssess2.hipps_code = 'ZZZZZ' or assess.status IN ('Accepted', 'Completed') 
               THEN 1 
             ELSE 0 
           END AS is_billable,
           CASE 
             WHEN txnAssess2.pdpm_flag = 1 
               THEN 1
             ELSE 0
           END AS is_pdpm,
           t.transaction_type,
           t.revenue_code,
           recurRef.recurring_tx_id,
           t.reduce_deductible_type,
           t.effective_date,
           t.fac_id,
           t.hcpcs_code,
           CASE 
             WHEN txnAssess2.pdpm_flag = 1 OR rateSchedule.is_reimbursement_use_hipps = 1 
               THEN ''
             ELSE t.rugs_modifier
           END AS rugs_modifier,
           t.therapy_modifier,
           t.therapy_modifier2,
           t.therapy_modifier3,
           t.daily_rate,
           t.days_amount,
           t.days_pay_amount,
           t.amount,
           t.mppr_flag,
           convert(BIT, CASE WHEN mppr_bumpup.bumpup_transaction_id IS NULL THEN 0 ELSE 1 END) AS mppr_bumpup_flag,
           CASE 
             WHEN txnAssess2.pdpm_flag = 1 
               THEN txnAssess2.pps_assessment_id
             ELSE NULL
           END AS invoice_assessment_id,
           t.assess_ref_date,
           txnAssess2.hipps_code,
           txnAssess.assessment_rug_id,
           CASE 
             WHEN txnAssess2.pdpm_flag = 1 OR rateSchedule.is_reimbursement_use_hipps = 1 
               THEN txnAssess2.hipps_code
             ELSE assessRug.code
           END AS rug_code,
           t.payer_id,
           range.reimbursement_type,
           stat.action_type AS status_type,
           t.parent_tx_type,
           recurringtx.charge_frequency,
           recurringtx.days_amount AS recurring_days_amount,
           recurringtx.prorate,
           recurringtx.daily_rate as recurring_tx_daily_rate,
           rateSchedule.is_reimbursement_use_hipps 
    FROM #tmpTrans tt
    JOIN ar_transactions t
      ON tt.transaction_id = t.transaction_id
    LEFT JOIN census_codes stat 
      ON t.status_code_id = stat.item_id
    INNER JOIN ar_date_range range 
      ON t.payer_id = range.payer_id
     AND t.fac_id = range.fac_id
     AND t.effective_date >= range.eff_date_from 
     AND (range.eff_date_to IS NULL OR t.effective_date <= range.eff_date_to)
     AND range.deleted = 'N'
    LEFT JOIN ar_mppr_bumpup mppr_bumpup 
      ON t.distribution_tx_id = mppr_bumpup.bumpup_transaction_id
    LEFT JOIN ar_transaction_assessment_info txnAssess 
      ON t.transaction_id=txnAssess.transaction_id
    LEFT JOIN as_std_rug_code assessRug 
      ON txnAssess.assessment_rug_id=assessRug.rug_code_id
    LEFT JOIN ar_transaction_assessment_info txnAssess2 
      ON t.distribution_tx_id=txnAssess2.transaction_id
    LEFT JOIN as_assessment assess 
      ON assess.assess_id = txnAssess2.pps_assessment_id 
     AND assess.deleted = 'N' AND assess.std_assess_id = 11
    LEFT JOIN ar_configuration arConfig 
      ON arConfig.fac_id = t.fac_id
    LEFT JOIN ar_transaction_recurring_tx_refs recurRef
      ON t.transaction_id = recurRef.transaction_id
	LEFT JOIN ar_recurring_transactions recurringtx 
	  ON recurRef.recurring_tx_id = recurringtx.transaction_id
	 AND recurringtx.deleted = 'N'
    LEFT JOIN ar_eff_rate_schedule rateSchedule
      ON t.eff_schedule_id = rateSchedule.eff_schedule_id  
    ORDER BY t.effective_date, t.distribution_tx_id, t.transaction_id  
  END TRY    
    
  BEGIN CATCH
    SELECT @errorCode = @@error, @status_text = ERROR_MESSAGE()
    SELECT @status_code = 1
    PRINT 'Stored procedure failure in step: '+ @step + '    ' + convert(varchar(26),getdate())
    PRINT 'Error code: '+ CAST(@errorCode AS VARCHAR) + '; Error description:    ' + @status_text
    GOTO PgmAbend
  END CATCH

  SET @status_code = 0

  --program success return
  PgmSuccess:
  BEGIN
    IF @status_code = 0 AND @debug='Y' 
      PRINT 'Successfull execution of stored procedure'    
  END
  
  --program failure return
  PgmAbend:
  BEGIN
    IF @status_code = 1 AND @debug='Y'
    BEGIN
      PRINT 'Stored procedure failure in step: '+ @step + '    ' + convert(varchar(26),getdate())
      PRINT 'Error code: '+ CAST(@errorCode AS VARCHAR) + '; Error description:    ' + @status_text
    END 
  END

END
GO

GRANT EXECUTE ON sproc_ar_getTransactionsByInvoice TO PUBLIC
GO

SET ANSI_NULLS OFF
SET QUOTED_IDENTIFIER OFF
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_getTransactionsByInvoice.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_getTransactionsByInvoice.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_getTransactionsByInvoice_adjustment.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*
================================================================================= 
Purpose:             
                     
Target ENVIRONMENT:  BOTH
Target DB Type:      Client Database
Re-Runable:          YES 

Return:              

Sample executions:   
DECLARE @status_code int, @status_text varchar(3000) 
EXEC dbo.sproc_ar_getTransactionsByInvoice_adjustment 
  @invoiceId = 46391317 
  , @trialFlag = 'Y' 
  , @facId = 97 
  , @debugFlag = 'N' 
  , @statusCode = @status_code 
  , @statusText = @status_text
=================================================================================
*/

SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO

IF EXISTS (SELECT 1 FROM sysobjects WHERE name = 'sproc_ar_getTransactionsByInvoice_adjustment')
    DROP procedure sproc_ar_getTransactionsByInvoice_adjustment
GO

CREATE PROCEDURE dbo.sproc_ar_getTransactionsByInvoice_adjustment
(
  @invoiceId          INT,
  @trialFlag          VARCHAR(1),
  @facId              INT,
  @debug              CHAR(1) = 'N',
  @status_code        INT = 0       OUT,
  @status_text        VARCHAR(3000) OUT
)
AS

BEGIN
  SET NOCOUNT ON
  
  DECLARE @vInvoiceId          INT,
          @vTrialFlag          VARCHAR(1),
          @vFacId              INT,
          @step                CHAR(1),
          @errorCode           INT          

  SET @vInvoiceId = @invoiceId
  SET @vTrialFlag = @trialFlag
  SET @vFacId = @facId
  SET @step = '1'   
  
  CREATE TABLE #tmpTrans 
  (
    transaction_id int
  )  
  
  BEGIN TRY     
    IF(@debug='Y') 
    BEGIN 
      PRINT 'BEGIN STEP ' + @step + ': get all trainsation_id and store into temp table ' + CONVERT(varchar(26), getdate(), 109) 
    END  

    INSERT INTO #tmpTrans
    (transaction_id)
    SELECT t.transaction_id
    FROM ar_transactions t
    WHERE t.reversing_tx_id IS NULL 
      AND (
           (@vTrialFlag <> 'Y' AND t.invoice_id = @vInvoiceId) 
    	 OR
           (@vTrialFlag = 'Y' AND t.invoice_id IS NULL AND t.trial_invoice_id = @vInvoiceId)
    	)
      AND case 
            when exists (select 1
                         from ar_batch_errors 
                         where ar_batch_errors.transaction_id=t.transaction_id
                           and ((warning_flag='N' and field_code like 'IE%') 
                                 or 
                                (warning_flag='Y' and field_code like 'IW%'))
                         ) 
              then 1 
            else 0 
          end = 0 
      AND (@vFacId = -1 OR t.fac_id = @vFacId) 
      AND t.deleted = 'N'
      
    SET @step = '2'   
    IF(@debug='Y') 
    BEGIN 
      PRINT 'BEGIN STEP ' + @step + ': select all required columns and return the result ' + CONVERT(varchar(26), getdate(), 109) 
    END  
    
    SELECT isnull(t.distribution_tx_id, t.transaction_id) AS distribution_tx_id,
             t.transaction_id,
             CASE 
               WHEN txnAssess2.pdpm_flag = 1 OR rateSchedule.is_reimbursement_use_hipps = 1 
                 THEN txnAssess2.hipps_code
               ELSE t.care_level
             END AS care_level,
             CASE 
               WHEN ISNULL(txnAssess2.pdpm_flag, 0) = 0 OR arConfig.financial_only = 'Y' OR txnAssess2.hipps_code = 'ZZZZZ' or assess.status IN ('Accepted', 'Completed') 
                 THEN 1 
               ELSE 0 
             END AS is_billable,
             CASE 
               WHEN txnAssess2.pdpm_flag = 1 
                 THEN 1
               ELSE 0
             END AS is_pdpm,
             t.transaction_type,
             t.revenue_code,
             recurRef.recurring_tx_id,
             t.reduce_deductible_type,
             t.effective_date,
             t.fac_id,
             t.hcpcs_code,
             CASE 
               WHEN txnAssess2.pdpm_flag = 1 OR rateSchedule.is_reimbursement_use_hipps = 1 
                 THEN ''
               ELSE t.rugs_modifier
             END AS rugs_modifier,
             t.therapy_modifier,
             t.therapy_modifier2,
             t.therapy_modifier3,
             t.daily_rate,
             t.days_amount,
             t.days_pay_amount,
             t.amount,
             t.mppr_flag,
             convert(BIT, CASE WHEN mppr_bumpup.bumpup_transaction_id IS NULL THEN 0 ELSE 1 END) AS mppr_bumpup_flag,
             CASE 
               WHEN txnAssess2.pdpm_flag = 1 
                 THEN txnAssess2.pps_assessment_id
               ELSE NULL
             END AS invoice_assessment_id,
             t.assess_ref_date,
             txnAssess2.hipps_code,
             txnAssess.assessment_rug_id,
             CASE 
               WHEN txnAssess2.pdpm_flag = 1 OR rateSchedule.is_reimbursement_use_hipps = 1 
                 THEN txnAssess2.hipps_code
               ELSE assessRug.code
             END AS rug_code,
             t.payer_id,
             range.reimbursement_type,
             stat.action_type AS status_type,
             t.parent_tx_type,
             recurringtx.charge_frequency,
             recurringtx.days_amount AS recurring_days_amount,
             recurringtx.prorate,
             recurringtx.daily_rate as recurring_tx_daily_rate,
             rateSchedule.is_reimbursement_use_hipps 
      FROM #tmpTrans tt
      JOIN ar_transactions t
        ON tt.transaction_id = t.transaction_id
      LEFT JOIN census_codes stat 
        ON t.status_code_id = stat.item_id
      INNER JOIN ar_date_range range 
        ON t.payer_id = range.payer_id
       AND t.fac_id = range.fac_id
       AND t.effective_date >= range.eff_date_from 
       AND (range.eff_date_to IS NULL OR t.effective_date <= range.eff_date_to)
       AND range.deleted = 'N'
      LEFT JOIN ar_mppr_bumpup mppr_bumpup 
        ON t.distribution_tx_id = mppr_bumpup.bumpup_transaction_id
      LEFT JOIN ar_transaction_assessment_info txnAssess 
        ON t.transaction_id=txnAssess.transaction_id
      LEFT JOIN as_std_rug_code assessRug 
        ON txnAssess.assessment_rug_id=assessRug.rug_code_id
      LEFT JOIN ar_transaction_assessment_info txnAssess2 
        ON t.distribution_tx_id=txnAssess2.transaction_id
      LEFT JOIN as_assessment assess 
        ON assess.assess_id = txnAssess2.pps_assessment_id 
       AND assess.deleted = 'N' AND assess.std_assess_id = 11
      LEFT JOIN ar_configuration arConfig 
        ON arConfig.fac_id = t.fac_id
      LEFT JOIN ar_transaction_recurring_tx_refs recurRef
        ON t.transaction_id = recurRef.transaction_id
	  LEFT JOIN ar_recurring_transactions recurringtx 
	    ON recurRef.recurring_tx_id = recurringtx.transaction_id
	   AND recurringtx.deleted = 'N'	
      LEFT JOIN ar_eff_rate_schedule rateSchedule
        ON t.eff_schedule_id = rateSchedule.eff_schedule_id
    ORDER BY t.effective_date, t.distribution_tx_id, t.transaction_id
    
  END TRY    
    
  BEGIN CATCH
    SELECT @errorCode = @@error, @status_text = ERROR_MESSAGE()
    SELECT @status_code = 1
    PRINT 'Stored procedure failure in step: '+ @step + '    ' + convert(varchar(26),getdate())
    PRINT 'Error code: '+ CAST(@errorCode AS VARCHAR) + '; Error description:    ' + @status_text
    GOTO PgmAbend
  END CATCH

  SET @status_code = 0

  --program success return
  PgmSuccess:
  BEGIN
    IF @status_code = 0 AND @debug='Y' 
      PRINT 'Successfull execution of stored procedure'    
  END
  
  --program failure return
  PgmAbend:
  BEGIN
    IF @status_code = 1 AND @debug='Y'
    BEGIN
      PRINT 'Stored procedure failure in step: '+ @step + '    ' + convert(varchar(26),getdate())
      PRINT 'Error code: '+ CAST(@errorCode AS VARCHAR) + '; Error description:    ' + @status_text
    END 
  END
  
END
GO

GRANT EXECUTE ON sproc_ar_getTransactionsByInvoice_adjustment TO PUBLIC
GO

SET ANSI_NULLS OFF
SET QUOTED_IDENTIFIER OFF
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_getTransactionsByInvoice_adjustment.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_getTransactionsByInvoice_adjustment.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_getTransactionsByInvoice_adjustment_combined.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*
================================================================================= 
Purpose:             
                     
Target ENVIRONMENT:  BOTH
Target DB Type:      Client Database
Re-Runable:          YES 

Return:              

Sample executions:   
DECLARE @status_code int, @status_text varchar(3000) 
EXEC dbo.sproc_ar_getTransactionsByInvoice_adjustment_combined 
  @invoiceId = 46391317 
  , @originalInvoiceId = 45727783 
  , @trialFlag = 'Y' 
  , @facId = 97 
  , @debugFlag = 'N' 
  , @statusCode = @status_code 
  , @statusText = @status_text
=================================================================================
*/

SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO

IF EXISTS (SELECT 1 FROM sysobjects WHERE name = 'sproc_ar_getTransactionsByInvoice_adjustment_combined')
    DROP procedure sproc_ar_getTransactionsByInvoice_adjustment_combined
GO

CREATE PROCEDURE dbo.sproc_ar_getTransactionsByInvoice_adjustment_combined
(
  @invoiceId          INT,
  @originalInvoiceId INT,
  @trialFlag          VARCHAR(1),
  @facId              INT,
  @debug              CHAR(1) = 'N',
  @status_code        INT = 0       OUT,
  @status_text        VARCHAR(3000) OUT
)
AS

BEGIN
  SET NOCOUNT ON
  
  DECLARE @vInvoiceId          INT,
          @vOriginalInvoiceId INT,
          @vTrialFlag          VARCHAR(1),
          @vFacId              INT,
          @step                CHAR(1),
          @errorCode           INT    

  SET @vInvoiceId = @invoiceId
  SET @vOriginalInvoiceId = @originalInvoiceId
  SET @vTrialFlag = @trialFlag
  SET @vFacId = @facId
  SET @step = '1'    
  
  CREATE TABLE #tmpTrans 
  (
    transaction_id int
  )  

  BEGIN TRY     
    IF(@debug='Y') 
    BEGIN 
      PRINT 'BEGIN STEP ' + @step + ': get all trainsation_id and store into temp table ' + CONVERT(varchar(26), getdate(), 109) 
    END  
    
    INSERT INTO #tmpTrans
    (transaction_id)
    SELECT t.transaction_id
    FROM ar_transactions t
    WHERE t.reversing_tx_id IS NULL 
      AND (
           (@vTrialFlag <> 'Y' AND t.invoice_id = @vInvoiceId) 
    	 OR
           (@vTrialFlag = 'Y' AND t.invoice_id IS NULL AND t.trial_invoice_id = @vInvoiceId) 
    	 OR 
    	 t.invoice_id = @vOriginalInvoiceId
    	)
      AND case 
            when exists (select 1
                         from ar_batch_errors 
                         where ar_batch_errors.transaction_id=t.transaction_id
                           and ((warning_flag='N' and field_code like 'IE%') 
                                 or 
                                (warning_flag='Y' and field_code like 'IW%'))
                         ) 
              then 1 
            else 0 
          end = 0
      AND (@vFacId = -1 OR t.fac_id = @vFacId) 
      AND t.deleted = 'N'
    UNION
    SELECT t1.transaction_id
    FROM ar_transactions t1
    LEFT JOIN ar_invoice invoice 
      ON t1.invoice_id = invoice.invoice_id
    WHERE t1.REVERSING_TX_ID IS NULL 
      AND invoice.original_invoice_id = @vOriginalInvoiceId
      AND case 
            when exists (select 1
                         from ar_batch_errors 
                         where ar_batch_errors.transaction_id=t1.transaction_id
                           and ((warning_flag='N' and field_code like 'IE%') 
                                 or 
                                (warning_flag='Y' and field_code like 'IW%'))
                         ) 
              then 1 
            else 0 
          end = 0 
      AND (@vFacId = -1 OR t1.fac_id = @vFacId) 
      AND t1.deleted = 'N'
      
    SET @step = '2'   
    IF(@debug='Y') 
    BEGIN 
      PRINT 'BEGIN STEP ' + @step + ': select all required columns and return the result ' + CONVERT(varchar(26), getdate(), 109) 
    END        
    SELECT isnull(t.distribution_tx_id, t.transaction_id) AS distribution_tx_id,
           t.transaction_id,
           CASE 
             WHEN txnAssess2.pdpm_flag = 1 OR rateSchedule.is_reimbursement_use_hipps = 1 
               THEN txnAssess2.hipps_code
             ELSE t.care_level
           END AS care_level,
           CASE 
             WHEN ISNULL(txnAssess2.pdpm_flag, 0) = 0 OR arConfig.financial_only = 'Y' OR txnAssess2.hipps_code = 'ZZZZZ' or assess.status IN ('Accepted', 'Completed') 
               THEN 1 
             ELSE 0 
           END AS is_billable,
           CASE 
             WHEN txnAssess2.pdpm_flag = 1 
               THEN 1
             ELSE 0
           END AS is_pdpm,
           t.transaction_type,
           t.revenue_code,
           recurRef.recurring_tx_id,
           t.reduce_deductible_type,
           t.effective_date,
           t.fac_id,
           t.hcpcs_code,
           CASE 
             WHEN txnAssess2.pdpm_flag = 1 OR rateSchedule.is_reimbursement_use_hipps = 1 
               THEN ''
             ELSE t.rugs_modifier
           END AS rugs_modifier,
           t.therapy_modifier,
           t.therapy_modifier2,
           t.therapy_modifier3,
           t.daily_rate,
           t.days_amount,
           t.days_pay_amount,
           t.amount,
           t.mppr_flag,
           convert(BIT, CASE WHEN mppr_bumpup.bumpup_transaction_id IS NULL THEN 0 ELSE 1 END) AS mppr_bumpup_flag,
           CASE 
             WHEN txnAssess2.pdpm_flag = 1 
               THEN txnAssess2.pps_assessment_id
             ELSE NULL
           END AS invoice_assessment_id,
           t.assess_ref_date,
           txnAssess2.hipps_code,
           txnAssess.assessment_rug_id,
           CASE 
             WHEN txnAssess2.pdpm_flag = 1 OR rateSchedule.is_reimbursement_use_hipps = 1 
               THEN txnAssess2.hipps_code
             ELSE assessRug.code
           END AS rug_code,
           t.payer_id,
           range.reimbursement_type,
           stat.action_type AS status_type,
           t.parent_tx_type,
           recurringtx.charge_frequency,
           recurringtx.days_amount AS recurring_days_amount,
           recurringtx.prorate,
           recurringtx.daily_rate as recurring_tx_daily_rate,
           rateSchedule.is_reimbursement_use_hipps
    FROM #tmpTrans tt
    JOIN ar_transactions t
      ON tt.transaction_id = t.transaction_id
    LEFT JOIN census_codes stat 
      ON t.status_code_id = stat.item_id
    INNER JOIN ar_date_range range 
      ON t.payer_id = range.payer_id
     AND t.fac_id = range.fac_id
     AND t.effective_date >= range.eff_date_from 
     AND (range.eff_date_to IS NULL OR t.effective_date <= range.eff_date_to)
     AND range.deleted = 'N'
    LEFT JOIN ar_mppr_bumpup mppr_bumpup 
      ON t.distribution_tx_id = mppr_bumpup.bumpup_transaction_id
    LEFT JOIN ar_transaction_assessment_info txnAssess 
      ON t.transaction_id=txnAssess.transaction_id
    LEFT JOIN as_std_rug_code assessRug 
      ON txnAssess.assessment_rug_id=assessRug.rug_code_id
    LEFT JOIN ar_transaction_assessment_info txnAssess2 
      ON t.distribution_tx_id=txnAssess2.transaction_id
    LEFT JOIN as_assessment assess 
      ON assess.assess_id = txnAssess2.pps_assessment_id 
     AND assess.deleted = 'N' AND assess.std_assess_id = 11
    LEFT JOIN ar_configuration arConfig 
      ON arConfig.fac_id = t.fac_id
    LEFT JOIN ar_transaction_recurring_tx_refs recurRef
      ON t.transaction_id = recurRef.transaction_id
	LEFT JOIN ar_recurring_transactions recurringtx 
	  ON recurRef.recurring_tx_id = recurringtx.transaction_id
	 AND recurringtx.deleted = 'N'
    LEFT JOIN ar_eff_rate_schedule rateSchedule
      ON t.eff_schedule_id = rateSchedule.eff_schedule_id
    ORDER BY t.effective_date, t.distribution_tx_id, t.transaction_id 
    
  END TRY    
    
  BEGIN CATCH
    SELECT @errorCode = @@error, @status_text = ERROR_MESSAGE()
    SELECT @status_code = 1
    PRINT 'Stored procedure failure in step: '+ @step + '    ' + convert(varchar(26),getdate())
    PRINT 'Error code: '+ CAST(@errorCode AS VARCHAR) + '; Error description:    ' + @status_text
    GOTO PgmAbend
  END CATCH

  SET @status_code = 0

  --program success return
  PgmSuccess:
  BEGIN
    IF @status_code = 0 AND @debug='Y' 
      PRINT 'Successfull execution of stored procedure'    
  END
  
  --program failure return
  PgmAbend:
  BEGIN
    IF @status_code = 1 AND @debug='Y'
    BEGIN
      PRINT 'Stored procedure failure in step: '+ @step + '    ' + convert(varchar(26),getdate())
      PRINT 'Error code: '+ CAST(@errorCode AS VARCHAR) + '; Error description:    ' + @status_text
    END 
  END    
END
GO

GRANT EXECUTE ON sproc_ar_getTransactionsByInvoice_adjustment_combined TO PUBLIC
GO

SET ANSI_NULLS OFF
SET QUOTED_IDENTIFIER OFF
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_getTransactionsByInvoice_adjustment_combined.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_getTransactionsByInvoice_adjustment_combined.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_isPayerReimbursedBasedOnHipps.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*
==============================================================================================
Purpose:               Check if payer is payer reimbursed based on HIPPS on a specific date

Target ENVIRONMENT:    BOTH
Target DB Type:        Client Database
Re-Runable:            YES

CORE-96488: - https://jira.pointclickcare.com/jira/browse/CORE-96488
Written By:            Martin OConnor (oconm) , Sherry Lyu (lyux) and Sanjay Patel (patelsan)

Description:           Check if payer is using reimbursed based on HIPPS on a specific date by looking at the appropriate payer date range.

Sample/Test executions in Abhow DB:
DECLARE @status_code int, @status_text VARCHAR(3000);
EXEC dbo.sproc_ar_isPayerReimbursedBasedOnHipps 622, 1, '2014-01-01', 'N', @status_code, @status_text;
==============================================================================================
*/

IF EXISTS (
		SELECT 1
		FROM dbo.sysobjects
		WHERE id = object_id(N'dbo.sproc_ar_isPayerReimbursedBasedOnHipps')
			AND objectproperty(id, N'IsProcedure') = 1
	)
BEGIN
DROP PROCEDURE dbo.sproc_ar_isPayerReimbursedBasedOnHipps;
END
GO

IF EXISTS (
		SELECT 1
		FROM dbo.sysobjects
		WHERE id = object_id(N'dbo.sproc_ar_isPayerReimbursedBasedOnHipps')
			AND objectproperty(id, N'IsProcedure') = 1
	)
BEGIN
DROP PROCEDURE dbo.sproc_ar_isPayerReimbursedBasedOnHipps;
END
GO

CREATE PROCEDURE dbo.sproc_ar_isPayerReimbursedBasedOnHipps
    @payerId INT
	, @facId INT
	, @date DATE
	, @debug_me CHAR(1) = 'N'
	, @status_code INT OUT
	, @status_text VARCHAR(3000) OUT
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
@error_code INT
		, @vgsStepStartTime DATETIME
		, @vgsTotalStartTime DATETIME = GETDATE()
		, @vgs_program_name VARCHAR(200) = Object_name(@@ProcID)  ---Current Store Proc Name
		, @reimb_basedon_hipps_flag CHAR(1) = 'N'
		;

	SET @status_code = 0;
	SET @status_text = NULL;

	IF @debug_me = 'Y'
BEGIN
		SET @vgsStepStartTime = GETDATE();
		IF @vgs_program_name IS NULL
			SET @vgs_program_name = 'SprocCodeTest';
		PRINT 'Executing store proc :  ' + @vgs_program_name + ' ' + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);
END

BEGIN TRY
		-- params validation
IF (@payerId IS NULL OR @payerId < 1)
BEGIN;
			SET @status_code = 50001;
			SET @status_text = 'Enter a valid payer id.';
			SET @error_code = 50001;
GOTO PgmAbend;
END;

		IF (@facId IS NULL OR @facId < 1)
BEGIN;
			SET @status_code = 50001;
			SET @status_text = 'Enter a valid fac id.';
			SET @error_code = 50001;
GOTO PgmAbend;
END;

		IF @date IS NULL
BEGIN;
			SET @status_code = 50002;
			SET @status_text = 'Enter a valid date.';
			SET @error_code = 50002;
GOTO PgmAbend;
END;

SELECT TOP 1 @reimb_basedon_hipps_flag = reimb_basedon_hipps_flag
FROM ar_date_range
WHERE payer_id = @payerId
  AND fac_id = @facId
  AND eff_date_from <= @date
  AND (eff_date_to IS NULL
    OR eff_date_to > @date)
  AND deleted = 'N';

SELECT CAST(IIF(@reimb_basedon_hipps_flag = 'Y', 1, 0) AS BIT);

END TRY
BEGIN CATCH
SET @error_code = @@error;
		SET @status_text = ERROR_MESSAGE();
		SET @status_code = 1;

GOTO PgmAbend;
END CATCH


IF @debug_me = 'Y'
		PRINT 'Total execution time: ' + LTRIM(RTRIM(STR(DATEDIFF(ms, @vgsTotalStartTime, GETDATE()))))+ ' ms';

	PgmSuccess:
	IF @status_code = 0
BEGIN
		IF @debug_me = 'Y'
			PRINT 'Successful execution of stored procedure.';

		RETURN;
END

	PgmAbend:
	IF @debug_me = 'Y'
BEGIN
		PRINT 'Stored procedure failure: ' + convert(varchar(26),getdate(),109);
		PRINT 'Error code: ' + convert(varchar(3),@error_code) + '; Error description:  ' + @status_text;
END
	RAISERROR (@status_text, 16, 1);

END
GO

GRANT EXECUTE ON dbo.sproc_ar_isPayerReimbursedBasedOnHipps TO PUBLIC;
GO

GO

print 'C_Branch/04_StoredProcedures/sproc_ar_isPayerReimbursedBasedOnHipps.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_isPayerReimbursedBasedOnHipps.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_list_getInvoiceTransactionsByCensus.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- =================================================================================
-- Jira #:              CORE-78331 - Get Invoice transactions by census id
--
-- Written By:          Shino Johnson
-- Reviewed By:         
--  
-- Target DB Type:      CLIENT
-- Target ENVIRONMENT:  BOTH (US/CA) 
--
-- Re-Runable:          YES 
-- 
-- Description of Script Function: 
-- list invoice transactions for an invoice
--
-- Special Instructions: 
-- ==================================================================
-- Sample execution: 
--EXEC dbo.sproc_ar_list_getInvoiceTransactionsByCensus 
--@invoiceId = 91901,
--@isQueryListType = 1
-- ================================================================== 
IF EXISTS (
		SELECT 1
		FROM sysobjects
		WHERE name = 'sproc_ar_list_getInvoiceTransactionsByCensus'
		)
BEGIN
	DROP PROCEDURE sproc_ar_list_getInvoiceTransactionsByCensus
END

SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE sproc_ar_list_getInvoiceTransactionsByCensus (
	@invoiceId INT
	,@isFromValidate BIT
	)
AS
SET NOCOUNT ON;

BEGIN
	DECLARE @vInvoiceId INT
		,@vIsFromValidate BIT

	SET @vInvoiceId = @invoiceId
	SET @vIsFromValidate = @isFromValidate

	IF (@vIsFromValidate = 1)
	BEGIN
		SELECT amount
			,care_level
			,daily_rate
			,days_amount
			,description
			,eff_date_from
			,eff_date_to
			,hcpcs_code
			,invoice_id
			,non_covered_amount
			,revenue_code
			,rugs_modifier
			,sequence_no
			,therapy_modifier
			,therapy_modifier2
			,therapy_modifier3
			,transaction_id
			,transaction_type
			,is_billable
			,is_pdpm
			,days_amount_in_0022_line_included
		FROM AR_INVOICE_TRANSACTION
		WHERE invoice_id = @invoiceId
			AND DELETED = 'N'
		ORDER BY sequence_no
	END
	ELSE
	BEGIN
		SELECT care_level
			,daily_rate
			,days_amount
			,eff_date_from
			,transaction_id
		FROM AR_INVOICE_TRANSACTION
		WHERE invoice_id = @invoiceId
			AND DELETED = 'N'
		ORDER BY sequence_no
	END
END
GO

GRANT EXECUTE
	ON sproc_ar_list_getInvoiceTransactionsByCensus
	TO PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_list_getInvoiceTransactionsByCensus.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_list_getInvoiceTransactionsByCensus.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_list_getUnbilledUBClients.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- Jira #:                CORE-94230             
--                           
-- Written By:            Daniel Chen
-- Reviewed By:         
-- 
-- Script Type:           DDL 
-- Target DB Type:        Client
-- Target Environment:    Both
-- 
-- 
-- Re-Runable:            YES 
-- 
-- Description of Script: get unbilled UB clients list
-- 
-- Special Instruction:   None
--
--Sample Execution 
--EXEC dbo.sproc_ar_list_getUnbilledUBClients
--  @facId = 1       
-- ,@payerId = 3    
-- ,@payerType = 'medicaid'  
-- ,@startDate = '2014-02-28'
-- ,@toDate = '2021-08-01'   
-- ,@excludeTrialFlag = 1
-- =================================================================================
IF EXISTS
(
    SELECT 1
    FROM INFORMATION_SCHEMA.ROUTINES
    WHERE ROUTINE_SCHEMA = 'dbo'
          AND ROUTINE_NAME = 'sproc_ar_list_getUnbilledUBClients'
          AND ROUTINE_TYPE = 'PROCEDURE'
)
BEGIN
    DROP PROCEDURE dbo.sproc_ar_list_getUnbilledUBClients;
END;
GO
SET ANSI_NULLS ON;
GO
SET QUOTED_IDENTIFIER ON;
GO
CREATE PROCEDURE dbo.sproc_ar_list_getUnbilledUBClients 

  @facId       INT 
 ,@payerId     INT 
 ,@payerType    VARCHAR(20)
 ,@startDate    DATETIME
 ,@toDate       DATETIME
 ,@excludeTrialFlag BIT
 
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @vFacId INT = @facId
    DECLARE @vPayerId INT = @payerId
    DECLARE @vPayerType VARCHAR(20) = @payerType
    DECLARE @vStartDate DATETIME = @startDate
    DECLARE @vToDate DATETIME = @toDate
    DECLARE @vExcludeTrialFlag BIT = @excludeTrialFlag
           
  --create temp tables
    CREATE TABLE #temp_unbilled_tx
    (
      transaction_id int,
      effective_date datetime,
      client_id int,
      payer_id int
    )

    CREATE TABLE #temp_qualified_unbilled_tx
    (
      transaction_id int,
      effective_date datetime,
      client_id int,
      payer_id int
    )

    -- get all unbilled UB clients
    INSERT INTO #temp_unbilled_tx
    (
        transaction_id,
        effective_date,
        payer_id, 
        client_id
    )
    SELECT
         tx.transaction_Id,
         tx.effective_date,
         tx.payer_id,
         tx.client_id
      FROM AR_TRANSACTIONS tx
           LEFT JOIN AR_INVOICE trialinvoice ON tx.trial_invoice_id = trialinvoice.invoice_id
                                                AND trialinvoice.deleted = 'N'
           LEFT JOIN AR_PAYERS arpayer ON tx.payer_id = arpayer.payer_id
                                          AND tx.fac_id = arpayer.fac_id
           LEFT JOIN AR_INVOICE invoice ON tx.invoice_id = invoice.invoice_id
           JOIN AR_LIB_PAYERS libpayer ON tx.payer_id = libpayer.payer_id
                                               AND libpayer.deleted = 'N'
      WHERE ((@vPayerId IS NULL AND @vPayerType IS NULL)
              OR (@vPayerId IS NOT NULL AND tx.PAYER_ID = @vPayerId) 
              OR (@vPayerId IS NULL AND libpayer.payer_type = @vPayerType ))
           AND (@vExcludeTrialFlag = 0 OR (@vExcludeTrialFlag = 1 and (tx.trial_invoice_id IS NULL
                  OR tx.revision_date > trialinvoice.revision_date)))
             AND libpayer.bill_form = 'UB92'
             AND tx.INVOICE_ID IS NULL
             AND tx.transaction_type NOT IN('X', 'C')
      AND tx.TRANSACTION_DATE IS NOT NULL
      AND (tx.distribution_tx_id IS NULL
           OR tx.distribution_tx_id = tx.transaction_id)
      AND tx.REVERSING_TX_ID IS NULL
      AND tx.EFFECTIVE_DATE < @vToDate
      AND tx.EFFECTIVE_DATE > @vStartDate
      AND (CASE
        WHEN EXISTS
        (
            SELECT *
            FROM ar_batch_errors
            WHERE ar_batch_errors.transaction_id = tx.transaction_id
                  AND ((warning_flag = 'N'
                        AND field_code LIKE 'IE%')
                       OR (warning_flag = 'Y'
                           AND field_code LIKE 'IW%'))
        )
             THEN 1
             ELSE 0
             END) = '0'
      AND tx.FAC_ID = @vFacId
           AND tx.DELETED = 'N'
    order by tx.client_id,tx.payer_id,tx.effective_date

    -- filter out tx in real bill period
    INSERT INTO #temp_qualified_unbilled_tx
    (
        transaction_id,
        effective_date,
        client_id,
        payer_id
    )
    SELECT 
        tx.transaction_id,
        tx.effective_date,
        tx.client_id, 
        tx.payer_id
    FROM #temp_unbilled_tx tx
    WHERE NOT EXISTS
     (
        SELECT 1
        FROM ar_invoice
           JOIN ar_invoice_claim ON ar_invoice.invoice_id = ar_invoice_claim.invoice_id
        WHERE ar_invoice.deleted = 'N'
           AND ar_invoice.trial_flag = 'N'
           AND ar_invoice.manual_flag = 'N'
           AND ar_invoice.original_invoice_id IS NULL
           AND ar_invoice.transaction_flag = 'Y'
           and ar_invoice.fac_id = @vFacId
           AND ar_invoice.client_id = tx.client_id
           AND ar_invoice.payer_id = tx.payer_id
           AND tx.effective_date >= ar_invoice_claim.effective_from_date
           AND tx.effective_date < DATEADD(day, 1, ar_invoice_claim.effective_to_date)
     )
    ORDER BY tx.transaction_id  
    
    DROP TABLE  #temp_unbilled_tx

    -- get client sum list
    SELECT SUM(tx.AMOUNT) AS claim_total, 
             MIN(qtx.EFFECTIVE_DATE) AS min_effective_date, 
             MAX(qtx.EFFECTIVE_DATE) AS max_effective_date, 
             billable_flag = CONVERT(BIT, 
             MIN(CASE
                 WHEN ISNULL(parentTransactionAssessmentInfo.pdpm_flag, 0) = 0
                      OR parentTransactionAssessmentInfo.hipps_code = 'ZZZZZ'
                      OR assess.STATUS IN('Accepted', 'Completed')
                 THEN 1
                 ELSE 0
                 END)),            
             mpi.last_name patient_last_name, 
             mpi.first_name patient_first_name, 
             client.client_id_number, 
             qtx.client_id, 
             libpayer.description AS payer_desc, 
             libpayer.payer_code, 
             libpayer.payer_type, 
             pps_flag = CONVERT(BIT, IIF(libpayer.pps_flag = 'Y', 1, 0)),
             libpayer.assessment_notifications_rates_flag, 
             libpayer.enforce_pps_updates_flag, 
             qtx.payer_id, 
             arpayer.bill_unk_flag AS payer_bill_unk_flag,              
             rateSchedule.is_reimbursement_use_hipps, 
             parentTransactionAssessmentInfo.hipps_code,
             tx.care_level,
             tx.transaction_type
      FROM AR_TRANSACTIONS tx
       JOIN #temp_qualified_unbilled_tx qtx on tx.transaction_id = qtx.transaction_id
           JOIN CLIENTS client ON qtx.client_id = client.client_id
           LEFT JOIN AR_PAYERS arpayer ON qtx.payer_id = arpayer.payer_id
                                          AND tx.fac_id = arpayer.fac_id
           LEFT JOIN MPI mpi ON client.mpi_id = mpi.mpi_id
                                AND (mpi.deleted = 'N')
           JOIN AR_LIB_PAYERS libpayer ON qtx.payer_id = libpayer.payer_id
                                               AND (libpayer.deleted = 'N')
           LEFT JOIN AR_TRANSACTION_ASSESSMENT_INFO transactionAssessmentInfo ON tx.transaction_id = transactionAssessmentInfo.transaction_id
           LEFT JOIN AR_TRANSACTION_ASSESSMENT_INFO parentTransactionAssessmentInfo ON tx.distribution_tx_id = parentTransactionAssessmentInfo.transaction_id
           LEFT JOIN AS_ASSESSMENT assess ON parentTransactionAssessmentInfo.pps_assessment_id = assess.assess_id
                                             AND (assess.deleted = 'N')
           LEFT JOIN ar_eff_rate_schedule rateSchedule ON tx.eff_schedule_id = rateSchedule.eff_schedule_id                                    
      GROUP BY mpi.last_name, 
              mpi.first_name, 
              client.client_id_number, 
              qtx.client_id, 
              libpayer.DESCRIPTION, 
              libpayer.payer_code, 
              libpayer.payer_type, 
              libpayer.pps_flag, 
              libpayer.assessment_notifications_rates_flag, 
              libpayer.enforce_pps_updates_flag, 
              qtx.PAYER_ID, 
              arpayer.bill_unk_flag, 
              rateSchedule.is_reimbursement_use_hipps, 
              parentTransactionAssessmentInfo.hipps_code,
              tx.care_level,
              tx.transaction_type
      ORDER BY mpi.last_name, 
               mpi.first_name, 
               client.client_id_number, 
               qtx.client_id, 
               libpayer.description, 
               libpayer.payer_code, 
               libpayer.payer_type, 
               libpayer.pps_flag, 
               libpayer.assessment_notifications_rates_flag, 
               libpayer.enforce_pps_updates_flag, 
               qtx.PAYER_ID, 
               arpayer.bill_unk_flag,
               rateSchedule.is_reimbursement_use_hipps, 
               parentTransactionAssessmentInfo.hipps_code,               
               tx.care_level, 
               tx.transaction_type
END
GO
GRANT EXECUTE ON dbo.sproc_ar_list_getUnbilledUBClients TO PUBLIC;
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_list_getUnbilledUBClients.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_list_getUnbilledUBClients.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_list_unbilledTransactionsByClientsAndPayers.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- =================================================================================
-- Jira #:              CORE-75857            
--
-- Written By:          Jimmy Zhang
-- Reviewed By:         
--  
-- Target DB Type:      CLIENT
-- Target ENVIRONMENT:  BOTH (US/CA) 
--
-- Re-Runable:          YES 
-- 
-- Description of Script Function: 
-- list all unbilled transactions by passed in client ids and payer ids
--  Special Instructions: 
-- ==================================================================
-- Sample execution: 
-- DECLARE @status_code int 
-- DECLARE @status_text varchar(3000) 
-- EXEC dbo.sproc_ar_list_unbilledTransactionsByClientsAndPayers 
-- @clientIdCSV = '1,2,3',
-- @payerIdCSV = '1,2,3',
-- @facId = 1,
-- @isHCR = 0,
-- @isRecalc = 0, 
-- @effFromDate = '2020-01-01',
-- @effToDate = '2020-01-31', 
-- @isUB = 1,
-- @isDeductable = 0
-- ================================================================== 

IF EXISTS (SELECT 1 FROM sysobjects WHERE name = 'sproc_ar_list_unbilledTransactionsByClientsAndPayers') 
BEGIN
  DROP PROCEDURE sproc_ar_list_unbilledTransactionsByClientsAndPayers
END
GO

CREATE PROCEDURE sproc_ar_list_unbilledTransactionsByClientsAndPayers
(
  @clientIdCSV varchar(max),
  @payerIdCSV varchar(max),
  @facId int,
  @isHCR bit,
  @isRecalc bit,  
  @effFromDate datetime, 
  @effToDate datetime, 
  @isUB bit,
  @isDeductable bit
)
AS
BEGIN
  declare @vFacId int = @facId
  declare @vClientIdCSV varchar(max) = @clientIdCSV
  declare @vPayerIdCSV varchar(max) = @payerIdCSV
  declare @vIsHCR bit = @isHCR
  declare @vEffFromDate datetime = @effFromDate
  declare @vEffToDate datetime = (SELECT DATEADD(s, -1, DATEADD(Day, DATEDIFF(Day, 0, @effToDate), 1)))
  declare @vEffToDateInTwoMonth datetime = (select DATEADD(m, DATEDIFF(m, 0, @effToDate) + 2, 0))
  declare @vIsRecalc bit = @isRecalc
  declare @vIsDeductable bit = @isDeductable
  
  declare @client_id table 
  (
    client_id int
  )
  
  declare @payer_id table 
  (
    payer_id int
  )
  
  INSERT INTO @client_id
  (
    client_id
  )
  SELECT VALUE 
  FROM pcc__csvToTableOfIntMax(@vClientIdCSV) sel 
  
  INSERT INTO @payer_id
  (
    payer_id
  )
  SELECT VALUE 
  FROM pcc__csvToTableOfIntMax(@vPayerIdCSV) sel 
  
  if (@isUB = 1)
  BEGIN
    if (@vIsDeductable = 1)
    BEGIN
      SELECT    
        SUM(t.AMOUNT) AS amount 
      FROM AR_TRANSACTIONS t
      JOIN @client_id clients
        ON t.client_id = clients.client_id
      JOIN @payer_id payers
        ON t.payer_id = payers.payer_id
      LEFT JOIN AR_PAYERS arpayer 
        ON t.payer_id = arpayer.payer_id 
       AND t.fac_id = arpayer.fac_id 
      LEFT JOIN AR_INVOICE invoice 
        ON t.invoice_id = invoice.invoice_id 
      LEFT JOIN AR_LIB_PAYERS libpayer 
        ON t.payer_id = libpayer.payer_id 
       AND (libpayer.deleted = 'N') 
      LEFT JOIN AR_TRANSACTION_RECURRING_TX_REFS recurtrans 
        ON t.transaction_id = recurtrans.transaction_id 
      LEFT JOIN ar_recurring_transactions recurringtx 
        ON recurtrans.recurring_tx_id = recurringtx.transaction_id 
       AND (recurringtx.deleted = 'N') 
      WHERE t.INVOICE_ID IS NULL 
        AND t.TRANSACTION_DATE IS NOT NULL 
        AND t.transaction_type = 'D'
        AND (@vEffFromDate is null OR t.effective_date >= @vEffFromDate)
        AND (@vEffToDate is null OR (t.EFFECTIVE_DATE <= @vEffToDate
            OR (t.EFFECTIVE_DATE < @vEffToDateInTwoMonth
                AND libpayer.bill_in_advance = 'Y' 
      	      AND (@vIsHCR = 0 OR t.AUTO_GENERATED <> 'R')) 
            OR (@vIsHCR = 1 AND (t.EFFECTIVE_DATE < @vEffToDateInTwoMonth
      	      AND recurringtx.bill_in_advance = 'Y' 
      	      AND t.AUTO_GENERATED = 'R' 
      	      AND libpayer.bill_in_advance = 'Y')))) 
        AND not exists (SELECT 1
      	              FROM ar_invoice i 
      	              JOIN @client_id c
      	                ON c.client_id = i.client_id
      	              JOIN @payer_id p
      	                ON i.payer_id = p.payer_id
      	              JOIN ar_invoice_claim claim
      	              	ON i.invoice_id = claim.invoice_id
                        WHERE i.deleted = 'N'
                    	AND i.trial_flag = 'N'
                    	AND i.manual_flag = 'N'
                    	AND i.original_invoice_id IS NULL
                    	AND i.transaction_flag = 'Y'
                    	AND i.fac_id = t.fac_id
                    	AND i.client_id = t.client_id
                    	AND i.payer_id = t.payer_id
                    	AND t.effective_date >= CONVERT(DATE, claim.effective_from_date)
                    	AND t.effective_date < DATEADD(DAY, 1, CONVERT(DATE, claim.effective_to_date))) 
        AND (@vIsRecalc = 1 
             OR (arpayer.allow_span_multiple_months = 'Y' 
                 OR (arpayer.allow_span_multiple_months = 'N' 
      		   AND t.trial_invoice_id IS NULL )))
        AND (isNull((SELECT TOP 1 1
      	           FROM ar_batch_errors
      	           WHERE ar_batch_errors.transaction_id = t.transaction_id
      	             AND ((warning_flag = 'N' AND field_code LIKE 'IE%')
      	                  OR (warning_flag = 'Y' AND field_code LIKE 'IW%'))),0)) = '0'  
        AND t.FAC_ID = @vFacId
        AND t.DELETED = 'N'     
    END
    ELSE
    BEGIN
      SELECT      
        libpayer.recurring_ancillary_charges_type
        ,libpayer.pri_sec_payer AS payer_pri_sec
        ,libpayer.break_in_stay
        ,libpayer.payer_type
        ,libpayer.bill_form
        ,libpayer.outpatient_payer_type AS payer_outpatient_payer_type
        ,libpayer.outpatient_payer_state AS payer_outpatient_payer_state
        ,recurtrans.recurring_tx_id
        ,recurringtx.bill_in_advance AS recurring_bill_in_advance
        ,arpayer.bill_unk_flag AS payer_bill_unk_flag
        ,arpayer.group_txs_by
        ,arpayer.daily_rate_field
        ,arpayer.anc_rate_field
        ,arpayer.submitter_id
        ,arpayer.allow_span_multiple_months
        ,rateSchedule.is_reimbursement_use_hipps 
        ,parentTransactionAssessmentInfo.hipps_code 
        ,t.care_level
        ,t.parent_tx_type
        ,t.CLIENT_ID
        ,t.PAYER_ID
        ,t.EFFECTIVE_DATE
        ,t.TRANSACTION_ID
        ,t.AMOUNT
        ,t.transaction_type
        ,t.DAYS_AMOUNT
        ,t.FAC_ID
        ,t.REVERSING_TX_ID
        ,t.trial_invoice_id
        ,recurringtx.charge_frequency as recurring_charge_frequency
        ,recurringtx.days_amount AS recurring_days_amount
        ,recurringtx.prorate
        ,recurringtx.daily_rate as recurring_tx_daily_rate
      FROM AR_TRANSACTIONS t
      JOIN @client_id clients
        ON t.client_id = clients.client_id
      JOIN @payer_id payers
        ON t.payer_id = payers.payer_id
      LEFT JOIN AR_PAYERS arpayer 
        ON t.payer_id = arpayer.payer_id 
       AND t.fac_id = arpayer.fac_id 
      LEFT JOIN AR_INVOICE invoice 
        ON t.invoice_id = invoice.invoice_id 
      LEFT JOIN AR_LIB_PAYERS libpayer 
        ON t.payer_id = libpayer.payer_id 
       AND (libpayer.deleted = 'N') 
      LEFT JOIN AR_TRANSACTION_RECURRING_TX_REFS recurtrans 
        ON t.transaction_id = recurtrans.transaction_id 
      LEFT JOIN ar_recurring_transactions recurringtx 
        ON recurtrans.recurring_tx_id = recurringtx.transaction_id 
       AND (recurringtx.deleted = 'N') 
      LEFT JOIN AR_TRANSACTION_ASSESSMENT_INFO parentTransactionAssessmentInfo 
        ON t.distribution_tx_id = parentTransactionAssessmentInfo.transaction_id
      LEFT JOIN ar_eff_rate_schedule rateSchedule 
        ON t.eff_schedule_id = rateSchedule.eff_schedule_id
      WHERE t.INVOICE_ID IS NULL 
        AND t.TRANSACTION_DATE IS NOT NULL 
        AND (@vEffFromDate is null OR t.effective_date >= @vEffFromDate)
        AND (@vEffToDate is null OR (t.EFFECTIVE_DATE <= @vEffToDate
            OR (t.EFFECTIVE_DATE < @vEffToDateInTwoMonth
                AND libpayer.bill_in_advance = 'Y' 
      	      AND (@vIsHCR = 0 OR t.AUTO_GENERATED <> 'R')) 
            OR (@vIsHCR = 1 AND (t.EFFECTIVE_DATE < @vEffToDateInTwoMonth
      	      AND recurringtx.bill_in_advance = 'Y' 
      	      AND t.AUTO_GENERATED = 'R' 
      	      AND libpayer.bill_in_advance = 'Y')))) 
        AND not exists (SELECT 1
      	              FROM ar_invoice i 
      	              JOIN @client_id c
      	                ON c.client_id = i.client_id
      	              JOIN @payer_id p
      	                ON i.payer_id = p.payer_id
      	              JOIN ar_invoice_claim claim
      	              	ON i.invoice_id = claim.invoice_id
                        WHERE i.deleted = 'N'
                    	AND i.trial_flag = 'N'
                    	AND i.manual_flag = 'N'
                    	AND i.original_invoice_id IS NULL
                    	AND i.transaction_flag = 'Y'
                    	AND i.fac_id = t.fac_id
                    	AND i.client_id = t.client_id
                    	AND i.payer_id = t.payer_id
                    	AND t.effective_date >= CONVERT(DATE, claim.effective_from_date)
                    	AND t.effective_date < DATEADD(DAY, 1, CONVERT(DATE, claim.effective_to_date))) 
        AND (@vIsRecalc = 1 
             OR (arpayer.allow_span_multiple_months = 'Y' 
                 OR (arpayer.allow_span_multiple_months = 'N' 
      		   AND t.trial_invoice_id IS NULL )))
        AND (isNull((SELECT TOP 1 1
      	           FROM ar_batch_errors
      	           WHERE ar_batch_errors.transaction_id = t.transaction_id
      	             AND ((warning_flag = 'N' AND field_code LIKE 'IE%')
      	                  OR (warning_flag = 'Y' AND field_code LIKE 'IW%'))),0)) = '0'  
        AND t.FAC_ID = @vFacId
        AND t.DELETED = 'N' 
      ORDER BY t.CLIENT_ID, t.PAYER_ID, t.EFFECTIVE_DATE, t.distribution_tx_id, t.TRANSACTION_ID
    END
  END
  ELSE
  BEGIN
    SELECT      
      libpayer.recurring_ancillary_charges_type
      ,libpayer.pri_sec_payer AS payer_pri_sec
      ,libpayer.break_in_stay
      ,libpayer.payer_type
      ,libpayer.bill_form
      ,libpayer.outpatient_payer_type AS payer_outpatient_payer_type
      ,libpayer.outpatient_payer_state AS payer_outpatient_payer_state
      ,recurtrans.recurring_tx_id
      ,recurringtx.bill_in_advance AS recurring_bill_in_advance
      ,arpayer.bill_unk_flag AS payer_bill_unk_flag
      ,arpayer.group_txs_by
      ,arpayer.daily_rate_field
      ,arpayer.anc_rate_field
      ,arpayer.submitter_id
      ,arpayer.allow_span_multiple_months
      ,t.care_level
      ,t.parent_tx_type
      ,t.CLIENT_ID
      ,t.PAYER_ID
      ,t.EFFECTIVE_DATE
      ,t.TRANSACTION_ID
      ,t.AMOUNT
      ,t.transaction_type
      ,t.DAYS_AMOUNT
      ,t.FAC_ID
      ,t.REVERSING_TX_ID
      ,t.trial_invoice_id
	  ,recurringtx.charge_frequency as recurring_charge_frequency
	  ,recurringtx.days_amount AS recurring_days_amount
	  ,recurringtx.prorate
	  ,recurringtx.daily_rate as recurring_tx_daily_rate
    FROM AR_TRANSACTIONS t
    JOIN @client_id clients
      ON t.client_id = clients.client_id
    JOIN @payer_id payers
      ON t.payer_id = payers.payer_id
    LEFT JOIN AR_PAYERS arpayer 
      ON t.payer_id = arpayer.payer_id 
     AND t.fac_id = arpayer.fac_id 
    LEFT JOIN AR_INVOICE invoice 
      ON t.invoice_id = invoice.invoice_id 
    LEFT JOIN AR_LIB_PAYERS libpayer 
      ON t.payer_id = libpayer.payer_id 
     AND (libpayer.deleted = 'N') 
    LEFT JOIN AR_TRANSACTION_RECURRING_TX_REFS recurtrans 
      ON t.transaction_id = recurtrans.transaction_id 
    LEFT JOIN ar_recurring_transactions recurringtx 
      ON recurtrans.recurring_tx_id = recurringtx.transaction_id 
     AND (recurringtx.deleted = 'N') 
    WHERE t.INVOICE_ID IS NULL 
      AND t.TRANSACTION_DATE IS NOT NULL 
      AND (@vEffFromDate is null OR t.effective_date >= @vEffFromDate)
      AND (@vEffToDate is null 
           OR (t.EFFECTIVE_DATE <= @vEffToDate
               OR (t.EFFECTIVE_DATE < @vEffToDateInTwoMonth
                   AND libpayer.bill_in_advance = 'Y' 
    	           AND (@vIsHCR = 0 OR t.AUTO_GENERATED <> 'R')) 
               OR (@vIsHCR = 1 
                   AND (t.EFFECTIVE_DATE < @vEffToDateInTwoMonth
    	                AND recurringtx.bill_in_advance = 'Y' 
    	                AND t.AUTO_GENERATED = 'R' 
    	                AND libpayer.bill_in_advance = 'Y')))) 
      AND not exists (SELECT 1
    	              FROM ar_invoice i 
    	              JOIN @client_id c
    	                ON c.client_id = i.client_id
    	              JOIN @payer_id p
    	                ON i.payer_id = p.payer_id
    	              WHERE i.deleted = 'N'
    	                AND i.trial_flag = 'N'
    	                AND i.manual_flag = 'N'
    	                AND i.original_invoice_id IS NULL
    	                AND i.transaction_flag = 'Y'
    	                AND i.fac_id = t.fac_id
    	                AND i.client_id = t.client_id
    	                AND i.payer_id = t.payer_id
    	                AND t.effective_date >= CONVERT(DATE, i.eff_date_from)
    	                AND t.effective_date < DATEADD(DAY, 1, CONVERT(DATE, i.eff_date_to))) 
      AND (isNull((SELECT TOP 1 1
    	           FROM ar_batch_errors
    	           WHERE ar_batch_errors.transaction_id = t.transaction_id
    	             AND ((warning_flag = 'N' AND field_code LIKE 'IE%')
    	                  OR (warning_flag = 'Y' AND field_code LIKE 'IW%'))),0)) = '0'  
      AND t.FAC_ID = @vFacId
      AND t.DELETED = 'N' 
    ORDER BY t.CLIENT_ID, t.PAYER_ID, t.EFFECTIVE_DATE, t.distribution_tx_id, t.TRANSACTION_ID
  END

END
GO

GRANT EXECUTE ON sproc_ar_list_unbilledTransactionsByClientsAndPayers TO PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_ar_list_unbilledTransactionsByClientsAndPayers.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_ar_list_unbilledTransactionsByClientsAndPayers.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_delete_records.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- CORE	- 86645	  :   script to create [sproc_azure_data_archive_delete_records] Procedure  in Client Database
--						-- f
-- Written By:          Dominic Christie
-- Reviewed By:         
-- 
-- Script Type:         DML 
-- Target DB Type:      Client Database
-- Target ENVIRONMENT:  Both

-- Re-Runable:          YES #

-- Description of Script : After the parquet file is generated and the data is return to the file the same data will be deleted from the on premise table in the same execution. 

-- Special Instruction: 
-- 
/*

exec sproc_azure_data_archive_delete_records 
'pcc-chrisd',
'y',
2296,
1889,
'996CE94B-1623-43BA-AC42-A979278B94CD',
4,
20000,
false,
0



Revision History:

2021-01-19 Dom Christie  		CORE-86645 4.4.2	 	- Initial Creation of the store proc.
-- =================================================================================
*/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_azure_data_archive_delete_records' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE [dbo].sproc_azure_data_archive_delete_records
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO
CREATE PROCEDURE dbo.sproc_azure_data_archive_delete_records
@execution_by VARCHAR(65),
@debug_me CHAR(1)='N',
@file_Id INT,
@audit_id INT,
@orgcode VARCHAR(500),
@detail_id INT,
@delete_batch_size INT=1000000,
@is_prev BIT='false',
@prev_del_count INT



AS



BEGIN

SET XACT_ABORT ON

BEGIN TRY

DECLARE @vauditId INT,
        @deletecount INT,
		@vmasterControllerId TINYINT,
		@vcontrollerId SMALLINT,
		@vdetailId INT,
		@vfileId INT,
		@errorCode VARCHAR(150),
		@errorEntry VARCHAR(4),
		@vErr VARCHAR(3500),
@debugId INT,
@totalDelCount INT

SELECT @vauditId=@audit_id 


INSERT INTO azure_data_archive_pipeline_steps_debug

SELECT 'Executing sproc_azure_data_archive_delete_records', @vauditId, 'Started',GETDATE(),NULL, 'Running for the fileId: '+' '+ CAST(@file_Id AS VARCHAR(15))+'  ',GETUTCDATE(),NULL,@file_Id



SET @debugId=SCOPE_IDENTITY()
   
   
   DECLARE 
				@sql VARCHAR(5000),		
				@root VARCHAR(1500),
				@folder VARCHAR(150),
				@subfolder VARCHAR(150),
				@rows INT,
				@vfileName VARCHAR(400),
				@source_table VARCHAR(150),
				@rowscopied INT,
				@yeartoarchive SMALLINT ,
				@textyeartoarchive CHAR(4),
				@rowsCnt INT,	
				@loop INT,
				@counter SMALLINT=1,
				@existingView BIT,							
				@rowsDeleted INT,
				@textBatchSize VARCHAR(15),	 
				@transactionTableCheckSum VARCHAR(170),        
				@deleteBatchSize INT,
				@checkSum_columns VARCHAR(1510),
				@checksumFilter VARCHAR(250),
		        @select_checksumColumn VARCHAR(200),
			    @filterDataType  VARCHAR(50),
				@checksum_uniqueId VARCHAR(200)

		


SET @vfileId=@file_Id	
SET @vdetailId=@detail_id

SELECT @textBatchSize=CAST(@delete_batch_size AS VARCHAR(15))

CREATE TABLE #detailsId (id BIGINT)

CREATE TABLE #filtercolumn (id TINYINT, min_val DATETIME,max_val DATETIME)



SELECT @vmasterControllerId=c.master_controller_id,
@vcontrollerId=c.controller_id
FROM azure_data_archive_pipeline_controller_detail dl 
INNER JOIN azure_data_archive_pipeline_controller c ON dl.controller_id=c.controller_id
WHERE dl.detail_id=@vdetailId

	 
IF NOT  EXISTS (SELECT 1 FROM azure_data_archive_pipeline_errors WHERE pipeline_audit_id=@vauditId AND @is_prev='false' AND controller_id=@vcontrollerId)
--IF 1=1
BEGIN




		SELECT @folder=transaction_table_name ,
		@source_table=source_table,
		@textyeartoarchive=CONVERT(char(4),year_to_archive),		
		@vfileName=azure_file_name,
		@transactionTableCheckSum=CASE WHEN is_history_exists =1 AND is_history_archive_completed=0 THEN source_table ELSE transaction_table_name END,
		@checkSum_columns=check_sum_columns,
		@checksum_uniqueId=check_sum_unique_id_column,
		@checksumFilter=check_sum_column_filter
		FROM   azure_data_archive_pipeline_storage_file_name f 
		INNER JOIN azure_data_archive_pipeline_controller_detail c
		ON f.detail_id=c.detail_id
		INNER JOIN azure_data_archive_pipeline_controller a
		ON a.controller_id=c.controller_id
		WHERE f.azure_file_id=@vfileId
	
				
			
		SET @transactionTableCheckSum=@transactionTableCheckSum+'_checksum'
					

	   
		 SELECT @rowscopied= rows_copied FROM azure_data_archive_pipeline_activity_audit 
		 WHERE azure_file_id=@vfileId

		 


		SET @root=''
	---SET @root=@orgcode+'/'+@folder+'/'+'deletefail'+'/'+@textyeartoarchive+'/'+@vfileName

	SET @root=@orgcode+'/'+@folder+'/'+@textyeartoarchive+'/'+@vfileName
		



UPDATE azure_data_archive_pipeline_steps_debug
SET additional_comment=ISNULL(additional_comment,'')+'  '+'Started  working on deleting the data from the db' 
WHERE debug_id=@debugId

IF @is_prev	='false'

BEGIN

		SET @deletecount=0


		SET @sql=''




		SET @sql=
	';WITH filechecksum
	AS
	(
	SELECT  '+ @checksum_uniqueId + ' table_unique_id,'  


	
	SET @sql=@sql+' '+ @checkSum_columns +' '+'
 checkId
	FROM  OPENROWSET(
		BULK  '+CHAR(39)+@root+''+CHAR(39)+','
		+'  '+ 'DATA_SOURCE =''ScheduleDetails'''+','
		+'  ' +'FORMAT = ''parquet'')  s' +' 
	)
	
	UPDATE c
	SET is_ready_delete=1
	FROM filechecksum s
	INNER JOIN '+@transactionTableCheckSum+' c ON c.table_unique_id=s.table_unique_id 
		WHERE     checkId =table_row_checksum
	'
 



EXEC(@sql)
---print(@sql)





SET @deletecount=@@ROWCOUNT

	IF @rowscopied<>@deletecount AND @is_prev	='false'

	-----IF 1=2
		BEGIN 

		 UPDATE azure_data_archive_pipeline_storage_file_name
		 SET is_file_table_deleted_rows_mismatch=1,
		 is_rows_from_table_deleted=0
		 WHERE azure_file_id=@vfileId


		 SET @vErr = 'The Deleted Rows' + CONVERT(VARCHAR(25),@deletecount)+ '  '+', does not match to the' + CONVERT(VARCHAR(25),@rowscopied)+  ' rows copied. The unmatched file will be moved to the umatched folder for the org.'
		 SET @errorCode='-2000010'
		 SET @errorEntry='New'
			RAISERROR (@vErr -- Message text
							   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
							   ,1 -- State
								);
     END

END


		SET @deletecount=0

		IF @is_prev='true'
		BEGIN
		SET @rowscopied=@rowscopied-@prev_del_count
		END

		IF @checksumFilter IS NOT NULL
		BEGIN

		SET @select_checksumColumn=RTRIM(LTRIM(SUBSTRING(@checksumFilter,0,CHARINDEX(' ',@checksumFilter))))
		SET @filterDataType=REVERSE(RTRIM(LTRIM(SUBSTRING(REVERSE(@checksumFilter),0,CHARINDEX(' ',REVERSE(@checksumFilter))))))
		SET @sql=' '
		SET @sql='ALTER TABLE #filtercolumn ALTER COLUMN max_val'
		SET @sql=@sql+' '+@filterDataType 


		SET @sql=@sql+'    '+ 'ALTER TABLE #filtercolumn ALTER COLUMN min_val'
		SET @sql=@sql+ '   '+@filterDataType 	

		SET @sql=@sql+'    '+ '	INSERT INTO #filtercolumn (min_val, max_val,id)  SELECT  MIN('
		
		SET @sql=@sql+@select_checksumColumn+')'+',MAX('+ @select_checksumColumn+')'+',1  ' + 'FROM'+' '+@transactionTableCheckSum+''


EXEC(@sql)
---print(@sql)




		END

		SELECT @loop=CASE WHEN @rowscopied%@delete_batch_size>0 THEN (@rowscopied/@delete_batch_size)+1 ELSE @rowscopied/@delete_batch_size END
       
		 

UPDATE azure_data_archive_pipeline_steps_debug
SET additional_comment=ISNULL(additional_comment,'')+'  '+' the loop value is: '+ CAST(@loop AS VARCHAR(10))
WHERE debug_id=@debugId
	
		SET @sql=''

	
		WHILE @counter<=@loop	   		 
		BEGIN

		SELECT @deleteBatchSize=CASE WHEN @counter=@loop AND   @rowscopied%@delete_batch_size>0 THEN @rowscopied%@delete_batch_size ELSE @delete_batch_size  END
	    SELECT @textBatchSize= CAST(@deleteBatchSize AS VARCHAR(15))

BEGIN TRANSACTION

		SET @sql='

		INSERT INTO #detailsId
		SELECT TOP '+@textBatchSize+'  table_unique_id 
		FROM  '+@transactionTableCheckSum+' c
		WHERE is_ready_delete=1 
		AND is_deleted=0		

		DELETE s
		FROM '+@source_table+' s
		INNER JOIN #detailsId t ON t.id='
		
		SET @sql=@sql+'  '+@checksum_uniqueId+ ' '


		IF @checksumFilter IS NOT NULL
		BEGIN

		SET @sql=@sql+'  '+ ' INNER JOIN #filtercolumn d ON d.id=1 WHERE '+@select_checksumColumn+' >=min_val AND '+@select_checksumColumn+' <=max_val

		'
		END

EXEC(@sql)
---print(@sql)

        SET @rowsDeleted=@@ROWCOUNT

		COMMIT
					IF @deleteBatchSize=@rowsDeleted
					BEGIN
					SET @sql=''
					SET @sql='
				
					UPDATE t
					SET is_deleted=1 
					FROM '+@transactionTableCheckSum+' t INNER JOIN #detailsId d
					ON d.id=t.table_unique_id
					WHERE is_ready_delete=1 
		
					TRUNCATE TABLE #detailsId'

EXEC(@sql)
---print(@sql)
	

					SET @deletecount=@deletecount+ @rowsDeleted
					END
				
			    SET @counter=@counter+1		


			



		END
		
	    

		IF @deletecount>0 AND @rowscopied<>@deletecount AND @is_prev='false'
		BEGIN
		 UPDATE azure_data_archive_pipeline_storage_file_name
		 SET is_rows_from_table_deleted=1,
		 is_partial_delete=1,
		 partial_delete_count=@deletecount
		 WHERe azure_file_id=@vfileId
		END

		IF @deletecount>0 AND @rowscopied=@deletecount
		BEGIN
		 UPDATE azure_data_archive_pipeline_storage_file_name
		 SET is_rows_from_table_deleted=1	,
		 partial_delete_count=CASE WHEN @is_prev='true' AND is_partial_delete=1 THEN partial_delete_count+@deletecount ELSE partial_delete_count END,
		 is_partial_delete=CASE WHEN @is_prev='true' AND is_partial_delete=1 THEN 0 ELSE is_partial_delete END
		 WHERe azure_file_id=@vfileId 
		 
		 SET @sql=''
		 SET @sql='TRUNCATE TABLE '+@transactionTableCheckSum+''

EXEC(@sql)
---print(@sql)


		END		

		
UPDATE azure_data_archive_pipeline_steps_debug
SET additional_comment=ISNULL(additional_comment,'')+'  '+'The delete has been completed now the control table and view will be handeld'
WHERE debug_id=@debugId


		 UPDATE  adl
		 SET total_rows_archived_deleted=ISNULL(total_rows_archived_deleted,0) + @deletecount
		 FROM azure_data_archive_pipeline_controller_detail adl 
		 WHERE detail_id=@vdetailId

		 UPDATE azure_data_archive_pipeline_steps_debug
		 SET additional_comment=ISNULL(additional_comment,'')+'  '+' The Total Number of rows deleted ' + '  '+CONVERT(VARCHAR(25),@deletecount)
		 WHERE debug_id=@debugId

 	



						   IF EXISTS (SELECT 1 FROM  azure_data_archive_pipeline_storage_file_name f
									  INNER JOIN azure_data_archive_pipeline_controller_detail dl ON dl.detail_id=f.detail_id				  
									  WHERE is_rows_from_table_deleted=1 and is_file_generated=1
									  AND dl.controller_id=@vcontrollerId
									  )
						   BEGIN

						   IF EXISTS ( SELECT 1 FROM azure_data_archive_pipeline_controller WHERE 
                                      controller_id=@vcontrollerId AND ISNULL(is_existing_view_updated,1)=0)

							BEGIN

								UPDATE azure_data_archive_pipeline_steps_debug
							set additional_comment=ISNULL(additional_comment,'')+ ' Updating the view after deleting the data' 
							WHERE debug_id=@debugId	

							EXEC  sproc_azure_data_archive_retreival_view
							@execution_by,
							@debug_me ,
							@audit_id ,
							@orgcode ,							
							@vmasterControllerId ,
							@vcontrollerId 
							END

			               END

UPDATE a
SET is_archiving_completed=CASE WHEN ISNULL(total_rows_archived,-1)>=total_rows_to_archive THEN 1 ELSE 0 END 
FROM azure_data_archive_pipeline_controller_detail a 
WHERE detail_id=@vdetailId


IF NOT EXISTS (SELECT 1 FROM azure_data_archive_pipeline_controller a
INNER JOIN azure_data_archive_pipeline_controller_detail dl
ON dl.controller_id=a.controller_id
WHERE dl.is_source_history_table=1
AND  is_archiving_completed=0)
BEGIN
UPDATE a
SET is_history_archive_completed=1
FROM azure_data_archive_pipeline_controller a
INNER JOIN azure_data_archive_pipeline_controller_detail dl
ON dl.controller_id=a.controller_id
END


SELECT NULL err_message, 'N' iserror


UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
step_status='Completed'
WHERE debug_id=@debugId


END

ELSE
BEGIN


UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
step_status='Completed',
additional_comment=ISNULL(additional_comment,'')+'  '+' The step was skipped as there was an error prior to this sproc execution'
WHERE debug_id=@debugId
END

UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
step_status='Completed'
WHERE debug_id=@debugId


END TRY

BEGIN CATCH



IF (XACT_STATE()) = -1  
    BEGIN  
         
        ROLLBACK TRANSACTION;  
    END; 
IF @@TRANCOUNT > 0
ROLLBACK

DECLARE  @errorId INT,
         @Error BIT,
		 @logId INT


IF @vErr IS NULL
BEGIN 

		SELECT @vErr=RTRIM( LEFT( 'Store Procedure failed at Line Number : ' +  CASt(ERROR_LINE() as VARCHAR(10)) + ', Description : ' +  ERROR_MESSAGE(), 5000 ) )
		SELECT @errorCode=CAST(ERROR_NUMBER() AS VARCHAR(15))
END
		EXEC sproc_azure_data_archive_pipeline_errors
						@vauditId,
						@vcontrollerId,
						@vmasterControllerId,
						@vdetailid,
						@file_Id,
						@vErr,
						@errorCode,
						'Sproc Proc',
						'SQL Script',
						'Data_Archival_FilenRow_Validation: StoredProcedure_Delete Archived Records',
						'sproc_azure_data_archive_delete_records',
						'New',
						@isError =@Error OUTPUT


		IF @Error=0 OR @Error IS NULL

			BEGIN

			SELECT  
	    
	    
					 'RE' actual_action_code,
					 'Y' isError,					 
					 'New' error_entry
					 
			END	   




UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
additional_comment=ISNULL(additional_comment,'')+'  '+'Step Ended into the Catch block and error is: ' + ISNULL(@vErr,''),
step_status='Error'
WHERE debug_id=@debugId

	


END CATCH


RETURN
END

GO






GO

print 'C_Branch/04_StoredProcedures/sproc_azure_data_archive_delete_records.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_delete_records.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_filename_generator.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- CORE	- 86645	  :   script to create [sproc_azure_data_archive_filename_generator] Procedure  in Client Database
--						-- 
-- Written By:          Dominic Christie
-- Reviewed By:         
-- 
-- Script Type:         DML 
-- Target DB Type:      Client Database
-- Target ENVIRONMENT:  Both
-- 
-- Re-Runable:          YES #
-- 
-- Description of Script : Returns  All the detail of the each controller -table

-- Special Instruction: 
-- 

/*
Revision History:


2021-03-24 Dom Christie  		CORE-86645 4.4.2	 	- Initial Creation of the store proc.
-- =================================================================================


EXEC SCRIPT

exec sproc_azure_data_archive_filename_generator 2,260,'RA','gss26207_996CE94B-1623-43BA-AC42-A979278B94CD', 'chrisd',1,'y',0

*/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_azure_data_archive_filename_generator' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE [dbo].sproc_azure_data_archive_filename_generator
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO

CREATE  PROCEDURE sproc_azure_data_archive_filename_generator

@detail_id INT,
@audit_id INT,
@actual_action_code VARCHAR(4),
@orgcode VARCHAR(100),
@execution_by VARCHAR(65),
@loop_id SMALLINT,
@debug_me CHAR(1)='N',
@is_prev_merge BIT
AS

BEGIN

DECLARE 	@vauditId INT,
            @vdetailid INT,
			@vcontrollerId SMALLINT,
			@vmasterControllerId TINYINT,
			@transactionTable VARCHAR(100),
			@vtextyear VARCHAR(4),
			@rowsperfile INT,
			@id INT,
			@text_detail_id VARCHAR(15),
		    @vactualActioncode VARCHAR(4),
			@table_name VARCHAR(150),
			@vErr VARCHAR(5000) ,
			@sql VARCHAR(2500),
			@errorEntry VARCHAR(4),
			@rwcnt TINYINT,
			@errorCode VARCHAR(150),
			@debugId INT,
			@outputdebugId INT,
			@prevId INT
			

BEGIN TRY 

	   DECLARE @file TABLE
	   (detail_id INT,
	    [file_id] INT,
		[file_name] VARCHAR(150),
		controller_id SMALLINT,
		source_table  VARCHAR(100),
		folder VARCHAR(60),
		subfolder CHAR(4),
		date_filter DATETIME
	   )



	   DECLARE @Output TABLE ( detail_id INT,
                        [file_id]  INT,
						[file_name] VARCHAR(150),
						controller_id SMALLINT,
						source_Table VARCHAR(150),
						folder VARCHAR(150),
						subfolder SMALLINT,
						date_filter DATE,
						isError CHAR(1),
						actual_action_code VARCHAR(4),
						debugId INT,
						ErrorType  VARCHAR(4)
					---,	rows_by_batch SMALLINT
)
SELECT @vauditId=@audit_id 

IF @loop_id=-1
BEGIN
INSERT INTO azure_data_archive_pipeline_steps_debug

SELECT 'Executing sproc_azure_data_archive_filename_generator- for merge', @vauditId, 'Started',GETDATE(),NULL, NULL,GETUTCDATE(),NULL,NULL

SET @debugId=SCOPE_IDENTITY()
END
ELSE

BEGIN
INSERT INTO azure_data_archive_pipeline_steps_debug

SELECT 'Executing sproc_azure_data_archive_filename_generator', @vauditId, 'Started',GETDATE(),NULL, NULL,GETUTCDATE(),NULL,NULL

SET @debugId=SCOPE_IDENTITY()

END



SET @vdetailid=@detail_id 
SET @vactualActioncode=@actual_action_code
SELECT @text_detail_id=CAST(@detail_id AS varchar(5))


SELECT @vmasterControllerId=c.master_controller_id,
@vcontrollerId=c.controller_id,
@table_name=source_table,
@rowsperfile=rows_per_file
FROM azure_data_archive_pipeline_controller_detail dl
INNER JOIN azure_data_archive_pipeline_controller c ON 
dl.controller_id=c.controller_id
INNER JOIN azure_data_archive_pipeline_master_controller m ON m.master_controller_id=c.master_controller_id
WHERE dl.detail_id=@vdetailid



IF @vactualActioncode IN ('CHRA','ECHA')

BEGIN
       IF EXISTS (SELECT 1 FROM azure_data_archive_pipeline_controller_detail WHERE detail_id=@vdetailid AND count_completed=0)
	   BEGIN



		UPDATE azure_data_archive_pipeline_steps_debug
		set additional_comment=ISNULL(additional_comment,'')+ ' Started counting the rows for the  detailid: '+'  '+ CAST(@vdetailId AS VARCHAR(15))
		WHERE debug_id=@debugId	   


								IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES where TABLE_NAME=@table_name)
								BEGIN
						      
							   


								SET @sql='
								IF EXISTS  (SELECT 1 FROM '+@table_name+')	
								BEGIN 
								UPDATE a
								SET total_rows_to_archive=ISNULL(cnt,0),
								count_completed=CASE WHEN ISNULL(cnt,0)>0 THEN 1 ELSE 0 END
								FROM azure_data_archive_pipeline_controller_detail a
								INNER JOIN (SELECT COUNT(*) cnt       
											FROM  '+@table_name+' 
											)t ON
								1=1
								WHERE detail_id='+@text_detail_id+'							
								END
								ELSE
								BEGIN 
								  UPDATE azure_data_archive_pipeline_controller_detail
									SET count_completed=1,
									is_archiving_completed=1 ,
									total_rows_to_archive=0
									WHERE is_source_history_table=1
									AND ISNULL(total_rows_to_archive,0)<1
									AND detail_id='+@text_detail_id+'	
								END
								'

								IF @debug_me='Y'
								BEGIN
								print(@sql)
								END 


								exec (@sql)	
		
								END

						IF NOT EXISTS (SELECT 1 FROM azure_data_archive_pipeline_controller_detail WHERE is_source_history_table=1 AND count_completed=0)
						BEGIN

						IF @debug_me='Y'
						BEGIN
						Select 'entered into if not exists pho_schedule_details is_source_history_table=1 AND count_completed=0'
						END 



						UPDATE azure_data_archive_pipeline_controller 
						SET is_history_rows_counted=1
						WHERE is_history_exists=1		
						AND controller_id=@vcontrollerId

						END


 


		UPDATE azure_data_archive_pipeline_steps_debug
		set additional_comment=ISNULL(additional_comment,'')+ ' The Counting was completed at'+CONVERT(VARCHAR(20),GETDATE())+  'for the  detailid:'+'  '+ CAST(@vdetailId AS VARCHAR(15))+'  '
		WHERE debug_id=@debugId	   



			 END
END



IF @loop_id>0 
BEGIN

					IF EXISTS (SELECT 1 FROM azure_data_archive_pipeline_storage_file_name WHERE detail_id=@vdetailId AND is_file_generated=0
							   AND is_rows_from_table_deleted=0 AND is_file_table_deleted_rows_mismatch=0)
					BEGIN
	   
						DELETE FROM azure_data_archive_pipeline_storage_file_name WHERE detail_id=@vdetailId AND is_file_generated=0
							   AND is_rows_from_table_deleted=0 AND is_file_table_deleted_rows_mismatch=0---- AND is_merged=0

						SET @rwcnt=@@ROWCOUNT

						UPDATE azure_data_archive_pipeline_steps_debug
						set additional_comment=ISNULL(additional_comment,' ')+ ' Deleted total ' +CAST(@rwcnt AS VARCHAR(10))+' file entries that were not used in previous execution for detailid:'+'  '+ CAST(@vdetailId AS VARCHAR(15))+' '
						WHERE debug_id=@debugId
					END


		   IF  EXISTS   (SELECT 1 FROM azure_data_archive_pipeline_storage_file_name WHERE detail_id=@vdetailId
		                  AND is_file_generated=1  AND   is_rows_from_table_deleted=0 AND (is_unmatched_file_deleted=0 OR is_unmatched_file_moved=0)
						  )
						  				  

						
					   
		   BEGIN






		   
						SELECT @vErr='The Copy Activity will not start since the previous file was successfully generated but neither the data was not successfully deleted.'
						
							 SET @vErr = @vErr+ ' for the detailId: '+ CAST(@vdetailid AS VARCHAR(15))+'  '
							 SET @errorCode='-2000022'
							 SET @errorEntry='New'
								RAISERROR (@vErr -- Message text
												   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
												   ,1 -- State
													);
           END
		   ELSE
		   BEGIN

				  IF  EXISTS   (SELECT 1 FROM azure_data_archive_pipeline_storage_file_name WHERE detail_id=@vdetailId
							  AND is_file_generated=1  AND is_rows_from_table_deleted=0  AND is_file_table_deleted_rows_mismatch=1 
							  AND (is_unmatched_file_deleted=0 OR is_unmatched_file_moved=0))

						
					   
				   BEGIN

		   			SELECT @vErr='The Copy Activity will not start since the previous file was successfully generated but the file with delete mismatch was not either moved or deleted sucessfully.'
						
									 SET @vErr = @vErr+ ' for the detailId: '+ CAST(@vdetailid AS VARCHAR(15))+'  '
									 SET @errorCode='-2000023'
									 SET @errorEntry='New'
										RAISERROR (@vErr -- Message text
														   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
														   ,1 -- State
															);

				   END
				   ELSE
				   BEGIN 
				   
					SELECT  @transactionTable=transaction_table_name,
					@vtextyear=CONVERT(VARCHAR(4),year_to_archive)
					FROM azure_data_archive_pipeline_controller_detail d 
					INNER JOIN  azure_data_archive_pipeline_controller c 
					ON c.controller_id=d.controller_id
					WHERE detail_id=@vdetailId
					AND c.controller_id=@vcontrollerId
					AND (
					( is_archiving_completed=0 AND is_source_history_table=1 AND ISNULL(total_rows_to_archive,0)>0)
					OR ( is_archiving_completed=0 AND is_source_history_table=0)
					)

					            IF @@ROWCOUNT>0
								BEGIN
			
				
								INSERT INTO azure_data_archive_pipeline_storage_file_name
								(azure_file_name,detail_id,pipeline_audit_id)
								SELECT @orgcode+'_'+@transactionTable+ '_'+ @vtextyear+'_'+CONVERT(VARCHAR,getdate(),121)+'.parquet',
									   @vdetailId,
									   @vauditId
									   

									   
								--FROM azure_data_archive_pipeline_storage_files_batch
								--WHERE master_controller_id=@vmasterControllerId
				   
				   

								INSERT INTO @Output

								SELECT   @vdetailid detail_id,
										 azure_file_id as [file_id],
										 azure_file_name [file_name] ,
										 @vcontrollerId controller_id,
										 source_table ,		
										 @transactionTable folder, 
										 @vtextyear subfolder,
										 date_filter,
										 CASE WHEN e.controller_id IS NOT NULL THEN 'Y' ELSE 'N'  END isError,
										 @actual_action_code actual_action_code,
										 @debugId output_Id,
										 CASE WHEN e.controller_id IS NOT NULL THEN 'PREV' ELSE 'NEW'  END ErrorType
										 ---rows_by_batch
								FROM azure_data_archive_pipeline_controller_detail c
								INNER JOIN azure_data_archive_pipeline_storage_file_name n
								ON c.detail_id=n.detail_id
								
								LEFT JOIN(SELECT DISTINCT pipeline_audit_id,controller_id FROM  azure_data_archive_pipeline_errors WHERE pipeline_audit_id=@vauditId AND controller_id=@vcontrollerId) e
								ON e.controller_id=c.controller_id
								WHERE is_file_generated=0
								AND n.detail_id=@vdetailid					
								AND is_archiving_completed=0
								AND c.controller_id=@vcontrollerId
								----AND (is_merged IS NULL OR is_merged=0)
								AND n.pipeline_audit_id=@vauditId




								SET @rwcnt=@@ROWCOUNT

								    IF @rwcnt>=0
										BEGIN

										UPDATE azure_data_archive_pipeline_steps_debug
										set additional_comment=ISNULL(additional_comment,' ')+ ' New file/s were created for detailid:'+'  '+ CAST(@vdetailId AS VARCHAR(15))+'  '
										WHERE debug_id=@debugId

									
										SELECT * FROM @Output

										END
									    ELSE
										BEGIN
											  SELECT NULL actual_action_code,
													'Y' isError,	
													@debugId output_Id,
												   'New' ErrorType
										END

			
								END
								ELSE

								BEGIN
								SELECT NULL actual_action_code,
												'Y' isError,	
												@debugId output_Id,
												'New' ErrorType
								END
									
				   END

		     


					

    
	





END


END

ELSE

BEGIN




		IF NOT EXISTS (SELECT 1 FROM azure_data_archive_pipeline_storage_file_master m
					   INNER JOIN azure_data_archive_pipeline_merge_activity_audit a 
					   ON a.master_file_id=m.master_file_id					   
					   WHERE is_utilized=0
					   AND detail_id=@vdetailid)

		BEGIN

					   	 			  			  			 
                   IF EXISTS (SELECT 1 FROM azure_data_archive_pipeline_storage_file_master m
			             LEFT JOIN azure_data_archive_pipeline_merge_activity_audit am
						 ON am.master_file_id=m.master_file_id 
						 LEFT JOIN azure_data_archive_pipeline_storage_file_name s
						 ON s.master_file_id=m.master_file_id 
						 WHERE m.detail_id=@vdetailid
			             AND is_utilized=1 
						 AND (s.master_file_id IS NULL OR am.master_file_id IS NULL )
					    )
					  BEGIN 

					 
				


					  		SELECT @vErr='The Merge Activity will not start since there is no merge activity for the previous Master file and master file showed as utilized'
						
							 SET @vErr = @vErr+ ' for the detailId: '+ CAST(@vdetailid AS VARCHAR(15))+'  '
							 SET @errorCode='-2000023'
							 SET @errorEntry='New'
								RAISERROR (@vErr -- Message text
												   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
												   ,1 -- State
													);


					  END
					  ELSE
					  BEGIN----1


					   IF  EXISTS (SELECT 1 FROM azure_data_archive_pipeline_storage_file_master m		
			                  INNER JOIN azure_data_archive_pipeline_storage_file_name s
			                  ON m.detail_id=ISNULL(s.detail_id,0)
						      WHERE is_utilized=0
						      AND m.detail_id=@vdetailid
							  AND is_merged=0							 
							  AND is_ready_delete=0)
			            BEGIN 

														
					 				INSERT INTO @Output

															SELECT   @vdetailid detail_id,
																	 master_file_id,
																	 azure_file_name [file_name] ,
																	 @vcontrollerId controller_id,
																	 source_table ,		
																	 transaction_table_name folder, 
																	 CONVERT(VARCHAR(4),year_to_archive) subfolder,
																	 NULL,
																	 CASE WHEN e.controller_id IS NOT NULL THEN 'Y' ELSE 'N'  END isError,
																	 @actual_action_code actual_action_code,
																	 @debugId debugId,
																	 CASE WHEN e.controller_id IS NOT NULL THEN 'PREV' ELSE 'NEW'  END ErrorType
																	
															FROM azure_data_archive_pipeline_controller_detail c
															INNER JOIN  azure_data_archive_pipeline_controller d
															ON c.controller_id=d.controller_id
															INNER JOIN azure_data_archive_pipeline_storage_file_master n
															ON c.detail_id=n.detail_id
															LEFT JOIN(SELECT DISTINCT pipeline_audit_id,controller_id FROM  azure_data_archive_pipeline_errors WHERE pipeline_audit_id=@vauditId AND controller_id=@vcontrollerId) e
															ON e.controller_id=c.controller_id
															WHERE n.detail_id=@vdetailid															
															AND is_archiving_completed=0
															AND c.controller_id=@vcontrollerId
															AND is_utilized=0 

															SET @rwcnt=@@ROWCOUNT

                                                            UPDATE azure_data_archive_pipeline_steps_debug
															set additional_comment=ISNULL(additional_comment,' ')+ ' Existing  master file  will be used for detailid:'+'  '+ CAST(@vdetailId AS VARCHAR(15))+' '
															WHERE debug_id=@debugId

															INSERT INTO azure_data_archive_pipeline_steps_debug

															SELECT 'The Merging will start if files exists the sproc was called with merge for:'+ CASE WHEN @is_prev_merge='true' THEN 'previous merge' ELSE 'no previous merge' END, @vauditId, 'Started',GETDATE(),NULL, NULL,GETUTCDATE(),NULL,NULL

															SET @outputdebugId=SCOPE_IDENTITY()

															IF @rwcnt>0
															BEGIN
															SELECT o.detail_id,
														   [file_id],
														   source_Table,
														   folder,
														   subfolder,
														   controller_id,
														   isError,
														   [file_name],
														   actual_action_code,
														   debugId,
														   ErrorType,
														   @outputdebugId output_Id
														   FROM   @Output o
														   END
														   ELSE
														    BEGIN
					   										 SELECT NULL actual_action_code,
																					'Y' isError,	
																					@outputdebugId output_Id,
																					'New' ErrorType
															END

							 



						END
						ELSE 
						BEGIN


										   IF EXISTS (SELECT 1 FROM azure_data_archive_pipeline_storage_file_name WHERE detail_id=@vdetailid
										   AND is_file_generated=1 AND is_rows_from_table_deleted=1 AND ISNULL(is_merged,0)=0 AND ISNULL(master_file_id,0)=0)
											BEGIN---2

				                                 SELECT     @transactionTable=transaction_table_name,
															@vtextyear=CONVERT(VARCHAR(4),year_to_archive)
															FROM azure_data_archive_pipeline_controller_detail d 
															INNER JOIN  azure_data_archive_pipeline_controller c 
															ON c.controller_id=d.controller_id
															WHERE detail_id=@vdetailId
															AND c.controller_id=@vcontrollerId

			
															INSERT INTO azure_data_archive_pipeline_storage_file_master
															(pipeline_audit_id,azure_file_name,detail_id)

															SELECT @vauditId,
																  'master_'+ @orgcode+'_'+@transactionTable+ '_'+ @vtextyear+'_'+CONVERT(VARCHAR,getdate(),121)+'.parquet',
																   @vdetailId	

															SELECT @id=SCOPE_IDENTITY()
			
															INSERT INTO @Output

															SELECT   @vdetailid detail_id,
																	 master_file_id,
																	 azure_file_name [file_name] ,
																	 @vcontrollerId controller_id,
																	 source_table ,		
																	 @transactionTable folder, 
																	 @vtextyear subfolder,
																	 NULL,
																	 CASE WHEN e.controller_id IS NOT NULL THEN 'Y' ELSE 'N'  END isError,
																	 @actual_action_code actual_action_code,
																	 @debugId debugId,
																	 CASE WHEN e.controller_id IS NOT NULL THEN 'PREV' ELSE 'NEW'  END ErrorType
																	 
															FROM azure_data_archive_pipeline_controller_detail c															
															INNER JOIN azure_data_archive_pipeline_storage_file_master n
															ON c.detail_id=n.detail_id
															LEFT JOIN(SELECT DISTINCT pipeline_audit_id,controller_id FROM  azure_data_archive_pipeline_errors WHERE pipeline_audit_id=@vauditId AND controller_id=@vcontrollerId) e
															ON e.controller_id=c.controller_id
															WHERE n.detail_id=@vdetailid
															AND master_file_id=@id
															AND is_archiving_completed=0
															AND c.controller_id=@vcontrollerId
															AND is_utilized=0 

																		 SET @rwcnt=@@ROWCOUNT

															UPDATE azure_data_archive_pipeline_steps_debug
															set additional_comment=ISNULL(additional_comment,' ')+ ' New  master file was created and will be used for detailid:'+'  '+ CAST(@vdetailId AS VARCHAR(15))+' '
															WHERE debug_id=@debugId

															INSERT INTO azure_data_archive_pipeline_steps_debug

															SELECT 'The Merging will start if files exists the sproc was called with merge previous flag:'+ CAST(@is_prev_merge AS VARCHAR(6)), @vauditId, 'Started',GETDATE(),NULL, NULL,GETUTCDATE(),NULL,NULL

															SET @outputdebugId=SCOPE_IDENTITY()

															IF @rwcnt>0
															BEGIN
															SELECT o.detail_id,
														   [file_id],
														   source_Table,
														   folder,
														   subfolder,
														   controller_id,
														   isError,
														   [file_name],
														   actual_action_code,
														   debugId,
														   ErrorType,
														   @outputdebugId output_Id
														   FROM   @Output o
														   END
														   ELSE
														    BEGIN
					   										 SELECT NULL actual_action_code,
																					'Y' isError,	
																					@outputdebugId output_Id,
																					'New' ErrorType
															END

							 

											END---2
											ELSE
											BEGIN--3

													SELECT @vErr='The Merge Activity will not start since there are no files available that are successfully generated and data deleted'
						
														 SET @vErr = @vErr+ ' for the detailId: '+ CAST(@vdetailid AS VARCHAR(15))+'  '+  'This could be because of the previous error for this execution or  script-logic issue or the pipeline activity failure'
														 SET @errorCode='-2000024'
														 SET @errorEntry='New'
															RAISERROR (@vErr -- Message text
																			   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
																			   ,1 -- State
																				);
											END---3
									END

                    END---1
					
				
		END
		ELSE
		BEGIN
			SELECT @vErr='The Merge Activity will not start since the previous Master file was successfully generated and merged but sometyhing went wrong with the script-logic and the master file still shows not utilized'
						
							 SET @vErr = @vErr+ ' for the detailId: '+ CAST(@vdetailid AS VARCHAR(15))+'  '
							 SET @errorCode='-2000023'
							 SET @errorEntry='New'
								RAISERROR (@vErr -- Message text
												   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
												   ,1 -- State
													);
		END




END



UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
step_status='Completed'
WHERE debug_id=@debugId

END TRY

BEGIN CATCH


DECLARE  @errorId INT,
         @Error BIT,
		 @logId INT


IF @vErr IS NULL
BEGIN 

		SELECT @vErr=RTRIM( LEFT( 'Store Procedure failed at Line Number : ' +  CASt(ERROR_LINE() as VARCHAR(10)) + ', Description : ' +  ERROR_MESSAGE(), 5000 ) )
		SELECT @errorCode=CAST(ERROR_NUMBER() AS VARCHAR(15))
END
		EXEC sproc_azure_data_archive_pipeline_errors
						@vauditId,
						@vcontrollerId,
						@vmasterControllerId,
						@vdetailid,
						-1,
						@vErr,
						@errorCode,
						'Sproc Proc',
						'SQL Script',
						'Data_Archival_FIle_Generator: Look Up_File Name Generator',
						'sproc_azure_data_archive_filename_generator',
						'New',
						@isError =@Error OUTPUT


		IF @Error=0 OR @Error IS NULL

			BEGIN

			SELECT  
	    
	    
					 'RE' actual_action_code,
					 'Y' isError,					
					 'New' error_entry,
					 @outputdebugId output_Id
					 
			END	   




UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
additional_comment=ISNULL(additional_comment,'')+'  '+'Step Ended into the Catch block and error is: ' + ISNULL(@vErr,''),
step_status='Error'
WHERE debug_id=@debugId

	


END CATCH

END








GO

print 'C_Branch/04_StoredProcedures/sproc_azure_data_archive_filename_generator.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_filename_generator.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_generate_parquet_files.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO



-- ================================================================================= 
-- CORE	- 86645	  :   script to create [sproc_azure_data_archive_generate_parquet_files] Procedure  in Client Database
--						-- 
-- Written By:          Dominic Christie
-- Reviewed By:         
-- 
-- Script Type:         DML 
-- Target DB Type:      Client Database
-- Target ENVIRONMENT:  Both
-- 
-- Re-Runable:          YES #
-- 
-- Description of Script : This store procedure will return the data that will be available in the parquet files
-- 
-- Special Instruction: 
-- 

/*
Revision History:


2021-03-24 Dom Christie  		CORE-86645 4.4.2	 	- Initial Creation of the store proc.
-- =================================================================================


EXEC SCRIPT:

exec sproc_azure_data_archive_generate_parquet_files 1,1,'CHRA',3,806,'pcc-chrisd','y',20000,2306


*/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_azure_data_archive_generate_parquet_files' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE [dbo].sproc_azure_data_archive_generate_parquet_files
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO

CREATE  PROCEDURE sproc_azure_data_archive_generate_parquet_files

(@controller_id SMALLINT,
@master_controller_id TINYINT,
@actual_action_code VARCHAR(4),
@detail_id INT,
@audit_id INT,
@execution_by VARCHAR(65),
@debug_me CHAR(1)='N',
@batch_size INT,
@file_id INT

)
AS


BEGIN




DECLARE @sql VARCHAR(3500),
       @vErr VARCHAR(3500),	 
        @vrowsperfile VARCHAR(12),
		@vtabletoarchive VARCHAR(150),
		@vcontrollerId SMALLINT,
		@vtransaction_table VARCHAR(100),		
        @vpipeline_end DATETIME,			
		@vstartdatetime DATETIME,
		@venddatetime DATETIME,
		@vtextyear VARCHAR(4),
		@vauditId INT,
		@vmasterControllerId SMALLINT,
		@vdetailId INT,
		@table_name VARCHAR(150),
		@vmaxrow INT,	
		@text_detail_id VARCHAR(15),
		@vactualActioncode VARCHAR(4),
		@sqlSelect  VARCHAR(2500),
		@debugId INT,
		@chkSum VARCHAR(1600),
		@sqlCheckSum VARCHAR(1500),
		@transactionTableCheckSum VARCHAR(170),
		@checksumFilter VARCHAR(350),
		@select_checksumColumn VARCHAR(300),
		@checksum_uniqueId VARCHAR(200)
		
		

SELECT @vauditId=@audit_id
SET @vcontrollerId =@controller_id
SET @vmasterControllerId=@master_controller_id
SET @vdetailId=@detail_id 
SET @vactualActioncode=@actual_action_code
SET @text_detail_id=@detail_id

INSERT INTO azure_data_archive_pipeline_steps_debug

SELECT 'Executing sproc_azure_data_archive_generate_parquet_files', @vauditId,'Started',GETDATE(),NULL, 'Running for the controllerid: '+' '+ CAST(@vcontrollerId AS VARCHAR(15))+'  ' + 'and detailId: '+  CAST(@detail_id AS VARCHAR(15))+'  ',GETUTCDATE(),NULL,@file_id

SET @debugId=SCOPE_IDENTITY()


IF  NOT EXISTS (SELECT 1 FROM azure_data_archive_pipeline_errors WHERE pipeline_audit_id=@vauditId AND controller_id=@vcontrollerId)

BEGIN 		



UPDATE azure_data_archive_pipeline_steps_debug
SET additional_comment=ISNULL(additional_comment,'')+'  '+'Started working on generating the data for parquet files' 
WHERE debug_id=@debugId



SELECT @vpipeline_end=pipeline_to_end_time_utc,
@vrowsperfile=CONVERT(VARCHAR(12),rows_per_file),	 
@vmaxrow=@batch_size
FROM azure_data_archive_pipeline_master_controller m
WHERE m.master_controller_id=@vmasterControllerId


IF @vpipeline_end>GETUTCDATE()
			BEGIN
			
UPDATE azure_data_archive_pipeline_steps_debug
SET additional_comment=ISNULL(additional_comment,'')+'  '+'The present time is still less than the pipeline to end and so will continue' 
WHERE debug_id=@debugId

			SELECT  @vtransaction_table=transaction_table_name,
			@vtextyear=CONVERT(VARCHAR(4),year_to_archive),
			@vtabletoarchive=source_table,
			@sqlSelect=sql_query_select,
			@chkSum=check_sum_columns,			
			@checksumFilter=check_sum_column_filter,
			@transactionTableCheckSum=CASE WHEN is_history_exists =1 AND is_history_archive_completed=0 THEN source_table ELSE transaction_table_name END,
			@checksum_uniqueId=check_sum_unique_id_column
			FROM azure_data_archive_pipeline_controller_detail d 
			INNER JOIN  azure_data_archive_pipeline_controller s
			ON s.controller_id=d.controller_id
			WHERE detail_id=@vdetailId

			       
					
			
			       	SET @transactionTableCheckSum=@transactionTableCheckSum+'_checksum'


						 IF @checksumFilter IS NULL
						 BEGIN
							 SET @sqlCheckSum='
							 IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='''+@transactionTableCheckSum+''')
							 BEGIN
							 CREATE TABLE '+@transactionTableCheckSum+' (table_unique_id BIGINT, table_row_checksum INT,is_ready_delete BIT, is_deleted BIT'
						 END 
						 ELSE
						 BEGIN

						 SELECT @select_checksumColumn=RTRIM(LTRIM(SUBSTRING(@checksumFilter,0,CHARINDEX(' ',@checksumFilter))))

						 	 SET @sqlCheckSum='
							 IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='''+@transactionTableCheckSum+''')
							 BEGIN
							 CREATE TABLE '+@transactionTableCheckSum+' (table_unique_id BIGINT, table_row_checksum INT,is_ready_delete BIT, is_deleted BIT , '+@checksumFilter+''
						 END

						
						 SET @sqlCheckSum=@sqlCheckSum + '

						 CONSTRAINT ['+@transactionTableCheckSum+'_tableUniqueId_PK] PRIMARY KEY CLUSTERED
								(
								   table_unique_id ASC
								)
						 )	
				 
						 CREATE NONCLUSTERED INDEX '+@transactionTableCheckSum+'_isReadyDeleted_INC_isDeleted_NCL_IX 
						 ON '+@transactionTableCheckSum+' (is_ready_delete) 
						 INCLUDE (is_deleted)
						 
						 END
						 


				 '
				 
				exec (@sqlCheckSum)
					---print (@sqlCheckSum)
			




			
		
										SET @sql=  'IF EXISTS (SELECT 1 FROM '+@vtabletoarchive+''

			

										SET @sql=@sql+' '+')'
										SET @sql=@sql+' '+
													' BEGIN


													        
																									   								
															IF NOT EXISTS (SELECT  1 FROM '+@transactionTableCheckSum+' WHERE is_ready_delete=1)
															BEGIN
															TRUNCATE TABLE '+@transactionTableCheckSum+'
															INSERT INTO  '+@transactionTableCheckSum+' 
															SELECT   TOP  '+@vrowsperfile+'  '+@checksum_uniqueId+', '+@chkSum+',0,0,'+@select_checksumColumn+' 
															FROM  '+@vtabletoarchive+' s
															
															SELECT  '+@sqlSelect+'				
							
															FROM '+@vtabletoarchive+' s
															INNER JOIN '+@transactionTableCheckSum+' t 
															ON t.table_unique_id='+@checksum_uniqueId+'
													
															END
											
													

								
													  END 
									
									
											 '     
                    
				 
							IF @debug_me='Y'
							BEGIN
							print  (@sql)
							END 
							
							EXEC(@sql)
						

				         


									--ELSE

									--BEGIN
									--SELECT @venddatetime=CASE WHEN LEN(@date)>1  THEN @date
									--ELSE CONVERT(DATETIME,CONVERT(varchar(4),@year_to_archive+1) +'-01-01 00:00:00.000',121) END
				
									--SET @sql='SELECT TOP  '+@vrowsperfile+' * FROM '+@vtabletoarchive+' 
									--				WHERE schedule_date>='''+CONVERT(VARCHAR(20),@vstartdatetime, 20)+'''
									--				AND schedule_date<'''+CONVERT(VARCHAR(20),@venddatetime, 20)+'''
									--				'
									--exec (@sql)
									--END



						END

UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
step_status='Completed'
WHERE debug_id=@debugId


			END




 
END




GO

print 'C_Branch/04_StoredProcedures/sproc_azure_data_archive_generate_parquet_files.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_generate_parquet_files.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_get_controller_detail.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- CORE	- 86645	  :   script to create [sproc_azure_data_archive_get_controller_detail] Procedure  in Client Database
--						-- 
-- Written By:          Dominic Christie
-- Reviewed By:         
-- 
-- Script Type:         DML 
-- Target DB Type:      Client Database
-- Target ENVIRONMENT:  Both
-- 
-- Re-Runable:          YES #
-- 
-- Description of Script : Returns  All the detail of the each controller - table

-- Special Instruction: 
-- 

/*
Revision History:


2021-03-24 Dom Christie  		CORE-86645 4.4.2	 	- Initial Creation of the store proc.
-- =================================================================================


EXEC SCRIPT
 
exec sproc_azure_data_archive_get_controller_detail 'chrisd',1,247,'n',1

*/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_azure_data_archive_get_controller_detail' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE [dbo].sproc_azure_data_archive_get_controller_detail
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO

CREATE  PROCEDURE sproc_azure_data_archive_get_controller_detail
@execution_by VARCHAR(65),
@master_controller_id TINYINT,
@audit_id INT,
@debug_me CHAR(1)='N',
@overrideError VARCHAR(150)


AS


BEGIN

DECLARE  @vauditId INT,      
         @vErr VARCHAR(5000) , 	
		 @errorEntry VARCHAR(4),
		 @vmasterControllerId TINYINT,
		 @vcontrollerId SMALLINT,
		 @errorCode VARCHAR(150),
		 @errorDetailId VARCHAR(100),
		 @vpipeLineToEnd DATETIME,
		 @debugId INT

DECLARE @TAB TABLE(Id INT)

BEGIN TRY

SET @vauditId=@audit_id 
SET @vmasterControllerId=@master_controller_id

INSERT INTO azure_data_archive_pipeline_steps_debug

SELECT 'Executing sproc_azure_data_archive_get_controller_detail', @vauditId, 'Started',GETDATE(),NULL, NULL,GETUTCDATE(),NULL,NULL

SET @debugId=SCOPE_IDENTITY()

SET @overrideError=ISNULL(NULLIF(@overrideError,''),'N')


IF @overrideError<>'N'
BEGIN

INSERT INTO @TAB
SELECT * from dbo.Split(@overrideError,',')


INSERT INTO azure_data_archive_pipeline_log
SELECT GETDATE(), 'The value of the OverRideError param was set to override the previous error by user '+ @execution_by , 'Warning Entry','Data_Archival_Controller'

END


--Error Tapping for any manual or unexpected parameter

IF NOT EXISTS (SELECT 1 FROM azure_data_archive_pipeline_audit WHERE pipeline_audit_id=@vauditId )---AND pipeline_actual_end IS NULL) 
BEGIN 

SET @vErr = 'Something went wrong, audit id: ' +CAST(@vauditId AS VARCHAR(15)) +' passed to the procedure does not match to the audit id in the azure_data_archive_pipeline_audit for the existing pipeline execution.'
SET @errorEntry='New'
SET @vcontrollerId=-1
SET @errorCode ='-2000004'

	RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);


END 



DECLARE 
		@id INT,
		@monthintrax SMALLINT,
		@transaction_table VARCHAR(150),
		@rowsperfile INT,
		@vtodate DATETIME,		
		@vdatefilter DATETIME,
		@outputrow SMALLINT,
		@maxyeararchived SMALLINT,
		@minyear SMALLINT,
		@textminyear CHAR(4),
		@historyBIT BIT,
		@ControllerId TINYINT,	
		@transactionTableCheckSum VARCHAR(170) 		


DECLARE @outputTableToArchive TABLE
(

detail_id INT,
controller_id SMALLINT,
master_controller_id TINYINT,	
folder VARCHAR(100),
subfolder VARCHAR(100),
action_today VARCHAR(1),		
actual_action_code VARCHAR(4)

)


DECLARE @Controller TABLE
( id TINYINT IDENTITY(1,1), 
 controller_id SMALLINT,
 master_controller_id TINYINT,		
 transaction_table_name VARCHAR(150),	
 number_of_months_in_transaction_table TINYINT,
 min_year_to_start_archive SMALLINT,
 is_rows_count BIT,
 is_error_run BIT,
 ishistoryComp BIT 


 
)

DECLARE @existingError TABLE 
(audit_id INT, 
 controller_id SMALLINT,
 errorEntry VARCHAR(4),
 errorDetailId VARCHAR(20)
 )



 --Error capturing from previous execution that had unexpected parameters or values or manual intervention



IF EXISTS (SELECT 1 FROM azure_data_archive_pipeline_errors e INNER JOIN  
           azure_data_archive_pipeline_controller c ON c.pipeline_audit_id=e.pipeline_audit_id WHERE 
		   c.master_controller_id=@vmasterControllerId AND  e.controller_id IS NULL AND is_job_fix=0
		   AND @overrideError='N'
)
BEGIN



SET @errorEntry='PREV'
SELECT @errorDetailId= 'error:' + CAST(e.error_id AS VARCHAR(10)) 
FROM azure_data_archive_pipeline_errors e 
INNER JOIN  azure_data_archive_pipeline_controller c 
ON c.pipeline_audit_id=e.pipeline_audit_id WHERE e.controller_id IS NULL AND is_job_fix=0
AND c.master_controller_id=@vmasterControllerId

	RAISERROR (@vErr-- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);



END





IF EXISTS (SELECT 1 FROM azure_data_archive_pipeline_controller c WHERE pipeline_audit_id IS NOT NULL
            AND  last_execution_end_time IS NULL AND c.master_controller_id=@vmasterControllerId AND @overrideError='N')
BEGIN



INSERT INTO azure_data_archive_pipeline_errors
SELECT c.pipeline_audit_id,
       -1,
	   -1,
       c.controller_id,
	   'Something went wrong in the previous pipeline execution and the (column: last_execution_end_time) for the table:'+'  '+transaction_table_name+'  '+ 'was NULL. The successful completion of the pipeline for the table will update the column with datetime.',
	   '-2000005',
	   GETDATE(),
	   'Unkown',
	   'Unkown',
	   'sproc_azure_data_archive_get_controller_detail',
	   '',
	   GETUTCDATE()

FROM azure_data_archive_pipeline_controller c 
LEFT JOIN  azure_data_archive_pipeline_errors e ON 
e.controller_id=c.controller_id AND e.pipeline_audit_id=c.pipeline_audit_id AND error_code='-2000005'
WHERE e.controller_id IS NULL AND e.pipeline_audit_id IS NULL
AND c.last_execution_end_time IS NULL
AND c.master_controller_id=@vmasterControllerId

END





INSERT INTO @existingError
SELECT c.pipeline_audit_id,
       c.controller_id,
	   CASE WHEN CONVERT(DATE,error_logged_time,1)=CONVERT(DATE,GETDATE(),1) THEN 'New' ELSE 'PREV' END,
	   'error:' + CAST(e.error_id AS VARCHAR(10))
	 
	 
FROM azure_data_archive_pipeline_errors  e 
INNER JOIN azure_data_archive_pipeline_controller c
ON c.controller_id=e.controller_id AND c.pipeline_audit_id=e.pipeline_audit_id
AND is_job_fix=0
AND c.master_controller_id=@vmasterControllerId
AND @overrideError='N'




IF @debug_me='Y'
BEGIN
SELECT '@existingError', * from @existingError 
END	 	



INSERT INTO @Controller

SELECT c.controller_id,

       c.master_controller_id,
       c.transaction_table_name,
       number_of_months_in_transaction_table,
	  ISNULL(min_year_to_start_archive,2007)min_year_to_start_archive,
	  CASE WHEN is_history_exists=1 AND is_history_rows_counted=0 THEN 1 ELSE 0 END,
	  CASE WHEN  is_last_job_error=1 AND is_job_fix=1 THEN 1 ELSE 0 END,
	  CASE WHEN is_history_exists=1 AND is_history_archive_completed=0 THEN 0 ELSE 1 END
	  

FROM azure_data_archive_pipeline_controller c
INNER JOIN azure_data_archive_pipeline_master_controller m ON  m.master_controller_id=c.master_controller_id
LEFT JOIN (SELECT DISTINCT controller_id
FROM @existingError) e  ON e.controller_id=c.controller_id
LEFT JOIN @TAB t ON (t.Id=c.controller_id OR t.Id=-1)
WHERE (e.controller_id IS NULL)
AND is_pipeline_enabled=1
AND 
(

(ISNULL(next_etl_schedule_date,CONVERT(DATE,GETDATE(),101))=CONVERT(DATE,GETDATE(),101) AND is_last_job_error=0)
OR
(is_last_job_error=1 AND is_job_fix=1)
OR 
(@overrideError<>'N' AND (t.Id=c.controller_id OR t.Id=-1))
)

AND m.master_controller_id=@vmasterControllerId


SELECT @id=SCOPE_IDENTITY()



IF @debug_me='Y'
BEGIN
SELECT '@Controller', * from @Controller 
END	 


WHILE @id>0

BEGIN 






			SELECT @vcontrollerId=controller_id,
			@monthintrax=number_of_months_in_transaction_table,
			@minyear=min_year_to_start_archive,
			@textminyear=CAST (min_year_to_start_archive AS CHAR(4)),
			@transaction_table=transaction_table_name,		
			@historyBIT=ishistoryComp
			FROM @Controller
			WHERE id=@id

		
		

 
			IF NOT EXISTS (SELECT 1 FROM azure_data_archive_pipeline_controller_detail WHERE is_archiving_completed=0  AND controller_id=@vcontrollerId)
				   
			BEGIN 

            SELECT @vtodate=GETDATE()
			
			       IF EXISTS (SELECT 1 FROM azure_data_archive_pipeline_controller_detail WHERE controller_id=@vcontrollerId)	
				  
						   BEGIN 

									SELECT @maxyeararchived=MAX(year_to_archive)+1
									FROM azure_data_archive_pipeline_controller_detail  dl 
									WHERE controller_id=@vcontrollerId
									AND is_archiving_completed=1
									AND @historyBIT=1

									SELECT @vdatefilter=DATEADD(mm,-@monthintrax,@vtodate)

									WHILE @maxyeararchived<=DATEPART(yyyy,@vdatefilter)

									BEGIN
			                
											INSERT INTO azure_data_archive_pipeline_controller_detail
											(controller_id,
												source_table,
												is_archiving_completed,		
												is_source_history_table,
												year_to_archive,														
												date_filter
											)
											SELECT @vcontrollerId,
													@transaction_table,
													0,				
													0,
													@maxyeararchived,															
													CASE WHEN @maxyeararchived=DATEPART(yyyy,@vdatefilter) THEN @vdatefilter ELSE NULL END

											SET @maxyeararchived=@maxyeararchived+1


									END

										INSERT INTO @outputTableToArchive
											SELECT detail_id, 			      
													dl.controller_id,	
													@vmasterControllerId,
													@transaction_table,
													year_to_archive,	 
													'R',
													CASE WHEN is_error_run=1 THEN 'ERA' ELSE 'RA' END
				                
											FROM azure_data_archive_pipeline_controller_detail 	dl
											INNER JOIN @Controller m
											ON dl.controller_id= m.controller_id																										
											WHERE is_source_history_table=0
											AND  m.id=@id
											AND is_archiving_completed=0
											AND dl.controller_id=@vcontrollerId




							END
					        ELSE
							BEGIN
								    SELECT @maxyeararchived=@minyear+1
									

									SELECT @vdatefilter=DATEADD(mm,-@monthintrax,@vtodate)

									WHILE @maxyeararchived<=DATEPART(yyyy,@vdatefilter)

									BEGIN
			                
											INSERT INTO azure_data_archive_pipeline_controller_detail
											(controller_id,
												source_table,
												is_archiving_completed,		
												is_source_history_table,
												year_to_archive,														
												date_filter
											)
											SELECT @vcontrollerId,
													@transaction_table,
													0,				
													0,
													@maxyeararchived,															
													CASE WHEN @maxyeararchived=DATEPART(yyyy,@vdatefilter) THEN @vdatefilter ELSE NULL END

											SET @maxyeararchived=@maxyeararchived+1

											

									END

										INSERT INTO @outputTableToArchive
											SELECT detail_id, 			      
													dl.controller_id,	
													
													@vmasterControllerId,
													@transaction_table,
													year_to_archive,	 
													'R',
													CASE WHEN is_error_run=1 THEN 'ERA' ELSE 'RA' END
				                
											FROM azure_data_archive_pipeline_controller_detail 	dl
											INNER JOIN @Controller m
											ON dl.controller_id= m.controller_id																										
											WHERE is_source_history_table=0
											AND  m.id=@id
											AND is_archiving_completed=0
											AND dl.controller_id=@vcontrollerId
											

							END     	
			
																			
					IF @debug_me='Y'
					BEGIN
					SELECT 'if outputTableToArchive', * from @outputTableToArchive 
					END	 
                                               
			END

			ELSE
			BEGIN

			INSERT INTO @outputTableToArchive
			SELECT detail_id, 			      
				dl.controller_id,	
				master_controller_id,
				@transaction_table,
				year_to_archive,	 
				 'R',
				CASE WHEN is_error_run=1 THEN CASE WHEN  is_rows_count=1 THEN 'ECHA'
																		  ELSE 'ERA' 
													END
						  ELSE CASE WHEN is_rows_count=1 THEN 'CHRA' 
														 ELSE 'RA'
								END
				END

				   
			FROM azure_data_archive_pipeline_controller_detail 	dl
			INNER JOIN @Controller m
			ON dl.controller_id= m.controller_id	
			WHERE  m.id=@id
			AND is_archiving_completed=0
			AND dl.controller_id=@vcontrollerId

		

					IF @debug_me='Y'
					BEGIN
					SELECT 'else outputTableToArchive', * from @outputTableToArchive 
					END	 

END





SET @id=@id-1


END

IF @overrideError='N'
BEGIN
INSERT INTO azure_data_archive_pipeline_errors_report_detailId 
SELECT errorDetailId,
       errorEntry
FROM @existingError
END


IF @debug_me='Y'
BEGIN
SELECT 'final outputTableToArchive', * from @outputTableToArchive 
SELECT 'detailId', * from azure_data_archive_pipeline_errors_report_detailId 
SELECT '@existingError', * from @existingError 
END	 




UPDATE a
SET last_execution_end_time=NULL
,pipeline_audit_id=@vauditId 			
FROM azure_data_archive_pipeline_controller a
INNER JOIN @outputTableToArchive o
ON a.controller_id=o.controller_id


UPDATE a
SET is_last_job_error=0,
is_job_fix=0
FROM azure_data_archive_pipeline_controller a 
INNER JOIN @outputTableToArchive m
ON m.controller_id=a.controller_id	
LEFT JOIN @TAB t ON (t.Id=a.controller_id OR t.Id=-1)
WHERE (a.is_job_fix=1)
OR 
(@overrideError<>'N' AND (t.Id=a.controller_id OR t.Id=-1))





UPDATE c
SET is_last_job_error=1,
last_action_code=CASE WHEN errorEntry='PREV' THEN 'RENR' ELSE 'RE' END
FROM azure_data_archive_pipeline_controller c
INNER JOIN @existingError e
ON c.controller_id=e.controller_id
AND c.master_controller_id=@vmasterControllerId
AND @overrideError='N'

UPDATE a
SET pipeline_audit_id=@vauditId,
pipeline_to_end_time_utc=DATEADD(HOUR,pipeline_max_hours_to_run,GETUTCDATE())
FROM azure_data_archive_pipeline_master_controller a 
INNER JOIN @outputTableToArchive  m ON m.master_controller_id=a.master_controller_id
WHERE a.master_controller_id=@vmasterControllerId

SELECT @vpipeLineToEnd=pipeline_to_end_time_utc
FROM azure_data_archive_pipeline_master_controller
WHERE master_controller_id=@vmasterControllerId

UPDATE a
SET next_etl_schedule_date=CASE WHEN CONVERT(DATE,GETDATE(),101) =ISNULL(next_etl_schedule_date,CONVERT(DATE,GETDATE(),101))
                                THEN DATEADD(DD,days_schedule,ISNULL(next_etl_schedule_date,CONVERT(DATE,GETDATE(),101))) 
								ELSE next_etl_schedule_date END
FROM azure_data_archive_pipeline_adf_schedule s 
INNER JOIN azure_data_archive_pipeline_master_controller a ON s.schedule_id=a.pipeline_schedule







SELECT @vauditId audit_id,
       controller_id,	   
       detail_id,    
	   folder,
	   subfolder,	  
	   action_today,
	   actual_action_code,
	   'N'   isError,		 
	   NULL  errorEntry,	  
	   @vpipeLineToEnd pipelineToEnd
	   
FROM @outputTableToArchive
ORDER BY controller_id,detail_id



UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
step_status='Completed'
WHERE debug_id=@debugId


END TRY

BEGIN CATCH

DECLARE  @errorId INT,
         @Error BIT,
		 @logId INT

SELECT  @errorEntry=ISNULL(@errorEntry,'New')

IF @vErr IS NULL AND @errorEntry='New'
BEGIN 

		SELECT @vErr=RTRIM( LEFT( 'Store Procedure  failed at Line Number : ' +  CASt(ERROR_LINE() as VARCHAR(10)) + ', Description : ' +  ERROR_MESSAGE(), 5000 ) )
		SELECT @errorCode=CAST(ERROR_NUMBER() AS VARCHAR(15))
END

IF @errorEntry='New'
BEGIN
		EXEC sproc_azure_data_archive_pipeline_errors
						@vauditId,
						@vcontrollerId,
						@vmasterControllerId,
						-1,
						-1,
						@vErr,
						@errorCode,
						'Sproc Proc',
						'SQL Script',
						'Data_Archival_Controller: LookUp_Tables to Archive',
						'sproc_azure_data_archive_get_controller_detail',
						'New',						
						@isError =@Error OUTPUT


		IF @Error=0 OR @Error IS NULL

			BEGIN

			SELECT  
	    
	    
					 'RE' actual_action_code,
					 'Y' isError,					 
					 'New' error_entry
					 
			END	   

END

IF @errorEntry='PREV'
BEGIN
SELECT  'RE' actual_action_code,
        'Y' isError,		
		@errorEntry
END


UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
additional_comment=ISNULL(additional_comment,'')+'  '+'Step Ended into the Catch block and error is: ' + ISNULL(@vErr,''),
step_status='Error'
WHERE debug_id=@debugId

	


END CATCH

END








GO

print 'C_Branch/04_StoredProcedures/sproc_azure_data_archive_get_controller_detail.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_get_controller_detail.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_pipeline_activity_audit.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO





-- ================================================================================= 
-- CORE	- 86645	  :   script to create [sproc_azure_data_archive_pipeline_activity_audit] Procedure  in Client Database
--						-- 
-- Written By:          Dominic Christie
-- Reviewed By:         
-- 
-- Script Type:         DML 
-- Target DB Type:      Client Database
-- Target ENVIRONMENT:  Both
-- 
-- Re-Runable:          YES #
-- 
-- Description of Script : This store procedure will save all the copy activity related information. 

-- Special Instruction: 
-- 

/*
Revision History:


2021-03-24 Dom Christie  		CORE-86645 4.4.2	 	- Initial Creation of the store proc.
-- =================================================================================


EXEC SCRIPT:

exec sproc_azure_data_archive_pipeline_activity_audit 
51,
83,
5,
'Copy Data- Generate Parquet Files',
100,
100,
1,
12,
'Succeeded',
'2021-08-31T13:41:43.1383331Z',
'2021-08-31T13:42:09.3017545Z',
4,
5


*/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_azure_data_archive_pipeline_activity_audit' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE [dbo].sproc_azure_data_archive_pipeline_activity_audit
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO

CREATE  PROCEDURE sproc_azure_data_archive_pipeline_activity_audit

@audit_id INT,
@file_id INT,
@detail_id INT,
@activityName VARCHAR(350),
@rowsCopied VARCHAR(50)=NULL,
@rowsRead INT=NULL,
@No_ParallelCopies INT=NULL,
@copyDuration_in_secs VARCHAR(8)=NULL,
@Execution_Status VARCHAR(50)=NULL,
@CopyActivity_Start_Time VARCHAR(30)=NULL,
@CopyActivity_End_Time VARCHAR(30)=NULL,
@CopyActivity_queuingDuration_in_secs VARCHAR(8)=NULL,
@CopyActivity_transferDuration_in_secs VARCHAR(8)=NULL


AS

BEGIN
DECLARE @activityaudit INT , 
        @vauditId INT,
		@vfileId INT,
		@vdetailId INT,
		@vtransactionTableName VARCHAR(150),
		@vErr VARCHAR(3500),	
		@vcontrollerId SMALLINT,
		@vmasterControllerId TINYINT,
		@errorEntry VARCHAR(4),
		@errorCode VARCHAR(15),
		@debugId INT

		SELECT @vauditID=@audit_id 


INSERT INTO azure_data_archive_pipeline_steps_debug

SELECT 'Executing sproc_azure_data_archive_pipeline_activity_audit', @vauditId,'Started',GETDATE(),NULL, NULL,GETUTCDATE(),NULL,@file_id

SET @debugId=SCOPE_IDENTITY()

		SET @vfileID=@file_id
		SET @vdetailId=@detail_id

BEGIN TRY



SELECT @vtransactionTableName=transaction_table_name ,
@vcontrollerId=c.controller_id,
@vmasterControllerId=c.master_controller_id
FROM azure_data_archive_pipeline_controller c 
INNER JOIN azure_data_archive_pipeline_controller_detail d ON d.controller_id=c.controller_id
WHERE d.detail_id=@vdetailId


IF @Execution_Status<>'Succeeded'
BEGIN 

 SET @vErr = 'The Copy activity for the table'+ ' '+ @vtransactionTableName+ ' resulted in failure. The pipeline will be terminated and further investigation is required for'+' '+CAST(@vfileID AS varchar(15))+ '.'+ '  '+' The detail id is: '+ CAST(@vdetailId AS varchar(15))
 SET @errorEntry='New'
 SET @errorCode='-2000008'
	RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);


END

ELSE
BEGIN 


		IF @rowsCopied<>@rowsRead

		BEGIN 

		 SET @vErr = 'The Copied Rows' + CONVERT(VARCHAR(25),@rowsCopied)+ '  '+', does not match to the' + CONVERT(VARCHAR(25),@rowsRead)+  ' rows read for the table.'+ ' '+ @vtransactionTableName+ ' The pipeline will be terminated and further investigation is required for'+' '+CAST(@vfileID AS varchar(15))+ '.'+ '  '+' The detail id is: '+ CAST(@vdetailId AS varchar(15))
		 SET @errorEntry='New'
		 SET @errorCode='-2000009'
			RAISERROR (@vErr -- Message text
							   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
							   ,1 -- State
								);

		END
		ELSE
		BEGIN

		UPDATE azure_data_archive_pipeline_steps_debug
		SET additional_comment='Started Capturing the Copy Activity Stats for fileId: '+ CAST(@file_id AS VARCHAR(15))
		WHERE debug_id=@debugId


		INSERT INTO azure_data_archive_pipeline_activity_audit
		   (
		   activity_name,  
		   azure_file_id ,
		   rows_copied ,
		   data_read ,
		   no_parallel_copies ,
		   copy_duration_in_secs ,
		   execution_status ,
		   copyActivity_start_time ,
		   copyActivity_end_time ,
		   copyActivity_queuing_duration_in_secs ,
		   copyActivity_transfer_duration_in_secs,
		    copyActivity_start_time_utc ,
		   copyActivity_end_time_utc
		   )
		SELECT 
		
		 @activityName
		,@vfileID
		,@rowsCopied
		,@rowsRead
		,@No_ParallelCopies
		,@copyDuration_in_secs
		,@Execution_Status
		,CONVERT(DATETIME2,@CopyActivity_Start_Time,101)
		,CONVERT(DATETIME2,@CopyActivity_End_Time,101)
		,@CopyActivity_queuingDuration_in_secs
		,@CopyActivity_transferDuration_in_secs
		,@CopyActivity_Start_Time
		,@CopyActivity_End_Time

		SELECT  @activityaudit=SCOPE_IDENTITY()


		-----SELECT @activityaudit as activityAuditId
		IF @activityaudit>0
		BEGIN

		UPDATE az
		SET is_file_generated=1
		FROM azure_data_archive_pipeline_storage_file_name az INNER JOIN azure_data_archive_pipeline_activity_audit a
		ON  az.azure_file_id=a.azure_file_id
		WHERE az.azure_file_id=@vfileID
		AND a.execution_status='Succeeded'
		AND az.detail_id=@vdetailId

		UPDATE d
		SET total_rows_archived=ISNULL(total_rows_archived,0)+ @rowsCopied
		FROM azure_data_archive_pipeline_storage_file_name fn 
		INNER JOIN azure_data_archive_pipeline_activity_audit a ON fn.azure_file_id=a.azure_file_id
		INNER JOIN azure_data_archive_pipeline_controller_detail d  ON fn.detail_id=d.detail_id
		AND is_file_generated=1
		AND fn.pipeline_audit_id=@vauditId
		AND a.azure_file_id=@vfileId
		AND d.detail_id=@vdetailId

		END

		END

END

SELECT NULL actual_action_code,

'N' isError,
NULL error_entry

UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
step_status='Completed'
WHERE debug_id=@debugId


END TRY

BEGIN CATCH


DECLARE  @errorId INT,
         @Error BIT,
		 @logId INT

SELECT  @errorEntry=ISNULL(@errorEntry,'New')

IF @vErr IS NULL AND @errorEntry='New'
BEGIN 

		SELECT @vErr=RTRIM( LEFT( 'Store Procedure  failed at Line Number : ' +  CASt(ERROR_LINE() as VARCHAR(10)) + ', Description : ' +  ERROR_MESSAGE(), 5000 ) )
		SELECT @errorCode=CAST(ERROR_NUMBER() as VARCHAR(15))

END


IF @errorEntry='New'
BEGIN
		EXEC sproc_azure_data_archive_pipeline_errors
						@vauditId,
						@vcontrollerId,
						@vmasterControllerId,
						-1,
						-1,
						@vErr,
						@errorCode,
						'Sproc Proc',
						'SQL Script',
						'Data_Archival_FileNRow_Validation: StoreProcedure_Audit On Success',
						'sproc_azure_data_archive_pipeline_activity_audit',
						'New',					
						@isError =@Error OUTPUT


		IF @Error=0 OR @Error IS NULL

			BEGIN

			SELECT  
	    
	    
					 'RE' actual_action_code,
					 'Y' isError,					 
					 'New' error_entry
					 
			END	   

END

	  

UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
additional_comment=ISNULL(additional_comment,'')+'  '+'Step Ended into the Catch block and error is: ' + ISNULL(@vErr,''),
step_status='Error'
WHERE debug_id=@debugId

END CATCH


END

GO

print 'C_Branch/04_StoredProcedures/sproc_azure_data_archive_pipeline_activity_audit.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_pipeline_activity_audit.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_pipeline_cleanup.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO




-- ================================================================================= 
-- CORE	- 86645	  :   script to create [sproc_azure_data_archive_pipeline_cleanup] Procedure  in Client Database
--						-- 
-- Written By:          Dominic Christie
-- Reviewed By:         
-- 
-- Script Type:         DML 
-- Target DB Type:      Client Database
-- Target ENVIRONMENT:  Both
-- 
-- Re-Runable:          YES #
-- 
-- Description of Script : This sproc checks will clean up data from the log , debug and error table periodically

-- Special Instruction: 
-- 
/*
Revision History:


2021-07-24 Dom Christie  		CORE-92694 4.4.5	 	- Initial Creation of the store proc.



exec sproc_azure_data_archive_pipeline_cleanup 30,30,30,1,187,30
-- =================================================================================
*/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_azure_data_archive_pipeline_cleanup' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE [dbo].sproc_azure_data_archive_pipeline_cleanup
END
GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE dbo.sproc_azure_data_archive_pipeline_cleanup

@debugTable SMALLINT,
@errorTable SMALLINT,
@logTable SMALLINT,
@activityTable SMALLINT,
@audit_id INT,
@mergeLogTable SMALLINT
AS

BEGIN



BEGIN TRY

DECLARE  @debugId INT

INSERT INTO azure_data_archive_pipeline_steps_debug
SELECT 'Executing sproc_azure_data_archive_pipeline_cleanup', @audit_id,'Started',GETDATE(),NULL,NULL,GETUTCDATE(),NULL,NULL
SET @debugId=SCOPE_IDENTITY()

IF @mergeLogTable>364
BEGIN

UPDATE azure_data_archive_pipeline_steps_debug
SET additional_comment=ISNULL(additional_comment,'')+'  '+ 'Cleaning File Merge Log Table'
WHERE debug_id=@debugId

DELETE a FROM azure_data_archive_pipeline_merge_log_dump  a
WHERE DATEDIFF(dd, CONVERT(DATE,time_logged,103), CONVERT(DATE,GETDATE(),103)) > @mergeLogTable

END

IF @debugTable>180
BEGIN

UPDATE azure_data_archive_pipeline_steps_debug
SET additional_comment=ISNULL(additional_comment,'')+'  '+ 'Cleaning Steps Debug Table'
WHERE debug_id=@debugId

DELETE a FROM azure_data_archive_pipeline_steps_debug a
WHERE  DATEDIFF(dd, CONVERT(DATE,step_start_date,103), CONVERT(DATE,GETDATE(),103)) > @debugTable
END


IF @errorTable>364
BEGIN

UPDATE azure_data_archive_pipeline_steps_debug
SET additional_comment=ISNULL(additional_comment,'')+'  '+ 'Cleaning  Error Table'
WHERE debug_id=@debugId

DELETE a FROM azure_data_archive_pipeline_errors a
WHERE  DATEDIFF(dd, CONVERT(DATE,error_logged_time,103), CONVERT(DATE,GETDATE(),103)) > @errorTable
END



IF @activityTable>364
BEGIN

UPDATE azure_data_archive_pipeline_steps_debug
SET additional_comment=ISNULL(additional_comment,'')+'  '+ 'Cleaning Activity Table'
WHERE debug_id=@debugId

DELETE a FROM azure_data_archive_pipeline_activity_audit a
WHERE  DATEDIFF(dd, CONVERT(DATE,copyActivity_start_time,103), CONVERT(DATE,GETDATE(),103)) > @activityTable
END


IF @logTable>364
BEGIN

UPDATE azure_data_archive_pipeline_steps_debug
SET additional_comment=ISNULL(additional_comment,'')+'  '+ 'Cleaning Log Table'
WHERE debug_id=@debugId

DELETE a FROM azure_data_archive_pipeline_log a
WHERE  DATEDIFF(dd, CONVERT(DATE,log_date,103), CONVERT(DATE,GETDATE(),103)) > @logTable
END


UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
step_status='Completed'
WHERE debug_id=@debugId


END TRY

BEGIN CATCH


DECLARE  @errorId INT,
         @Error BIT,
		 @logId INT,
		 @errorCode VARCHAR(150),
		 @vErr VARCHAR(3500)



BEGIN 

		SELECT @vErr=RTRIM( LEFT( 'Store Procedure failed at Line Number : ' +  CASt(ERROR_LINE() as VARCHAR(10)) + ', Description : ' +  ERROR_MESSAGE(), 5000 ) )
		SELECT @errorCode=CAST(ERROR_NUMBER() AS VARCHAR(15))
END
		EXEC sproc_azure_data_archive_pipeline_errors
						@audit_id,
						0,
						0,
						-1,
						-1,
						@vErr,
						@errorCode,
						'Sproc Proc',
						'SQL Script',
						'Data_Archival_Master: StoredProcedure_Table Clean Up',
						'sproc_azure_data_archive_pipeline_cleanup',
						'New',
						@isError =@Error OUTPUT



UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
additional_comment=ISNULL(additional_comment,'')+'  '+'Step Ended into the Catch block. This is new error and the error is '+ISNULL(@vErr,''),
step_status='Error'
WHERE debug_id=@debugId


END CATCH

END



GO

print 'C_Branch/04_StoredProcedures/sproc_azure_data_archive_pipeline_cleanup.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_pipeline_cleanup.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_pipeline_complete.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO





-- ================================================================================= 
-- CORE	- 86645	  :   script to create [sproc_azure_data_archive_pipeline_complete] Procedure  in Client Database
--						-- 
-- Written By:          Dominic Christie
-- Reviewed By:         
-- 
-- Script Type:         DML 
-- Target DB Type:      Client Database
-- Target ENVIRONMENT:  Both
-- 
-- Re-Runable:          YES #
-- 
-- Description of Script : This sproc will update the tables after the pipeline has been excuted compeltely
--

-- Special Instruction: 
-- 

/*
Revision History:


2021-03-24 Dom Christie  		CORE-86645 4.4.2	 	- Initial Creation of the store proc.
-- =================================================================================


EXEC SCRIPT:

exec sproc_azure_data_archive_pipeline_complete 0,0,1,'T','T','N'

*/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_azure_data_archive_pipeline_complete' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE [dbo].sproc_azure_data_archive_pipeline_complete
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO

CREATE  PROCEDURE sproc_azure_data_archive_pipeline_complete

@master_controller_id TINYINT,
@controller_id SMALLINT,
@audit_id VARCHAR(15),
@action_today CHAR(1),
@actual_action_today VARCHAR(4),
@overrideError CHAR(1)

AS

BEGIN


BEGIN TRY

DECLARE @vauditId INT  ,
        @vcontrollerId SMALLINT,
		@vmasterControllerId TINYINT,
		@debugId INT,
		@vErr VARCHAR(5000) , 	
		@errorCode VARCHAR(150)

SElECT @vauditId=CAST(@audit_id AS INT)

SELECT @overrideError=ISNULL(NULLIF(@overrideError,''),'N')

INSERT INTO azure_data_archive_pipeline_steps_debug
SELECT 'Executing sproc_azure_data_archive_pipeline_complete', @vauditId,'Started',GETDATE(),NULL, NULL,GETUTCDATE(),NULL,NULL

SET @debugId=SCOPE_IDENTITY()


SElECT @vcontrollerId=@controller_id
SElECT @vmasterControllerId=@master_controller_id 


IF  @actual_action_today='PC' 
BEGIN     
UPDATE azure_data_archive_pipeline_audit
SET	pipeline_actual_end=GETDATE(),
pipeline_actual_end_utc=GETUTCDATE(),
pipeline_last_action_code='C'
WHERE pipeline_audit_id=@vauditId


UPDATE  a
SET next_etl_schedule_date=CASE WHEN CONVERT(DATE,GETDATE(),101) =ISNULL(next_etl_schedule_date,CONVERT(DATE,GETDATE(),101))
                                THEN DATEADD(DD,days_schedule,ISNULL(next_etl_schedule_date,CONVERT(DATE,GETDATE(),101)))
								WHEN @overrideError='Y' AND (next_etl_schedule_date IS NULL OR next_etl_schedule_date<GETDATE()) 
								THEN  DATEADD(DD,pipeline_schedule,ISNULL(next_etl_schedule_date,CONVERT(DATE,GETDATE(),101)))
								ELSE next_etl_schedule_date END
FROM azure_data_archive_pipeline_master_controller a
INNER JOIN azure_data_archive_pipeline_adf_schedule s 
ON s.schedule_id=a.pipeline_schedule

END


IF @action_today='C' AND @vcontrollerId>0 AND @vauditId>0
BEGIN     	 
UPDATE azure_data_archive_pipeline_controller
SET last_execution_end_time= GETDATE(),
last_execution_end_time_utc=GETUTCDATE(),
last_action_code=@actual_action_today
WHERE controller_id=@vcontrollerId AND pipeline_audit_id=@vauditId 
END



IF  EXISTS (SELECT 1 FROM azure_data_archive_pipeline_errors WHERE pipeline_audit_id=@vauditId)
BEGIN

UPDATE azure_data_archive_pipeline_controller
SET is_job_fix=0,
is_last_job_error=1,
last_execution_end_time= GETDATE(),
last_execution_end_time_utc=GETUTCDATE(),
last_action_code=CASE WHEN @action_today='E' THEN ISNULL(@actual_action_today,'RE') ELSE 'C' END
WHERE pipeline_audit_id=@vauditId
AND @vcontrollerId<0 

END


IF EXISTS (SELECT 1 FROM azure_data_archive_pipeline_errors_report_detailId WHERE error_detail_id IS NOT NULL)
BEGIN 
SELECT 'Y' AS isErrorDetail
END
ELSE
BEGIN 

SELECT 'N' AS isErrorDetail
END


UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
step_status='Completed',
additional_comment=ISNULL(@actual_action_today,'') + '  '+ CASE WHEN @actual_action_today='PC' THEN 'The entire pipeline execution was completed ' ELSE 'The execution for the controller:'+'  '+ CONVERT(VARCHAR(15),@vcontrollerId)+'  '+ 'has been completed' END
WHERE debug_id=@debugId

END TRY
BEGIN CATCH 

DECLARE  @errorId INT,
         @Error BIT

SELECT @vErr=RTRIM( LEFT( 'Store Procedure  failed at Line Number : ' +  CASt(ERROR_LINE() as VARCHAR(10)) + ', Description : ' +  ERROR_MESSAGE(), 5000 ) )
SELECT @errorCode=CAST(ERROR_NUMBER() AS VARCHAR(15))

EXEC sproc_azure_data_archive_pipeline_errors
						@vauditId,
						@vcontrollerId,
						@vmasterControllerId,
						-1,
						-1,
						@vErr,
						@errorCode,
						'Sproc Proc',
						'SQL Script',
						'Complete the Pipeline Execution: LookUp_Complete the_Pipeline Execution',
						'sproc_azure_data_archive_pipeline_complete',
						'New',						
						@isError =@Error OUTPUT

SELECT 'Y' AS isErrorDetail

UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
additional_comment=ISNULL(additional_comment,'')+'  '+'Step Ended into the Catch block. This is new error and the error is '+ISNULL(@vErr,''),
step_status='Error'
WHERE debug_id=@debugId


END CATCH


END









		
	


GO

print 'C_Branch/04_StoredProcedures/sproc_azure_data_archive_pipeline_complete.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_pipeline_complete.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_pipeline_handle_unmatched_file.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO





-- ================================================================================= 
-- CORE	- 86645	  :   script to create [sproc_azure_data_archive_pipeline_handle_unmatchedFile] Procedure  in Client Database
--						-- 
-- Written By:          Dominic Christie
-- Reviewed By:         
-- 
-- Script Type:         DML 
-- Target DB Type:      Client Database
-- Target ENVIRONMENT:  Both
-- 
-- Re-Runable:          YES #
-- 
-- Description of Script : This sproc will update the storage table to a value 1 if the file is moved successfully and then will update the table with unmatched ids.
--

-- Special Instruction: 
-- 

/*
Revision History:


2021-10-06 Dom Christie  		CORE-86645 4.4.2	 	- Initial Creation of the store proc.
-- =================================================================================


EXEC SCRIPT:

exec sproc_azure_data_archive_pipeline_handle_unmatchedFile 1,1,1,P

*/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_azure_data_archive_pipeline_handle_unmatchedFile' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE [dbo].sproc_azure_data_archive_pipeline_handle_unmatchedFile
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO

CREATE  PROCEDURE sproc_azure_data_archive_pipeline_handle_unmatchedFile

@azure_file_id INT,
@audit_id VARCHAR(15),
@controller_id TINYINT,
@is_move_delete CHAR(1) ---M---D---F--E--I--P

AS

BEGIN


BEGIN TRY

DECLARE @vfileID INT,
        @vauditId INT  ,
        @debugId INT,
		@error_detailId INT,
		@sqlCheckSum VARCHAR(250),
		@transactionTableCheckSum VARCHAR(170) 
	

	

SET @vfileID=@azure_file_id
SElECT @vauditId=CAST(@audit_id AS INT)

	SELECT  @transactionTableCheckSum=CASE WHEN is_history_exists =1 AND is_history_archive_completed=0 THEN 
	                                  source_table ELSE transaction_table_name END
	
	FROM azure_data_archive_pipeline_controller_detail d 
			INNER JOIN  azure_data_archive_pipeline_controller c 
			ON c.controller_id=d.controller_id
			INNER JOIN azure_data_archive_pipeline_storage_file_name s 
			ON s.detail_id=d.detail_id
			WHERE s.azure_file_id=@vfileID

INSERT INTO azure_data_archive_pipeline_steps_debug
SELECT 'Executing sproc_azure_data_archive_pipeline_handle_unmatchedFile', @vauditId, 'Started',GETDATE(),NULL,'The sproc was exec with action type'+@is_move_delete,GETUTCDATE(),NULL,NULL


SET @debugId=SCOPE_IDENTITY()


IF @is_move_delete IN ('I','P')
BEGIN



SELECT  DISTINCT ac.controller_id,transaction_table_name folder,year_to_archive subfolder,afl.azure_file_id,azure_file_name,
CASE WHEN is_file_table_deleted_rows_mismatch=1 THEN 1 ELSE 2 END match_delete,
CASE WHEN is_file_table_deleted_rows_mismatch=1  AND is_unmatched_file_moved=0 AND is_unmatched_file_deleted=0 THEN 'MD'
     WHEN is_file_table_deleted_rows_mismatch=1  AND is_unmatched_file_moved=1 AND is_unmatched_file_deleted=0 THEN 'DO'
	 WHEN is_file_table_deleted_rows_mismatch=1  AND is_unmatched_file_moved=0 AND is_unmatched_file_deleted=1 THEN 'MO'
	 WHEN is_rows_from_table_deleted=0 AND is_file_table_deleted_rows_mismatch=0 AND is_unmatched_file_moved=0 AND is_unmatched_file_deleted=0 THEN 'MD'
	 WHEN is_rows_from_table_deleted=0 AND is_file_table_deleted_rows_mismatch=0 AND is_unmatched_file_moved=1 AND is_unmatched_file_deleted=0 THEN 'DO'
	 WHEN is_rows_from_table_deleted=0 AND is_file_table_deleted_rows_mismatch=0 AND is_unmatched_file_moved=0 AND is_unmatched_file_deleted=1 THEN 'MO'
	 ELSE 'NA' END action_type,
	 'N' isError
FROM azure_data_archive_pipeline_storage_file_name afl
INNER JOIN azure_data_archive_pipeline_activity_audit aa
ON aa.azure_file_id=afl.azure_file_id
INNER JOIN azure_data_archive_pipeline_controller_detail adl 
ON afl.detail_id=adl.detail_id
INNER JOIN azure_data_archive_pipeline_controller ac
ON adl.controller_id=ac.controller_id
WHERE
is_partial_delete=0 
AND
(
(

(is_file_generated=1 AND is_rows_from_table_deleted=0)
AND (( is_unmatched_file_moved IS NULL OR is_unmatched_file_moved =0)
OR
(is_unmatched_file_moved=1 AND is_unmatched_file_deleted=0))

)
OR
(
is_file_table_deleted_rows_mismatch=1
AND is_file_generated=1
AND
(
( is_unmatched_file_moved IS NULL OR is_unmatched_file_moved =0)
OR
(is_unmatched_file_moved=1 AND is_unmatched_file_deleted=0)
)
)
)
UNION

SELECT NULL AS controller_id,NULL AS folder,NULL AS subfolder ,-1 azure_file_id,NULL AS azure_file_name, 3 AS match_delete,'NA' action_type,'N' isError

END

ELSE
BEGIN

UPDATE azure_data_archive_pipeline_storage_file_name
SET is_unmatched_file_moved=1
WHERE azure_file_id=@azure_file_id
AND (
(is_file_table_deleted_rows_mismatch=1)
OR (is_file_table_deleted_rows_mismatch=0 AND is_file_generated=1 AND is_rows_from_table_deleted=0)
)AND @is_move_delete='M'





IF @is_move_delete='D'
BEGIN

UPDATE azure_data_archive_pipeline_storage_file_name
SET is_unmatched_file_deleted=1
WHERE azure_file_id=@azure_file_id
AND (
(is_file_table_deleted_rows_mismatch=1)
OR (is_file_table_deleted_rows_mismatch=0 AND is_file_generated=1 AND is_rows_from_table_deleted=0)
)

	SET @sqlCheckSum =''
	SET @transactionTableCheckSum =@transactionTableCheckSum+'_checksum'

	SET @sqlCheckSum= 'TRUNCATE TABLE '+@transactionTableCheckSum+''
	EXEC (@sqlCheckSum)

END



IF @is_move_delete='E'
BEGIN

INSERT INTO [dbo].[azure_data_archive_pipeline_errors]
    
   SELECT @vauditId
         ,-1
		 ,@vfileID
		 ,@controller_id
         ,'The file that was supposed to be deleted following to the unmatched row/s was not deleted. Having this file at the original location will lead to the data duplication.'
	     ,'-2000011'
	     ,GETDATE()
	     ,'File'
		 ,'Storage Folder'
		 ,'sproc_azure_data_archive_pipeline_handle_unmatchedFile'
		 ,'Data_Archival_Check_File_Deleted:Get Metadata'
		 ,GETUTCDATE()


		 SELECT @error_detailId=SCOPE_IDENTITY()	 

INSERT INTO azure_data_archive_pipeline_errors_report_detailId
SELECT 'error:'+ CAST(@error_detailId AS VARCHAR(15)),
       'New'

END

END
UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
step_status='Completed'
---additional_comment=ISNULL(@actual_action_today,'') + '  '+ CASE WHEN @actual_action_today='PC' THEN 'The entire pipeline execution was completed ' ELSE 'The execution for the controller:'+'  '+ CONVERT(VARCHAR(15),@vcontrollerId)+'  '+ 'has been completed' END
WHERE debug_id=@debugId

END TRY
BEGIN CATCH 

DECLARE  @errorId INT,
         @Error BIT,	
         @vErr VARCHAR(5000) , 	
		 @errorCode VARCHAR(150)

SELECT @vErr=RTRIM( LEFT( 'Store Procedure  failed at Line Number : ' +  CASt(ERROR_LINE() as VARCHAR(10)) + ', Description : ' +  ERROR_MESSAGE(), 5000 ) )
SELECT @errorCode=CAST(ERROR_NUMBER() AS VARCHAR(15))

EXEC sproc_azure_data_archive_pipeline_errors
						@vauditId,
						-1,
						-1,
						@controller_id,
						@vfileID,
						@vErr,
						@errorCode,
						'Sproc Proc',
						'SQL Script',
						'Data_Archival_Check_File_Deleted: Sproc Activity',
						'sproc_azure_data_archive_pipeline_handle_unmatchedFile',
						'New',						
						@isError =@Error OUTPUT



	IF @Error=0 OR @Error IS NULL

			BEGIN

			SELECT  
	    
	    
					 'RE' actual_action_code,
					 'Y' isError,					 
					 'New' error_entry,
					  'NA' action_type
					 
			END	  
UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
additional_comment=ISNULL(additional_comment,'')+'  '+'Step Ended into the Catch block. This is new error and the error is '+ISNULL(@vErr,''),
step_status='Error'
WHERE debug_id=@debugId


END CATCH


END









		
	


GO

print 'C_Branch/04_StoredProcedures/sproc_azure_data_archive_pipeline_handle_unmatched_file.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_pipeline_handle_unmatched_file.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_pipeline_master.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO




-- ================================================================================= 
-- CORE	- 86645	  :   script to create [sproc_azure_data_archive_pipeline_master] Procedure  in Client Database
--						-- 
-- Written By:          Dominic Christie
-- Reviewed By:         
-- 
-- Script Type:         DML 
-- Target DB Type:      Client Database
-- Target ENVIRONMENT:  Both
-- 
-- Re-Runable:          YES #
-- 
-- Description of Script : This sproc checks whether the required objects exists or not and creates the audit 

-- Special Instruction: 
-- 
/*
Revision History:


2021-03-24 Dom Christie  		CORE-86645 4.4.2	 	- Initial Creation of the store proc.
-- =================================================================================
*/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_azure_data_archive_pipeline_master' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE [dbo].sproc_azure_data_archive_pipeline_master
END
GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE dbo.sproc_azure_data_archive_pipeline_master

@runId VARCHAR(250),
@triggerType VARCHAR(300),
@triggerId VARCHAR(300),
@triggerName VARCHAR(300),
@triggerTime VARCHAR(300),
@dataFactory VARCHAR(500),
@pipelineName VARCHAR(500),
@primary_contact_email VARCHAR(150),
@execution_by VARCHAR(65),
@debug_me CHAR(1)='N',
@overrideError VARCHAR(150),
@delete_batch_size INT=20000

AS

/*


exec sproc_azure_data_archive_pipeline_master

'6262c4b7-785c-42c5-86ce-8ea7b203768d',
'Manual',
'a234b25546b84d0d94ff6980a2e88d9e',
'Sandbox',
'2021-08-31 09:26:24.070',
'adf-use2-nprd-arc-data-archival',
'Data_Archive_Check_Objects',
'dominic.christie@pointclickcare.com',
'chrisd',
'n',
'1',
1000



*/

BEGIN


BEGIN TRY


DECLARE @debugId INT
INSERT INTO azure_data_archive_pipeline_steps_debug

SELECT 'Executing sproc_azure_data_archive_pipeline_master', -1, 'Started',GETDATE(),NULL, NULL,GETUTCDATE(),NULL,NULL

SET @debugId=SCOPE_IDENTITY()


DECLARE @vErr VARCHAR(7000) , 	
		@vauditId INT,
		@maxId INT,
		@errorEntry VARCHAR(4),
		@errorCode VARCHAR(150),
		@logId INT,
		@errorId INT,
        @Error BIT,
		@vErrText VARCHAR(60),		
		@rwcnt TINYINT,
		@errorDetailId VARCHAR(30),
		@rowid INT
		,@loop INT
		,@batchsize INT
		,@rowtoarchive INT,
		@mastercntrl SMALLINT,
		@mastercntrlId TINYINT
		
DECLARE @batch TABLE (id TINYINT IDENTITY(1,1),rows_per_file INT, master_controller_id TINYINT)

SET @overrideError=ISNULL(NULLIF(@overrideError,''),'N')

DELETE FROM azure_data_archive_pipeline_errors_report_detailId



				IF @overrideError<>'N'
				BEGIN
					INSERT INTO azure_data_archive_pipeline_log
					SELECT GETDATE(), 
						  'The value of the OverRideError param was set for:'+ @overrideError+'  '+ 'to override  previous error by user '+ @execution_by , 
						   'Warning Entry',
							@pipelineName

					UPDATE azure_data_archive_pipeline_steps_debug
					SET additional_comment=ISNULL(additional_comment,'') + 'The value of the OverRideError param was set for:'+ @overrideError+'  '+ 'to override  previous error by user  ' + @execution_by
					WHERE debug_id=@debugId

				END



SET @vErrText='The pipeline cannot be excecuted without the mandatory Table'




IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES
				WHERE TABLE_NAME='azure_data_archive_pipeline_audit')
BEGIN
SET @vErr = @vErrText +' azure_data_archive_pipeline_audit.'
SET @errorCode='-2000001'
	RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);

END
ELSE
BEGIN
		

SELECT @maxid=MAX(pipeline_audit_id)  FROM azure_data_archive_pipeline_audit
WHERE pipeline_audit_id IS NOT NULL
AND pipeline_start<GETDATE()

END

IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_NAME='azure_data_archive_pipeline_action_code')
BEGIN
SET @vErr = @vErrText + ' azure_data_archive_pipeline_action_code'
SET @errorCode='-2000001'
	RAISERROR (@vErr -- Message text
						,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
						,1 -- State
						);

						
END


	


IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES
				WHERE TABLE_NAME='azure_data_archive_pipeline_master_controller')
BEGIN
SET @vErr =  @vErrText + ' azure_data_archive_pipeline_master_controller'
SET @errorCode='-2000001'
	RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);


END



IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES
				WHERE TABLE_NAME='azure_data_archive_pipeline_master_controller_audit')
BEGIN
SET @vErr =  @vErrText + ' azure_data_archive_pipeline_master_controller_audit'
SET @errorCode='-2000001'
	RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);


END





IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES
				WHERE TABLE_NAME='azure_data_archive_pipeline_controller')
BEGIN
SET @vErr =  @vErrText + ' azure_data_archive_pipeline_controller'
SET @errorCode='-2000001'
	RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);


END



IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES
				WHERE TABLE_NAME='azure_data_archive_pipeline_controller_audit')
BEGIN
SET @vErr =  @vErrText + ' azure_data_archive_pipeline_controller_audit'
SET @errorCode='-2000001'
	RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);


END



IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES
				WHERE TABLE_NAME='azure_data_archive_pipeline_controller_detail')
BEGIN
SET @vErr = @vErrText + ' azure_data_archive_pipeline_controller_detail'
SET @errorCode='-2000001'
	RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);


END

IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES
				WHERE TABLE_NAME='azure_data_archive_pipeline_storage_file_name')
BEGIN
SET @vErr = @vErrText + ' azure_data_archive_pipeline_storage_file_name'
SET @errorCode='-2000001'
	RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);


END


IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES
				WHERE TABLE_NAME='azure_data_archive_pipeline_storage_file_name_audit')
BEGIN
SET @vErr = @vErrText + ' azure_data_archive_pipeline_storage_file_name_audit'
SET @errorCode='-2000001'
	RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);


END



IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES
				WHERE TABLE_NAME='azure_data_archive_pipeline_activity_audit')
BEGIN
SET @vErr = @vErrText + ' azure_data_archive_pipeline_activity_audit'
SET @errorCode='-2000001'
	RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);



END






IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES
				WHERE TABLE_NAME='azure_data_archive_pipeline_errors')
BEGIN
SET @vErr = @vErrText + ' azure_data_archive_pipeline_errors'
SET @errorCode='-2000001'
	RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);


END


IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES
				WHERE TABLE_NAME='azure_data_archive_pipeline_steps_debug')
BEGIN
SET @vErr = @vErrText + ' azure_data_archive_pipeline_steps_debug'
SET @errorCode='-2000001'
	RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);


END


IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES
				WHERE TABLE_NAME='azure_data_archive_pipeline_errors_report_detailId')
BEGIN
SET @vErr = @vErrText + ' azure_data_archive_pipeline_errors_report_detailId'
SET @errorCode='-2000001'
	RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);


END







SET @vErrText='The pipeline cannot be excecuted without the mandatory Store Procedure'


IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES
WHERE ROUTINE_NAME='sproc_azure_data_archive_get_controller_detail' AND ROUTINE_TYPE='PROCEDURE')
BEGIN
SET @vErr = @vErrText + ' sproc_azure_data_archive_get_controller_detail'
SET @errorCode='-2000001'
	RAISERROR (@vErr -- Message text
						,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
						,1 -- State
						);


END





IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES
WHERE ROUTINE_NAME='sproc_azure_data_archive_filename_generator' AND ROUTINE_TYPE='PROCEDURE')
BEGIN
SET @vErr = @vErrText + ' sproc_azure_data_archive_filename_generator'
SET @errorCode='-2000002'
	RAISERROR (@vErr -- Message text
						,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
						,1 -- State
						);


END



IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES
WHERE ROUTINE_NAME='sproc_azure_data_archive_generate_parquet_files' AND ROUTINE_TYPE='PROCEDURE')
BEGIN
SET @vErr = @vErrText + ' sproc_azure_data_archive_generate_parquet_files'
SET @errorCode='-2000002'
	RAISERROR (@vErr -- Message text
						,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
						,1 -- State
						);


END


IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES
WHERE ROUTINE_NAME='sproc_azure_data_archive_pipeline_activity_audit' AND ROUTINE_TYPE='PROCEDURE')
BEGIN
SET @vErr = @vErrText + ' sproc_azure_data_archive_pipeline_activity_audit'
SET @errorCode='-2000002'
	RAISERROR (@vErr -- Message text
						,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
						,1 -- State
						);


END

IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES
WHERE ROUTINE_NAME='sproc_azure_data_archive_pipeline_errors' AND ROUTINE_TYPE='PROCEDURE')
BEGIN
SET @vErr =  @vErrText + ' sproc_azure_data_archive_pipeline_errors'
SET @errorCode='-2000002'
	RAISERROR (@vErr -- Message text
						,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
						,1 -- State
						);


END

IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES
WHERE ROUTINE_NAME='sproc_azure_data_archive_pipeline_activity_audit' AND ROUTINE_TYPE='PROCEDURE')
BEGIN
SET @vErr =  @vErrText + ' sproc_azure_data_archive_pipeline_activity_audit'
SET @errorCode='-2000002'
	RAISERROR (@vErr -- Message text
						,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
						,1 -- State
						);


END

IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES
WHERE ROUTINE_NAME='sproc_azure_data_archive_retreival_view' AND ROUTINE_TYPE='PROCEDURE')
BEGIN
SET @vErr =   @vErrText + ' sproc_azure_data_archive_retreival_view'
SET @errorCode='-2000002'
	RAISERROR (@vErr -- Message text
						,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
						,1 -- State
						);


END


IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES
WHERE ROUTINE_NAME='sproc_azure_data_archive_return_error_detail' AND ROUTINE_TYPE='PROCEDURE')
BEGIN
SET @vErr =  @vErrText + ' sproc_azure_data_archive_return_error_detail'
SET @errorCode='-2000002'
	RAISERROR (@vErr -- Message text
						,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
						,1 -- State
						);


END


IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES
WHERE ROUTINE_NAME='sproc_azure_data_archive_pipeline_complete' AND ROUTINE_TYPE='PROCEDURE')
BEGIN
SET @vErr =   @vErrText + ' sproc_azure_data_archive_pipeline_complete'
SET @errorCode='-2000002'
	RAISERROR (@vErr -- Message text
						,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
						,1 -- State
						);


END



IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES
WHERE ROUTINE_NAME='sproc_azure_data_archive_delete_records' AND ROUTINE_TYPE='PROCEDURE')
BEGIN
SET @vErr =  @vErrText + ' sproc_azure_data_archive_delete_records'
SET @errorCode='-2000002'
	RAISERROR (@vErr -- Message text
						,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
						,1 -- State
						);


END

			




IF EXISTS (SELECT 1 FROM  azure_data_archive_pipeline_audit WHERE pipeline_audit_id=@maxid AND pipeline_actual_end IS NULL AND pipeline_start IS NOT NULL AND @overrideError='N')

BEGIN 
		
		    IF NOT EXISTS ( SELECT 1 FROM azure_data_archive_pipeline_errors WHERE pipeline_audit_id=@maxid AND error_code='-2000003')

			BEGIN
					SELECT @errorEntry='New',
					@vErr='Something went wrong, the previous pipeline execution for the audit id:' + CAST(@maxid AS VARCHAR(15)) +' did not completed as designed (column pipeline_actual_end is  NULL ).',
					@errorCode='-2000003'

					UPDATE azure_data_archive_pipeline_audit 
					SET is_error=1,
					pipeline_last_action_code='RE'
					WHERE pipeline_audit_id=@maxid

				


					RAISERROR (@vErr -- Message text
									,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
									,1 -- State
									);

					
			END
			ELSE
			BEGIN	
			
			

			        UPDATE azure_data_archive_pipeline_audit 
					SET is_error=1,
					pipeline_last_action_code='RENR'
					WHERE pipeline_audit_id=@maxid

					INSERT INTO azure_data_archive_pipeline_errors_report_detailId
					SELECT 'error:'+ CAST(error_id AS VARCHAR(15)) ,'PREV'
					FROM azure_data_archive_pipeline_errors WHERE pipeline_audit_id=@maxid AND error_code='-2000003'

					SELECT @errorEntry='PREV'
					RAISERROR (@vErr -- Message text
									,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
									,1 -- State
									);


			


			END 		 	  
		

			
	


END
ELSE
BEGIN


		INSERT INTO azure_data_archive_pipeline_errors_report_detailId
		SELECT 'error:'+ CAST(error_id AS VARCHAR(15)) ,'PREV'
		FROM azure_data_archive_pipeline_errors  e 
		INNER JOIN azure_data_archive_pipeline_audit a ON a.pipeline_audit_id=e.pipeline_audit_id
		INNER JOIN azure_data_archive_pipeline_controller c ON c.controller_id= e.controller_id
		WHERE e.pipeline_audit_id=@maxid AND error_code<>'-2000003' 
		AND (is_last_job_error=1 AND is_job_fix=0)
		AND @overrideError='N'

		
		IF @@ROWCOUNT>0
		BEGIN
		SELECT @errorEntry='PREV'
		RAISERROR (@vErr -- Message text
											,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
											,1 -- State
											);

		END
		ELSE
		BEGIN







		INSERT INTO [dbo].[azure_data_archive_pipeline_audit]
		(           
				[run_id]         
				,[executed_by]  
				,pipeline_name
				,pipeline_last_action_code
				,pipeline_start
				,datafactory_name
				,trigger_type
				,trigger_id
				,trigger_name
				,pipeline_trigger_time_utc  
				,pipeline_start_utc
     
           
         
		)
		VALUES
		(       
			@RunId    
			,@execution_by
			,@pipelineName
			,'D'
			,GETDATE()	
			,@dataFactory
			,@triggerType
			,@triggerId
			,@triggerName
			,@triggerTime  
			,GETUTCDATE()
	 
      
		)


		SET @vauditId=SCOPE_IDENTITY()
		END
	
END     

IF @vauditId>0 
BEGIN



------TRUNCATE TABLE azure_data_archive_pipeline_storage_files_batch

--INSERT INTO @batch
--SELECT rows_per_file , m.master_controller_id FROM azure_data_archive_pipeline_master_controller m
--INNER JOIN azure_data_archive_pipeline_controller c ON c.master_controller_id=m.master_controller_id

--SELECT @mastercntrl=SCOPE_IDENTITY()

--WHILE @mastercntrl>0 
--BEGIN

--SELECT @loop=rows_per_file,
--@mastercntrlId=master_controller_id
--FROM @batch
--WHERE id=@mastercntrl



--		WHILE @loop>0
--		BEGIN
--		INSERT INTO  azure_data_archive_pipeline_storage_files_batch
--		SELECT @mastercntrlId,
--		       @vauditId,
--			   CASE WHEN @loop<@delete_batch_size
--		                      THEN @loop 
--		                      ELSE 
--		                      @delete_batch_size
--		                      END
--		SET @loop=@loop-@delete_batch_size
--		END


--SET @mastercntrl=@mastercntrl-1
--END









SELECT master_controller_id,
       @vauditId audit_id, 
       'N'   isError,
	   'RA' actionCode,
	   NULL errorDetailId,
	   NULL errorEntry
FROM azure_data_archive_pipeline_master_controller
ORDER BY master_controller_id

END


UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
step_status='Completed'
WHERE debug_id=@debugId


END TRY

BEGIN CATCH 

DECLARE @errorSource VARCHAR(6),
        @failureType VARCHAR(25)

SELECT @errorSource=	CASE WHEN @errorCode='-2000003' THEN 'Unkown' ELSE 'Sproc' END 
SELECT @failureType=    CASE WHEN @errorCode='-2000003' THEN 'Unkown' ELSE 'SQL Script' END 



SET @errorEntry=ISNULL(@errorEntry,'New')


IF @vErr IS NULL AND @errorEntry<>'PREV'
BEGIN 

SELECT @vErr=RTRIM( LEFT( 'Store Procedure failed at Line Number : ' +  CASt(ERROR_LINE() as VARCHAR(10)) + ', Description : ' +  ERROR_MESSAGE(), 5000 ) )
SELECT @errorCode=CAST(ERROR_NUMBER() as VARCHAR(15))

END

IF @errorEntry='New'
BEGIN
EXEC sproc_azure_data_archive_pipeline_errors
	@maxid,
	-1,
		0,
	-1,
	-1,
	@vErr,
	@errorCode,
	@errorSource,
	@failureType,
	'Data_Archival_Master: Lookup_Check Objects And Audit The Execution',
	'sproc_azure_data_archive_pipeline_master',
	@errorEntry,	
	@isError =@Error OUTPUT


		IF @Error=0 OR @Error IS NULL
		BEGIN
	         
				  SELECT        
					'Y' isError,
					'RE' actionCode,
					@maxid audit_id,
					@errorEntry errorEntry
		END
END
		 		 	  
	
	IF @errorEntry='PREV'
    BEGIN
	SELECT 'Y' isError,
			'RENR' actionCode,	
			 @maxid audit_id,
			 @errorEntry errorEntry
	END
 
 UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
additional_comment=ISNULL(additional_comment,'')+'  '+'Step Ended into the Catch block and error is: ' +  ISNULL(@vErr,'')+ ' This is '+'  '+ CASE WHEN @errorEntry='pREV' THEN 'previous error reported' ELSE ' new error' END,
step_status='Error'
WHERE debug_id=@debugId

END CATCH 




END

GO




GO

print 'C_Branch/04_StoredProcedures/sproc_azure_data_archive_pipeline_master.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_pipeline_master.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_retreival_view.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- CORE	- 86645	  :   script to create [sproc_azure_data_archive_retreival_view] Procedure  in Client Database
--						-- 
-- Written By:          Dominic Christie
-- Reviewed By:         
-- 
-- Script Type:         DML 
-- Target DB Type:      Client Database
-- Target ENVIRONMENT:  Both
-- 
-- Re-Runable:          YES #
-- 
-- Description of Script : This script will update the view for the existig aging process

-- Special Instruction: 
-- 


/*


exec sproc_azure_data_archive_retreival_view 
'pcc-chrisd',
'y',
315478,
'hcr',
1,
1


Revision History:


2021-01-19 Dom Christie  		CORE-86645 4.4.2	 	- Initial Creation of the store proc.
-- =================================================================================
*/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_azure_data_archive_retreival_view' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE [dbo].sproc_azure_data_archive_retreival_view
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO
CREATE PROCEDURE dbo.sproc_azure_data_archive_retreival_view


@execution_by VARCHAR(65),
@debug_me CHAR(1)='N',
@audit_id INT,
@orgcode VARCHAR(500),
@master_controller_id VARCHAR(25),
@controller_id VARCHAR(25)

AS

BEGIN




   
     DECLARE @vErr VARCHAR(3500),
		     @errorCode INT,
			 @vauditId INT,
			 @vmasterControllerId SMALLINT,
		     @vcontrollerId SMALLINT,
			 @folder VARCHAR(150),
			 @root VARCHAR(1500),
			 @sql VARCHAR(5000),	
			 @errorEntry VARCHAR(4),
			 @debugId INT,
			 @viewCol VARCHAR(3000)
			  



BEGIN TRY

	  SET @vmasterControllerId=CAST(@master_controller_id AS INT)
	  SET @vcontrollerId=CAST(@controller_id AS INT)
	  SELECT @vauditId=@audit_id

INSERT INTO azure_data_archive_pipeline_steps_debug

SELECT 'Executing sproc_azure_data_archive_retreival_view', @audit_id, 'Started',GETDATE(),NULL,NULL,GETUTCDATE(),NULL,NULL

SET @debugId=SCOPE_IDENTITY()



IF @vauditId IS NULL OR @vauditId=''
BEGIN
SET @vErr = 'Something went wrong, audit id cannot be blank.For a Job to continue azure_data_archive_pipeline_audit should have the recent audit id for the existing pipeline execution.'
SET @errorCode='-2000028'
SET @errorEntry='New'
	RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);

END

IF NOT EXISTS (SELECT 1 FROM azure_data_archive_pipeline_errors WHERE pipeline_audit_id=@vauditId)

BEGIN


IF @debug_me='Y'
BEGIN
SELECT @vauditId auditId
END

select @folder=transaction_table_name ,
@viewCol=view_columns
from azure_data_archive_pipeline_controller
WHERE controller_id=@vcontrollerId

IF @folder ='pho_schedule_details'
BEGIN
SET @root=''
SET @root=@orgcode+'/'+@folder+'/'+'*'+'/*.parquet'

		
SET @sql=''
SET @sql='
ALTER VIEW [dbo].[view_pho_schedule_details_aging] AS

select * from pho_schedule_details_2017
union all
select * from pho_schedule_details_2016
union all
select * from pho_schedule_details_2015
union all
select * from pho_schedule_details_2014
union all
select * from pho_schedule_details_2013
union all
select * from pho_schedule_details_2012
union all
select * from pho_schedule_details_2011
union all
select * from pho_schedule_details_2010
union all
select * from pho_schedule_details_2009
union all
select * from pho_schedule_details_2008

UNION ALL 

 SELECT  '+@viewCol+' FROM  OPENROWSET(
 BULK  '+CHAR(39)+@root+''+CHAR(39)+','
 +'  '+ 'DATA_SOURCE =''ScheduleDetails'''+','
 +'  ' +'FORMAT = ''parquet'') AS f'




				

END
---print (@sql)
EXEC (@sql)


 UPDATE azure_data_archive_pipeline_controller
 set is_existing_view_updated=1
 WHERE controller_id=@vcontrollerId

UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
step_status='Completed'
WHERE debug_id=@debugId

END

UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
step_status='Completed',
additional_comment=ISNULL(additional_comment,'')+'  '+' The step was skipped as there was an error prior to this sproc execution'
WHERE debug_id=@debugId



END TRY 

BEGIN CATCH




DECLARE  @errorId INT,
         @Error BIT,
		 @logId INT

SELECT  @errorEntry=ISNULL(@errorEntry,'New')

IF @vErr IS NULL AND @errorEntry='New'
BEGIN 

		SELECT @vErr=RTRIM( LEFT( 'Store Procedure  failed at Line Number : ' +  CASt(ERROR_LINE() as VARCHAR(10)) + ', Description : ' +  ERROR_MESSAGE(), 5000 ) )
		SELECT @errorCode=CAST(ERROR_NUMBER() as VARCHAR(15))

END

IF @errorEntry='New'
BEGIN
		EXEC sproc_azure_data_archive_pipeline_errors
						@vauditId,
						@vcontrollerId,
						@vmasterControllerId,
						-1,
						-1,
						@vErr,
						@errorCode,
						'Sproc Proc',
						'SQL Script',
						'Data_Archival_FilenRow_Validation: StoredProcedure_Delete Archived Records',
						'sproc_azure_data_archive_retreival_view',
						'New',
						@isError =@Error OUTPUT


		IF @Error=0 OR @Error IS NULL

			BEGIN

			SELECT  
	    
	    
					 'RE' actual_action_code,
					 'Y' isError,					
					 'New' error_entry
					 
			END	   

END
	  	
UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
additional_comment=ISNULL(additional_comment,'')+'  '+'Step Ended into the Catch block and error is: ' + ISNULL(@vErr,''),
step_status='Error'
WHERE debug_id=@debugId


END CATCH





	  	

END



GO

print 'C_Branch/04_StoredProcedures/sproc_azure_data_archive_retreival_view.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_retreival_view.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_return_error_detail.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- CORE	- 86645	  :   script to create [sproc_azure_data_archive_return_error_detail] Procedure  in Client Database
--						-- 
-- Written By:          Dominic Christie
-- Reviewed By:         
-- 
-- Script Type:         DML 
-- Target DB Type:      Client Database
-- Target ENVIRONMENT:  Both
-- 
-- Re-Runable:          YES #
-- 
-- Description of Script : 
-- This Sproc will return the error detail id- for the errors
-- Special Instruction: 
-- 



/*

exec sproc_azure_data_archive_return_error_detail 

'dominic.christie@pointclickcare.com',
'S',
230,
2


Revision History: 



2021-01-19 Dom Christie  		CORE-86645 4.4.2	 	- Initial Creation of the store proc.
-- =================================================================================
*/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_azure_data_archive_return_error_detail' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE [dbo].sproc_azure_data_archive_return_error_detail
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO
CREATE PROCEDURE dbo.sproc_azure_data_archive_return_error_detail


@primary_contact_email VARCHAR(250),
@error_report_type CHAR(1)=NULL,---On Error E, On Schedule S-- Both B,
@audit_id INT,
@threshold TINYINT =2




AS

BEGIN


DECLARE @debugId INT

INSERT INTO azure_data_archive_pipeline_steps_debug

SELECT 'Executing sproc_azure_data_archive_return_error_detail', -1, 'Started',GETDATE(),NULL, NULL,GETUTCDATE(),NULL,NULL

SET @debugId=SCOPE_IDENTITY()



DECLARE @compeletedInfo TABLE (
	header TINYINT ,
	pipeline_duration VARCHAR(37) ,
	gntotal VARCHAR(4),
	deltotal VARCHAR(4) ,
	tgntext VARCHAR(14) ,
	tdeltext VARCHAR(15) ,
	total SMALLINT,
	movedcnt SMALLINT ,
	deletedcnt SMALLINT,
	detail VARCHAR(max) 
	)
DECLARE @Id INT ,
        @type VARCHAR(8),		
        @revErrorDetailId VARCHAR(17),		
		@emailNote VARCHAR(520),
		@prevText VARCHAR(120),
		@newText VARCHAR(120),
		@rwcnt TINYINT



IF EXISTS (SELECT 1 FROM  azure_data_archive_pipeline_steps_debug WHERE pipeline_audit_id=@audit_id
           AND (step_desc  LIKE '%delete%' OR step_desc LIKE '%parquet%'))

BEGIN


UPDATE azure_data_archive_pipeline_steps_debug
SET additional_comment=ISNULL(additional_comment,'') + ' Started working on capturing the processed file data before error ocurred'
WHERE debug_id=@debugId


DECLARE @filescnt TABLE (is_unmatched_file_deleted BIT,is_unmatched_file_moved BIT )

DECLARE @totalfilescnt TABLE (id TINYINT, total SMALLINT,movedcnt SMALLINT,deletedcnt SMALLINT)

INSERT INTO @filescnt
SELECT is_unmatched_file_deleted,is_unmatched_file_moved FROM 
azure_data_archive_pipeline_storage_file_name s 
WHERE is_file_generated=1 AND (is_rows_from_table_deleted=0 OR is_file_table_deleted_rows_mismatch=1)
AND s.pipeline_audit_id=@audit_id

IF @@ROWCOUNT>0 
BEGIN

UPDATE azure_data_archive_pipeline_steps_debug
SET additional_comment=ISNULL(additional_comment,'') + ' Files were processed gathering the count'
WHERE debug_id=@debugId


;WITH total
AS
( SELECT 1 id, COUNT(*)total  FROM @filescnt
)
, moved
AS
( SELECT 1 id, COUNT(*) movedcnt FROM @filescnt WHERE is_unmatched_file_moved=1 
 )

 , deleted
AS
( SELECT 1 id, COUNT(*) deletedcnt FROM @filescnt WHERE is_unmatched_file_deleted=1 
 )

 INSERT INTO @totalfilescnt
 SELECT t.id,total,movedcnt,deletedcnt
 FROM total t
 LEFT JOIN moved m ON m.id=t.id
 LEFT JOIN deleted d ON d.id=t.id

 END





;WITH completiondetail
AS

(
SELECT DATEDIFF(s,step_start_date,step_end_date)/60 threshold,
d.azure_file_id,
CAST ((DATEDIFF(s,step_start_date,step_end_date)/60) AS VARCHAR(10)) +'  '+'mins'+' and '+  CAST ((DATEDIFF(s,step_start_date,step_end_date)%60) AS VARCHAR(10))+'  '+'secs' time_min,
p.pipeline_audit_id, 
'd' del_gen,
CAST ((DATEDIFF(s,pipeline_start,pipeline_actual_end)/60) AS VARCHAR(10))+'  '+'mins'+' and '+  CAST ((DATEDIFF(s,pipeline_start,pipeline_actual_end)%60) AS VARCHAR(10))+'  '+'secs' pipeline_duration
FROM azure_data_archive_pipeline_steps_debug d
INNER JOIN azure_data_archive_pipeline_audit p
ON p.pipeline_audit_id=d.pipeline_audit_id
INNER JOIN azure_data_archive_pipeline_activity_audit au
ON au.azure_file_id=d.azure_file_id
WHERE step_desc='Executing sproc_azure_data_archive_delete_records'
AND p.pipeline_audit_id=@audit_id
AND step_start_date IS NOT NULL 
AND step_end_date IS NOT NULL 
AND pipeline_actual_end IS NOT NULL
AND execution_status='Succeeded'


UNION ALL

SELECT DATEDIFF(s,step_start_date,step_end_date)/60 threshold, 
d.azure_file_id,
CAST ((DATEDIFF(s,step_start_date,step_end_date)/60) AS VARCHAR(10)) +'  '+'mins'+ ' and  '+ CAST ((DATEDIFF(s,step_start_date,step_end_date)%60) AS VARCHAR(10))+'  '+'secs' 
time_min,
p.pipeline_audit_id,
'g' del_gen,
CAST ((DATEDIFF(s,pipeline_start,pipeline_actual_end)/60) AS VARCHAR(10)) +'  '+'mins'+ ' and '+ CAST ((DATEDIFF(s,pipeline_start,pipeline_actual_end)%60) AS VARCHAR(10))+'  '+'secs'  pipeline_duration
FROM azure_data_archive_pipeline_steps_debug d
INNER JOIN azure_data_archive_pipeline_audit p
ON p.pipeline_audit_id=d.pipeline_audit_id
INNER JOIN azure_data_archive_pipeline_activity_audit au
ON au.azure_file_id=d.azure_file_id

WHERE step_desc='Executing sproc_azure_data_archive_generate_parquet_files'
AND p.pipeline_audit_id=@audit_id
AND step_start_date IS NOT NULL 
AND step_end_date IS NOT NULL 
AND pipeline_actual_end IS NOT NULL
AND execution_status='Succeeded'

)

,gnfiles
AS
(SELECT 1 header, CAST(COUNT(*) AS VARCHAR(4)) gntotal FROM completiondetail WHERE del_gen='g') 
,delfiles
AS
(SELECT 1 header, CAST(COUNT(*) AS VARCHAR(4)) deltotal FROM completiondetail WHERE del_gen='d') 
,threshgnfiles
AS
(SELECT 1 header, CAST(@threshold AS VARCHAR(2))+' '+ 'mins:- '+ CAST(COUNT(*) AS VARCHAR(4)) tgntext FROM completiondetail WHERE del_gen='g' AND  threshold>@threshold) 
,threshdelfiles
AS
(SELECT 1 header, CAST(@threshold AS VARCHAR(2))+' '+ 'mins:-  '+ CAST(COUNT(*) AS VARCHAR(4)) tdeltext FROM completiondetail WHERE del_gen='d' AND  threshold>@threshold) 
,pipelineduration
AS
(SELECT DISTINCT pipeline_duration , 1 header FROM [completiondetail])
,headertext
AS
(
SELECT p.header, pipeline_duration, gntotal,deltotal,tgntext,tdeltext
FROM pipelineduration p
LEFT JOIN  gnfiles g ON g.header=p.header
LEFT JOIN  delfiles d ON d.header=p.header
LEFT JOIN  threshgnfiles tg ON tg.header=p.header
LEFT JOIN  threshdelfiles td ON td.header=p.header
)
,textgenerate
AS
(

select 1 header,'Time Taken to ' + CASE WHEN cl.del_gen='g' THEN 'generate' ELSE 'delete' END + '  '+ CASE WHEN cl.del_gen='g' THEN  ' file ' 
ELSE ' rows from the '+'  '+   ' file is'   END +'  '+  +time_min+'  '+' refer the file id: '+CAST(azure_file_id  AS VARCHAR(30))textgd, pipeline_audit_id 
FROM completiondetail cl
WHERE threshold>2
)
INSERT INTO @compeletedInfo
SELECT 
   DISTINCT  h.header, pipeline_duration, gntotal ,deltotal,tgntext,tdeltext,total,movedcnt,deletedcnt,
   ISNULL( STUFF((SELECT  i.textgd  +'  '+'<br/>' 
          FROM textgenerate i
          WHERE i.pipeline_audit_id = ih.pipeline_audit_id
          FOR XML PATH('')), 1, 0, ''), 'Neither Generate nor Delete process for any file crossed the threshold') detail
		  
FROM headertext h
LEFT JOIN  textgenerate ih ON ih.header=h.header
LEFT JOIN @totalfilescnt tf ON tf.id=h.header



UPDATE azure_data_archive_pipeline_steps_debug
SET additional_comment=ISNULL(additional_comment,'') + ' Done gathering the count data for the files'
WHERE debug_id=@debugId

END

ELSE 
BEGIN 
INSERT INTO @compeletedInfo
SELECT NULL header,NULL  pipeline_duration,NULL gntotal ,NULL deltotal,NULL tgntext,NULL tdeltext,NULL total, NULL movedcnt, NULL deletedcnt,' No Detail Data for this Execution after the pipleline completion.' detail
END 





IF EXISTS (SELECT 1 FROM azure_data_archive_pipeline_errors_report_detailId WHERE error_detail_id IS NOT NULL)
BEGIN


UPDATE azure_data_archive_pipeline_steps_debug
SET additional_comment=ISNULL(additional_comment,'') + ' Now started capturing the error details at :' +CAST(GETDATE() AS VARCHAR(16))
WHERE debug_id=@debugId

SET @emailNote='After any failure, if the error/s are not fixed the subsequent pipeline execution will terminate without any action. After a fix, it is required to update the is_job_fix flag to 1 for the table azure_data_archive_pipeline_controller,and pipeline_actual_end with the date time if the error left the column null. Failing to do so would not re-run the pipeline with the fixes. For more information on the Archiving framework,refer https://confluence.pointclickcare.com/confluence/display/POM/Azure+Data+Archiving'
SET @prevText= 'Notification for the previous error encountered during Pipeline Execution which requires an immediate attention.'
SET @newText='Recent Pipeline Execution Resulted in an error and requires an immediate attention.'


DECLARE @retrieveError TABLE
(
 email SMALLINT,
 error_entry VARCHAR(4),
 error_type VARCHAR(6),
 error_id VARCHAR(150)

)






    ;WITH errorId
	AS 
	(
	SELECT 
          REVERSE(LEFT(REVERSE(error_detail_id), CHARINDEX(':',REVERSE(error_detail_id))-1)) id,
		  LEFT(error_detail_id, CHARINDEX(':',error_detail_id)-1) errType,
		  error_entry
	FROM  azure_data_archive_pipeline_errors_report_detailId 

	),controllerId
	AS
	(
	SELECT id, errType, error_entry, ISNULL(err.controller_id,-1) controller_id, err.pipeline_audit_id
	FROM errorId e 
	LEFT JOIN azure_data_archive_pipeline_errors err ON ( (err.error_id=e.id AND errType LIKE 'error%') OR (err.pipeline_audit_id=e.id AND errType LIKE 'audit%'))
	LEFT JOIN azure_data_archive_pipeline_log lg ON lg.log_id=e.id AND  errType LIKE 'log%'	
	)

	SELECT    pipeline_duration, 
	gntotal ,deltotal,tgntext,tdeltext,total,movedcnt,deletedcnt,detail,
	
	'Y' isErrorData,CASE WHEN re.error_entry='PREV' THEN  @prevText
	                                        ELSE @newText
			   END emailHeader,   
			  'For further investigation and error detail please refer the '+
			   CASE WHEN error_type LIKE 'log%' THEN 'azure_data_archive_pipeline_log' +' ' 
			        ELSE 'azure_data_archive_pipeline_errors'
					END+' '+' table with the'+'  ' +
			   CASE WHEN error_type LIKE 'log%' THEN 'log id/s:' +' ' 
			        ELSE 'error id/s:'
					END +' '+ '[ '  +error_id+ ' ]' 
			   +'  '+  CASE WHEN c.controller_id IS NOT NULL THEN 'This error is for the transaction table'+' '+c.transaction_table_name+'.' ELSE '' END errorMessage,
	            CASE WHEN  @error_report_type='S' THEN @primary_contact_email 
				     WHEN  @error_report_type='E' THEN ISNULL(c.notify_email_to,@primary_contact_email)
				     WHEN  @error_report_type='B' THEN CASE WHEN c.notify_email_to IS NULL THEN @primary_contact_email
					                                        ELSE c.notify_email_to+';'+@primary_contact_email
															END
					 
					 END emailList,
				CASE WHEN @error_report_type='E' THEN ISNULL(c.notify_email_cc,@primary_contact_email)
				
				     END emailCc,
				@emailNote emailNote
	FROM (	SELECT DISTINCT c.controller_id,
	                        c.error_entry,
							c.errType error_type,
				    STUFF((SELECT ';' + t.id
					FROM controllerId t
					WHERE ((c.controller_id = t.controller_id) OR  t.controller_id=-1)
					AND c.error_entry=t.error_entry
					AND c.errType=t.errType
					ORDER BY c.id
					FOR XML PATH('')),1,1,'') error_id									

	                FROM controllerId c) re 
	LEFT JOIN	azure_data_archive_pipeline_controller c  ON c.controller_id=re.controller_id
	CROSS APPLY @compeletedInfo
	SET @rwcnt=@@ROWCOUNT
	IF @rwcnt<0
	BEGIN
	SELECT 'N' isErrorData
	END

END
ELSE
BEGIN

	
	SELECT 'E' isErrorData

END

UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
step_status='Completed'
WHERE debug_id=@debugId

END



GO

print 'C_Branch/04_StoredProcedures/sproc_azure_data_archive_return_error_detail.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_return_error_detail.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_send_email_completion.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- CORE	- 86645	  :   script to create [sproc_azure_data_archive_send_email_completion] Procedure  in Client Database
--						-- 
-- Written By:          Dominic Christie
-- Reviewed By:         
-- 
-- Script Type:         DML 
-- Target DB Type:      Client Database
-- Target ENVIRONMENT:  Both
-- 
-- Re-Runable:          YES #
-- 
-- Description of Script : Returns  All the detail of the each controller - table

-- Special Instruction: 
-- 

/*
Revision History:


2021-03-24 Dom Christie  		CORE-86645 4.4.2	 	- Initial Creation of the store proc.
-- =================================================================================


EXEC SCRIPT
 

---exec sproc_azure_data_archive_send_email_completion 'dcc','n',189,1


*/
IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_azure_data_archive_send_email_completion' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE [dbo].sproc_azure_data_archive_send_email_completion
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO
CREATE PROCEDURE dbo.sproc_azure_data_archive_send_email_completion
@execution_by VARCHAR(65),
@debug_me CHAR(1)='N',
@audit_id INT,
@threshold TINYINT =2

AS



BEGIN



BEGIN TRY

DECLARE  @debugId INT

INSERT INTO azure_data_archive_pipeline_steps_debug
SELECT 'Executing sproc_azure_data_archive_send_email_completion', @audit_id, 'Started',GETDATE(),NULL,NULL,GETUTCDATE(),NULL,NULL

SET @debugId=SCOPE_IDENTITY()




DECLARE @vCharNewLine  char(2)
SET @vCHARNewLine  = CHAR(13) + CHAR(10); 

IF EXISTS (SELECT 1 FROM  azure_data_archive_pipeline_steps_debug WHERE pipeline_audit_id=@audit_id
           AND (step_desc  LIKE '%delete%' OR step_desc LIKE '%parquet%'))

BEGIN


DECLARE @filescnt TABLE (is_unmatched_file_deleted BIT,is_unmatched_file_moved BIT )

DECLARE @totalfilescnt TABLE (id TINYINT, total SMALLINT,movedcnt SMALLINT,deletedcnt SMALLINT)

INSERT INTO @filescnt
SELECT is_unmatched_file_deleted,is_unmatched_file_moved FROM 
azure_data_archive_pipeline_storage_file_name s 
WHERE is_file_generated=1 AND (is_rows_from_table_deleted=0 OR is_file_table_deleted_rows_mismatch=1)
AND s.pipeline_audit_id=@audit_id

IF @@ROWCOUNT>0 
BEGIN
;WITH total
AS
( SELECT 1 id, COUNT(*)total  FROM @filescnt
)
, moved
AS
( SELECT 1 id, COUNT(*) movedcnt FROM @filescnt WHERE is_unmatched_file_moved=1 
 )

 , deleted
AS
( SELECT 1 id, COUNT(*) deletedcnt FROM @filescnt WHERE is_unmatched_file_deleted=1 
 )

 INSERT INTO @totalfilescnt
 SELECT t.id,total,movedcnt,deletedcnt
 FROM total t
 LEFT JOIN moved m ON m.id=t.id
 LEFT JOIN deleted d ON d.id=t.id

 END





;WITH completiondetail
AS

(
SELECT DATEDIFF(s,step_start_date,step_end_date)/60 threshold,
d.azure_file_id,
CAST ((DATEDIFF(s,step_start_date,step_end_date)/60) AS VARCHAR(10)) +'  '+'mins'+' and '+  CAST ((DATEDIFF(s,step_start_date,step_end_date)%60) AS VARCHAR(10))+'  '+'secs' time_min,
p.pipeline_audit_id, 
'd' del_gen,
CAST ((DATEDIFF(s,pipeline_start,pipeline_actual_end)/60) AS VARCHAR(10))+'  '+'mins'+' and '+  CAST ((DATEDIFF(s,pipeline_start,pipeline_actual_end)%60) AS VARCHAR(10))+'  '+'secs' pipeline_duration
FROM azure_data_archive_pipeline_steps_debug d
INNER JOIN azure_data_archive_pipeline_audit p
ON p.pipeline_audit_id=d.pipeline_audit_id
INNER JOIN azure_data_archive_pipeline_activity_audit au
ON  au.azure_file_id=d.azure_file_id
WHERE step_desc='Executing sproc_azure_data_archive_delete_records'
AND p.pipeline_audit_id=@audit_id
AND step_start_date IS NOT NULL 
AND step_end_date IS NOT NULL 
AND pipeline_actual_end IS NOT NULL
AND execution_status='Succeeded'

UNION ALL

SELECT DATEDIFF(s,step_start_date,step_end_date)/60 threshold, 
d.azure_file_id,
CAST ((DATEDIFF(s,step_start_date,step_end_date)/60) AS VARCHAR(10)) +'  '+'mins'+ ' and  '+ CAST ((DATEDIFF(s,step_start_date,step_end_date)%60) AS VARCHAR(10))+'  '+'secs' 
time_min,
p.pipeline_audit_id,
'g' del_gen,
CAST ((DATEDIFF(s,pipeline_start,pipeline_actual_end)/60) AS VARCHAR(10)) +'  '+'mins'+ ' and '+ CAST ((DATEDIFF(s,pipeline_start,pipeline_actual_end)%60) AS VARCHAR(10))+'  '+'secs'  pipeline_duration
FROM azure_data_archive_pipeline_steps_debug d
INNER JOIN azure_data_archive_pipeline_audit p
ON p.pipeline_audit_id=d.pipeline_audit_id
INNER JOIN azure_data_archive_pipeline_activity_audit au
ON au.azure_file_id=d.azure_file_id
WHERE step_desc='Executing sproc_azure_data_archive_generate_parquet_files'
AND p.pipeline_audit_id=@audit_id
AND step_start_date IS NOT NULL 
AND step_end_date IS NOT NULL 
AND pipeline_actual_end IS NOT NULL
AND execution_status='Succeeded'

)

,gnfiles
AS
(SELECT 1 header, CAST(COUNT(*) AS VARCHAR(4)) gntotal FROM completiondetail WHERE del_gen='g') 
,delfiles
AS
(SELECT 1 header, CAST(COUNT(*) AS VARCHAR(4)) deltotal FROM completiondetail WHERE del_gen='d') 
,threshgnfiles
AS
(SELECT 1 header, CAST(@threshold AS VARCHAR(2))+' '+ 'mins:- '+ CAST(COUNT(*) AS VARCHAR(4)) tgntext FROM completiondetail WHERE del_gen='g' AND  threshold>@threshold) 
,threshdelfiles
AS
(SELECT 1 header, CAST(@threshold AS VARCHAR(2))+' '+ 'mins:-  '+ CAST(COUNT(*) AS VARCHAR(4)) tdeltext FROM completiondetail WHERE del_gen='d' AND  threshold>@threshold) 
,pipelineduration
AS
(SELECT DISTINCT pipeline_duration , 1 header FROM [completiondetail])
,headertext
AS
(
SELECT p.header, pipeline_duration, gntotal,deltotal,tgntext,tdeltext
FROM pipelineduration p
LEFT JOIN  gnfiles g ON g.header=p.header
LEFT JOIN  delfiles d ON d.header=p.header
LEFT JOIN  threshgnfiles tg ON tg.header=p.header
LEFT JOIN  threshdelfiles td ON td.header=p.header
)
,textgenerate
AS
(

select 1 header,'Time Taken to ' + CASE WHEN cl.del_gen='g' THEN 'generate' ELSE 'delete' END + '  '+ CASE WHEN cl.del_gen='g' THEN  ' file ' 
ELSE ' rows from the '+'  '+   ' file is'   END +'  '+  +time_min+'  '+' refer the file id: '+CAST(azure_file_id  AS VARCHAR(30))textgd, pipeline_audit_id 
FROM completiondetail cl
WHERE threshold>@threshold
)
SELECT 
   DISTINCT  h.header, pipeline_duration, gntotal ,deltotal,tgntext,tdeltext,total,movedcnt,deletedcnt,
   ISNULL( STUFF((SELECT  i.textgd  +'  '+'<br/>' 
          FROM textgenerate i
          WHERE i.pipeline_audit_id = ih.pipeline_audit_id
          FOR XML PATH('')), 1, 0, ''), 'Neither Generate nor Delete process for any file crossed the threshold') detail
		  
FROM headertext h
LEFT JOIN  textgenerate ih ON ih.header=h.header
LEFT JOIN @totalfilescnt tf ON tf.id=h.header


END

ELSE 
BEGIN 
SELECT NULL header,NULL  pipeline_duration,NULL gntotal ,NULL deltotal,NULL tgntext,NULL tdeltext,NULL total, NULL movedcnt, NULL deletedcnt,' No Detail Data for this Execution after the pipleline completion.' detail
END 

UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
step_status='Completed'
WHERE debug_id=@debugId

END TRY

BEGIN CATCH


DECLARE  @errorId INT,
         @Error BIT,
		 @logId INT,
		 @errorCode VARCHAR(150),
		 @vErr VARCHAR(3500)



BEGIN 

		SELECT @vErr=RTRIM( LEFT( 'Store Procedure failed at Line Number : ' +  CASt(ERROR_LINE() as VARCHAR(10)) + ', Description : ' +  ERROR_MESSAGE(), 5000 ) )
		SELECT @errorCode=CAST(ERROR_NUMBER() AS VARCHAR(15))
END
		EXEC sproc_azure_data_archive_pipeline_errors
						@audit_id,
						0,
						0,
						-1,
						-1,
						@vErr,
						@errorCode,
						'Sproc Proc',
						'SQL Script',
						'Data_Archival_Master: LookUp_Complete The Pipeline Execution',
						'sproc_azure_data_archive_send_email_completion',
						'New',
						@isError =@Error OUTPUT



UPDATE azure_data_archive_pipeline_steps_debug
SET step_end_date=GETDATE(),
step_end_time_utc=GETUTCDATE(),
additional_comment=ISNULL(additional_comment,'')+'  '+'Step Ended into the Catch block. This is new error and the error is '+ISNULL(@vErr,''),
step_status='Error'
WHERE debug_id=@debugId


END CATCH


END



GO

print 'C_Branch/04_StoredProcedures/sproc_azure_data_archive_send_email_completion.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_azure_data_archive_send_email_completion.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_core_update_iam_sync.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- =================================================================================
-- Script Type:          DDL
-- Target DB Type:       CLIENTDB
-- Target ENVIRONMENT:   US and CDN
--
--
-- Re-Runable:           YES
--
-- Description: Updates the iam sync status for one or more users by updating the
-- profile_sync_time column to the given timestamp value or seeding a new row with
-- profile_update_time and profile_sync_time column set to the given timestamp value.
-- If updating for a single user, the optional @iamUserUuid argument can be supplied
-- to associate the given PCC userid with that @iamUserUuid
--
-- Special Instruction:  
--
-- Revision History:
--   CORE-84019 01/29/2021   procedure created
-- =================================================================================
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create or alter procedure [dbo].sproc_core_update_iam_sync
(
  @userids xml,
  @profileSyncTime datetimeoffset,
  @iamUserUuid varchar(40)
)
as
begin

  set nocount on

  MERGE sec_user_iam_sync AS TARGET
  USING (
    SELECT x.y.value('.','int') AS userid
    FROM @userids.nodes('/userids/id/text()') AS x(y)
  ) AS SOURCE
  ON TARGET.userid = SOURCE.userid
  WHEN MATCHED THEN UPDATE SET profile_sync_time = @profileSyncTime, iam_uuid = ISNULL(@iamUserUuid, iam_uuid)
  WHEN NOT MATCHED BY TARGET THEN INSERT (userid, profile_update_time, profile_sync_time, iam_uuid) VALUES (SOURCE.userid, @profileSyncTime, @profileSyncTime, @iamUserUuid)
  ;

end

GO

GRANT EXECUTE ON sproc_core_update_iam_sync TO PUBLIC

GO


GO

print 'C_Branch/04_StoredProcedures/sproc_core_update_iam_sync.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_core_update_iam_sync.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_data_assert_add_data_facility.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- =================================================================================
-- CORE-92301          Create stored procs to insert facility data in target data assertion table
--
-- Script Type:         DML
-- Target DB Type:      Client
-- Target ENVIRONMENT:  BOTH
--
--
-- Re-Runable:          YES
--
-- Description of Script:  Data insertion for facility data in target data assertion table
--
-- Special Instruction:
--
-- =================================================================================

IF EXISTS (SELECT 1 FROM SYSOBJECTS WHERE NAME = 'sproc_data_assert_add_data_facility')
    BEGIN
        DROP PROCEDURE sproc_data_assert_add_data_facility
    END
GO

CREATE PROCEDURE [dbo].[sproc_data_assert_add_data_facility] (
    @env_name varchar(500),
    @org_id int,
    @org_code varchar(500)
)

AS
BEGIN
	DECLARE @team  varchar(100) = 'Team Pixels',
			@email varchar(100) = 'TeamPixels@pointclickcare.com',
			@description varchar(500)  = 'Data assertion sproc for inserting facility data in target data assertion table',
			@start_time datetime2(3) = GETDATE(),
			@end_time datetime2(3) = GETDATE();
    
	EXEC        sproc_add_data_assertion_result
                @sp_proc_name='sproc_data_assert_add_data_facility',
                @env_name = @env_name,
                @org_id = @org_id,
                @org_code = @org_code,
                @status = 'co_export_started',
                @message = 'Data assertion export started',
                @start_time = @start_time,
				@team = @team,
				@team_email = @email


    BEGIN TRY
            DECLARE @SQLString NVARCHAR(4000);
            DECLARE @ParmDefinition NVARCHAR(4000);
            DECLARE @data_assertion_db  NVARCHAR(500);

            SELECT @data_assertion_db = data_source FROM sys.servers WHERE is_linked = 'true' AND name = 'DATA_ASSERTION'
			IF (@data_assertion_db IS NULL)
				BEGIN
					SELECT @data_assertion_db = data_source FROM sys.servers WHERE is_linked = 'false'
				END
			ELSE
				BEGIN
					SET @data_assertion_db = 'DATA_ASSERTION'
				END
				
            SET @SQLString =
                        N'INSERT INTO [' +  @data_assertion_db + '].[DataAssertion].[dbo].[da_facility_data]
				 SELECT 
					fac_id, 
					fac_uuid, 
					name AS fac_name, 
					org_id, 
					@org_code AS org_code, 
					@env_name AS env_name from facility
				 WITH (NOLOCK)
				 WHERE fac_uuid IS NOT NULL
					AND deleted = ''N'' 
				'
			SET @ParmDefinition = N'
			@env_name varchar(255),
			@org_code varchar(255)
			';
			
            EXECUTE sp_executesql @SQLString, @ParmDefinition,
					@env_name = @env_name,
					@org_code = @org_code;
			
			SET @end_time = GETDATE();
			EXEC sproc_update_data_assertion_result
				@sp_proc_name= 'sproc_data_assert_add_data_facility',
				@env_name = @env_name,
				@org_id = @org_id,
				@start_time = @start_time,
				@status = 'co_export_completed',
				@message = 'Data assertion export completed',
				@end_time = @end_time
        RETURN @@identity
    END TRY
    BEGIN CATCH
        SELECT
            ERROR_NUMBER() AS ErrorNumber,
            ERROR_STATE() AS ErrorState,
            ERROR_SEVERITY() AS ErrorSeverity,
            ERROR_PROCEDURE() AS ErrorProcedure,
            ERROR_LINE() AS ErrorLine,
            ERROR_MESSAGE() AS ErrorMessage;
		SET @end_time = GETDATE();
		EXEC sproc_update_data_assertion_result
			@sp_proc_name = 'sproc_data_assert_add_data_facility',
			@env_name = @env_name,
			@org_id = @org_id,
			@start_time = @start_time,
			@status = 'co_export_error',
			@message = 'Data assertion export error',
			@end_time = @end_time
    END CATCH
END
GO

GRANT EXECUTE ON [dbo].[sproc_data_assert_add_data_facility] TO PUBLIC
GO

GO

print 'C_Branch/04_StoredProcedures/sproc_data_assert_add_data_facility.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_data_assert_add_data_facility.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_mds_list_generateMDS3ExportXML.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*****************************************************************************************************
**  Created By: Peter Bellamy
**  Created Date: 07/09/10
**
**  Purpose:  The purpose of this procedure is to generate the export XML for MDS 3.0 assessment.
**
**  Parameters:
**          @assessId           - The assess id to get the sections for.
**          @batchId            - The batch id from as_batch_export
**          @facId              - The facility id the assessment(s) belongs to.
**          @debug              - Flag to print debug statements.
**          @status_code        - Return value if the procedure ran correctly, 1 if error, 0 if success.
**          @status_text        - Error message if status_code is 1.
**
**  Revision History:
**  Date                User            JIRA          Description
**  2020, Jan 22     Brian Young     CORE-52927     Allow Z0300A and Z0300B to be exported after Oct 1, 2019 
**  2020, Jul 14     Colin Collins   CORE-71698     Add STATE_PDPM_OBRA_CD to exported XML
**  2021, Nov 16	 Brian Young     CORE-93509     SQL Performance improvements
*****************************************************************************************************/
IF EXISTS (	SELECT 1
			FROM sys.objects
			WHERE object_id = OBJECT_ID(N'[dbo].[sproc_mds_list_generateMDS3ExportXML]')
			  AND OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
BEGIN			
   DROP PROCEDURE [dbo].[sproc_mds_list_generateMDS3ExportXML]
END   
GO

CREATE PROCEDURE sproc_mds_list_generateMDS3ExportXML
(
	@assessId			int
	,@batchId			int
	,@facId				int
	,@prodTestIndicator	char(1) = 'T'
	,@debug				char(1) = 'N'
	,@status_code		int 			OUTPUT
	,@status_text		varchar(3000)	OUTPUT
)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE
		 @step					int = 0
		,@error_code			int = 0
		,@questionKeys			nvarchar(MAX)
		,@questionKeysCol		nvarchar(MAX)
		,@stateProviderNumber	varchar(16)             -- CMS.gov spec length is max 16 char for FAC_ID value
		,@pccDBVersion			varchar(20)				-- CMS.gov spec length is max 20 char for SFTWR_PROD_VRSN_CD value
		,@isMdsForVA			char(1)
		,@prov					varchar(3)
		,@SQL					nvarchar(MAX)
		,@SQLMainTable			nvarchar(MAX)
		,@SQLPivoting			nvarchar(MAX)
		,@SQLTopTable			nvarchar(MAX)
		,@Oct2019				varchar(10) = '2019-10-01'
	;
	SET @status_code = 0;
	SET @status_text = '';

	BEGIN TRY
		-- Don't generate anything if the batch id and assess id are both NULL
		IF (@assessId IS NULL AND @batchId IS NULL)
		BEGIN
			SET @status_text = 'Assess Id and Batch Id are null';
			RETURN 1;
		END

		IF (@debug = 'Y')
		BEGIN
			PRINT 'BEGIN STEP 1: select assess ids to generate for. ' + CONVERT(varchar(26), GETDATE(), 109);
			SET @step = 1;
		END

		-- Put assess ids into temp table
		-- Need to keep as temp table because required in dyanamic SQL
		CREATE TABLE #tempAssessIds 
		(
			assess_id int PRIMARY KEY 
			,assess_date datetime not null
			,assess_type_code varchar(3) not null
			,prov_state varchar(3) not null
			,STATE_PDPM_OBRA_CD char(1) 
		);

		IF (@assessId IS NULL)
		BEGIN   
			--multi assessments
			--this is for DS to do bulk extracts for assessments.
			INSERT INTO #tempAssessIds
			SELECT b.assess_id, a.assess_date, a.assess_type_code, a.prov_state, pdpm.STATE_PDPM_OBRA_CD
			FROM as_batch_assess_extract b 
			JOIN as_assessment a ON a.assess_id = b.assess_id
            LEFT JOIN as_assessment_pdpm pdpm ON pdpm.assess_id = a.assess_id
			WHERE b.batch_id = @batchId
			  AND b.fac_id	 = @facId;
		END
		ELSE
		BEGIN
			--single assessment
			INSERT INTO #tempAssessIds
			SELECT a.assess_id, a.assess_date, a.assess_type_code, a.prov_state, pdpm.STATE_PDPM_OBRA_CD
			FROM as_assessment a
            LEFT JOIN as_assessment_pdpm pdpm ON pdpm.assess_id = a.assess_id
			WHERE a.assess_id = @assessId;
		END

		IF (@debug = 'Y')
		BEGIN
			PRINT 'BEGIN STEP 2: select distinct question keys. ' + CONVERT(varchar(26), GETDATE(), 109);
			SET @step = 2;
		END

		

		-- Get a distinct list of question keys that will be used.
		
		CREATE TABLE #excludeQuestionKeys 
		(
			  question_key varchar(40)		
		    , ard_start_date datetime
		    , ard_stop_date datetime
		);

		INSERT INTO #excludeQuestionKeys (question_key, ard_start_date, ard_stop_date)		
			VALUES  ('A_SHORTA', '1900-01-01', '9999-12-31'),
					('A_SHORTB', '1900-01-01', '9999-12-31'), 
					('A_SHORTC', '1900-01-01', '9999-12-31'), 
					('V0200B1', '1900-01-01', '9999-12-31'), 
					('V0200C1', '1900-01-01', '9999-12-31'), 
					('X0900Z2', '1900-01-01', '9999-12-31'), 
					('X1050Z2', '1900-01-01', '9999-12-31'),
					('Z0300A', '1900-01-01', '2019-09-30'), 
					('Z0300B', '1900-01-01', '2019-09-30'), 
					('Z0300C', '1900-01-01', '9999-12-31'), 
					('Z0350A', '1900-01-01', '9999-12-31'), 
					('Z0350B', '1900-01-01', '9999-12-31'),
					('Z0500A', '1900-01-01', '9999-12-31') 
		;					
	
		CREATE TABLE #tempQuestionKeys 
		(
			question_key varchar(40) -- changed from 16
		);
		
		INSERT INTO #tempQuestionKeys 
			SELECT DISTINCT resp.question_key
			FROM #tempAssessIds a
			INNER JOIN as_response resp ON resp.assess_id = a.assess_id
			LEFT JOIN #excludeQuestionKeys tqk ON resp.question_key	= tqk.question_key and a.assess_date BETWEEN tqk.ard_start_date AND tqk.ard_stop_date
			WHERE tqk.question_key is NULL 
			;
	
		SET @questionKeys = STUFF (
			(	SELECT DISTINCT ',[' + question_key + ']'
				FROM #tempQuestionKeys
				ORDER BY ',[' + question_key + ']'
				FOR XML PATH('')
			)
			,1
			,1
			,''
		);
		
		SET @questionKeysCol = STUFF (
			(	SELECT DISTINCT ',' + question_key 
				FROM #tempQuestionKeys
				ORDER BY ',' + question_key 
				FOR XML PATH('')
			)
			,1
			,1
			,''
		);
		
		IF (@debug = 'Y')
		BEGIN
			PRINT 'BEGIN STEP 3: generate SQL. ' + CONVERT(varchar(26), GETDATE(), 109);
			SET @step = 3;
		END

		-- Get value for FAC_ID
		SET @stateProviderNumber = ISNULL(
			(	SELECT value
				FROM configuration_parameter
				WHERE fac_id = @facId
					AND name LIKE 'mds3_second_state_facid'
			)
			,'^'
		);

		-- Get value for SFTWR_PROD_VRSN_CD
		SET @pccDBVersion = ISNULL(
			(	SELECT TOP 1 RTRIM(db_version_code)
				FROM pcc_db_version
				WHERE db_upload_date =
					(	SELECT MAX(db_upload_date)
						FROM pcc_db_version
					)
				ORDER BY db_version_code DESC
			)
			,'^'
		);

		-- Use facility prov code in case of Veteran Affairs facility
		SET @prov = '';
		SET @isMdsForVA = ISNULL(
			(	SELECT value
				FROM configuration_parameter
				WHERE fac_id = @facId
					AND name = 'is_mds_for_va'
			)
			,''
		);

		IF (@isMdsForVA = 'Y')
		BEGIN
			SELECT @prov = prov
			FROM facility
			WHERE fac_id = @facId
			;
		END
	
		SET @SQLMainTable = N'
		( SELECT * FROM
		(	SELECT
				''MDS''				AS ASMT_SYS_CD
				,assess_type_code	AS ITM_SBST_CD
				,CASE
					WHEN (ass.assess_date >= ''2019-10-01'') THEN ''1.17''
					WHEN (ass.assess_date >= ''2018-10-01'' AND ass.assess_date < ''2019-10-01'') THEN ''1.16''
					WHEN (ass.assess_date >= ''2017-10-01'' AND ass.assess_date < ''2018-10-01'') THEN ''1.15''
					WHEN (ass.assess_date >= ''2016-10-01'' AND ass.assess_date < ''2017-10-01'') THEN ''1.14''
					WHEN (ass.assess_date >= ''2015-10-01'' AND ass.assess_date < ''2016-10-01'') THEN ''1.13''
					WHEN (ass.assess_date >= ''2014-10-01'' AND ass.assess_date < ''2015-10-01'') THEN ''1.12''
					WHEN (ass.assess_date >= ''2013-10-01'' AND ass.assess_date < ''2014-10-01'') THEN ''1.11''
					WHEN (ass.assess_date >= ''2012-04-01'' AND ass.assess_date < ''2013-10-01'') THEN ''1.10''
					ELSE ''1.00''
					END				AS ITM_SET_VRSN_CD
				,CASE
					WHEN (ass.assess_date >= ''2019-10-01'') THEN ''3.00''
					WHEN (ass.assess_date >= ''2018-10-01'' AND ass.assess_date < ''2019-10-01'') THEN ''2.02''
					WHEN (ass.assess_date >= ''2017-10-01'' AND ass.assess_date < ''2018-10-01'') THEN ''2.01''
					WHEN (ass.assess_date >= ''2016-10-01'' AND ass.assess_date < ''2017-10-01'') THEN ''2.00''
					WHEN (ass.assess_date >= ''2015-10-01'' AND ass.assess_date < ''2016-10-01'') THEN ''1.15''
					WHEN (ass.assess_date >= ''2014-10-01'' AND ass.assess_date < ''2015-10-01'') THEN ''1.14''
					WHEN (ass.assess_date >= ''2013-10-01'' AND ass.assess_date < ''2014-10-01'') THEN ''1.13''
					WHEN (ass.assess_date >= ''2013-05-19'' AND ass.assess_date < ''2013-10-01'') THEN ''1.12''
					WHEN (ass.assess_date >= ''2012-10-01'' AND ass.assess_date < ''2013-05-19'') THEN ''1.11''
					WHEN (ass.assess_date >= ''2012-04-01'' AND ass.assess_date < ''2012-10-01'') THEN ''1.10''
					WHEN (ass.assess_date >= ''2011-10-01'' AND ass.assess_date < ''2012-04-01'') THEN ''1.02''
					WHEN (ass.assess_date >= ''2011-04-01'' AND ass.assess_date < ''2011-10-01'') THEN ''1.01''
					ELSE ''1.00''
					END				AS SPEC_VRSN_CD
				,''' + @prodTestIndicator + '''			AS PRODN_TEST_CD
				,CASE
					WHEN ''Y'' = ''' + @isMdsForVA + ''' THEN ''' + @prov + '''
					ELSE ass.prov_state
					END				AS STATE_CD
                ,ass.STATE_PDPM_OBRA_CD
				,''' + @stateProviderNumber + '''	AS FAC_ID
				,''^''				AS SFTWR_VNDR_ID
				,''^''				AS SFTWR_VNDR_NAME
				,''^''				AS SFTWR_VNDR_EMAIL_ADR
				,''PointClickCare''	AS SFTWR_PROD_NAME
				,''' + @pccDBVersion + '''		AS SFTWR_PROD_VRSN_CD
				,''^''				AS FAC_DOC_ID
				,resp.question_key
				,item_value =
					CASE
						WHEN (resp.question_key LIKE ''I8000%'' OR resp.question_key = ''I0020A'' OR resp.question_key = ''I0020B'' ) THEN (dbo.fn_clinical_mds3_icd_fmt_sub(ass.assess_date, resp.item_value))
						WHEN (ass.prov_state = ''IL'' AND resp.question_key LIKE ''S9002%'' AND resp.item_value=''^'') THEN (''0'')
						WHEN (resp.question_key = ''S0120'' AND LEN(resp.item_value) > 5) THEN (SUBSTRING(resp.item_value, 1, 5))
						WHEN (ISNULL(resp.item_value, '''') = '''') THEN (''^'')
						ELSE (resp.item_value)
					END
				,ass.assess_id as assess_id
			FROM #tempAssessIds AS ass
				INNER JOIN as_response resp ON resp.assess_id = ass.assess_id
			) responses '
		;

		SET @SQLPivoting = N'
		PIVOT (
			MAX(item_value)
			FOR question_key
			IN (' + @questionKeys + ')
		) AS PIVOTTABLE	) '
		;
		 
		SET @SQL = @SQLMainTable + @SQLPivoting;
		
		SET @SQLTopTable = N'SELECT assess_id, mds_output_xml = ( SELECT ASMT_SYS_CD,ITM_SBST_CD,ITM_SET_VRSN_CD,SPEC_VRSN_CD,PRODN_TEST_CD,' +
			'STATE_CD,STATE_PDPM_OBRA_CD,FAC_ID,SFTWR_VNDR_ID,SFTWR_VNDR_NAME,SFTWR_VNDR_EMAIL_ADR,SFTWR_PROD_NAME,SFTWR_PROD_VRSN_CD,FAC_DOC_ID, ' + 
		@questionKeysCol + ' FOR XML PATH(''ASSESSMENT'')) ' +
		' FROM ' +@SQL +' AS xmlinput ORDER BY assess_id ASC';
		
		
		IF (@debug = 'Y')
		BEGIN 
			IF (@SQL = '')
				PRINT 'statement is empty';

			--PRINT N'Generated SQL: ' + @SQL;

            -- @SQLTopTable is often over 14,000 characters, but Print only allows 4000 of unicode.  Split it up to print.
            declare 
                @chunks      int 
               ,@loopy       int = 1
            ;
            set @chunks = ceiling(len(@SQLTopTable) / 3500.0);
			print '@SQLTopTable length is ' + cast(len(@SQLTopTable) as varchar(20))
			PRINT N'Generated SQLTopTable: ';
            while (@loopy <= @chunks)
            begin
                print 'CHUNK: ' + SUBSTRING (@SQLTopTable, (1 + (@loopy - 1) * 3500), 3500)
                set @loopy = @loopy + 1
            end

			PRINT 'BEGIN STEP 4: Exec generated SQL. ' + CONVERT(varchar(26), GETDATE(), 109);
			SET @step = 4;
		END

		--Return assess_id and XML as a string
		EXEC sp_executesql @SQLTopTable;

		IF (@debug = 'Y')
		BEGIN
			PRINT 'BEGIN STEP 5: Done .... ' + CONVERT(varchar(26), GETDATE(), 109);
			SET @step = 5;
		END

	END TRY

	-- Error trapping
	BEGIN CATCH
		SELECT
			@error_code		= @@error
			,@status_text	= ERROR_MESSAGE()
		;

		SET @status_code = 1;
		GOTO PgmAbend;
	END CATCH

	-- Program success return
PgmSuccess:
	IF (@debug = 'Y')
		PRINT 'Successful execution of stored procedure';
	-- Temp table clean up
	DROP TABLE #tempAssessIds;
	DROP TABLE #tempQuestionKeys;
	DROP TABLE #excludeQuestionKeys 

	RETURN @status_code;

	-- Program failure return
PgmAbend:
	IF (@debug = 'Y')
	BEGIN
		PRINT 'Stored procedure failure in step:' + CONVERT(varchar(3), @step) + ' ' + CONVERT(varchar(26), GETDATE());
		PRINT 'Error code: ' + CONVERT(varchar, @error_code) + '; Error description: ' + @status_text;
	END
	-- Temp table clean up
	DROP TABLE #tempAssessIds;
	DROP TABLE #tempQuestionKeys;
	DROP TABLE #excludeQuestionKeys 

	RETURN @status_code;
END
GO

GRANT EXECUTE ON sproc_mds_list_generateMDS3ExportXML TO PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_mds_list_generateMDS3ExportXML.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_mds_list_generateMDS3ExportXML.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_mnd_dml_mergeResidents.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================================
-- CORE-79701
--
-- Purpose: This procedure is used to merge client data from one client into another
--
-- Written By:          Mitch Bilensky
--
-- Target DB Type:      Client Database
-- Target ENVIRONMENT:  BOTH
-- Re-Runable:          YES
--
-- Params:
-- clientIdKept             - id of client to merge data into
-- clientIdDeleted          - id of client to merge data from
-- revisionBy               - pcc user calling the stored procedure
-- facId              - id of the facility containing the clients
-- status_code              - 0 for success.
-- status_text              - error text
--
-- Revision History:
-- 2020-11-25  Mitch Bilensky   - Initial creation
-- ================================================================================================
IF EXISTS (SELECT 1 FROM sysobjects WHERE id = object_id(N'sproc_mnd_dml_mergeResidents'))
  DROP PROCEDURE sproc_mnd_dml_mergeResidents
GO

SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE sproc_mnd_dml_mergeResidents
(
  @clientIdKept                 INT = NULL,
  @clientIdDeleted              INT = NULL,
  @revisionBy                   VARCHAR(60),
  @facId                        INT,
  @pnText                       VARCHAR(255),
  @debugMe                      CHAR(1) = 'N',
  @status_code                  INT = 0 OUT,
  @status_text                  VARCHAR(3000) OUT
)
AS

SET NOCOUNT ON
SET @status_code = 0
DECLARE @step INT
SET @step = 1

----Parameter Sniffing - use local variables WHEN they are used in a WHERE clause
DECLARE 
  @vClientIdKept     INT = NULL
, @vClientIdDeleted  INT = NULL
, @vRevisionBy       VARCHAR(60)
, @vFacId            INT
, @vPnText           VARCHAR(255)
, @vDebugMe          CHAR(1)
, @vgsStepStartTime  DATETIME
, @vgsStepEndTime    DATETIME
, @rowsUpdated       INT


create table #tablesToCheck (
 table_name NVARCHAR(MAX),
 column_name NVARCHAR(MAX),
 deleted_column BIT,
 facility_column BIT,
)

create table #sqlStatements (
 table_name NVARCHAR(MAX),
 sql_statement NVARCHAR(MAX),
 error_msg NVARCHAR(MAX)
)

BEGIN TRY

  SET @vClientIdKept = @clientIdKept;
  SET @vClientIdDeleted  = @clientIdDeleted;
  SET @vRevisionBy = @revisionBy;
  SET @vFacId = @facId;
  SET @vPnText = @pnText;
  SET @vDebugMe = @debugMe;
  SET @rowsUpdated = 0;

  DECLARE @vClientIdKeptMPI INT = (SELECT mpi_id FROM clients WHERE client_id = @vClientIdKept)
  DECLARE @vClientIdDeletedMPI INT = (SELECT mpi_id FROM clients WHERE client_id = @vClientIdDeleted)

  DECLARE @deletedClientPOCDocuments INT = (
    SELECT COUNT (intervention.text1) 
        FROM cp_schedule schedule 
        INNER JOIN cp_rev_intervention intervention ON intervention.gen_intervention_id = schedule.intervention_id 
        INNER JOIN view_cp_prn_documentation_responses_active details ON schedule.schedule_id = details.schedule_id 
        INNER JOIN cp_std_question stdQuestion ON stdQuestion.std_question_id = details.std_question_id 
        JOIN sec_user u ON u.long_username = details.created_by_longname 
        WHERE 
        schedule.fac_id = @vFacId
        AND details.fac_id = @vFacId 
        AND intervention.clientid = @vClientIdDeleted 
        AND intervention.fac_id = @vFacId 
        AND intervention.current_row = 'Y' 
        AND intervention.deleted = 'N' 
        AND details.entered_date IS NOT NULL 
        AND details.strikeout_flag = 'N'
  )

  DECLARE @deletedClientEMARDocuments INT = (
    SELECT COUNT (*) 
        FROM pho_phys_order a 
        JOIN clients cl ON cl.client_id = a.client_id 
        JOIN pho_schedule b ON a.phys_order_id = b.phys_order_id 
        JOIN pho_schedule_details c ON c.pho_schedule_id = b.schedule_id 
        WHERE c.deleted = 'N' 
        AND c.perform_by IS NOT NULL 
        AND c.perform_date IS NOT NULL 
        AND cl.client_id = @vClientIdDeleted 
        AND b.fac_id = @vFacId
  )

  SET @step = 2 -- Creating audit record
  INSERT INTO mnd_resident_merge_and_delete_audit 
    ([action], [deleted_client_id], [kept_client_id], [poc_document_count], [emar_document_count], [created_by], [created_date])
  VALUES
    ('MERGE', @vClientIdDeleted, @vClientIdKept, @deletedClientPOCDocuments, @deletedClientEMARDocuments, @vRevisionBy, GETDATE());
  DECLARE @mndAuditId INT = SCOPE_IDENTITY(); 

  SET @step = 3 -- Creating list of tables to check

  -- Create list of table to check
  INSERT INTO #tablesToCheck ( table_name, column_name, deleted_column, facility_column)
   SELECT * FROM (
    SELECT TABLE_NAME as table_name,COLUMN_NAME as column_name,0 AS deleted_column, 0 As fac_id   
    FROM INFORMATION_SCHEMA.COLUMNS  
    WHERE table_schema = 'dbo' 
      AND COLUMN_NAME IN ('client_id', 'clientid')   
      AND TABLE_NAME IN (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_SCHEMA = 'dbo') 
      AND TABLE_NAME NOT LIKE '[_]%' 
      AND TABLE_NAME NOT LIKE 'bak%'  
      AND TABLE_NAME NOT LIKE 'STAGING_%' 
      AND TABLE_NAME NOT like 'copy%'  
      AND TABLE_NAME NOT like 'tmp%'  
      AND TABLE_NAME NOT like 'if_%' 
      AND TABLE_NAME NOT like 'stage_%' 
      AND TABLE_NAME NOT like 'load_%'  
      AND TABLE_NAME NOT like 'case%' 
      AND TABLE_NAME NOT like 'merge%' 
      AND TABLE_NAME NOT like 'pcc_index%'  
      AND TABLE_NAME NOT IN (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME = 'deleted') 
      AND TABLE_NAME NOT IN (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME = 'fac_id') 
    UNION 
    SELECT TABLE_NAME as table_name,COLUMN_NAME  as column_name,1 AS deleted_column, 0 As fac_id   
    FROM INFORMATION_SCHEMA.COLUMNS  
    WHERE table_schema = 'dbo' 
      AND COLUMN_NAME IN ('client_id', 'clientid')    
      AND TABLE_NAME IN (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_SCHEMA = 'dbo') 
      AND TABLE_NAME NOT LIKE '[_]%' 
      AND TABLE_NAME NOT LIKE 'bak%'  
      AND TABLE_NAME NOT LIKE 'STAGING_%' 
      AND TABLE_NAME NOT like 'copy%'  
      AND TABLE_NAME NOT like 'tmp%'  
      AND TABLE_NAME NOT like 'if_%' 
      AND TABLE_NAME NOT like 'stage_%' 
      AND TABLE_NAME NOT like 'load_%'  
      AND TABLE_NAME NOT like 'case%' 
      AND TABLE_NAME NOT like 'merge%' 
      AND TABLE_NAME NOT like 'pcc_index%'  
      AND TABLE_NAME IN (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME = 'deleted') 
      AND TABLE_NAME NOT IN (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME = 'fac_id') 
    UNION
    SELECT TABLE_NAME as table_name,COLUMN_NAME  as column_name,0 AS deleted_column, 1 As fac_id   
    FROM INFORMATION_SCHEMA.COLUMNS  
    WHERE table_schema = 'dbo' 
      AND COLUMN_NAME IN ('client_id', 'clientid')    
      AND TABLE_NAME IN (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_SCHEMA = 'dbo') 
      AND TABLE_NAME NOT LIKE '[_]%' 
      AND TABLE_NAME NOT LIKE 'bak%'  
      AND TABLE_NAME NOT LIKE 'STAGING_%' 
      AND TABLE_NAME NOT like 'copy%'  
      AND TABLE_NAME NOT like 'tmp%'  
      AND TABLE_NAME NOT like 'if_%' 
      AND TABLE_NAME NOT like 'stage_%' 
      AND TABLE_NAME NOT like 'load_%'  
      AND TABLE_NAME NOT like 'case%' 
      AND TABLE_NAME NOT like 'merge%' 
      AND TABLE_NAME NOT like 'pcc_index%' 
      AND TABLE_NAME NOT IN (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME = 'deleted') 
      AND TABLE_NAME IN (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME = 'fac_id')
    UNION
    SELECT TABLE_NAME as table_name,COLUMN_NAME  as column_name,1 AS deleted_column, 1 As fac_id   
    FROM INFORMATION_SCHEMA.COLUMNS  
    WHERE table_schema = 'dbo' AND COLUMN_NAME IN ('client_id', 'clientid')    
    AND TABLE_NAME IN (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'AND TABLE_SCHEMA = 'dbo')  
    AND TABLE_NAME NOT LIKE '[_]%' 
    AND TABLE_NAME NOT LIKE 'bak%'  
    AND TABLE_NAME NOT LIKE 'STAGING_%' 
    AND TABLE_NAME NOT like 'copy%'  
    AND TABLE_NAME NOT like 'tmp%'  
    AND TABLE_NAME NOT like 'if_%' 
    AND TABLE_NAME NOT like 'stage_%' 
    AND TABLE_NAME NOT like 'load_%'  
    AND TABLE_NAME NOT like 'case%' 
    AND TABLE_NAME NOT like 'merge%' 
    AND TABLE_NAME NOT like 'pcc_index%'  
    AND TABLE_NAME IN (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME = 'deleted') 
    AND TABLE_NAME IN (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME = 'fac_id')
  ) A WHERE table_name not in ('auth_remote_resource_configuration')
  
  IF @vDebugMe = 'Y' SELECT * FROM #tablesToCheck

  ---- Setup cursor for checking tables
  DECLARE @table_name VARCHAR(MAX), @column_name VARCHAR(MAX), @deleted_column BIT, @facility_column BIT;
  DECLARE table_cursor CURSOR FOR SELECT * FROM #tablesToCheck
  
  OPEN table_cursor  
  FETCH NEXT FROM table_cursor   
  INTO @table_name, @column_name, @deleted_column, @facility_column

  SET @step = 4 -- Looping over tables to build queries
  WHILE @@FETCH_STATUS = 0  
  BEGIN  

    -- No touch tables
    IF @table_name <> 'ar_client_configuration' 
      AND @table_name <> 'client_ids' 
      AND @table_name <> 'clients_audit' 
      AND @table_name <> 'clients' 
      AND @table_name <> 'adt_client_loc'
      AND @table_name <> 'ar_transactions_deleted' 
      AND @table_name <> 'ta_client_configuration'
      AND @table_name <> 'pho_phys_order_esignature_client_snapshot'
    BEGIN
      -- Check if unique constrains prevent merging
      DECLARE @checkConflictSql NVARCHAR(max)
      DECLARE @columnname varchar(max)
      DECLARE @recordsInConflict INT = 0;

      IF(Object_ID('TempDB..#unique') IS NOT NULL) DROP TABLE #unique
      IF(Object_ID('TempDB..#temp') IS NOT NULL) DROP TABLE #temp
      IF(Object_ID('TempDB..#' + @table_name) IS NOT NULL) DECLARE @DynSql NVARCHAR(max) = 'DROP TABLE #' + @table_name; EXEC(@DynSql);

      SELECT d.name as Tablename, c.name as columnname  , a.index_id
       into #unique
      FROM sys.indexes a inner join sys.index_columns b
      on a.index_id = b.index_id
      AND a.object_id = b.object_id
      AND a.is_unique = 1
      inner join sys.columns c
      on b.column_id = c.column_id
      AND b.object_id = c.object_id
      inner join sys.objects d
      on a.object_id = d.object_id
      WHERE d.type= 'U' --AND a.index_id = 1
      AND d.name = @table_name
      order by 1

      SELECT * into #temp FROM #unique a 
      WHERE EXISTS (
        SELECT * FROM #unique b
        WHERE columnname in ('client_id','clientid')
          AND a.Tablename = b.Tablename
          AND a.index_id = b.index_id
      )
      AND tablename=@table_name
      order by 1

      SET @columnname=(SELECT 
        distinct STUFF((SELECT ', ' + columnname FROM #temp t2 WHERE t1.Tablename = t2.Tablename FOR XML PATH ('')), 1, 1, '')  columnname FROM #temp t1
      )

      SET @checkConflictSql=''
      SET @checkConflictSql='
      SELECT * into #' + @table_name + '
      FROM ' + @table_name + ' WHERE client_id in ( ' + CAST(@vClientIdKept as VARCHAR(10)) + ' , ' + CAST(@vClientIdDeleted as VARCHAR(10)) + ') 
      update #' + @table_name + '
      SET client_id = ' + CAST(@vClientIdKept as VARCHAR(10)) + '
      WHERE client_id = ' + CAST(@vClientIdDeleted as VARCHAR(10)) + '

      SELECT @recordsInConflict = count(1) FROM #' + @table_name + ' group by  '+@columnname+' having count(*)>1'

      if 'allergy'=@table_name
      BEGIN
        IF(Object_ID('TempDB..#inserted') IS NOT NULL)
          DROP TABLE #inserted

          SELECT * into #inserted FROM allergy WHERE client_id in (@vClientIdKept , @vClientIdDeleted)
          update #inserted
          SET client_id=@vClientIdKept
        IF EXISTS 
          (          
          SELECT 1 FROM 
          (SELECT T.client_id, T.allergy_category_id, T.lib_allergy_id
            FROM #inserted I 
            INNER JOIN dbo.allergy T 
            ON T.client_id = I.client_id 
            AND T.allergy_category_id = I.allergy_category_id
            AND T.lib_allergy_id = I.lib_allergy_id
            AND (T.mmdb_allergen_audit = I.mmdb_allergen_audit OR I.mmdb_allergen_audit is NULL)
            WHERE T.status_id = 1 AND  I.status_id = 1) tmp-- Only check for active status
          group by client_id, allergy_category_id, lib_allergy_id
          having count(*) > 1
          )
          BEGIN
          SET @recordsInConflict = (SELECT 1)
          END
      END
      ELSE
      BEGIN
        EXECUTE sp_executesql @checkConflictSql, N'@recordsInConflict int OUTPUT',@recordsInConflict=@recordsInConflict OUTPUT
      END  

      IF @recordsInConflict <> 0
      BEGIN
        IF @vDebugMe = 'Y' Print 'Merged Records would cause UNIQUE constraint error! Skipping table:' + @table_name
        INSERT INTO mnd_resident_merge_and_delete_table_audit ([audit_id], [table_name], [reason])
        VALUES (@mndAuditId, @table_name, 'Merged Records would cause UNIQUE constraint error');
      END
      ELSE IF @table_name = 'ar_census_notification' 
      BEGIN
        IF @vDebugMe = 'Y' Print 'ar_census_notification can only be merged manually'
        INSERT INTO mnd_resident_merge_and_delete_table_audit ([audit_id], [table_name], [reason])
        VALUES (@mndAuditId, @table_name, 'Ignored as this is only updated manually');
      END
      ELSE IF @table_name = 'ar_client_payer_info' 
      BEGIN
        -- Special handling for ar_client_payer_info
        SELECT a.client_payer_info_id INTO #ar_client_payer_info_temp FROM (
          SELECT * FROM ar_client_payer_info WHERE client_id = @vClientIdDeleted AND fac_id = @vFacId
        ) a 
        left join (
          SELECT * FROM ar_client_payer_info WHERE client_id = @vClientIdKept AND fac_id = @vFacId
        ) b 
        ON a.payer_id = b.payer_id 
          AND a.effective_date=b.effective_date  
          AND a.ineffective_date = b.ineffective_date 
        WHERE b.payer_id is NULL

        DECLARE @client_payer_info_id INT
        DECLARE ar_client_payer_info_cursor CURSOR FOR SELECT client_payer_info_id FROM #ar_client_payer_info_temp
        OPEN ar_client_payer_info_cursor  
        FETCH NEXT FROM ar_client_payer_info_cursor   
        INTO @client_payer_info_id

        WHILE @@FETCH_STATUS = 0  
        BEGIN  
          INSERT INTO #sqlStatements (table_name, sql_statement) VALUES (@table_name, 'UPDATE ar_client_payer_info SET client_id = @vClientIdKept, revision_by = @vRevisionBy, revision_date = GETDATE() WHERE client_payer_info_id = ' + CAST(@client_payer_info_id as VARCHAR(10)) + ' AND client_id = @vClientIdDeleted')

          FETCH NEXT FROM ar_client_payer_info_cursor   
          INTO @client_payer_info_id
        END
        CLOSE ar_client_payer_info_cursor;  
        DEALLOCATE ar_client_payer_info_cursor;
      END
      ELSE IF @table_name = 'ar_invoice_claim_setup' 
      BEGIN
        -- Special handling for ar_invoice_claim_setup
        SELECT a.claim_setup_id INTO #ar_invoice_claim_setup_temp FROM (
          SELECT * FROM ar_invoice_claim_setup WHERE client_id = @vClientIdDeleted AND fac_id = @vFacId
        ) a 
        left join (
          SELECT * FROM ar_invoice_claim_setup WHERE client_id = @vClientIdKept AND fac_id =@vFacId
        ) b 
        ON a.payer_id = b.payer_id 
          AND a.effective_date=b.effective_date  
          AND a.ineffective_date = b.ineffective_date 
        WHERE b.payer_id is NULL

        DECLARE @claim_setup_id INT
        DECLARE ar_invoice_claim_setup_cursor CURSOR FOR SELECT claim_setup_id FROM #ar_invoice_claim_setup_temp
        OPEN ar_invoice_claim_setup_cursor  
        FETCH NEXT FROM ar_invoice_claim_setup_cursor   
        INTO @claim_setup_id

        WHILE @@FETCH_STATUS = 0  
        BEGIN  
          INSERT INTO #sqlStatements (table_name, sql_statement) VALUES (@table_name, 'UPDATE ar_invoice_claim_setup SET client_id = @vClientIdKept, revision_by = @vRevisionBy, revision_date = getdate() WHERE claim_setup_id = ' + CAST(@claim_setup_id as VARCHAR(10)) + ' AND client_id = @vClientIdDeleted')
          
          FETCH NEXT FROM ar_invoice_claim_setup_cursor   
          INTO @claim_setup_id
        END
        CLOSE ar_invoice_claim_setup_cursor;
        DEALLOCATE ar_invoice_claim_setup_cursor;
      END
      ELSE IF @table_name = 'client_ext_facilities' 
      BEGIN
        SELECT a.ext_fac_id INTO #client_ext_facilities_temp FROM (
          SELECT * FROM client_ext_facilities WHERE client_id = @vClientIdDeleted AND fac_id = @vFacId
        ) a 
        left join (
          SELECT * FROM client_ext_facilities WHERE client_id = @vClientIdKept AND fac_id = @vFacId
        ) b ON a.ext_fac_id = b.ext_fac_id  
        WHERE b.ext_fac_id is NULL

        DECLARE @ext_fac_id INT
        DECLARE client_ext_facilities_cursor CURSOR FOR SELECT ext_fac_id FROM #client_ext_facilities_temp
        OPEN client_ext_facilities_cursor  
        FETCH NEXT FROM client_ext_facilities_cursor   
        INTO @ext_fac_id

        WHILE @@FETCH_STATUS = 0  
        BEGIN  
          INSERT INTO #sqlStatements (table_name, sql_statement) VALUES (@table_name, 'UPDATE client_ext_facilities SET client_id = @vClientIdKept, revision_by = @vRevisionBy, revision_date = getdate() WHERE ext_fac_id = ' + CAST(@ext_fac_id as VARCHAR(10)) + ' AND client_id = @vClientIdDeleted')

          FETCH NEXT FROM client_ext_facilities_cursor   
          INTO @claim_setup_id
        END
        CLOSE client_ext_facilities_cursor;
        DEALLOCATE client_ext_facilities_cursor;
      END
      ELSE IF @table_name = 'client_staff' 
      BEGIN
        SELECT a.staff_client_id INTO #client_staff_temp FROM (
          SELECT * FROM client_staff WHERE client_id = @vClientIdDeleted AND fac_id = @vFacId
        ) a left join (
          SELECT * FROM client_staff WHERE client_id = @vClientIdKept AND fac_id = @vFacId
        ) b ON a.staff_id = b.staff_id  WHERE b.staff_id is NULL

        DECLARE @staff_client_id INT
        DECLARE client_staff_cursor CURSOR FOR SELECT staff_client_id FROM #client_staff_temp
        OPEN client_staff_cursor  
        FETCH NEXT FROM client_staff_cursor   
        INTO @staff_client_id

        WHILE @@FETCH_STATUS = 0  
        BEGIN
          INSERT INTO #sqlStatements (table_name, sql_statement) VALUES (@table_name, 'UPDATE client_staff SET client_id = @vClientIdKept, revision_by = @vRevisionBy, revision_date = getdate() WHERE staff_client_id = ' + CAST(@staff_client_id as VARCHAR(10)) + ' AND client_id = @vClientIdDeleted')

          FETCH NEXT FROM client_staff_cursor   
          INTO @staff_client_id
        END
        CLOSE client_staff_cursor;
        DEALLOCATE client_staff_cursor; 
      END
      ELSE IF @table_name = 'ta_client_account' 
      BEGIN
        SELECT a.std_account_id INTO #ta_client_account_temp FROM (
          SELECT * FROM ta_client_account WHERE client_id = @vClientIdDeleted AND fac_id = @vFacId
        ) a left join (
          SELECT * FROM ta_client_account WHERE client_id = @vClientIdKept AND fac_id = @vFacId
        ) b ON a.std_account_id = b.std_account_id  WHERE b.std_account_id is NULL

        DECLARE @std_account_id INT
        DECLARE ta_client_account_cursor CURSOR FOR SELECT std_account_id FROM #ta_client_account_temp
        OPEN ta_client_account_cursor  
        FETCH NEXT FROM ta_client_account_cursor   
        INTO @std_account_id

        WHILE @@FETCH_STATUS = 0  
        BEGIN
          INSERT INTO #sqlStatements (table_name, sql_statement) VALUES (@table_name, 'UPDATE ta_client_account SET client_id = @vClientIdKept, revision_by = @vRevisionBy, revision_date = getdate() WHERE std_account_id = ' + CAST(@std_account_id as VARCHAR(10)) + ' AND client_id = @vClientIdDeleted')

          FETCH NEXT FROM ta_client_account_cursor   
          INTO @std_account_id
        END
        CLOSE ta_client_account_cursor;
        DEALLOCATE ta_client_account_cursor; 
      END
      ELSE IF @table_name = 'ta_client_income_source' 
      BEGIN
        SELECT a.client_income_source_id INTO #ta_client_income_source_temp FROM (
          SELECT * FROM ta_client_income_source WHERE client_id = @vClientIdDeleted AND fac_id = @vFacId
        ) a left join (
          SELECT * FROM ta_client_income_source WHERE client_id = @vClientIdKept AND fac_id = @vFacId
        ) b ON a.client_income_source_id = b.client_income_source_id  WHERE b.client_income_source_id is NULL

        DECLARE @client_income_source_id INT
        DECLARE ta_client_income_source_cursor CURSOR FOR SELECT client_income_source_id FROM #ta_client_income_source_temp
        OPEN ta_client_income_source_cursor  
        FETCH NEXT FROM ta_client_income_source_cursor   
        INTO @client_income_source_id

        WHILE @@FETCH_STATUS = 0  
        BEGIN
          INSERT INTO #sqlStatements (table_name, sql_statement) VALUES (@table_name, 'UPDATE ta_client_income_source SET client_id = @vClientIdKept, revision_by = @vRevisionBy, revision_date = getdate() WHERE client_income_source_id = ' + CAST(@client_income_source_id as VARCHAR(10)) + ' AND client_id = @vClientIdDeleted')

          FETCH NEXT FROM ta_client_income_source_cursor   
          INTO @client_income_source_id
        END
        CLOSE ta_client_income_source_cursor;
        DEALLOCATE ta_client_income_source_cursor; 
      END
      ELSE IF @table_name = 'wv_vitals' 
      BEGIN
        SELECT t.vitals_id INTO #wv_vitals_temp FROM (SELECT * FROM wv_vitals WHERE client_id = @vClientIdDeleted) t
        WHERE NOT EXISTS (
          SELECT 1 FROM wv_vitals a WITH (NOLOCK) 
          WHERE a.client_id = @vClientIdKept
            AND t.std_vitals_id = a.std_vitals_id 
            AND t.date = a.date 
            AND ((t.baseline = a.baseline) OR (a.baseline IS NULL AND t.baseline IS NULL)) 
            AND ((t.strikeout_date = a.strikeout_date) OR (a.strikeout_date IS NULL AND t.strikeout_date IS NULL))
          ) 
          AND NOT EXISTS (
          SELECT 1 FROM wv_vitals a WITH (NOLOCK) 
          WHERE  a.client_id = @vClientIdKept
          AND t.fac_id = a.fac_id 
          AND t.std_vitals_id = a.std_vitals_id 
          AND (t.[baseline]='Y') 
          AND (a.[baseline]='Y')
        )

        DECLARE @vitals_id INT
        DECLARE wv_vitals_cursor CURSOR FOR SELECT vitals_id FROM #wv_vitals_temp
        OPEN wv_vitals_cursor  
        FETCH NEXT FROM wv_vitals_cursor   
        INTO @vitals_id

        WHILE @@FETCH_STATUS = 0  
        BEGIN
          INSERT INTO #sqlStatements (table_name, sql_statement) VALUES (@table_name, 'update wv_vitals SET client_id = @vClientIdKept, revision_by = @vRevisionBy, revision_date = getdate() WHERE vitals_id = ' + CAST(@vitals_id as VARCHAR(10)) + ' AND client_id = @vClientIdDeleted')

          FETCH NEXT FROM wv_vitals_cursor   
          INTO @vitals_id
        END
        CLOSE wv_vitals_cursor;
        DEALLOCATE wv_vitals_cursor;
      END
      ELSE IF @table_name = 'scrm_lead'
      BEGIN
        INSERT INTO #sqlStatements (table_name, sql_statement) VALUES (@table_name, 'UPDATE scrm_lead SET mpi_id = ' + CAST(@vClientIdKeptMPI as VARCHAR(10)) + ', revision_by = @vRevisionBy, revision_date = GETDATE() WHERE mpi_id = ' + CAST(@vClientIdDeletedMPI as VARCHAR(10)))
      END
      ELSE
      BEGIN

        -- Create UPDATE Statement
        DECLARE @sql NVARCHAR(MAX)
        DECLARE @updateSql NVARCHAR(MAX) = N'UPDATE ' + @table_name + ' SET ' + @column_name + ' = @vClientIdKept';
        DECLARE @whereSql NVARCHAR(MAX) = N' WHERE ' + @column_name + ' = @vClientIdDeleted';

        -- Check if table has revision columns
        DECLARE @has_revision_by BIT = 0, @has_revision_date BIT = 0;
        SELECT @has_revision_by = (SELECT count(0) FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME in ('revision_by') AND TABLE_NAME = @table_name)
        SELECT @has_revision_date = (SELECT count(0) FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME in ('revision_date') AND TABLE_NAME = @table_name)

        --IF @vDebugMe = 'Y' SELECT @table_name as TableName, @column_name as ColumnName, @has_revision_by as HasRevisionBy, @has_revision_date as HasRevisionDate

        -- Update UPDATE statement for revision history (if present)
        IF @has_revision_by <> 0 SET @updateSql += ', revision_by = @vRevisionBy';
        IF @has_revision_date <> 0 SET @updateSql += ', revision_date = GETDATE()';

        -- Update WHERE conditions for deleted & fac_id (if present)
        IF @facility_column <> 0 SET @whereSql += ' AND fac_id = @vFacId';

        SET @sql = @updateSql + @whereSql;
        INSERT INTO #sqlStatements (table_name, sql_statement) VALUES (@table_name, @sql)
      END;
    END;

    FETCH NEXT FROM table_cursor   
    INTO @table_name, @column_name, @deleted_column, @facility_column
  END;  
  CLOSE table_cursor;  
  DEALLOCATE table_cursor;

  SET @step = 5 -- Adding query for map_identifiers    

  DECLARE @vendorCode VARCHAR(30) = NULL;

  SET @vendorCode = (
     SELECT TOP(1) a.vendor_code 
       FROM (SELECT internal_id,vendor_code FROM map_identifier WHERE internal_id = @clientIdKept AND map_type_id = 2) a
              INNER JOIN (SELECT internal_id, vendor_code FROM map_identifier WHERE internal_id = @clientIdDeleted AND map_type_id = 2) b ON a.vendor_code = b.vendor_code
      WHERE a.vendor_code = b.vendor_code
      GROUP BY a.internal_id, b.internal_id, a.vendor_code
  )

  --IF we have a vendor code here it means that we found a map identifier for the kept and deleted clients
    IF (@vendorCode IS NOT NULL)
    BEGIN
      INSERT INTO #sqlStatements (table_name, sql_statement) VALUES ('map_identifier', 'DELETE map_identifier 
        WHERE internal_id IN (@vClientIdKept, @vClientIdDeleted) AND map_type_id = 2 AND vendor_code = @vVendorCode');
      

      INSERT INTO #sqlStatements (table_name, sql_statement) VALUES ('msg_unmatched_client_data', 'UPDATE msg_unmatched_client_data 
         SET DELETED = ''Y'',
             DELETED_BY = @vRevisionBy,
             DELETED_DATE = GETDATE()
       WHERE matching_pcc_client_id IN (@vClientIdKept, @vClientIdDeleted)
         AND vendor_code = @vVendorCode');
    END
  ELSE
    BEGIN  
      INSERT INTO #sqlStatements (table_name, sql_statement) VALUES ('map_identifier', 'UPDATE a SET internal_id = @vClientIdKept,
                   revision_by = @vRevisionBy,
                   revision_date = GETDATE()
              FROM map_identifier a 
             WHERE a.fac_id = @vFacId 
               AND a.map_type_id = 2 
               AND a.internal_id = @vClientIdDeleted 
               AND NOT EXISTS (SELECT 1 FROM map_identifier WITH (NOLOCK) 
                                WHERE fac_id = @vFacId AND map_type_id = 2 
                                  AND internal_id = @vClientIdKept
                                  AND vendor_code = a.vendor_code
                              );')
      END

  IF @vDebugMe = 'Y' SELECT * FROM #sqlStatements

  SET @step = 6 -- Looping through tables and executing UPDATEs
  DECLARE @updateSQLStatement NVARCHAR(MAX);
  DECLARE update_sql_cursor CURSOR FOR SELECT table_name, sql_statement FROM #sqlStatements;
  DECLARE @t1 DATETIME;
  DECLARE @dateDiff BIGINT;
  DECLARE @statementRowCount INT;
  
  OPEN update_sql_cursor  
  FETCH NEXT FROM update_sql_cursor   
  INTO @table_name, @updateSQLStatement

  WHILE @@FETCH_STATUS = 0  
  BEGIN  
    IF @vDebugMe = 'Y' Print ' Updating table: ' + @table_name;
    IF @vDebugMe = 'Y' SET @t1 = GETDATE();
    
    BEGIN TRY        
      EXECUTE sp_executesql @updateSQLStatement,
        N'@vClientIdKept INT, @vClientIdDeleted INT, @vRevisionBy VARCHAR(MAX), @vFacId INT, @vVendorCode VARCHAR(30)',
        @vClientIdKept = @vClientIdKept,
        @vClientIdDeleted = @vClientIdDeleted,
        @vRevisionBy = @vRevisionBy,
        @vFacId = @vFacId,
        @vVendorCode = @vendorCode

      SET @statementRowCount = @@ROWCOUNT;
      IF @vDebugMe = 'Y' SET @dateDiff = (SELECT DATEDIFF(millisecond, @t1, GETDATE()));
      
      SET @rowsUpdated += @statementRowCount;      
      IF @vDebugMe = 'Y' AND @dateDiff > 0 PRINT 'Updated ' + CAST(@statementRowCount as VARCHAR(10)) + ' rows in ' + CAST(@dateDiff as VARCHAR(20)) + ' milliseconds'; 

    END TRY
    BEGIN CATCH
      DECLARE @tableUpdateError VARCHAR(3000) = ERROR_MESSAGE()
      IF @DebugMe='Y' Print 'Table Name: '+ @table_name + '; Error description:  ' + @tableUpdateError

      -- Update #sqlStatements with error message to mark for second pass
      UPDATE #sqlStatements SET error_msg = @tableUpdateError WHERE table_name = @table_name;
    END CATCH

    FETCH NEXT FROM update_sql_cursor   
    INTO @table_name, @updateSQLStatement
  END;  
  CLOSE update_sql_cursor;  
  DEALLOCATE update_sql_cursor;

  SET @step = 7 -- Looping through tables that failed first pass and executing UPDATEs again
  IF @vDebugMe = 'Y' SELECT * FROM #sqlStatements WHERE error_msg IS NOT NULL;

  DECLARE update_sql_second_attempt_cursor CURSOR FOR SELECT table_name, sql_statement FROM #sqlStatements WHERE error_msg IS NOT NULL;
  OPEN update_sql_second_attempt_cursor  
  FETCH NEXT FROM update_sql_second_attempt_cursor   
  INTO @table_name, @updateSQLStatement

  WHILE @@FETCH_STATUS = 0  
  BEGIN  
    IF @vDebugMe = 'Y' Print ' Updating table: ' + @table_name;
    IF @vDebugMe = 'Y' SET @t1 = GETDATE();
    
    BEGIN TRY        
      EXECUTE sp_executesql @updateSQLStatement,
        N'@vClientIdKept INT, @vClientIdDeleted INT, @vRevisionBy VARCHAR(MAX), @vFacId INT, @vVendorCode VARCHAR(30)',
        @vClientIdKept = @vClientIdKept,
        @vClientIdDeleted = @vClientIdDeleted,
        @vRevisionBy = @vRevisionBy,
        @vFacId = @vFacId,
        @vVendorCode = @vendorCode

      SET @statementRowCount = @@ROWCOUNT;
      IF @vDebugMe = 'Y' SET @dateDiff = (SELECT DATEDIFF(millisecond, @t1, GETDATE()));
      
      SET @rowsUpdated += @statementRowCount;      
      IF @vDebugMe = 'Y' AND @dateDiff > 0 PRINT 'Updated ' + CAST(@statementRowCount as VARCHAR(10)) + ' rows in ' + CAST(@dateDiff as VARCHAR(20)) + ' milliseconds'; 

      -- Second Pass UPDATE success, clear out error message
      UPDATE #sqlStatements SET error_msg = NULL WHERE table_name = @table_name;
    END TRY
    BEGIN CATCH
      DECLARE @secondPassUpdateError VARCHAR(3000) = ERROR_MESSAGE()
      IF @DebugMe='Y' Print 'Table Name: '+ @table_name + '; Error description:  ' + @secondPassUpdateError

      -- Insert record into audit table after second failure
      INSERT INTO mnd_resident_merge_and_delete_table_audit ([audit_id], [table_name], [reason])
        VALUES (@mndAuditId, @table_name, @secondPassUpdateError);
    END CATCH

    FETCH NEXT FROM update_sql_second_attempt_cursor   
    INTO @table_name, @updateSQLStatement
  END;  
  CLOSE update_sql_second_attempt_cursor;  
  DEALLOCATE update_sql_second_attempt_cursor;

  SET @step = 8 --All went well, add a progress note for the kept resident

  DECLARE @new_pn_id BIGINT;
  DECLARE @pn_type_id INT = (SELECT pn_type_id FROM pn_type WHERE description = 'System Note' AND system = 'Y');
  DECLARE @section_id INT;
  DECLARE @template_id INT;
  
  SELECT @section_id = section_id, @template_id = pt.template_id 
  FROM pn_template_section pts 
    INNER JOIN pn_template pt ON pts.template_id = pt.template_id
  WHERE pt.description = 'Narrative' AND system='Y' AND retired='N' AND type='N';

  EXEC get_next_primary_key 'pn_progress_note', 'pn_id', @new_pn_id output, 1

  INSERT INTO pn_progress_note(pn_id, fac_id, created_by, created_date, revision_by, revision_date, client_id, pn_type_id, effective_date,created_by_fullname, show_on_shift, show_on_24hr, template_id, completed )
    VALUES (@new_pn_id, @facId, @vRevisionBy, GETDATE(), @vRevisionBy, GETDATE(), @vClientIdKept, @pn_type_id, GETDATE(), 'System', 'Y', 'Y',  @template_id, 'Y');

  INSERT INTO PN_TEXT(pn_id, ordr, fac_id, deleted, created_by, created_date, revision_by, revision_date, text1, section_id)
    VALUES (@new_pn_id, 0, @facId, 'N', @vRevisionBy, GETDATE(), @vRevisionBy, GETDATE(), @vPnText, @section_id);

  SET @step = 9 --Soft Delete the leftover client and mpi
  
  UPDATE clients 
     SET deleted = 'Y', 
         revision_by = @vRevisionBy,
         revision_date = GETDATE()
   WHERE client_id = @vClientIdDeleted;

  IF ((SELECT COUNT(1) FROM clients WHERE mpi_id = @vClientIdDeletedMPI AND deleted = 'N') = 0) 
  BEGIN
    UPDATE mpi
       SET deleted = 'Y',
           deleted_by = @vRevisionBy,
           deleted_date = GETDATE()
     WHERE mpi_id = @vClientIdDeletedMPI;
  END  

  SET @step = 10 -- Update total rows updated from merge process
  
  IF @rowsUpdated <> 0
  BEGIN
    UPDATE mnd_resident_merge_and_delete_audit SET total_rows_updated = @rowsUpdated WHERE audit_id = @mndAuditId
  END

  SET @step = 11 -- Check if any errors persisted and raise error if so
  IF ((SELECT COUNT(1) FROM #sqlStatements WHERE error_msg IS NOT NULL) > 0)
  BEGIN
    IF @vDebugMe = 'Y' SELECT * FROM #sqlStatements WHERE error_msg IS NOT NULL;
    DECLARE @concatErrors NVARCHAR(MAX)
    SELECT @concatErrors = COALESCE(@concatErrors + ', ', '') + table_name + ': ' + error_msg
    FROM (SELECT table_name, error_msg FROM #sqlStatements WHERE error_msg IS NOT NULL) a

    IF @DebugMe='Y' Print 'Concatinated Errors: '+ @concatErrors
    RAISERROR(@concatErrors, 16, 1);
  END

END TRY
BEGIN CATCH
  SELECT @status_text = ERROR_MESSAGE()
  SET @status_code = 1

  IF @DebugMe='Y' Print 'Rollback execution of stored procedure'

  GOTO PgmAbend
END CATCH

--program success return
IF @status_code = 0
BEGIN
  IF @DebugMe='Y' Print 'Successful execution of stored procedure'
  RETURN
END

--program failure return
PgmAbend:
  IF @DebugMe='Y' Print 'Stored procedure failure in step:'+ CONVERT(VARCHAR(3),@step) + '  ' + CONVERT(VARCHAR(26),GETDATE())
  IF @DebugMe='Y' Print 'Error code: '+CONVERT(VARCHAR(3),@step) + '; Error description:  ' +@status_text
  RETURN @status_code
GO

GRANT EXECUTE ON dbo.sproc_mnd_dml_mergeResidents TO PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_mnd_dml_mergeResidents.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_mnd_dml_mergeResidents.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_getPhysicianOrders.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*****************************************************************************************************
** ---------------
**  Deprecated
** ---------------
**  Created By: Mustafa Behrainwala
**  Created Date: 11/21/2017
**
**  Purpose: Returns the phys order along with its supplies and the med info. This only gets physician orders.
**
**  Params:
**          @facId           - facility id (Required)
**          @clientId        - the client for which the orders are to be loaded (Required)
**          @physOrderIdsCsv - csv list of phys order ids which we may want to load. If this is null, all physician orders are loaded
**			@orderStatusCSV  - csv of the order statuses you require. If this is null, then all orders are loaded.
**          @orderClassId    - Order class id 1 for institutional, 2 for Discharge. If null or less than 1 then it considers all the classes.
**								defaulted to null so that it does not impacts the existing functionality.
**          @debug           - Debug param, 'Y' or 'N'
**          @status_code     - SP execution flag, 0 for success.
**          @status_text     - SP error text if error occurs.
**  
** Revision History:
**  2021-11-18 		  CORE-97119  Sree Naghasundharam  This Stored Procedure 'sproc_pho_getPhysicianOrders' is herebry deprecated(CORE-97119).
**														New stored procedure 'sproc_pho_getPhysicianOrders_v2' created to remove 'mmdb' references.
**														Any further changes to 'sproc_pho_getPhysicianOrders' should also be made in the new stored procedure.
*****************************************************************************************************/

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'[dbo].[sproc_pho_getPhysicianOrders]') AND OBJECTPROPERTY(id, N'IsProcedure') = 1) 
	DROP PROCEDURE [dbo].[sproc_pho_getPhysicianOrders]
    
GO

CREATE PROCEDURE [dbo].[sproc_pho_getPhysicianOrders]  
	@facId				INT, --required
    @clientId			INT, --required
    @physOrderIdsCsv	varchar(max), --if null will pick up all physician orders, if not null, will pick up only passed in physician orders.
    @orderStatusCSV     varchar(max), --if @physOrderIdsCsv is not null, then it will use this to get orders by status, otherwise it can be null
    @orderClassId		tinyint = 0,
    @debug              char(1)  = 'N',
	@status_code        int  = 0 out,
    @status_text        varchar(3000) out
    	
AS
BEGIN TRY

	DECLARE @step                       int,
    		@error_code                 int
    		
	SET @step = 0
	SET @error_code = 0

	DECLARE @physOrderIds table 
	( 
	  phys_order_id int 
	)
	
	DECLARE @orderStatus TABLE
    (
        stat int  not null
    )

	DECLARE @result TABLE
    (
        phys_order_id int
        ,status int
        ,status_reason int
        ,fac_id int NOT NULL
        ,client_id int NOT NULL
        ,description varchar(500)
        ,related_generic varchar(250)
        ,dispense_as_written varchar(1)
        ,directions varchar(1000)
        ,drug_strength varchar(100)
        ,drug_strength_uom varchar(10)
        ,discontinued_date datetime
        ,end_date datetime
        ,hold_date datetime
        ,hold_date_end datetime
        ,last_reorder_date datetime
        ,order_type_id int
        ,order_category_id int
        ,order_date datetime
        ,order_status int
		,physician_id int
        ,reorder varchar(1)
        ,revision_by varchar(60)
        ,revision_date datetime
        ,route_of_admin int
        ,start_date datetime
        ,order_verified varchar(1)
        ,communication_method int
        ,pho_ext_lib_id int
        ,pho_ext_lib_med_id int
        ,pho_ext_lib_med_ddid int
		,ext_lib_rxnorm_id varchar(10)
		,order_class_id tinyint
    )

	declare @vpos table (
		phys_order_id int NOT NULL,
		fac_id int NOT NULL,
		order_status int NOT NULL,
		order_relationship int NULL,
		status_reason int NULL
	)
	
	if @physOrderIdsCsv is not null
	begin
		SET @step = 1
		INSERT INTO @physOrderIds
		SELECT value FROM pcc__csvToTableOfInt(@physOrderIdsCsv)
	end
	
	if @orderStatusCSV is not null
	begin
		SET @step = 2
		INSERT INTO @orderStatus (stat)
		select * from dbo.Split(@orderStatusCSV, ',')
	end

	DECLARE @now datetime = dbo.fn_facility_getCurrentTime(@facId)

	SET @step = 3
	insert into @vpos
	exec sproc_pho_getOrderStatus  @facId,@clientId,null,@now,'N',@debug,@status_code out,@status_text out

	SET @step = 4
	insert into @result (phys_order_id, status
        ,status_reason
		,fac_id
		,client_id
		,description
		,dispense_as_written
		,related_generic
		,directions
		,drug_strength
		,drug_strength_uom
		,order_date
		,order_status
		,physician_id
		,reorder
		,revision_by
		,revision_date
		,route_of_admin
		,start_date
		,last_reorder_date
		,discontinued_date
		,end_date
		,hold_date
		,hold_date_end
		,order_class_id
		,order_category_id
		,order_type_id
		,order_verified
		,communication_method
		,pho_ext_lib_id
		,pho_ext_lib_med_id
		,pho_ext_lib_med_ddid
		,ext_lib_rxnorm_id)
		select ppo.phys_order_id
			,vpos.order_status
			,vpos.status_reason
			,ppo.fac_id
			,ppo.client_id
			,ppo.description
			,ppo.dispense_as_written
			,ppo.related_generic
			,ppo.directions
			,ppo.drug_strength
			,ppo.drug_strength_uom
			,ppo.order_date
			,ppo.order_status
			,ppo.physician_id
			,ppo.reorder
			,ppo.revision_by
			,ppo.revision_date
			,ppo.route_of_admin
			,ppo.start_date
			,ppo.last_reorder_date
			,ppo.discontinued_date
			,ppo.end_date
			,ppo.hold_date
			,ppo.hold_date_end
			,order_class_id
			,order_category_id
			,order_type_id
			,order_verified
			,communication_method
			, lib.pho_ext_lib_id
			, lib.pho_ext_lib_med_id
			, lib.pho_ext_lib_med_ddid
			, lib.ext_lib_rxnorm_id
		 from pho_phys_order ppo
		JOIN @vpos vpos on vpos.phys_order_id=ppo.phys_order_id
		LEFT JOIN @orderStatus stIds on stIds.stat = vpos.order_status
		LEFT JOIN pho_order_ext_lib_med_ref lib WITH (NOLOCK) ON lib.phys_order_id = ppo.phys_order_id AND lib.deleted='N'
		where ppo.client_id=@clientId and ppo.fac_id=@facId and order_category_id=3022 --only physician orders
			and  ppo.order_verified = 'Y' and (isNULL(ppo.active_flag, 'Y') = 'Y')
			and (stIds.stat is not null or @orderStatusCSV is null)
			and (@orderClassId = 0 or @orderClassId=ppo.order_class_id)
		union all--get the orders passed in using the CSV regardless of their status.
			select ppo.phys_order_id
			,vpos.order_status
			,vpos.status_reason
			,ppo.fac_id
			,ppo.client_id
			,ppo.description
			,ppo.dispense_as_written
			,ppo.related_generic
			,ppo.directions
			,ppo.drug_strength
			,ppo.drug_strength_uom
			,ppo.order_date
			,ppo.order_status
			,ppo.physician_id
			,ppo.reorder
			,ppo.revision_by
			,ppo.revision_date
			,ppo.route_of_admin
			,ppo.start_date
			,ppo.last_reorder_date
			,ppo.discontinued_date
			,ppo.end_date
			,ppo.hold_date
			,ppo.hold_date_end
			,order_class_id
			,order_category_id
			,order_type_id
			,order_verified
			,communication_method
			, lib.pho_ext_lib_id
			, lib.pho_ext_lib_med_id
			, lib.pho_ext_lib_med_ddid
			, lib.ext_lib_rxnorm_id
		 from pho_phys_order ppo
			JOIN @physOrderIds ids on ppo.phys_order_id=ids.phys_order_id
			LEFT JOIN @vpos vpos on vpos.phys_order_id=ppo.phys_order_id
			LEFT JOIN pho_order_ext_lib_med_ref lib WITH (NOLOCK) ON lib.phys_order_id = ppo.phys_order_id AND lib.deleted='N'

	--get the order information
	SET @step = 5
	select * from @result

	--get the supply information
	SET @step = 6
	select pos.phys_order_id,
        pos.order_supply_id,
        pos.description as supply_description,
        pos.directions as supply_directions,
        pos.date_dispensed as date_dispensed,
        pos.last_received_date as supply_received_date,
        pos.med_src_type_id as supply_med_src_type_id,
        pos.pharmacy_id as supply_pharmacy_id,
        eef.name as supply_pharmacy_name,
        pos.reordering as supply_reordering,
        pos.status AS supply_status,
        pos.new_supply_flag as supply_new_supply_flag,
        pos.last_reorder_date as supply_last_reorder_date,
        pos.disp_code as supply_disp_code,
        pos.pharm_nurse_notes as pharm_nurse_notes,
        pos.nurse_pharm_notes as nurse_pharm_notes,
        pos.disp_package_identifier as supply_disp_package_identifier,
        pos.controlled_substance_code as supply_controlled_substance_code,
        pos.prescription as supply_prescription,
        pos.do_not_fill as supply_do_not_fill,
        pos.inventory_on_hand as inventory_on_hand,
        pos.next_refill_date as next_refill_date,
        psd.pharmacy_order_id as pharmacy_order_id,
        pos.active as supply_active,
        mmdb.dbo.fn_pho_getImageFilenameByNDC(pos.drug_code) as imageFileName, -- PCC-33017
        pos.drug_code as drug_code
    FROM pho_order_supply pos
        INNER JOIN  @result result ON [result].phys_order_id = pos.phys_order_id
        LEFT JOIN emc_ext_facilities eef ON eef.ext_fac_id = pos.pharmacy_id
        left join pho_supply_dispense psd on psd.order_supply_id = pos.order_supply_id and psd.deleted='N'
    WHERE (pos.active = 'Y' or pos.active = 'N') AND pos.deleted = 'N'
    ORDER BY pos.created_date DESC

END TRY
BEGIN CATCH
    SELECT @error_code = @@error, @status_text = 'Error at step:'+convert(varchar(3),@step)+', '+ERROR_MESSAGE()

    SET @status_code = 1

    GOTO PgmAbend

END CATCH

PgmSuccess:
if @status_code = 0
begin
    if @debug='Y' Print 'Successfull execution of stored procedure'
    return
end
--program failure return
PgmAbend:

if @debug='Y' Print 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '    ' + convert(varchar(26),getdate(),109)
if @debug='Y' Print 'Error code: '+convert(varchar(10),@error_code) + '; Error description:   ' +@status_text
    
GO
GRANT EXECUTE ON [sproc_pho_getPhysicianOrders] TO public
GO

GO

print 'C_Branch/04_StoredProcedures/sproc_pho_getPhysicianOrders.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_getPhysicianOrders.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_getPhysicianOrders_v2.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*****************************************************************************************************
**  Created By: Mustafa Behrainwala
**  Created Date: 11/21/2017
**
**  Purpose: Returns the phys order along with its supplies and the med info. This only gets physician orders.
**			 Please note that this stored procedure is a copy of 'sproc_pho_getPhysicianOrders' but has all MMDB references removed.
**
**  Params:
**          @facId           - facility id (Required)
**          @clientId        - the client for which the orders are to be loaded (Required)
**          @physOrderIdsCsv - csv list of phys order ids which we may want to load. If this is null, all physician orders are loaded
**			@orderStatusCSV  - csv of the order statuses you require. If this is null, then all orders are loaded.
**          @orderClassId    - Order class id 1 for institutional, 2 for Discharge. If null or less than 1 then it considers all the classes.
**								defaulted to null so that it does not impacts the existing functionality.
**          @debug           - Debug param, 'Y' or 'N'
**          @status_code     - SP execution flag, 0 for success.
**          @status_text     - SP error text if error occurs.
**  
**
** Revision History:
**  2021-11-18 		  CORE-97119  Created this new stored procedure 'sproc_pho_getPhysicianOrders_v2' and Sree Naghasundharam  Removed MMDB references
*****************************************************************************************************/

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'[dbo].[sproc_pho_getPhysicianOrders_v2]') AND OBJECTPROPERTY(id, N'IsProcedure') = 1) 
	DROP PROCEDURE [dbo].[sproc_pho_getPhysicianOrders_v2]
    
GO

CREATE PROCEDURE [dbo].[sproc_pho_getPhysicianOrders_v2]  
	@facId				INT, --required
    @clientId			INT, --required
    @physOrderIdsCsv	varchar(max), --if null will pick up all physician orders, if not null, will pick up only passed in physician orders.
    @orderStatusCSV     varchar(max), --if @physOrderIdsCsv is not null, then it will use this to get orders by status, otherwise it can be null
    @orderClassId		tinyint = 0,
    @debug              char(1)  = 'N',
	@status_code        int  = 0 out,
    @status_text        varchar(3000) out
    	
AS
BEGIN TRY

	DECLARE @step                       int,
    		@error_code                 int
    		
	SET @step = 0
	SET @error_code = 0

	DECLARE @physOrderIds table 
	( 
	  phys_order_id int 
	)
	
	DECLARE @orderStatus TABLE
    (
        stat int  not null
    )

	DECLARE @result TABLE
    (
        phys_order_id int
        ,status int
        ,status_reason int
        ,fac_id int NOT NULL
        ,client_id int NOT NULL
        ,description varchar(500)
        ,related_generic varchar(250)
        ,dispense_as_written varchar(1)
        ,directions varchar(1000)
        ,drug_strength varchar(100)
        ,drug_strength_uom varchar(10)
        ,discontinued_date datetime
        ,end_date datetime
        ,hold_date datetime
        ,hold_date_end datetime
        ,last_reorder_date datetime
        ,order_type_id int
        ,order_category_id int
        ,order_date datetime
        ,order_status int
		,physician_id int
        ,reorder varchar(1)
        ,revision_by varchar(60)
        ,revision_date datetime
        ,route_of_admin int
        ,start_date datetime
        ,order_verified varchar(1)
        ,communication_method int
        ,pho_ext_lib_id int
        ,pho_ext_lib_med_id int
        ,pho_ext_lib_med_ddid int
		,ext_lib_rxnorm_id varchar(10)
		,order_class_id tinyint
    )

	declare @vpos table (
		phys_order_id int NOT NULL,
		fac_id int NOT NULL,
		order_status int NOT NULL,
		order_relationship int NULL,
		status_reason int NULL
	)
	
	if @physOrderIdsCsv is not null
	begin
		SET @step = 1
		INSERT INTO @physOrderIds
		SELECT value FROM pcc__csvToTableOfInt(@physOrderIdsCsv)
	end
	
	if @orderStatusCSV is not null
	begin
		SET @step = 2
		INSERT INTO @orderStatus (stat)
		select * from dbo.Split(@orderStatusCSV, ',')
	end

	DECLARE @now datetime = dbo.fn_facility_getCurrentTime(@facId)

	SET @step = 3
	insert into @vpos
	exec sproc_pho_getOrderStatus  @facId,@clientId,null,@now,'N',@debug,@status_code out,@status_text out

	SET @step = 4
	insert into @result (phys_order_id, status
        ,status_reason
		,fac_id
		,client_id
		,description
		,dispense_as_written
		,related_generic
		,directions
		,drug_strength
		,drug_strength_uom
		,order_date
		,order_status
		,physician_id
		,reorder
		,revision_by
		,revision_date
		,route_of_admin
		,start_date
		,last_reorder_date
		,discontinued_date
		,end_date
		,hold_date
		,hold_date_end
		,order_class_id
		,order_category_id
		,order_type_id
		,order_verified
		,communication_method
		,pho_ext_lib_id
		,pho_ext_lib_med_id
		,pho_ext_lib_med_ddid
		,ext_lib_rxnorm_id)
		select ppo.phys_order_id
			,vpos.order_status
			,vpos.status_reason
			,ppo.fac_id
			,ppo.client_id
			,ppo.description
			,ppo.dispense_as_written
			,ppo.related_generic
			,ppo.directions
			,ppo.drug_strength
			,ppo.drug_strength_uom
			,ppo.order_date
			,ppo.order_status
			,ppo.physician_id
			,ppo.reorder
			,ppo.revision_by
			,ppo.revision_date
			,ppo.route_of_admin
			,ppo.start_date
			,ppo.last_reorder_date
			,ppo.discontinued_date
			,ppo.end_date
			,ppo.hold_date
			,ppo.hold_date_end
			,order_class_id
			,order_category_id
			,order_type_id
			,order_verified
			,communication_method
			, lib.pho_ext_lib_id
			, lib.pho_ext_lib_med_id
			, lib.pho_ext_lib_med_ddid
			, lib.ext_lib_rxnorm_id
		 from pho_phys_order ppo
		JOIN @vpos vpos on vpos.phys_order_id=ppo.phys_order_id
		LEFT JOIN @orderStatus stIds on stIds.stat = vpos.order_status
		LEFT JOIN pho_order_ext_lib_med_ref lib WITH (NOLOCK) ON lib.phys_order_id = ppo.phys_order_id AND lib.deleted='N'
		where ppo.client_id=@clientId and ppo.fac_id=@facId and order_category_id=3022 --only physician orders
			and  ppo.order_verified = 'Y' and (isNULL(ppo.active_flag, 'Y') = 'Y')
			and (stIds.stat is not null or @orderStatusCSV is null)
			and (@orderClassId = 0 or @orderClassId=ppo.order_class_id)
		union all--get the orders passed in using the CSV regardless of their status.
			select ppo.phys_order_id
			,vpos.order_status
			,vpos.status_reason
			,ppo.fac_id
			,ppo.client_id
			,ppo.description
			,ppo.dispense_as_written
			,ppo.related_generic
			,ppo.directions
			,ppo.drug_strength
			,ppo.drug_strength_uom
			,ppo.order_date
			,ppo.order_status
			,ppo.physician_id
			,ppo.reorder
			,ppo.revision_by
			,ppo.revision_date
			,ppo.route_of_admin
			,ppo.start_date
			,ppo.last_reorder_date
			,ppo.discontinued_date
			,ppo.end_date
			,ppo.hold_date
			,ppo.hold_date_end
			,order_class_id
			,order_category_id
			,order_type_id
			,order_verified
			,communication_method
			, lib.pho_ext_lib_id
			, lib.pho_ext_lib_med_id
			, lib.pho_ext_lib_med_ddid
			, lib.ext_lib_rxnorm_id
		 from pho_phys_order ppo
			JOIN @physOrderIds ids on ppo.phys_order_id=ids.phys_order_id
			LEFT JOIN @vpos vpos on vpos.phys_order_id=ppo.phys_order_id
			LEFT JOIN pho_order_ext_lib_med_ref lib WITH (NOLOCK) ON lib.phys_order_id = ppo.phys_order_id AND lib.deleted='N'

	--get the order information
	SET @step = 5
	select * from @result

	--get the supply information
	SET @step = 6
	select pos.phys_order_id,
        pos.order_supply_id,
        pos.description as supply_description,
        pos.directions as supply_directions,
        pos.date_dispensed as date_dispensed,
        pos.last_received_date as supply_received_date,
        pos.med_src_type_id as supply_med_src_type_id,
        pos.pharmacy_id as supply_pharmacy_id,
        eef.name as supply_pharmacy_name,
        pos.reordering as supply_reordering,
        pos.status AS supply_status,
        pos.new_supply_flag as supply_new_supply_flag,
        pos.last_reorder_date as supply_last_reorder_date,
        pos.disp_code as supply_disp_code,
        pos.pharm_nurse_notes as pharm_nurse_notes,
        pos.nurse_pharm_notes as nurse_pharm_notes,
        pos.disp_package_identifier as supply_disp_package_identifier,
        pos.controlled_substance_code as supply_controlled_substance_code,
        pos.prescription as supply_prescription,
        pos.do_not_fill as supply_do_not_fill,
        pos.inventory_on_hand as inventory_on_hand,
        pos.next_refill_date as next_refill_date,
        psd.pharmacy_order_id as pharmacy_order_id,
        pos.active as supply_active,
        '' as imageFileName, -- PCC-33017
        pos.drug_code as drug_code
    FROM pho_order_supply pos
        INNER JOIN  @result result ON [result].phys_order_id = pos.phys_order_id
        LEFT JOIN emc_ext_facilities eef ON eef.ext_fac_id = pos.pharmacy_id
        left join pho_supply_dispense psd on psd.order_supply_id = pos.order_supply_id and psd.deleted='N'
    WHERE (pos.active = 'Y' or pos.active = 'N') AND pos.deleted = 'N'
    ORDER BY pos.created_date DESC

END TRY
BEGIN CATCH
    SELECT @error_code = @@error, @status_text = 'Error at step:'+convert(varchar(3),@step)+', '+ERROR_MESSAGE()

    SET @status_code = 1

    GOTO PgmAbend

END CATCH

PgmSuccess:
if @status_code = 0
begin
    if @debug='Y' Print 'Successfull execution of stored procedure'
    return
end
--program failure return
PgmAbend:

if @debug='Y' Print 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '    ' + convert(varchar(26),getdate(),109)
if @debug='Y' Print 'Error code: '+convert(varchar(10),@error_code) + '; Error description:   ' +@status_text
    
GO
GRANT EXECUTE ON [sproc_pho_getPhysicianOrders_v2] TO public
GO

GO

print 'C_Branch/04_StoredProcedures/sproc_pho_getPhysicianOrders_v2.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_getPhysicianOrders_v2.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_getPhysOrdersForDoseCheckGoLive.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- =================================================================================
-- CORE-508
--
-- Written By:           Jose Diaz
-- Script Type:          DML
-- Target DB Type:       Client
-- Target ENVIRONMENT:   BOTH
-- Re-Runnable:          YES
-- Where tested:         T43A-Dev DB
-- Staging Recommendations/Warnings: None
-- Execution Sample: EXEC dbo.sproc_pho_getPhysOrdersForDoseCheckGoLive @facId=1,@facilityDateTime=GetDate(),@drugLibraryType=2
--
-- Description of Script Function: Return a list of orders along with their DDID that can be potentially used for dose-check.
-- =================================================================================
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'[dbo].[sproc_pho_getPhysOrdersForDoseCheckGoLive]')
		AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
    DROP PROCEDURE [dbo].[sproc_pho_getPhysOrdersForDoseCheckGoLive]
GO

CREATE PROCEDURE [dbo].[sproc_pho_getPhysOrdersForDoseCheckGoLive]
    @facId INT,
    @facilityDateTime DATETIME,
    @drugLibraryType INT
AS
BEGIN
	DECLARE @local_facId int = @facId
  DECLARE @clients TABLE
  (
    client_id int,
    hasDOB char
  )

  INSERT INTO @clients
  SELECT
    c.client_id
    , CASE WHEN m.date_of_birth is NULL THEN 0 ELSE 1 END hasDOB
  FROM clients c
    INNER JOIN mpi m ON m.mpi_id = c.mpi_id
    LEFT JOIN census_item ci ON ci.census_id = c.current_census_id
  WHERE c.fac_id =  @local_facId AND ci.fac_id=@local_facId
    AND (c.discharge_date IS NULL OR c.discharge_date > @facilityDateTime)

  SELECT
    DISTINCT
		ppo.phys_order_id,
		medref.pho_ext_lib_med_ddid,
        case
		 when c.hasDOB = '0' then 0
         when medref.pho_ext_lib_med_ddid is null or medref.pho_ext_lib_med_ddid = 0 then 0
         else null end AS 'overdose',
		case
		 when (pos.dose_uom_id is not null or pos.quantity_uom_id is not null) then 1
		 else 0 END as 'has_uom',
        IIF(poq.phys_order_id is not null and poq.deleted = 'N' and poq.promoted_date is null, 1, 0) as is_queued_order
  FROM pho_phys_order ppo WITH (NOLOCK)
    INNER JOIN @clients c ON c.client_id= ppo.client_id
    INNER JOIN pho_order_ext_lib_med_ref medref ON medref.phys_order_id=ppo.phys_order_id AND pho_ext_lib_id = @drugLibraryType
    LEFT JOIN pho_phys_order_dose_check_acknowledgement pa ON ppo.phys_order_id = pa.phys_order_id
	LEFT JOIN pho_order_schedule pos ON pos.phys_order_id = ppo.phys_order_id
    LEFT JOIN pho_order_queue poq ON ppo.phys_order_id = poq.phys_order_id
    LEFT JOIN pho_phys_order_dose_check_warning dcw ON ppo.phys_order_id = dcw.phys_order_id
  WHERE
    ppo.fac_id = @local_facId
	AND ppo.order_class_id=1 -- only institutional orders have dose check
    AND order_category_id=3022 -- only pharmacy orders to be considered
    AND pa.phys_order_id is null
    AND dcw.phys_order_id IS NULL
    --include queued orders
    AND (poq.phys_order_id is null
        OR
        (poq.promoted_date is NULL AND poq.complete = 'Y' AND poq.deleted = 'N'))
    --orders must be verified and active, unless queued
    AND (( (poq.phys_order_id is NULL
     OR
      poq.promoted_date is not null) --order is not queued, check for active and verified
    AND ppo.order_verified = 'Y'
    AND (ISNULL(ppo.active_flag, 'Y') = 'Y'))
     OR --order is queued
      (poq.phys_order_id is not null and poq.promoted_date is null)
      )
END
GO

GRANT EXECUTE ON sproc_pho_getPhysOrdersForDoseCheckGoLive TO PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_pho_getPhysOrdersForDoseCheckGoLive.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_getPhysOrdersForDoseCheckGoLive.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_getBatchDib4EnhancedOrdersForMSCRescreening.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ===============================================================================================================================
--
-- Purpose: The purpose of this procedure is to load all phys order with all it's schedule information for given facility
-- given that phys order has overdose in old DIB4
--
-- Target ENVIRONMENT: BOTH
--
--  Special Instructions:
--
--	Params:
--
--			@facId			- Facility Id
--          @orderType      - result scope that handles 3 different cases: D - orders with dose check only, Q - queued orders only, A - all orders that can be processed
--			@debug          - Debug param, 'Y' or 'N'
--			@status_code    - SP execution flag, 0 for success.
--			@status_text    - SP error text if error occurs.
--
-- Change History:
--   Author			Date		Comment
-- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--	 Rhys Thomas     09/27/2021	 Created.
--   Jarek Zawojski  10/05/2021  Added @order_type parameter to handle 3 different scopes: D - orders with dose check only, Q - queued orders only, A - all orders that can be processed
-- ======================================================================================================================================================================================

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[sproc_pho_list_getBatchDib4EnhancedOrdersForMSCRescreening]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
   drop procedure [dbo].[sproc_pho_list_getBatchDib4EnhancedOrdersForMSCRescreening]
GO

create
proc sproc_pho_list_getBatchDib4EnhancedOrdersForMSCRescreening
(
	@facId			int,
    @orderType  char(1),
	@debug char(1)  = 'N',
	@status_code int out,
	@status_text varchar(3000) out
)
as
begin

SET NOCOUNT ON

DECLARE @step			int,
		@error_code		int


BEGIN TRY

    DECLARE
            @vFacId int
    -- Set the local variables
    select
      @vFacId       = @facId
     ,@status_code 	= 0;

    DECLARE
    @include_DC_only TINYINT,
        @include_Q_only TINYINT;

    if @orderType='D'
    begin
      SET @include_DC_only = 1;
      SET @include_Q_only = 0;
    end
    if @orderType='Q'
    begin
        SET @include_Q_only = 1;
        SET @include_DC_only = 0;
    end
    --if all orders are to be processed ignore criteria for:
    --  - previous values of dose check and
    --  - queued orders
    if @orderType='A'
    begin
        SET @include_DC_only = 0;
        SET @include_Q_only = 0;
    end

    if(@debug='Y') begin Print 'BEGIN STEP select 100 unique clients with criteria for phys orders overdose' + ' ' + convert(varchar(26),getdate(),109) end
-- Table variable to store the result of getting unique clients that meet criteria
    declare @TMP_UniqueClients table (client_id int)

INSERT INTO @TMP_UniqueClients
SELECT TOP(10) *
FROM (
         SELECT DISTINCT(c.client_id)
         FROM pho_phys_order ppo
                  INNER JOIN clients c ON ppo.client_id = c.client_id AND c.fac_id = @vFacID
                  INNER JOIN mpi m ON m.mpi_id = c.mpi_id
                  INNER JOIN census_item ci ON ci.census_id = c.current_census_id AND ci.fac_id = @vFacID
                  INNER JOIN pho_order_ext_lib_med_ref medref ON ppo.phys_order_id = medref.phys_order_id AND medref.pho_ext_lib_id = 2
                  LEFT JOIN pho_phys_order_dose_check_acknowledgement pa ON ppo.phys_order_id = pa.phys_order_id
                  LEFT JOIN pho_phys_order_dose_check_warning dcw ON ppo.phys_order_id = dcw.phys_order_id
                  LEFT JOIN pho_order_queue poq ON ppo.phys_order_id = poq.phys_order_id
         WHERE m.deceased_date IS NULL
           AND m.date_of_birth IS NOT NULL
           AND ppo.order_class_id = 1
           AND ppo.order_category_id = 3022
           --if orders with dose check only
           AND ((@include_DC_only = 0) OR pa.over_dose IN (1, 2)) -- Include \"overdose\" (1) AND \"was not performed\" (2)
           AND NOT (medref.pho_ext_lib_med_ddid IS NULL OR medref.pho_ext_lib_med_ddid <= 0)
           AND dcw.phys_order_id IS NULL
           AND ppo.fac_id = @vFacId
           -- if queued orders only, then order must not be promoted
           AND ((@include_Q_only = 0) OR (poq.phys_order_id is not null and poq.promoted_date IS NULL))
           --if record in poq table exists (all orderTypes) then it must be completed and not deleted
           AND (poq.phys_order_id is null OR poq.complete = 'Y' and poq.deleted = 'N')
           --orders must be verified and active, unless queued
           AND (( (poq.phys_order_id is NULL
             OR
                   poq.promoted_date is not null) --order is not queued, check for active and verified
             AND ppo.order_verified = 'Y'
             AND (ISNULL(ppo.active_flag, 'Y') = 'Y'))
             OR --order is queued
                (poq.phys_order_id is not null and poq.promoted_date is null)
             )
            --skip queued orders that are in dosecheck could not be performed
            AND NOT EXISTS (select 1 from pho_order_queue_drug_protocol_action poqdpa
                            where poqdpa.phys_order_id = ppo.phys_order_id and poqdpa.interaction_type = 'ND')
     ) unique_client

    if(@debug='Y') begin Print 'END STEP select 100 unique clients with criteria for phys orders overdose, number of returned rows: ' + convert(varchar(10), @@ROWCOUNT, 109) + ', ' + convert(varchar(26),getdate(),109) end
    if(@debug='Y') begin Print 'BEGIN STEP filtering unique clients into phys order ids	' + ' ' + convert(varchar(26),getdate(),109) end
    declare @TMP_FilteredOrders table (client_id    int,
                                    phys_order_id int,
                                    is_queued_order int,
                                    over_dose int,
                                    queued_over_dose int
                                  );
    INSERT into @TMP_FilteredOrders
    select uc.client_id, ppo.phys_order_id,
           IIF(poq.phys_order_id is not null and poq.deleted = 'N' and poq.promoted_date is null, 1, 0) as is_queued_order,
           pa.over_dose,
           IIF(exists(select 1
                      from pho_order_queue_drug_protocol_action poqdpa
                      where poqdpa.phys_order_id = ppo.phys_order_id
                        and poqdpa.interaction_type = 'OD'), 1, 0) queued_over_dose
    from @TMP_UniqueClients uc
             left join pho_phys_order ppo on ppo.client_id = uc.client_id
             left JOIN pho_order_ext_lib_med_ref medref ON ppo.phys_order_id = medref.phys_order_id AND medref.pho_ext_lib_id = 2
             left JOIN pho_phys_order_dose_check_acknowledgement pa ON ppo.phys_order_id = pa.phys_order_id
             left JOIN pho_phys_order_dose_check_warning dcw ON ppo.phys_order_id = dcw.phys_order_id
             LEFT JOIN pho_order_queue poq ON ppo.phys_order_id = poq.phys_order_id
    WHERE ppo.order_class_id = 1
      AND ppo.order_category_id = 3022
      AND ((@include_DC_only = 0) OR (pa.over_dose IN (1, 2)))  -- Include \"overdose\" (1) AND \"was not performed\" (2)
      AND NOT (medref.pho_ext_lib_med_ddid IS NULL OR medref.pho_ext_lib_med_ddid <= 0)
      AND dcw.phys_order_id IS NULL
      AND ppo.fac_id = @vFacId
      -- if queued orders only, then order must not be promoted
      AND ((@include_Q_only = 0) OR (poq.phys_order_id is not null and poq.promoted_date IS NULL))
      --if record in poq table exists (all orderTypes) then it must be completed and not deleted
      AND (poq.phys_order_id is null OR poq.complete = 'Y' and poq.deleted = 'N')
      --orders must be verified and active, unless queued
      AND (( (poq.phys_order_id is NULL
        OR
              poq.promoted_date is not null) --order is not queued, check for active and verified
        AND ppo.order_verified = 'Y'
        AND (ISNULL(ppo.active_flag, 'Y') = 'Y'))
        OR --order is queued
           (poq.phys_order_id is not null and poq.promoted_date is null)
        )
      --skip queued orders that are in dosecheck could not be performed
      AND NOT EXISTS (select 1 from pho_order_queue_drug_protocol_action poqdpa
                      where poqdpa.phys_order_id = ppo.phys_order_id and poqdpa.interaction_type = 'ND')

    if(@debug='Y') begin Print 'END STEP filtering unique clients into phys order ids, number of returned rows: ' + convert(varchar(10), @@ROWCOUNT, 109) + ', ' + convert(varchar(26),getdate(),109) end
	if(@debug='Y') begin Print 'BEGIN STEP select enhanced phys order	' + ' ' + convert(varchar(26),getdate(),109) end

    SELECT
        DISTINCT (o.phys_order_id)
         , o.order_schedule_id
         , o.client_id
         , o.drug_code
         , o.drug_manufacturer
         , o.drug_class_number
         , o.drug_strength
         , o.drug_strength_uom
         , o.drug_name
         , o.is_new_order
         , o.order_class_id
         , o.start_date
         , o.end_date
         , s.schedule_id
         , s.schedule_type
         , s.pho_std_time_id
         , s.xxdays as xx_days
         , s.xxhours as xx_hours
         , s.xxmonths as xx_months
         , s.sun
         , s.mon
         , s.tues as tue
         , s.wed
         , s.thurs as thu
         , s.fri
         , s.sat
         , s.days_on
         , s.days_off
         , s.std_freq_id
         , s.dose AS dose_value
         , s.dose_low
         , s.alternate_dose
         , s.start_time
         , s.end_time
         , s.nurse_action_notes
         , s.date_start
         , s.date_stop
         , s.repeat_week
         , s.apply_to
         , s.prn_admin
         , s.prn_admin_value
         , s.prn_admin_units
         , s.std_freq_time_label
         , s.until_finished
         , s.quantity_uom_id
         , s.dose_uom_id
         , s.schedule_template
         , s.xxMonths
         , s.date_of_month
         , s.std_shift_id
         , s.schedule_sliding_scale_id
         , s.apply_remove_flag
         , s.remove_time
         , s.remove_duration
         , s.behavior_lookback
         , lib.pho_ext_lib_id
         , lib.pho_ext_lib_med_id
         , lib.pho_ext_lib_med_ddid
         , lib.pho_ext_lib_generic_id
         , lib.pho_ext_lib_generic_desc
         , lib.ext_lib_rxnorm_id
         , filtered_orders.is_queued_order
         , IIF(filtered_orders.is_queued_order = 0 and filtered_orders.over_dose = 1, 1,
             IIF(filtered_orders.is_queued_order = 1 and filtered_orders.queued_over_dose = 1, 1, 0))  over_dose
    FROM @TMP_FilteredOrders filtered_orders
        LEFT JOIN view_pho_phys_order o ON o.phys_order_id = filtered_orders.phys_order_id
        LEFT JOIN view_pho_schedule s
                  ON o.order_schedule_id = s.order_schedule_id AND o.phys_order_id = s.phys_order_id
                      AND s.deleted = 'N'
        LEFT JOIN pho_order_ext_lib_med_ref lib
                  ON o.order_category_id=3022 and lib.phys_order_id = o.phys_order_id -- only need for pharmacy order
       LEFT JOIN pho_phys_order_dose_check_warning dcw ON o.phys_order_id = dcw.phys_order_id


    WHERE o.fac_id = @vFacId
    AND dcw.phys_order_id IS NULL
    ORDER BY o.order_schedule_id, s.schedule_id

	if(@debug='Y') begin Print 'END STEP select enhanced phys order, number of returned rows: ' + convert(varchar(10), @@ROWCOUNT, 109) + ', ' + convert(varchar(26),getdate(),109) end

END TRY

--error trapping
BEGIN CATCH

SELECT @error_code = @@error
     , @status_text = ERROR_MESSAGE()

    SET @status_code = 1

	GOTO PgmAbend

END CATCH

--program success return
PgmSuccess:
IF @status_code = 0
BEGIN
	IF @debug='Y' PRINT 'Successful execution of stored procedure'
	RETURN @status_code
END

--program failure return
PgmAbend:
IF @debug='Y' PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '	' + convert(varchar(26),getdate())
IF @debug='Y' PRINT 'Error code: '+convert(varchar(3),@step) + '; Error description:	' +@status_text
RETURN @status_code

END
GO

GRANT EXECUTE ON sproc_pho_list_getBatchDib4EnhancedOrdersForMSCRescreening TO PUBLIC
GO



GO

print 'C_Branch/04_StoredProcedures/sproc_pho_list_getBatchDib4EnhancedOrdersForMSCRescreening.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_getBatchDib4EnhancedOrdersForMSCRescreening.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_getEnhancedOrder.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


 -- ===============================================================================================================================
 -- ---------------
 -- Deprecated
 --	---------------
 -- 
 -- Purpose: The purpose of this procedure is to load a phys order with all it's schedule information
 --
 -- Target ENVIRONMENT: BOTH 
 --
 --  Special Instructions: 
 --
 --	Params:
 --			
 --			@physOrderId    - phys order id
 --			@facId			- Facility Id 
 --			@includeAdministrativeOrder - Flag to include Administrative Orders, 'Y' or 'N'
 --			@includeSupplyInfo - Flag to include Supply Info, 'Y' or 'N'
 --			@debug          - Debug param, 'Y' or 'N'
 --			@status_code    - SP execution flag, 0 for success.
 --			@status_text    - SP error text if error occurs.
 --
 -- Change History:
 --   Author			Date		Comment
 -- ------------------------------------------------------------------------------------------------------------------------------- 
 --	  Joel Pelletier    08/11/2011	Created.
 --   Alireza Mandegar	10/15/2012	Updated due to PCC-33677 and Replaced the usage of fn_pho_getOrderStatus with sproc_pho_getOrderStatus
 --									Also modified the file maintenance box to be in sql comment format rather than java format
 --									and added the Change History section to it to keep track of changes.
 --  Alireza Mandegar	 11/12/2012	Added pho_ext_lib_generic_desc/id for PCC-34329
 --  Alireza Mandegar	 11/22/2012	Added schedule_sliding_scale_id due to PCC-30715
 --  Alireza Mandegar	 11/29/2012	Added schedule_dose_duration due to PCC-32538
 --  Feng Xia			 12/15/2012	Added xxMonths
 --  Alireza Mandegar	 12/20/2012	Added apply_remove_flag due to PCC-32537
 --  Alireza Mandegar	 01/25/2013	Added remove_time due to PCC-32537
 --  Alireza Mandegar	 01/31/2013	Added remove_duration due to PCC-32537
 --  Aarti Malhotra      09/24/2013  Added pho_ext_lib_rxnorm for PCC-47251 (main JIRA PCC-46704)
 --  Mustafa Behrainwala 04/28/2014  Added table to handle Therapeutic Interchange sliding scale PCC-52492 
 --  Mustafa Behrainwala 07/31/2014  Added Linked Set Id and Description for PCC-59209
 --	 Mustafa Behrainwala 10/29/2015	 Added order_class_id
 --  Willie Wong		 05/11/2016	 Added schedule_directions for dietary orders for PCC-94151
 --	 Nooshin Hayeri		 06/29/2016	Added snapshot_schedule_start_date for PCC-96359
 --  Melvin Parinas      07/16/2016  Removed snapshot_schedule_start_date and replaced with earliest_prescriber_start_date date PCC-96359
 --  Melvin Parinas      07/25/2016  Added prescriber_schedule_start_date due to PCC-98059	
 --	 Devika Bapat		 02/24/2017	Added 2 optional parameters to include administrative orders and supply info PCC-108894
 --	 Mustafa Behrainwala 10/12/2018 Modified due to CORE-23367 to add dose_low for dose ranging.
 --	 Elias Ghanem 		 12/21/2018 	Added last_pharmacy_end_date due to CORE-28433.
 --  Mustafa Behrainwala 01/29/2019 Modified due to CORE-29190 return behavior lookup
 --  Elias Ghanem 		 01/29/2019 Added schedule_revision_date due to CORE-85435
 --  Sree Naghasundharam 11/18/2021 This Stored Procedure 'sproc_pho_list_getEnhancedOrder' is herebry deprecated(CORE-97119).
 --									New stored procedure 'sproc_pho_list_getEnhancedOrder_v2' created to remove 'mmdb' references.
 --									Any further changes to 'sproc_pho_list_getEnhancedOrder' should also be made in the new stored procedure.
 -- ===============================================================================================================================

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[sproc_pho_list_getEnhancedOrder]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
   drop procedure [dbo].[sproc_pho_list_getEnhancedOrder]
GO

create 
proc sproc_pho_list_getEnhancedOrder
(
	@physOrderId	int,
	@facId			int,
	@includeAdministrativeOrder	char(1) = 'N',
	@includeSupplyInfo char(1) = 'N',
	@debug char(1)  = 'N',
	@status_code int out, 
	@status_text varchar(3000) out
)
as 
begin

SET NOCOUNT ON

DECLARE @step			int,
		@error_code		int

	   

BEGIN TRY

    -- PCC-33677
    ----Localize input Variables
    DECLARE  @vFacId int
            ,@vClientId int
            ,@vPhysOrderId int
            ,@vDateTime datetime
			,@vOrderCategory int
        
    -- Set the local variables
    select 
        @vFacId         = @facId 
       ,@vClientId      = null 
	   ,@vPhysOrderId   = @physOrderId
       ,@vDateTime      = dbo.fn_facility_getCurrentTime(@facId)
	   ,@status_code 	= 0
        
    -- Table variable to store the result of sproc_pho_getOrderStatus
    declare @TMP_PhoOrderStatus table (phys_order_id    int
                                    ,fac_id             int
                                    ,order_status       smallint
                                    ,order_relationship int
                                    ,status_reason      varchar(75));
    
	set @vOrderCategory = (select order_category_id from pho_phys_order where phys_order_id=@vPhysOrderId)
	
	-- Check exist in pho_phys_order table, struck out order does not has record in pho_phys_order table, if not exit, there is no need to execute sproc_pho_getOrderStatus
	if @vOrderCategory > 0
	begin
		-- Fill the table variable
		insert into @TMP_PhoOrderStatus
		exec sproc_pho_getOrderStatus 
				@facId          = @vFacId
				,@clientId      = @vClientId
				,@physOrderId   = @vPhysOrderId
				,@date          = @vDateTime
				,@debug         = 'N'
				,@status_code   = @status_code
				,@status_text   = @status_text
	end

	if @debug = 'Y'  select * From @TMP_PhoOrderStatus

	if isnull(@status_code,0) <> 0
		  begin
				set @status_text = 'sproc_pho_getOrderStatus returned the following error: ' + isnull(@status_text,'')
				Raiserror( @status_text, 11, 1 );
		  end

	
	if(@debug='Y') begin Print 'BEGIN STEP select enhanced phys order	' + ' ' + convert(varchar(26),getdate(),109) end

SELECT 
o.phys_order_id
, o.order_type_id
, o.physician_id
, o.pharmacy_id
, o.fac_id
, o.std_freq_id
, o.client_id
, o.drug_code
, o.created_by
, o.created_date
, o.revision_by
, o.revision_date
, o.reorder
, o.date_ordered
, o.start_date
, o.end_date
, o.strength
, o.form
, o.route_of_admin
, o.diagnoses
, o.description
, o.directions
, o.related_generic
, o.supplementary_notes
, o.communication_method
, o.diet_type
, diettype.item_description AS diet_type_description
, o.diet_texture
, diettexture.item_description AS diet_texture_description
, o.stat
, o.packaging
, o.disc_with_pharm
, o.quantity_to_administer
, o.std_order_id
, o.discontinued_date
, o.fluid_consistency
, fluidcon.item_description AS fluid_consistency_description
, o.diet_supplement
, dietsup.item_description AS diet_supplement_description
, o.hold_date
, o.nurse_admin_notes
, o.nurse_pharm_notes
, o.delivery_notes
, o.delivery_type
, o.self_admin
, o.administered_by_id
, o.prn_flag
, o.label_name
, o.reorder_count
, o.last_reorder_date
, o.quantity_received
, o.tran_id
, o.prescription
, o.start_date_type
, o.end_date_type
, o.end_date_duration_type
, o.end_date_duration
, o.schedule_dose_duration -- PCC-32538
, o.alter_med_src
, o.alter_med_src_name
, o.sent_date
, vpos.order_status
, o.status_change_by
, o.status_change_date
, o.hold_physician_id
, o.discontinue_physician_id
, o.pharm_nurse_notes
, o.first_admin
, o.drug_manufacturer
, o.drug_class_number
, o.resume_physician_id
, o.event_driven_flag
, o.auto_fill_flag
, o.controlled_substance_code
, o.related_phys_order_id
, o.relationship
, o.auto_created_flag
, o.active_flag
, o.new_supply_flag
, o.resume_date
, o.last_received_date
, o.orig_phys_order_id
, o.disp_package_identifier
, o.hold_date_end
, o.vendor_phys_order_id
, o.order_date
, o.sliding_scale_id
, o.order_verified
, o.dispense_as_written
, o.next_refill_date
, o.do_not_fill
, o.cur_supply_id
, o.first_documented
, o.substitution_indicator
, o.reassessment_required
, o.completed_date
, o.completed_by
, o.verify_copied_order
, o.original_route_of_admin
, o.indications_for_use
, o.draft
, o.origin_id
, o.order_category_id
, o.order_revision_date
, o.order_revision_by
, o.drug_strength
, o.drug_strength_uom
, o.drug_name
, o.is_new_order
, o.order_schedule_id
, o.start_date as schedule_start_date
, o.end_date as schedule_end_date
, o.last_pharmacy_end_date
, o.physician_name_in_msg
, s.schedule_id
, s.schedule_type
, s.pho_std_time_id
, s.xxdays as xx_days
, s.sun
, s.mon
, s.tues as tue
, s.wed
, s.thurs as thu
, s.fri
, s.sat
, s.days_on
, s.days_off
, s.std_freq_id
, s.dose AS dose_value
, s.dose_low
, s.alternate_dose
, s.start_time
, s.end_time
, s.nurse_action_notes
, s.date_start
, s.date_stop
, s.repeat_week
, s.apply_to
, s.prn_admin
, s.prn_admin_value
, s.prn_admin_units
, s.std_freq_time_label
, s.until_finished
, s.quantity_uom_id
, s.dose_uom_id
, case 
       -- diet orders do not populate the view_pho_schedule need to get directly from the pho_order_schedule table
       when  s.schedule_directions is null and o.order_category_id = 3031 then o.schedule_directions 
       else s.schedule_directions
end as schedule_directions
, o.order_directions as order_directions
, s.schedule_template
, s.xxMonths
, s.date_of_month
, s.std_shift_id
, s.schedule_sliding_scale_id
, s.apply_remove_flag
, s.remove_time
, s.remove_duration
, s.behavior_lookback
, o.schedule_revision_date
, v.vital
, p.prompt_id
, p.value_type
, p.description as prompt_description
, p.long_description
, p.notes
, p.no_of_values
, p.current_value2
, p.current_value
, p.specify_initial_value
, p.value_data_type
, p.prompt_frequency_type
, p.prompt_frequency
, p.value_date
, pt.short_desc
, c.first_name AS physician_first_name
, c.last_name AS physician_last_name
, c.title + ' ' + c.first_name + ' ' + c.last_name AS physician_fullname
, cb.long_username AS created_by_long
, rb.long_username AS revision_by_long
, poua.edited_by_audit_id
, poua.edited_date
, poua.created_by_audit_id
, edituser.long_username AS edited_by_long
, edituser.position_description AS edited_by_position
, edituser.designation_desc AS edited_by_designation
, createuser.long_username AS created_by_audit_long
, createuser.position_description AS created_by_position
, createuser.designation_desc AS created_by_designation
, poua.confirmed_by_audit_id
, poua.confirmed_date
, confuser.long_username AS confirmed_by_long
, confuser.position_description AS confirmed_by_position
, confuser.designation_desc AS confirmed_by_designation
, lib.pho_ext_lib_id
, lib.pho_ext_lib_med_id
, lib.pho_ext_lib_med_ddid
, lib.pho_ext_lib_generic_id
, lib.pho_ext_lib_generic_desc
, lib.ext_lib_rxnorm_id
, o.min_start_date
, o.max_end_date
, o.emergency_pharmacy_flag
, o.need_location_of_admin
, so.advanced_directive as order_advanced_directive
, poad.advanced_dir_status
, pspo.advanced_directive as advanced_directive
, signuser.long_username as signed_by_long
, ppos.signature_date
, o.extended_end_date
, o.extended_count
, custmed.cust_med_id
, ti.orig_phys_order_id as original_ti_phys_order_id
, lsi.linked_set_id as linked_set_id
, ls.set_description as linked_set_description
, nctrlsc.new_controlled_substance_code as new_controlled_substance_code
, esign.marked_to_sign_user_id
, case when marked_to_sign_user_id is not null then dbo.fn_get_username(marked_to_sign_user_id) else null end as marked_to_sign_user_longname
, esign.marked_to_sign_date
, esign.marked_to_sign_contact_id
, esign.marked_to_sign_authentication_type_id
, esign.marked_to_sign_source_type_id
, rstype.description as marked_to_sign_source_type_description
, esign.sign_user_id
, case when sign_user_id is not null then dbo.fn_get_username(sign_user_id) else null end as sign_user_longname
, esign.sign_date
, esign.sign_contact_id
, esign.sign_authentication_type_id
, atype.description as sign_authentication_type_description
, esign.sign_source_type_id
, stype.description as sign_source_type_description
, popr.reason_binary_code
, clinrev.reviewed_date
, clinrev.phys_order_id as review_order_id
, clinrev.reviewed_by
, oq.quantity as prescription_quantity
, oq.unit_of_measure as prescription_quantity_uom
, oq.no_of_refills as prescription_no_of_refills
, o.order_class_id
, o.prescriber_schedule_start_date as earliest_prescriber_start_date
, o.prescriber_schedule_start_date
, o.linked_order_id
, o.linked_reason_id
FROM
	view_pho_phys_order o
	LEFT JOIN @TMP_PhoOrderStatus vpos
		ON o.phys_order_id = vpos.phys_order_id
	LEFT JOIN view_pho_schedule s
		ON o.order_schedule_id = s.order_schedule_id AND o.phys_order_id = s.phys_order_id
		AND s.deleted = 'N'
	LEFT JOIN COMMON_CODE diettype
        ON @vOrderCategory=3031 and o.diet_type = diettype.item_id and diettype.item_code = 'phodyt' -- only need for diet order
    LEFT JOIN COMMON_CODE diettexture
        ON @vOrderCategory=3031 and o.diet_texture = diettexture.item_id and diettexture.item_code = 'phodtx' -- only need for diet order
    LEFT JOIN COMMON_CODE dietsup
        ON @vOrderCategory=3032 and o.diet_supplement = dietsup.item_id and dietsup.item_code = 'phosup' -- only need for diet supplement order
    LEFT JOIN COMMON_CODE fluidcon
    	ON @vOrderCategory=3031 and o.fluid_consistency = fluidcon.item_id and fluidcon.item_code = 'phocst' -- only need for diet order
	LEFT JOIN pho_schedule_vitals v
		ON s.schedule_id = v.schedule_id and v.deleted = 'N'
	LEFT JOIN pho_order_related_prompt p
		ON s.schedule_id = p.schedule_id and p.deleted ='N'
	LEFT JOIN pho_order_related_value_type pt
		ON p.value_type = pt.type_id
	LEFT JOIN contact c
		ON c.contact_id = o.physician_id
	LEFT JOIN sec_user cb
		ON cb.loginname = o.created_by
	LEFT JOIN sec_user rb
		ON rb.loginname = o.revision_by
	LEFT JOIN pho_phys_order_useraudit poua
		ON poua.phys_order_id = o.phys_order_id
	LEFT JOIN cp_sec_user_audit createuser
	  ON createuser.cp_sec_user_audit_id = poua.created_by_audit_id
	LEFT JOIN cp_sec_user_audit edituser
	  ON edituser.cp_sec_user_audit_id = poua.edited_by_audit_id
	LEFT JOIN cp_sec_user_audit confuser
	  ON confuser.cp_sec_user_audit_id = poua.confirmed_by_audit_id
	LEFT JOIN pho_order_ext_lib_med_ref lib
	  ON @vOrderCategory=3022 and lib.phys_order_id = o.phys_order_id -- only need for pharmacy order
	LEFT JOIN pho_phys_order_std_order templateorder
	  ON @vOrderCategory=3029 and templateorder.phys_order_id = o.phys_order_id -- only need for other category order
	LEFT JOIN  pho_std_order so 
	  ON @vOrderCategory=3029 and templateorder.std_order_id = so.std_order_id -- only need for other category order
	LEFT JOIN pho_std_phys_order pspo
	  ON @vOrderCategory=3029 and o.std_order_id = pspo.std_phys_order_id -- only need for other category order
	LEFT JOIN pho_phys_order_advanced_directive poad
	  ON @vOrderCategory=3029 and o.phys_order_id = poad.phys_order_id -- only need for other category order
	LEFT JOIN pho_phys_order_sign ppos
	  ON o.phys_order_id = ppos.phys_order_id
	LEFT JOIN cp_sec_user_audit signuser
	  ON signuser.cp_sec_user_audit_id = ppos.cp_sec_user_audit_id
	LEFT JOIN pho_phys_order_cust_med custmed
	  ON @vOrderCategory=3022 and custmed.phys_order_id = o.phys_order_id -- only need for pharmacy order
	LEFT JOIN pho_phys_order_ti ti
	  ON ti.phys_order_id = o.phys_order_id
	LEFT JOIN pho_linked_set_item lsi
	  ON lsi.phys_order_id = o.phys_order_id
	LEFT JOIN pho_linked_set ls on ls.linked_set_id = lsi.linked_set_id
	LEFT JOIN pho_phys_order_new_ctrlsubstancecode nctrlsc ON @vOrderCategory=3022 and nctrlsc.phys_order_id=o.phys_order_id -- only need for pharmacy order
	LEFT JOIN pho_phys_order_esignature esign  ON o.phys_order_id = esign.phys_order_id
	LEFT JOIN order_sign_source_type stype ON esign.sign_source_type_id = stype.source_type_id
	LEFT JOIN order_sign_source_type rstype ON esign.marked_to_sign_source_type_id = rstype.source_type_id
	LEFT JOIN order_sign_authentication_type atype ON esign.sign_authentication_type_id = atype.authentication_type_id
	LEFT JOIN pho_order_pending_reason popr ON popr.phys_order_id = o.phys_order_id
    LEFT JOIN pho_order_clinical_review clinrev ON clinrev.phys_order_id=o.phys_order_id 
    LEFT JOIN pho_phys_order_quantity_info oq on @vOrderCategory=3022 and oq.phys_order_id=o.phys_order_id -- only need for pharmacy order
WHERE
	o.phys_order_id = @physOrderId
	
ORDER BY o.order_schedule_id, s.schedule_id

-- select administrative orders
if @includeAdministrativeOrder='Y'
	select vpao.admin_created_date,
	vpao.admin_order_verified,
	vpao.order_related_id,
	vpao.phys_order_id,
	vpao.standard_phys_order_id,
	vpao.created_by,
	vpao.created_date,
	vpao.revision_by,
	vpao.revision_date,
	vpao.deleted_by,
	vpao.deleted_date,
	vpao.deleted,
	vpao.fac_id,
	vpao.order_relationship_id,
	vpao.admin_communication_method,
	vpao.admin_effective_date,
	vpao.admin_ineffective_date,
	vpao.admin_physician_id,
	vpao.admin_reason,
	vpao.admin_noted_by,
	vpao.admin_physician_first_name,
	vpao.admin_physician_last_name,
	vpao.strikeout_by,
	vpao.strikeout_date,
	vpao.strikeout_reason_code,
	vpao.strikeout_reason_description,
	vpao.strikeout_by_long,
	vpao.admin_order_id,
	vpao.admin_origin_id,
	secuser.long_username 'created_by_long' , secuser.designation_desc as created_by_designation, ccc.item_description as created_by_position
	,csua.long_username confirmed_by_username, csua.position_description as confirmed_by_position, csua.designation_desc as confirmed_by_designation, ua.confirmed_date as confirmed_date
	FROM view_pho_administrative_order vpao
	left join SEC_USER secuser on secuser.loginname = vpao.created_by
	left join common_code ccc on ccc.item_id = secuser.position_id
	left join pho_admin_order_useraudit ua ON ua.admin_order_id = vpao.admin_order_id
	left join cp_sec_user_audit csua on csua.cp_sec_user_audit_id = ua.confirmed_by_audit_id
	WHERE vpao.standard_phys_order_id = @physOrderId
	ORDER BY vpao.revision_date  DESC

IF @includeSupplyInfo='Y'
BEGIN
	DECLARE @integratedPharmacies TABLE
    (
        pharmacy_id int not null
    )
	INSERT INTO @integratedPharmacies (pharmacy_id)
	select distinct extFacId from (
		SELECT mp.ext_fac_id as extFacId
			FROM message_profile mp WITH (NOLOCK)
			INNER JOIN lib_message_profile lmp WITH (NOLOCK)
				ON lmp.message_profile_id = mp.message_profile_id
			       AND lmp.deleted = 'N' and lmp.is_enabled='Y'
			WHERE mp.is_enabled = 'Y' and mp.is_integrated_pharmacy='Y'
			AND mp.fac_id = @facId
			AND mp.message_protocol_id = 12
			GROUP BY mp.ext_fac_id
		UNION
		SELECT distinct mi.internal_id as extFacId
			FROM map_identifier mi WITH (NOLOCK)
			INNER JOIN lib_message_profile libmp WITH (NOLOCK)
			ON libmp.vendor_code = mi.vendor_code
			AND libmp.deleted = 'N'
			INNER JOIN message_profile mp WITH (NOLOCK)
			ON libmp.message_profile_id = mp.message_profile_id
			WHERE mi.map_type_id = 3 and mp.fac_id = @facId and  mi.fac_id = @facId
	) a where extFacId is not null

select pos.phys_order_id,
        pos.order_supply_id,
        pos.description as supply_description,
        pos.directions as supply_directions,
        pos.date_dispensed as date_dispensed,
        pos.last_received_date as supply_received_date,
        pos.med_src_type_id as supply_med_src_type_id,
        pos.pharmacy_id as supply_pharmacy_id,
        eef.name as supply_pharmacy_name,
        pos.reordering as supply_reordering,
        pos.status AS supply_status,
        pos.new_supply_flag as supply_new_supply_flag,
        pos.last_reorder_date as supply_last_reorder_date,
        pos.disp_code as supply_disp_code,
        pos.pharm_nurse_notes as pharm_nurse_notes,
        pos.nurse_pharm_notes as nurse_pharm_notes,
        pos.disp_package_identifier as supply_disp_package_identifier,
        pos.controlled_substance_code as supply_controlled_substance_code,
        pos.prescription as supply_prescription,
        pos.do_not_fill as supply_do_not_fill,
        pos.inventory_on_hand as inventory_on_hand,
        pos.next_refill_date as next_refill_date,
        psd.pharmacy_order_id as pharmacy_order_id,
        CASE  WHEN ip.pharmacy_id IS NULL THEN 'N' ELSE 'Y' END 'integrated_pharmacy',
        pos.active as supply_active,
        mmdb.dbo.fn_pho_getImageFilenameByNDC(pos.drug_code) as imageFileName, 
        pos.drug_code as drug_code
    FROM pho_order_supply pos
        
        LEFT JOIN emc_ext_facilities eef ON eef.ext_fac_id = pos.pharmacy_id
        left join pho_supply_dispense psd on psd.order_supply_id = pos.order_supply_id and psd.deleted='N'
        LEFT JOIN @integratedPharmacies ip
                    ON ip.pharmacy_id = pos.pharmacy_id
    WHERE (pos.active = 'Y' or pos.active = 'N') AND pos.deleted = 'N' and pos.phys_order_id = @physOrderId
    ORDER BY pos.created_date DESC
END

	if(@debug='Y') begin Print 'END STEP select enhanced phys order		' + ' ' + convert(varchar(26),getdate(),109) end

END TRY
 
--error trapping
BEGIN CATCH

SELECT @error_code = @@error
	 , @status_text = ERROR_MESSAGE()
 
	SET @status_code = 1

	GOTO PgmAbend
 
END CATCH

--program success return
PgmSuccess:
IF @status_code = 0
BEGIN
	IF @debug='Y' PRINT 'Successfull execution of stored procedure'
	RETURN @status_code
END

--program failure return
PgmAbend:
IF @debug='Y' PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '	' + convert(varchar(26),getdate())
IF @debug='Y' PRINT 'Error code: '+convert(varchar(3),@step) + '; Error description:	' +@status_text
RETURN @status_code

END
GO

GRANT EXECUTE ON sproc_pho_list_getEnhancedOrder TO PUBLIC
GO



GO

print 'C_Branch/04_StoredProcedures/sproc_pho_list_getEnhancedOrder.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_getEnhancedOrder.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_getEnhancedOrder_v2.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


 -- ===============================================================================================================================
 -- 
 -- Purpose: The purpose of this procedure is to load a phys order with all it's schedule information.
 --			 Please note that this stored procedure is a copy of 'sproc_pho_list_getEnhancedOrder' but has all MMDB references removed.
 --
 --
 -- Target ENVIRONMENT: BOTH 
 --
 --  Special Instructions: 
 --
 --	Params:
 --			
 --			@physOrderId    - phys order id
 --			@facId			- Facility Id 
 --			@includeAdministrativeOrder - Flag to include Administrative Orders, 'Y' or 'N'
 --			@includeSupplyInfo - Flag to include Supply Info, 'Y' or 'N'
 --			@debug          - Debug param, 'Y' or 'N'
 --			@status_code    - SP execution flag, 0 for success.
 --			@status_text    - SP error text if error occurs.
 --
 -- Change History:
 --   Author			Date		Comment
 -- ------------------------------------------------------------------------------------------------------------------------------- 
 --	  Joel Pelletier    08/11/2011	Created.
 --   Alireza Mandegar	10/15/2012	Updated due to PCC-33677 and Replaced the usage of fn_pho_getOrderStatus with sproc_pho_getOrderStatus
 --									Also modified the file maintenance box to be in sql comment format rather than java format
 --									and added the Change History section to it to keep track of changes.
 --  Alireza Mandegar	 11/12/2012	Added pho_ext_lib_generic_desc/id for PCC-34329
 --  Alireza Mandegar	 11/22/2012	Added schedule_sliding_scale_id due to PCC-30715
 --  Alireza Mandegar	 11/29/2012	Added schedule_dose_duration due to PCC-32538
 --  Feng Xia			 12/15/2012	Added xxMonths
 --  Alireza Mandegar	 12/20/2012	Added apply_remove_flag due to PCC-32537
 --  Alireza Mandegar	 01/25/2013	Added remove_time due to PCC-32537
 --  Alireza Mandegar	 01/31/2013	Added remove_duration due to PCC-32537
 --  Aarti Malhotra      09/24/2013  Added pho_ext_lib_rxnorm for PCC-47251 (main JIRA PCC-46704)
 --  Mustafa Behrainwala 04/28/2014  Added table to handle Therapeutic Interchange sliding scale PCC-52492 
 --  Mustafa Behrainwala 07/31/2014  Added Linked Set Id and Description for PCC-59209
 --	 Mustafa Behrainwala 10/29/2015	 Added order_class_id
 --  Willie Wong		 05/11/2016	 Added schedule_directions for dietary orders for PCC-94151
 --	 Nooshin Hayeri		 06/29/2016	Added snapshot_schedule_start_date for PCC-96359
 --  Melvin Parinas      07/16/2016  Removed snapshot_schedule_start_date and replaced with earliest_prescriber_start_date date PCC-96359
 --  Melvin Parinas      07/25/2016  Added prescriber_schedule_start_date due to PCC-98059	
 --	 Devika Bapat		 02/24/2017	Added 2 optional parameters to include administrative orders and supply info PCC-108894
 --	 Mustafa Behrainwala 10/12/2018 Modified due to CORE-23367 to add dose_low for dose ranging.
 --	 Elias Ghanem 		 12/21/2018 	Added last_pharmacy_end_date due to CORE-28433.
 --  Mustafa Behrainwala 01/29/2019 Modified due to CORE-29190 return behavior lookup
 --  Elias Ghanem 		 01/29/2019 Added schedule_revision_date due to CORE-85435
 --  Sree Naghasundharam 11/18/2021 Created this new stored procedure 'sproc_pho_list_getEnhancedOrder_v2' and Removed MMDB references (CORE-97119)
 -- ===============================================================================================================================

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[sproc_pho_list_getEnhancedOrder_v2]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
   drop procedure [dbo].[sproc_pho_list_getEnhancedOrder_v2]
GO

create 
proc sproc_pho_list_getEnhancedOrder_v2
(
	@physOrderId	int,
	@facId			int,
	@includeAdministrativeOrder	char(1) = 'N',
	@includeSupplyInfo char(1) = 'N',
	@debug char(1)  = 'N',
	@status_code int out, 
	@status_text varchar(3000) out
)
as 
begin

SET NOCOUNT ON

DECLARE @step			int,
		@error_code		int

	   

BEGIN TRY

    -- PCC-33677
    ----Localize input Variables
    DECLARE  @vFacId int
            ,@vClientId int
            ,@vPhysOrderId int
            ,@vDateTime datetime
			,@vOrderCategory int
        
    -- Set the local variables
    select 
        @vFacId         = @facId 
       ,@vClientId      = null 
	   ,@vPhysOrderId   = @physOrderId
       ,@vDateTime      = dbo.fn_facility_getCurrentTime(@facId)
	   ,@status_code 	= 0
        
    -- Table variable to store the result of sproc_pho_getOrderStatus
    declare @TMP_PhoOrderStatus table (phys_order_id    int
                                    ,fac_id             int
                                    ,order_status       smallint
                                    ,order_relationship int
                                    ,status_reason      varchar(75));
    
	set @vOrderCategory = (select order_category_id from pho_phys_order where phys_order_id=@vPhysOrderId)
	
	-- Check exist in pho_phys_order table, struck out order does not has record in pho_phys_order table, if not exit, there is no need to execute sproc_pho_getOrderStatus
	if @vOrderCategory > 0
	begin
		-- Fill the table variable
		insert into @TMP_PhoOrderStatus
		exec sproc_pho_getOrderStatus 
				@facId          = @vFacId
				,@clientId      = @vClientId
				,@physOrderId   = @vPhysOrderId
				,@date          = @vDateTime
				,@debug         = 'N'
				,@status_code   = @status_code
				,@status_text   = @status_text
	end

	if @debug = 'Y'  select * From @TMP_PhoOrderStatus

	if isnull(@status_code,0) <> 0
		  begin
				set @status_text = 'sproc_pho_getOrderStatus returned the following error: ' + isnull(@status_text,'')
				Raiserror( @status_text, 11, 1 );
		  end

	
	if(@debug='Y') begin Print 'BEGIN STEP select enhanced phys order	' + ' ' + convert(varchar(26),getdate(),109) end

SELECT 
o.phys_order_id
, o.order_type_id
, o.physician_id
, o.pharmacy_id
, o.fac_id
, o.std_freq_id
, o.client_id
, o.drug_code
, o.created_by
, o.created_date
, o.revision_by
, o.revision_date
, o.reorder
, o.date_ordered
, o.start_date
, o.end_date
, o.strength
, o.form
, o.route_of_admin
, o.diagnoses
, o.description
, o.directions
, o.related_generic
, o.supplementary_notes
, o.communication_method
, o.diet_type
, diettype.item_description AS diet_type_description
, o.diet_texture
, diettexture.item_description AS diet_texture_description
, o.stat
, o.packaging
, o.disc_with_pharm
, o.quantity_to_administer
, o.std_order_id
, o.discontinued_date
, o.fluid_consistency
, fluidcon.item_description AS fluid_consistency_description
, o.diet_supplement
, dietsup.item_description AS diet_supplement_description
, o.hold_date
, o.nurse_admin_notes
, o.nurse_pharm_notes
, o.delivery_notes
, o.delivery_type
, o.self_admin
, o.administered_by_id
, o.prn_flag
, o.label_name
, o.reorder_count
, o.last_reorder_date
, o.quantity_received
, o.tran_id
, o.prescription
, o.start_date_type
, o.end_date_type
, o.end_date_duration_type
, o.end_date_duration
, o.schedule_dose_duration -- PCC-32538
, o.alter_med_src
, o.alter_med_src_name
, o.sent_date
, vpos.order_status
, o.status_change_by
, o.status_change_date
, o.hold_physician_id
, o.discontinue_physician_id
, o.pharm_nurse_notes
, o.first_admin
, o.drug_manufacturer
, o.drug_class_number
, o.resume_physician_id
, o.event_driven_flag
, o.auto_fill_flag
, o.controlled_substance_code
, o.related_phys_order_id
, o.relationship
, o.auto_created_flag
, o.active_flag
, o.new_supply_flag
, o.resume_date
, o.last_received_date
, o.orig_phys_order_id
, o.disp_package_identifier
, o.hold_date_end
, o.vendor_phys_order_id
, o.order_date
, o.sliding_scale_id
, o.order_verified
, o.dispense_as_written
, o.next_refill_date
, o.do_not_fill
, o.cur_supply_id
, o.first_documented
, o.substitution_indicator
, o.reassessment_required
, o.completed_date
, o.completed_by
, o.verify_copied_order
, o.original_route_of_admin
, o.indications_for_use
, o.draft
, o.origin_id
, o.order_category_id
, o.order_revision_date
, o.order_revision_by
, o.drug_strength
, o.drug_strength_uom
, o.drug_name
, o.is_new_order
, o.order_schedule_id
, o.start_date as schedule_start_date
, o.end_date as schedule_end_date
, o.last_pharmacy_end_date
, o.physician_name_in_msg
, s.schedule_id
, s.schedule_type
, s.pho_std_time_id
, s.xxdays as xx_days
, s.sun
, s.mon
, s.tues as tue
, s.wed
, s.thurs as thu
, s.fri
, s.sat
, s.days_on
, s.days_off
, s.std_freq_id
, s.dose AS dose_value
, s.dose_low
, s.alternate_dose
, s.start_time
, s.end_time
, s.nurse_action_notes
, s.date_start
, s.date_stop
, s.repeat_week
, s.apply_to
, s.prn_admin
, s.prn_admin_value
, s.prn_admin_units
, s.std_freq_time_label
, s.until_finished
, s.quantity_uom_id
, s.dose_uom_id
, case 
       -- diet orders do not populate the view_pho_schedule need to get directly from the pho_order_schedule table
       when  s.schedule_directions is null and o.order_category_id = 3031 then o.schedule_directions 
       else s.schedule_directions
end as schedule_directions
, o.order_directions as order_directions
, s.schedule_template
, s.xxMonths
, s.date_of_month
, s.std_shift_id
, s.schedule_sliding_scale_id
, s.apply_remove_flag
, s.remove_time
, s.remove_duration
, s.behavior_lookback
, o.schedule_revision_date
, v.vital
, p.prompt_id
, p.value_type
, p.description as prompt_description
, p.long_description
, p.notes
, p.no_of_values
, p.current_value2
, p.current_value
, p.specify_initial_value
, p.value_data_type
, p.prompt_frequency_type
, p.prompt_frequency
, p.value_date
, pt.short_desc
, c.first_name AS physician_first_name
, c.last_name AS physician_last_name
, c.title + ' ' + c.first_name + ' ' + c.last_name AS physician_fullname
, cb.long_username AS created_by_long
, rb.long_username AS revision_by_long
, poua.edited_by_audit_id
, poua.edited_date
, poua.created_by_audit_id
, edituser.long_username AS edited_by_long
, edituser.position_description AS edited_by_position
, edituser.designation_desc AS edited_by_designation
, createuser.long_username AS created_by_audit_long
, createuser.position_description AS created_by_position
, createuser.designation_desc AS created_by_designation
, poua.confirmed_by_audit_id
, poua.confirmed_date
, confuser.long_username AS confirmed_by_long
, confuser.position_description AS confirmed_by_position
, confuser.designation_desc AS confirmed_by_designation
, lib.pho_ext_lib_id
, lib.pho_ext_lib_med_id
, lib.pho_ext_lib_med_ddid
, lib.pho_ext_lib_generic_id
, lib.pho_ext_lib_generic_desc
, lib.ext_lib_rxnorm_id
, o.min_start_date
, o.max_end_date
, o.emergency_pharmacy_flag
, o.need_location_of_admin
, so.advanced_directive as order_advanced_directive
, poad.advanced_dir_status
, pspo.advanced_directive as advanced_directive
, signuser.long_username as signed_by_long
, ppos.signature_date
, o.extended_end_date
, o.extended_count
, custmed.cust_med_id
, ti.orig_phys_order_id as original_ti_phys_order_id
, lsi.linked_set_id as linked_set_id
, ls.set_description as linked_set_description
, nctrlsc.new_controlled_substance_code as new_controlled_substance_code
, esign.marked_to_sign_user_id
, case when marked_to_sign_user_id is not null then dbo.fn_get_username(marked_to_sign_user_id) else null end as marked_to_sign_user_longname
, esign.marked_to_sign_date
, esign.marked_to_sign_contact_id
, esign.marked_to_sign_authentication_type_id
, esign.marked_to_sign_source_type_id
, rstype.description as marked_to_sign_source_type_description
, esign.sign_user_id
, case when sign_user_id is not null then dbo.fn_get_username(sign_user_id) else null end as sign_user_longname
, esign.sign_date
, esign.sign_contact_id
, esign.sign_authentication_type_id
, atype.description as sign_authentication_type_description
, esign.sign_source_type_id
, stype.description as sign_source_type_description
, popr.reason_binary_code
, clinrev.reviewed_date
, clinrev.phys_order_id as review_order_id
, clinrev.reviewed_by
, oq.quantity as prescription_quantity
, oq.unit_of_measure as prescription_quantity_uom
, oq.no_of_refills as prescription_no_of_refills
, o.order_class_id
, o.prescriber_schedule_start_date as earliest_prescriber_start_date
, o.prescriber_schedule_start_date
, o.linked_order_id
, o.linked_reason_id
FROM
	view_pho_phys_order o
	LEFT JOIN @TMP_PhoOrderStatus vpos
		ON o.phys_order_id = vpos.phys_order_id
	LEFT JOIN view_pho_schedule s
		ON o.order_schedule_id = s.order_schedule_id AND o.phys_order_id = s.phys_order_id
		AND s.deleted = 'N'
	LEFT JOIN COMMON_CODE diettype
        ON @vOrderCategory=3031 and o.diet_type = diettype.item_id and diettype.item_code = 'phodyt' -- only need for diet order
    LEFT JOIN COMMON_CODE diettexture
        ON @vOrderCategory=3031 and o.diet_texture = diettexture.item_id and diettexture.item_code = 'phodtx' -- only need for diet order
    LEFT JOIN COMMON_CODE dietsup
        ON @vOrderCategory=3032 and o.diet_supplement = dietsup.item_id and dietsup.item_code = 'phosup' -- only need for diet supplement order
    LEFT JOIN COMMON_CODE fluidcon
    	ON @vOrderCategory=3031 and o.fluid_consistency = fluidcon.item_id and fluidcon.item_code = 'phocst' -- only need for diet order
	LEFT JOIN pho_schedule_vitals v
		ON s.schedule_id = v.schedule_id and v.deleted = 'N'
	LEFT JOIN pho_order_related_prompt p
		ON s.schedule_id = p.schedule_id and p.deleted ='N'
	LEFT JOIN pho_order_related_value_type pt
		ON p.value_type = pt.type_id
	LEFT JOIN contact c
		ON c.contact_id = o.physician_id
	LEFT JOIN sec_user cb
		ON cb.loginname = o.created_by
	LEFT JOIN sec_user rb
		ON rb.loginname = o.revision_by
	LEFT JOIN pho_phys_order_useraudit poua
		ON poua.phys_order_id = o.phys_order_id
	LEFT JOIN cp_sec_user_audit createuser
	  ON createuser.cp_sec_user_audit_id = poua.created_by_audit_id
	LEFT JOIN cp_sec_user_audit edituser
	  ON edituser.cp_sec_user_audit_id = poua.edited_by_audit_id
	LEFT JOIN cp_sec_user_audit confuser
	  ON confuser.cp_sec_user_audit_id = poua.confirmed_by_audit_id
	LEFT JOIN pho_order_ext_lib_med_ref lib
	  ON @vOrderCategory=3022 and lib.phys_order_id = o.phys_order_id -- only need for pharmacy order
	LEFT JOIN pho_phys_order_std_order templateorder
	  ON @vOrderCategory=3029 and templateorder.phys_order_id = o.phys_order_id -- only need for other category order
	LEFT JOIN  pho_std_order so 
	  ON @vOrderCategory=3029 and templateorder.std_order_id = so.std_order_id -- only need for other category order
	LEFT JOIN pho_std_phys_order pspo
	  ON @vOrderCategory=3029 and o.std_order_id = pspo.std_phys_order_id -- only need for other category order
	LEFT JOIN pho_phys_order_advanced_directive poad
	  ON @vOrderCategory=3029 and o.phys_order_id = poad.phys_order_id -- only need for other category order
	LEFT JOIN pho_phys_order_sign ppos
	  ON o.phys_order_id = ppos.phys_order_id
	LEFT JOIN cp_sec_user_audit signuser
	  ON signuser.cp_sec_user_audit_id = ppos.cp_sec_user_audit_id
	LEFT JOIN pho_phys_order_cust_med custmed
	  ON @vOrderCategory=3022 and custmed.phys_order_id = o.phys_order_id -- only need for pharmacy order
	LEFT JOIN pho_phys_order_ti ti
	  ON ti.phys_order_id = o.phys_order_id
	LEFT JOIN pho_linked_set_item lsi
	  ON lsi.phys_order_id = o.phys_order_id
	LEFT JOIN pho_linked_set ls on ls.linked_set_id = lsi.linked_set_id
	LEFT JOIN pho_phys_order_new_ctrlsubstancecode nctrlsc ON @vOrderCategory=3022 and nctrlsc.phys_order_id=o.phys_order_id -- only need for pharmacy order
	LEFT JOIN pho_phys_order_esignature esign  ON o.phys_order_id = esign.phys_order_id
	LEFT JOIN order_sign_source_type stype ON esign.sign_source_type_id = stype.source_type_id
	LEFT JOIN order_sign_source_type rstype ON esign.marked_to_sign_source_type_id = rstype.source_type_id
	LEFT JOIN order_sign_authentication_type atype ON esign.sign_authentication_type_id = atype.authentication_type_id
	LEFT JOIN pho_order_pending_reason popr ON popr.phys_order_id = o.phys_order_id
    LEFT JOIN pho_order_clinical_review clinrev ON clinrev.phys_order_id=o.phys_order_id 
    LEFT JOIN pho_phys_order_quantity_info oq on @vOrderCategory=3022 and oq.phys_order_id=o.phys_order_id -- only need for pharmacy order
WHERE
	o.phys_order_id = @physOrderId
	
ORDER BY o.order_schedule_id, s.schedule_id

-- select administrative orders
if @includeAdministrativeOrder='Y'
	select vpao.admin_created_date,
	vpao.admin_order_verified,
	vpao.order_related_id,
	vpao.phys_order_id,
	vpao.standard_phys_order_id,
	vpao.created_by,
	vpao.created_date,
	vpao.revision_by,
	vpao.revision_date,
	vpao.deleted_by,
	vpao.deleted_date,
	vpao.deleted,
	vpao.fac_id,
	vpao.order_relationship_id,
	vpao.admin_communication_method,
	vpao.admin_effective_date,
	vpao.admin_ineffective_date,
	vpao.admin_physician_id,
	vpao.admin_reason,
	vpao.admin_noted_by,
	vpao.admin_physician_first_name,
	vpao.admin_physician_last_name,
	vpao.strikeout_by,
	vpao.strikeout_date,
	vpao.strikeout_reason_code,
	vpao.strikeout_reason_description,
	vpao.strikeout_by_long,
	vpao.admin_order_id,
	vpao.admin_origin_id,
	secuser.long_username 'created_by_long' , secuser.designation_desc as created_by_designation, ccc.item_description as created_by_position
	,csua.long_username confirmed_by_username, csua.position_description as confirmed_by_position, csua.designation_desc as confirmed_by_designation, ua.confirmed_date as confirmed_date
	FROM view_pho_administrative_order vpao
	left join SEC_USER secuser on secuser.loginname = vpao.created_by
	left join common_code ccc on ccc.item_id = secuser.position_id
	left join pho_admin_order_useraudit ua ON ua.admin_order_id = vpao.admin_order_id
	left join cp_sec_user_audit csua on csua.cp_sec_user_audit_id = ua.confirmed_by_audit_id
	WHERE vpao.standard_phys_order_id = @physOrderId
	ORDER BY vpao.revision_date  DESC

IF @includeSupplyInfo='Y'
BEGIN
	DECLARE @integratedPharmacies TABLE
    (
        pharmacy_id int not null
    )
	INSERT INTO @integratedPharmacies (pharmacy_id)
	select distinct extFacId from (
		SELECT mp.ext_fac_id as extFacId
			FROM message_profile mp WITH (NOLOCK)
			INNER JOIN lib_message_profile lmp WITH (NOLOCK)
				ON lmp.message_profile_id = mp.message_profile_id
			       AND lmp.deleted = 'N' and lmp.is_enabled='Y'
			WHERE mp.is_enabled = 'Y' and mp.is_integrated_pharmacy='Y'
			AND mp.fac_id = @facId
			AND mp.message_protocol_id = 12
			GROUP BY mp.ext_fac_id
		UNION
		SELECT distinct mi.internal_id as extFacId
			FROM map_identifier mi WITH (NOLOCK)
			INNER JOIN lib_message_profile libmp WITH (NOLOCK)
			ON libmp.vendor_code = mi.vendor_code
			AND libmp.deleted = 'N'
			INNER JOIN message_profile mp WITH (NOLOCK)
			ON libmp.message_profile_id = mp.message_profile_id
			WHERE mi.map_type_id = 3 and mp.fac_id = @facId and  mi.fac_id = @facId
	) a where extFacId is not null

select pos.phys_order_id,
        pos.order_supply_id,
        pos.description as supply_description,
        pos.directions as supply_directions,
        pos.date_dispensed as date_dispensed,
        pos.last_received_date as supply_received_date,
        pos.med_src_type_id as supply_med_src_type_id,
        pos.pharmacy_id as supply_pharmacy_id,
        eef.name as supply_pharmacy_name,
        pos.reordering as supply_reordering,
        pos.status AS supply_status,
        pos.new_supply_flag as supply_new_supply_flag,
        pos.last_reorder_date as supply_last_reorder_date,
        pos.disp_code as supply_disp_code,
        pos.pharm_nurse_notes as pharm_nurse_notes,
        pos.nurse_pharm_notes as nurse_pharm_notes,
        pos.disp_package_identifier as supply_disp_package_identifier,
        pos.controlled_substance_code as supply_controlled_substance_code,
        pos.prescription as supply_prescription,
        pos.do_not_fill as supply_do_not_fill,
        pos.inventory_on_hand as inventory_on_hand,
        pos.next_refill_date as next_refill_date,
        psd.pharmacy_order_id as pharmacy_order_id,
        CASE  WHEN ip.pharmacy_id IS NULL THEN 'N' ELSE 'Y' END 'integrated_pharmacy',
        pos.active as supply_active,
        '' as imageFileName, 
        pos.drug_code as drug_code
    FROM pho_order_supply pos
        
        LEFT JOIN emc_ext_facilities eef ON eef.ext_fac_id = pos.pharmacy_id
        left join pho_supply_dispense psd on psd.order_supply_id = pos.order_supply_id and psd.deleted='N'
        LEFT JOIN @integratedPharmacies ip
                    ON ip.pharmacy_id = pos.pharmacy_id
    WHERE (pos.active = 'Y' or pos.active = 'N') AND pos.deleted = 'N' and pos.phys_order_id = @physOrderId
    ORDER BY pos.created_date DESC
END

	if(@debug='Y') begin Print 'END STEP select enhanced phys order		' + ' ' + convert(varchar(26),getdate(),109) end

END TRY
 
--error trapping
BEGIN CATCH

SELECT @error_code = @@error
	 , @status_text = ERROR_MESSAGE()
 
	SET @status_code = 1

	GOTO PgmAbend
 
END CATCH

--program success return
PgmSuccess:
IF @status_code = 0
BEGIN
	IF @debug='Y' PRINT 'Successfull execution of stored procedure'
	RETURN @status_code
END

--program failure return
PgmAbend:
IF @debug='Y' PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '	' + convert(varchar(26),getdate())
IF @debug='Y' PRINT 'Error code: '+convert(varchar(3),@step) + '; Error description:	' +@status_text
RETURN @status_code

END
GO

GRANT EXECUTE ON sproc_pho_list_getEnhancedOrder_v2 TO PUBLIC
GO



GO

print 'C_Branch/04_StoredProcedures/sproc_pho_list_getEnhancedOrder_v2.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_getEnhancedOrder_v2.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_residentchart.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*****************************************************************************************************
** ---------------
**  Deprecated
** ---------------
**  Created By:
**  Created Date:
**
**	Purpose:  To return a list of Physician Orders.
**
**	Params:
**			@facId
**			@clientId
**			@facilityDateTime
**			@orderCategoryIdsCSV
**			@orderStatusCSV
**			@startDateoperator
**			@startDate
***			@endDateoperator
**			@endDate
**			@orderDateoperator
**			@orderDate
**			@createdBy
**			@orderedById
**			@orderTypeId
**			@adminRecordId
**			@routeOfAdminIdsCSV
**			@communicationMethodIdsCSV
**			@medicationSourceId
**			@pharmacyId
**			@providerId
**			@showLegacyOrder
**			@clientIdNumber
**			@clientStatus
**			@unit
**			@floor
**			@completedDate
**			@completedDateoperator
**			@discontinuedDate
**			@discontinuedDateoperator
**			@confirmedDate datetime,
**			@confirmedDateoperator
**			@confirmedBy
**			@medication
**			@medicationclassification
**			@holdDate
**			@holdDateoperator
**			@supplyStatusId
**			@fromIntegratedPharmacy
**			@medSrcTypeId
**			@physOrderId
**			@narcoticsOnly     - Narcotics order or not, 'Y' or 'N'
**          @alwaysShowOrderWithAlert
**			@orderLinkedOption	- (1) None, (2) Only, (3) Both
**			@orderClassId	- smallint (-1) All (1) Institutional order, (2) Discharge order
**			@includeRetired	- Show deleted physicians or not , 'Y' or 'N' 
**			@includeSlidingScale - show sliding scale information or not, 'Y' or 'N'. Defaulted to 'N'.
**			@historicalOrdersOnly - get historical orders only or not, 'Y' or 'N'. Defaulted to 'N'
**			@historicalOrdersOnlyPeriodStart - start of period to get historical orders for, if null get all historical orders
**			@debug          - Debug param, 'Y' or 'N'
**			@status_code    - SP execution flag, 0 for success.
**			@status_text    - SP error text if error occurs.
**
**  Special Instructions:  Run view_pho_order stsus first before running this
**	sproc during the build process.
**
**  Revision History:
**  2012-09-06        PCC-32548   Feng  Xia      added a new search criteria for showing only narcotics drugs
**  2012-04-03        PCC-29069   Nabil Hamade   changed order by from revision_date to edited_date for orders list
**  2016-04-04        PCC-92113   Ramin Shojaei Add condition to include deleted (retired) physician in the result set
**  2016-11-17 		  PCC-105022  Veerpal Khanuja	Added schedule_sliding_scale_id and flag custom_sliding_scale_exists in result set for schedules.
**  2016-11-17 		  PCC-105019  Veerpal Khanuja	Added alternate_dose in result set for schedules.
**	2017-01-23		  PCC-107915  Devika Bapat		Added apply_remove_flag in result set for schedules.
**	2017-03-08		  PCC-110558  Devika Bapat		Added date_start, date_stop, dose_uom_id, dose, indications_for_use, 
													quantity_uom_id, prn_admin, prn_admin_units, prn_admin_value, for schedules. 
**	2017-04-06		  PCC-113549  Devika Bapat		Added apply_to in result set for schedules.
**	2017-11-08		  CORE-5680   Elias Ghanem		Added condition to select historical orders only based on the historicalOrdersOnly and historicalOrdersOnlyPeriodStart parameters.
**  2018-01-03		  CORE-7999   Hao Liu           Added support to filter by old medical professional id if new id provided
**  2018-12-18		  CORE-24715  Samuel Martey     Changed the return block to return the schedules for struck-out orders as well to build directions from them.
**  2019-01-02		  CORE-24715  Samuel Martey     Optimize cases for selecting struck-out orders. Do not select when not requested in the union query
**  2019-03-11		  CORE-35559  Henry Jin			Added join to the table cr_alert_triggered_item_type_category when fecthing alerts.  
**  2019-07-17		  CORE-46275  Elias Ghanem		Return alerts of type 'O' or 'M' instead of only 'O'. Also modify the sorting of the returned result set to be
**													ASC instead of DESC. The sorting modification will not affect the final result displayed to the user since the Java code
**													handling the result set has been modified accordingly.  
**  2019-08-01		  CORE-43789  Elias Ghanem		Add configuration parameters to return orders having alerts of type M or having supplies with alerts of type D regardless of their status
**  2020/09/03 		  CORE-71858  Elias Ghanem 		When computing if order has Allergy, D2D or blackBox alerts, include alerts for supplies even even if the supplies are in Processed By Pharmacy status (3) not only if 
**													they are On Hand
**	2021-01-22  	  CORE-83505  Elias Ghanem      Add revision_date field to the schedules result set
**  2021-11-18 		  CORE-97119  Sree Naghasundharam  This Stored Procedure 'sproc_pho_list_residentchart' is herebry deprecated(CORE-97119).
**														New stored procedure 'sproc_pho_list_residentchart_v2' created to remove 'mmdb' references.
**														Any further changes to 'sproc_pho_list_residentchart' should also be made in the new stored procedure.
******************************************************************************************************************************************************/
IF EXISTS (SELECT *
               FROM
                   dbo.sysobjects
               WHERE
                   id = object_id(N'[dbo].[sproc_pho_list_residentchart]')
                   AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
    DROP PROCEDURE [dbo].[sproc_pho_list_residentchart]

SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[sproc_pho_list_residentchart]   @facId                        INT, --required
                                                        @clientId                     INT, --required
                                                        @facilityDateTime             DATETIME, --required
                                                        @orderCategoryIdsCSV          varchar(100), -- required comma seperated list of categegory id
                                                        @orderStatusCSV               varchar(100),
                                                        @startDateoperator            INT = 0, --0 equal to, -1 less than, 1 greater than
                                                        @startDate                    DATETIME, -- date to compare,
                                                        @endDateoperator              INT = 0, --0 equal to, -1 less than, 1 greater than
                									    @endDate                      DATETIME, -- date to compare,
                                                        @orderDateoperator            INT = 0, --0 equal to, -1 less than, 1 greater than
                                                        @orderDate                    DATETIME, -- date to compare,
                                                        @createdBy                    varchar(60),
                                                        @orderedById int,
                                                        @orderTypeId int,
                                                        @adminRecordId int,
                                                        @routeOfAdminIdsCSV varchar(50),
                                                        @communicationMethodIdsCSV varchar(50), -- required comma seperated list of communication method id
                                                        @medicationSourceId int,
                                                        @pharmacyId int,
                                                        @providerId int,
                                                        @showLegacyOrder char(1), -- Null both , Y - show only legacy order, N - show only new orders
                                                        @clientIdNumber varchar(100),
                                                        @clientStatus int,
                                                        @unit int,
                                                        @floor int,
                                                        @completedDate datetime,
                                                        @completedDateoperator int = 0, --0 equal to, -1 less than, 1 greater than
                                                        @discontinuedDate datetime,
                                                        @discontinuedDateoperator int = 0, --0 equal to, -1 less than, 1 greater than
                                                        @confirmedDate datetime,
                                                        @confirmedDateoperator int = 0, --0 equal to, -1 less than, 1 greater than
                                                        @confirmedBy varchar(100),
                                                        @medication varchar(200),
                                                        @medicationclassification varchar(200),
                                                        @holdDate datetime,
                                                        @holdDateoperator int = 0, --0 equal to, -1 less than, 1 greater than
                                                        @supplyStatusId     int,
                                                        @fromIntegratedPharmacy char(1),
                                                        @medSrcTypeId       int,
                                                        @physOrderId int,
                                                        @pageSize int,
                                                        @pageNumber int,
                                                        @sortByColumn varchar(100),
                                                        @sortByOrder  varchar(10),
                                                        @narcoticsOnly     char(1)  = 'N',
                                                        @alwaysShowOrderWithAlert char(1) = 'N',
														@orderLinkedOption	int,
														@orderClassId		smallint, -- required
														@pharmacyNCPDP varchar(10),
														@includeRetired char(1) = 'Y',
														@includeSlidingScale char(1)='N',
														@historicalOrdersOnly char(1) = 'N',
														@historicalOrdersOnlyPeriodStart datetime,
														@debug              char(1)  = 'N',
														@status_code        int  = 0 out,
                                                        @status_text        varchar(3000) out
                                                          --useful when debugging within sqlserver studio



/***********************************************************************************************

Purpose:
This procedure provides data shown on Resident' Order Chart
This procedure does not use VIEW_PHO_PHYS_ORDER

*************************************************************************************************/

AS
BEGIN TRY
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

DECLARE @step                       			int,
        @error_code                 			int,
        @num_records							int,
		@facIdLocal								int,
		@clientIdLocal							int,
		@drugAllergyCheckEnabled    			char,
		@drugInteractionEnabled					char,
		@doseCheckEnabled						char,
        @blackBoxEnabled						char,
		@orderClassId_local         			smallint,
		@pharmacyNCPDP_local					varchar(10),
		@oldOrderById							int,
		@includeStruckOutOrders					char,
		@showOrdersWithIntegrationAlerts 		varchar(1),
		@showOrdersWithSupplyIntegrationAlerts 	varchar(1)

set @clientIdLocal = @clientId
set @facIdLocal = @facId
SET @step = 0
SET @error_code = 0
SET @orderClassId_local = @orderClassId
SET @pharmacyNCPDP_local = @pharmacyNCPDP
SET @showOrdersWithIntegrationAlerts = 'Y'
SET @showOrdersWithSupplyIntegrationAlerts = 'Y'

SELECT @drugAllergyCheckEnabled=ISNULL(value,'N') FROM configuration_parameter WHERE name='enable_drug_allergy_check' AND value='Y' AND fac_id=@facId
SELECT @drugInteractionEnabled=ISNULL(value,'N') FROM configuration_parameter WHERE name='enable_drug_interaction' AND value='Y' AND fac_id=@facId
SELECT @doseCheckEnabled=ISNULL(value,'N') FROM configuration_parameter WHERE name='enable_dose_check' AND value='Y' AND fac_id=@facId
SELECT @blackBoxEnabled=ISNULL(value,'N') FROM configuration_parameter WHERE name='enable_black_box' AND value='Y' AND fac_id=@facId
SELECT @showOrdersWithIntegrationAlerts=ISNULL(value,'Y') FROM configuration_parameter WHERE name='show_orders_with_integration_alerts' AND value='N' AND fac_id=@facId
SELECT @showOrdersWithSupplyIntegrationAlerts=ISNULL(value,'Y') FROM configuration_parameter WHERE name='show_orders_with_supply_integration_alerts' AND value='N' AND fac_id=@facId

SET @oldOrderById = dbo.fn_medprof_getOldMedicalProfessionalId(@orderedById, @facId)

    DECLARE @result TABLE
	--create table #result
    (

        phys_order_id int not null PRIMARY KEY
        ,status int
        ,relationship int
        ,status_reason int
        ,fac_id int NOT NULL
        ,client_id int NOT NULL
        ,diet_type int
        ,diet_texture int
        ,diet_supplement int
        ,fluid_consistency int
        ,alter_med_src int
        ,nurse_pharm_notes varchar(512)
        ,created_by varchar(60)
        ,created_by_longname varchar(100)
        ,created_date datetime
        ,date_ordered datetime
        ,description varchar(500)
        ,related_generic varchar(250)
        ,dispense_as_written varchar(1)
        ,directions varchar(1000)
		,strength varchar(30)
        ,drug_strength varchar(100)
        ,drug_strength_uom varchar(10)
        ,discontinued_date datetime
        ,end_date datetime
        ,hold_date datetime
        ,hold_date_end datetime
        ,last_reorder_date datetime
        ,order_type_id int
        ,order_category_id int
        ,order_category_description varchar(250)
        ,family_portal_sort_order tinyint
        ,order_date datetime
        ,order_status int
        ,physician_id int
        ,reorder varchar(1)
        ,revision_by varchar(60)
        ,revision_date datetime
        ,edited_date datetime
        ,route_of_admin int
        ,start_date datetime
        ,order_verified varchar(1)
        ,next_refill_date datetime
        ,do_not_fill varchar(1)
        ,first_documented datetime
        ,origin_id int
        ,controlled_substance_code varchar(50)
        ,pharmacy_id int
        ,communication_method int
        ,legacy_order varchar(1)
        ,discharge_date datetime
        ,client_id_number varchar(35)
        ,resident_last_name varchar(50)
        ,resident_first_name varchar(50)
        ,orig_phys_order_id int
        ,pho_ext_lib_id int
        ,pho_ext_lib_med_id int
        ,pho_ext_lib_med_ddid int
        ,ext_lib_rxnorm_id varchar(10)
        ,strikeout_date datetime
        ,strikeout_by varchar(60)
		,strikeout_reason_code varchar(254)
		,vendor_phys_order_id varchar(30)
		,advanced_directive varchar(1)
		,end_date_filter datetime
		,linked_set_id int
		,linked_set_name varchar(100)
		,order_class_id tinyint
    )

	declare @orderData table
    (
        phys_order_id int not null PRIMARY KEY
        ,status int
        ,relationship int
        ,status_reason int
        ,fac_id int NOT NULL
        ,client_id int NOT NULL
        ,diet_type int
        ,diet_texture int
        ,diet_supplement int
        ,fluid_consistency int
        ,alter_med_src int
        ,nurse_pharm_notes varchar(512)
        ,created_by varchar(60)
        ,created_by_longname varchar(100)
        ,created_date datetime
        ,date_ordered datetime
        ,calculated_description varchar(500)
        ,related_generic varchar(250)
        ,dispense_as_written varchar(1)
        ,directions varchar(1000)
		,strength varchar(30)
        ,drug_strength varchar(100)
        ,drug_strength_uom varchar(10)
        ,discontinued_date datetime
        ,end_date datetime
        ,hold_date datetime
        ,hold_date_end datetime
        ,last_reorder_date datetime
        ,order_type_id int
        ,order_category_id int
        ,order_category_description varchar(250)
        ,family_portal_sort_order tinyint
        ,order_date datetime
        ,order_status int
        ,physician_id int
        ,reorder varchar(1)
        ,revision_by varchar(60)
        ,revision_date datetime
        ,edited_date datetime
        ,route_of_admin int
        ,start_date datetime
        ,order_verified varchar(1)
        ,next_refill_date datetime
        ,do_not_fill varchar(1)
        ,first_documented datetime
        ,origin_id int
        ,controlled_substance_code varchar(50)
        ,pharmacy_id int
        ,communication_method int
        ,legacy_order varchar(1)
        ,discharge_date datetime
        ,client_id_number varchar(35)
        ,resident_last_name varchar(50)
        ,resident_first_name varchar(50)
        ,orig_phys_order_id int
        ,pho_ext_lib_id int
        ,pho_ext_lib_med_id int
        ,pho_ext_lib_med_ddid int
        ,ext_lib_rxnorm_id varchar(10)
		,vendor_phys_order_id varchar(30)
		,advanced_directive varchar(1)
		, confirmed_by_audit_id int
       , ppone_phys_order_id int
		,description varchar(500)
		,linked_set_id int
		,linked_set_name varchar(100)
		,order_class_id tinyint
    )

   	declare @vpos table (
	[phys_order_id] [int] NOT NULL,
	[fac_id] [int] NOT NULL,
	[order_status] [int] NOT NULL,
	[order_relationship] [int] NULL,
	[status_reason] int NULL
	)

    DECLARE @routeOfAdminIds TABLE
    (
        route_of_admin int  not null
    )

    DECLARE @orderCategoryIds TABLE
    (
        order_category_id int  not null
    )

    DECLARE @communicationMethodIds TABLE
    (
        method_id int  not null
    )

    DECLARE @orderStatus TABLE
    (
        [status] int  not null
    )

    DECLARE @integratedPharmacies TABLE
    (
        pharmacy_id int not null
    )

    DECLARE @supplyCriteria TABLE
    (
        phys_order_id int not null
    )

	  DECLARE @medicationClassificationIds TABLE
    (
        medication_classification_id varchar(10) not null
    )

    DECLARE @physOrderAllergies TABLE
    (
      phys_order_id int  NOT NULL
    )

    DECLARE @physOrderDrugInteraction TABLE
    (
      phys_order_id int  NOT NULL,
      severity_code varchar(1)
    )

    DECLARE @physOrderBlackbox TABLE
    (
      phys_order_id int  NOT NULL
    )

    DECLARE @physOrderDoseCheck TABLE
    (
      phys_order_id int  NOT NULL,
      over_dose varchar(1)
    )

    DECLARE @physOrderNoDrugProtocolCheck TABLE
    (
      phys_order_id int  NOT NULL
    )

	DECLARE @dischargePharmacyNCPDP TABLE
    (
        discharge_pharm_phys_order_id int not null
    )

	DECLARE @ordersHavingAlerts TABLE
	(
		phys_order_id int  NOT NULL
	)

SET @step = 1
    INSERT INTO @orderCategoryIds (order_category_id)
    select * from dbo.Split(@orderCategoryIdsCSV, ',')
	delete from @orderCategoryIds where order_category_id=1 or order_category_id=3030
SET @step = 2
    INSERT INTO @communicationMethodIds (method_id)
    select * from dbo.Split(@communicationMethodIdsCSV, ',')
SET @step = 3
    INSERT INTO @routeOfAdminIds (route_of_admin)
    select * from dbo.Split(replace(@routeOfAdminIdsCSV,'_',','), ',')
SET @step = 4
    INSERT INTO @orderStatus (status)
    select * from dbo.Split(@orderStatusCSV, ',');
	SET @includeStruckOutOrders = CASE WHEN EXISTS (SELECT os.status FROM @orderStatus os WHERE status = 4) THEN 'Y' ELSE 'N' END;
SET @step = 5
    INSERT INTO @medicationClassificationIds (medication_classification_id)
    select * from dbo.Split(@medicationclassification, ',')

SET @step = 41
	INSERT INTO @integratedPharmacies (pharmacy_id)
	select distinct extFacId from (
		SELECT mp.ext_fac_id as extFacId
			FROM message_profile mp WITH (NOLOCK)
			INNER JOIN lib_message_profile lmp WITH (NOLOCK)
				ON lmp.message_profile_id = mp.message_profile_id
			       AND lmp.deleted = 'N' and lmp.is_enabled='Y'
			WHERE mp.is_enabled = 'Y' and mp.is_integrated_pharmacy='Y'
			AND mp.fac_id = @facIdLocal
			AND mp.message_protocol_id = 12
			GROUP BY mp.ext_fac_id
		UNION
		SELECT distinct mi.internal_id as extFacId
			FROM map_identifier mi WITH (NOLOCK)
			INNER JOIN lib_message_profile libmp WITH (NOLOCK)
			ON libmp.vendor_code = mi.vendor_code
			AND libmp.deleted = 'N'
			INNER JOIN message_profile mp WITH (NOLOCK)
			ON libmp.message_profile_id = mp.message_profile_id
			WHERE mi.map_type_id = 3 and mp.fac_id = @facIdLocal and  mi.fac_id = @facIdLocal
	) a where extFacId is not null

-- put all criteria related to pho_order_supply in here so that we
-- can make sure they interact correctly and we don't need a hundred
-- different subqueries in the main query, also only populate it if
-- we're going to need it
SET @step = 42
    IF @supplyStatusId IS NOT NULL
          OR @fromIntegratedPharmacy IS NOT NULL
          OR @medSrcTypeId IS NOT NULL
    BEGIN
      INSERT INTO @supplyCriteria (phys_order_id)
        SELECT phys_order_id
          FROM pho_order_supply WITH (NOLOCK)
          WHERE (active = 'Y' OR active = 'N')
            AND deleted = 'N'
            AND (@supplyStatusId IS NULL OR status = @supplyStatusId)
            AND (
              @fromIntegratedPharmacy IS NULL
              OR (
                @fromIntegratedPharmacy = 'Y'
                AND pharmacy_id IN (select * from @integratedPharmacies)
              )
              OR (
                @fromIntegratedPharmacy = 'N'
                AND pharmacy_id NOT IN (select * from @integratedPharmacies)
              )
            )
            AND (@medSrcTypeId IS NULL OR med_src_type_id = @medSrcTypeId)
    END

set @step = 43
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Function call'
IF @debug='Y'
PRINT @status_text

DECLARE @now datetime
set @now = dbo.fn_facility_getCurrentTime(@facIdLocal)

insert into @vpos
exec sproc_pho_getOrderStatus  @facIdLocal,@clientIdLocal,@physOrderId,@now,'N',@debug,@status_code out,@status_text out

SET @step = 5
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Start getting med classification'
IF @debug='Y'
    PRINT @status_text


	declare @medicationclassificationTable table
	(
		phys_order_id	int
	)

	if( @medicationclassification is not null )
	BEGIN
		insert into @medicationclassificationTable
		SELECT distinct poelmr.phys_order_id from pho_order_ext_lib_med_ref poelmr WITH (NOLOCK) INNER JOIN
		(
			SELECT poelc.phys_order_ext_lib_rec_id, pho_ext_lib_class_id 'class_id' from pho_order_ext_lib_cls poelc WITH (NOLOCK)
			UNION
			SELECT poelc.phys_order_ext_lib_rec_id, pho_ext_lib_sub_class_id 'class_id' from pho_order_ext_lib_cls poelc WITH (NOLOCK)
		) classes ON classes.phys_order_ext_lib_rec_id = poelmr.phys_order_ext_lib_rec_id
		INNER JOIN @medicationClassificationIds mclassids on classes.class_id = mclassids.medication_classification_id
    INNER JOIN @vpos vpos on vpos.phys_order_id = poelmr.phys_order_id
	END


SET @step = 5
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert orders/client/mpi data.'
IF @debug='Y'
    PRINT @status_text

declare @clientInfo table
(
	fac_id int,
	client_id int,
	discharge_date datetime,
	client_id_number varchar(35),
	first_name	varchar(50),
	last_name	varchar(50)
)
insert into @clientInfo ( 	fac_id , client_id , discharge_date , client_id_number,first_name, last_name )
select distinct
	c.fac_id,
	c.client_id,
	 c.discharge_date
     , c.client_id_number
     , m.last_name
     , m.first_name
from
	clients c
	INNER JOIN mpi  m  WITH (NOLOCK) ON m.mpi_id = c.mpi_id
where
c.client_id = @clientIdLocal




SET @step = 5
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Get common data for queries.'
IF @debug='Y'
    PRINT @status_text

IF(@orderClassId_local > -1)
BEGIN
	insert into @orderData
	select
		distinct ppo.phys_order_id
				 ,vpos.order_status
				 ,vpos.order_relationship
				 ,vpos.status_reason
				 , ppo.fac_id
				 , ppo.client_id
				 , ppo.diet_type
				 , ppo.diet_texture
				 , ppo.diet_supplement
				 , ppo.fluid_consistency
				 , ppo.alter_med_src
				 , ppo.nurse_pharm_notes
				 , ppo.created_by
				 , createdBySu.long_username
				 , ppo.created_date
				 , ppo.date_ordered
				 , case when ppo.order_category_id=3031 then diettype.item_description
							 when ppo.order_category_id=3032 then dietsup.item_description
							 when ppo.order_category_id=3023 then diettype.item_description
							 when ppo.order_category_id=3033 then 'Enteral Feed'
							 else ppo.description
						end 'calculated_description'
				 , ppo.related_generic
				 , ppo.dispense_as_written
				 , ppo.directions
				 , ppo.strength
				 , ppo.drug_strength
				 , ppo.drug_strength_uom
				 , ppo.discontinued_date
				 , ppo.end_date
				 , ppo.hold_date
				 , ppo.hold_date_end
				 , ppo.last_reorder_date
				 , ppo.order_type_id
				 , ppo.order_category_id
				 , ordercat.category_desc
				 , ordercat.family_portal_sort_order
				 , ppo.order_date
				 , ppo.order_status
				 , ppo.physician_id
				 , ppo.reorder
				 , ppo.revision_by
				 , ppo.revision_date
				 , CASE WHEN useraudit.edited_date is null THEN ppo.revision_date ELSE useraudit.edited_date END  'useraudit.edited_date'
				 , ppo.route_of_admin
				 , ppo.start_date
				 , isnull(ppo.order_verified, 'Y') 'order_verified'
				 , ppo.next_refill_date
				 , ppo.do_not_fill
				 , ppo.first_documented
				 , ppo.origin_id
				 , ppo.controlled_substance_code
				 , ppo.pharmacy_id
				 , ppo.communication_method
				 , CASE WHEN ppone.phys_order_id is null THEN 'Y' ELSE 'N' END  'ppone.phys_order_id'
				 , c.discharge_date
				 , c.client_id_number
				 , c.last_name
				 , c.first_name
				 , ppo.orig_phys_order_id
				 , lib.pho_ext_lib_id
				 , lib.pho_ext_lib_med_id
				 , lib.pho_ext_lib_med_ddid
				 , lib.ext_lib_rxnorm_id
				 , ppo.vendor_phys_order_id
				 , case
					when pso.std_order_id is not null and (pso.advanced_directive=1) then 'Y'
					when pstd.std_phys_order_id is not null and (pstd.advanced_directive='Y') then 'Y'
					else 'N'
				  end as 'advanced_directive'
				, confirmed_by_audit_id
				, ppone.phys_order_id
				, ppo.description
				, ls.linked_set_id
				, ls.set_description
				, ppo.order_class_id
	from
		@clientInfo c
		INNER JOIN pho_phys_order ppo WITH (NOLOCK)
			ON c.client_id = ppo.client_id
		INNER JOIN @vpos vpos
			ON vpos.phys_order_id = ppo.phys_order_id
		LEFT JOIN pho_phys_order_new_entry ppone WITH (NOLOCK)
			ON ppone.phys_order_id = ppo.phys_order_id
		LEFT JOIN pho_order_ext_lib_med_ref lib WITH (NOLOCK)
			ON lib.phys_order_id = ppo.phys_order_id AND lib.deleted='N'
		LEFT JOIN pho_std_phys_order pstd WITH (NOLOCK)
			ON pstd.std_phys_order_id = ppo.std_order_id
		LEFT JOIN pho_std_order pso WITH (NOLOCK)
			ON pso.std_order_id = ppo.std_order_id
		LEFT JOIN pho_phys_order_useraudit useraudit WITH (NOLOCK)
			ON useraudit.phys_order_id = ppo.phys_order_id
		LEFT JOIN PHO_ORDER_CATEGORY ordercat WITH (NOLOCK)
     		ON ppo.order_category_id = ordercat.order_category_id
		LEFT JOIN sec_user createdBySu  WITH (NOLOCK)
     		ON createdBySu.loginname = ppo.created_by
		LEFT JOIN COMMON_CODE diettype WITH (NOLOCK)
			ON ppo.diet_type = diettype.item_id
		LEFT JOIN COMMON_CODE dietsup WITH (NOLOCK)
			ON ppo.diet_supplement = dietsup.item_id
		LEFT JOIN pho_linked_set_item lsi on lsi.phys_order_id=ppo.phys_order_id
		LEFT JOIN pho_linked_set ls on ls.linked_set_id=lsi.linked_set_id

	where
		( @physOrderId IS NULL OR ppo.phys_order_id = @physOrderId  )
		AND (isnull(ppo.active_flag, 'Y') = 'Y')
		AND
			(
				(@narcoticsOnly = 'N')
				OR
				(
					ppo.controlled_substance_code IS NOT NULL AND LTRIM(RTRIM(ppo.controlled_substance_code)) IN ('2','3','4','5','6','99')
				)
			)
		AND (@orderLinkedOption=3 or (@orderLinkedOption=2 and lsi.phys_order_id=ppo.phys_order_id)
			or (@orderLinkedOption=1 and lsi.phys_order_id is null))
		AND order_class_id = @orderClassId_local
END
ELSE -- get both Institutional orders and Discharge orders
BEGIN
	insert into @orderData
	select
		distinct ppo.phys_order_id
				 ,vpos.order_status
				 ,vpos.order_relationship
				 ,vpos.status_reason
				 , ppo.fac_id
				 , ppo.client_id
				 , ppo.diet_type
				 , ppo.diet_texture
				 , ppo.diet_supplement
				 , ppo.fluid_consistency
				 , ppo.alter_med_src
				 , ppo.nurse_pharm_notes
				 , ppo.created_by
				 , createdBySu.long_username
				 , ppo.created_date
				 , ppo.date_ordered
				 , case when ppo.order_category_id=3031 then diettype.item_description
							 when ppo.order_category_id=3032 then dietsup.item_description
							 when ppo.order_category_id=3023 then diettype.item_description
							 when ppo.order_category_id=3033 then 'Enteral Feed'
							 else ppo.description
						end 'calculated_description'
				 , ppo.related_generic
				 , ppo.dispense_as_written
				 , ppo.directions
				 , ppo.strength
				 , ppo.drug_strength
				 , ppo.drug_strength_uom
				 , ppo.discontinued_date
				 , ppo.end_date
				 , ppo.hold_date
				 , ppo.hold_date_end
				 , ppo.last_reorder_date
				 , ppo.order_type_id
				 , ppo.order_category_id
				 , ordercat.category_desc
				 , ordercat.family_portal_sort_order
				 , ppo.order_date
				 , ppo.order_status
				 , ppo.physician_id
				 , ppo.reorder
				 , ppo.revision_by
				 , ppo.revision_date
				 , CASE WHEN useraudit.edited_date is null THEN ppo.revision_date ELSE useraudit.edited_date END  'useraudit.edited_date'
				 , ppo.route_of_admin
				 , ppo.start_date
				 , isnull(ppo.order_verified, 'Y') 'order_verified'
				 , ppo.next_refill_date
				 , ppo.do_not_fill
				 , ppo.first_documented
				 , ppo.origin_id
				 , ppo.controlled_substance_code
				 , ppo.pharmacy_id
				 , ppo.communication_method
				 , CASE WHEN ppone.phys_order_id is null THEN 'Y' ELSE 'N' END  'ppone.phys_order_id'
				 , c.discharge_date
				 , c.client_id_number
				 , c.last_name
				 , c.first_name
				 , ppo.orig_phys_order_id
				 , lib.pho_ext_lib_id
				 , lib.pho_ext_lib_med_id
         , lib.pho_ext_lib_med_ddid
         , lib.ext_lib_rxnorm_id
				 , ppo.vendor_phys_order_id
				 , case
					when pso.std_order_id is not null and (pso.advanced_directive=1) then 'Y'
					when pstd.std_phys_order_id is not null and (pstd.advanced_directive='Y') then 'Y'
					else 'N'
				  end as 'advanced_directive'
				, confirmed_by_audit_id
				, ppone.phys_order_id
				, ppo.description
				, ls.linked_set_id
				, ls.set_description
				, ppo.order_class_id
	from
		@clientInfo c
		INNER JOIN pho_phys_order ppo WITH (NOLOCK)
			ON c.client_id = ppo.client_id
		INNER JOIN @vpos vpos
			ON vpos.phys_order_id = ppo.phys_order_id
		LEFT JOIN pho_phys_order_new_entry ppone WITH (NOLOCK)
			ON ppone.phys_order_id = ppo.phys_order_id
		LEFT JOIN pho_order_ext_lib_med_ref lib WITH (NOLOCK)
			ON lib.phys_order_id = ppo.phys_order_id AND lib.deleted='N'
		LEFT JOIN pho_std_phys_order pstd WITH (NOLOCK)
			ON pstd.std_phys_order_id = ppo.std_order_id
		LEFT JOIN pho_std_order pso WITH (NOLOCK)
			ON pso.std_order_id = ppo.std_order_id
		LEFT JOIN pho_phys_order_useraudit useraudit WITH (NOLOCK)
			ON useraudit.phys_order_id = ppo.phys_order_id
		LEFT JOIN PHO_ORDER_CATEGORY ordercat WITH (NOLOCK)
     		ON ppo.order_category_id = ordercat.order_category_id
		LEFT JOIN sec_user createdBySu  WITH (NOLOCK)
     		ON createdBySu.loginname = ppo.created_by
		LEFT JOIN COMMON_CODE diettype WITH (NOLOCK)
			ON ppo.diet_type = diettype.item_id
		LEFT JOIN COMMON_CODE dietsup WITH (NOLOCK)
			ON ppo.diet_supplement = dietsup.item_id
		LEFT JOIN pho_linked_set_item lsi on lsi.phys_order_id=ppo.phys_order_id
		LEFT JOIN pho_linked_set ls on ls.linked_set_id=lsi.linked_set_id

	where
		( @physOrderId IS NULL OR ppo.phys_order_id = @physOrderId  )
		AND (isnull(ppo.active_flag, 'Y') = 'Y')
		AND
			(
				(@narcoticsOnly = 'N')
				OR
				(
					ppo.controlled_substance_code IS NOT NULL AND LTRIM(RTRIM(ppo.controlled_substance_code)) IN ('2','3','4','5','6','99')
				)
			)
		AND (@orderLinkedOption=3 or (@orderLinkedOption=2 and lsi.phys_order_id=ppo.phys_order_id)
			or (@orderLinkedOption=1 and lsi.phys_order_id is null))
END

-- remove the orders from @orderData that does not match the discharge order pharmacy only when discharge order and when the pharmacy search is provided
IF(@pharmacyNCPDP_local is not null)
BEGIN
	insert into @dischargePharmacyNCPDP
	select s.phys_order_id from pho_phys_order_discharge_snapshot s
	inner join @orderData o on o.phys_order_id = s.phys_order_id and o.order_class_id = 2
	where ncpdp_identifier = @pharmacyNCPDP_local

	delete from @orderData where order_class_id = 2 and phys_order_id NOT IN (select discharge_pharm_phys_order_id from @dischargePharmacyNCPDP)
END

SET @step = 5
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert non struckout orders into cache'
IF @debug='Y'
    PRINT @status_text
    INSERT INTO @result
    SELECT
		distinct
		 ppo.phys_order_id
        ,ppo.status
        ,ppo.relationship
        ,ppo.status_reason
        ,ppo.fac_id
        ,ppo.client_id
        ,ppo.diet_type
        ,ppo.diet_texture
        ,ppo.diet_supplement
        ,ppo.fluid_consistency
        ,ppo.alter_med_src
        ,ppo.nurse_pharm_notes
        ,ppo.created_by
        ,ppo.created_by_longname
        ,ppo.created_date
        ,ppo.date_ordered
        ,ppo.calculated_description
        ,ppo.related_generic
        ,ppo.dispense_as_written
        ,ppo.directions
		,ppo.strength
        ,ppo.drug_strength
        ,ppo.drug_strength_uom
        ,ppo.discontinued_date
        ,ppo.end_date
        ,ppo.hold_date
        ,ppo.hold_date_end
        ,ppo.last_reorder_date
        ,ppo.order_type_id
        ,ppo.order_category_id
        ,ppo.order_category_description
        ,ppo.family_portal_sort_order
        ,ppo.order_date
        ,ppo.order_status
        ,ppo.physician_id
        ,ppo.reorder
        ,ppo.revision_by
        ,ppo.revision_date
        ,ppo.edited_date
        ,ppo.route_of_admin
        ,ppo.start_date
        ,ppo.order_verified
        ,ppo.next_refill_date
        ,ppo.do_not_fill
        ,ppo.first_documented
        ,ppo.origin_id
        ,ppo.controlled_substance_code
        ,ppo.pharmacy_id
        ,ppo.communication_method
        ,ppo.legacy_order
        ,ppo.discharge_date
        ,ppo.client_id_number

        ,ppo.resident_last_name
        ,ppo.resident_first_name
        ,ppo.orig_phys_order_id
        ,ppo.pho_ext_lib_id
        ,ppo.pho_ext_lib_med_id
        ,ppo.pho_ext_lib_med_ddid
        ,ppo.ext_lib_rxnorm_id
		,null
		,null
		,null
		,ppo.vendor_phys_order_id
		,ppo.advanced_directive
        ,ppo.end_date
		,ppo.linked_set_id
		,ppo.linked_set_name
		,ppo.order_class_id
           FROM
				@orderData ppo
				INNER JOIN @orderStatus os
					on  os.status = ppo.status
				INNER JOIN @communicationMethodIds cm
					ON cm.method_id = isnull(ppo.communication_method, 3027)
				INNER JOIN @orderCategoryIds oc
					ON oc.order_category_id = ppo.order_category_id
				LEFT JOIN pho_order_type orderType WITH (NOLOCK)
            		ON ppo.order_type_id = orderType.order_type_id
				LEFT JOIN pho_order_supply pos
        			ON ppo.phys_order_id = pos.phys_order_id
				LEFT JOIN pho_phys_order_useraudit  useraudit
				    on useraudit.phys_order_id = ppo.phys_order_id
				LEFT JOIN pho_administration_record  adminRecord WITH (NOLOCK)
            		ON orderType.administration_record_id = adminRecord.administration_record_id
				LEFT JOIN cp_sec_user_audit confuser  WITH (NOLOCK)
					ON confuser.cp_sec_user_audit_id = ppo.confirmed_by_audit_id
				LEFT JOIN contact physcon ON physcon.contact_id = ppo.physician_id
            WHERE

                (@providerId IS NULL OR ppo.pharmacy_id = @providerId)
                AND
                (@orderedById IS NULL OR ppo.physician_id = @orderedById OR ppo.physician_id = @oldOrderById)
                AND
                (@orderTypeId IS NULL OR ppo.order_type_id = @orderTypeId)
                AND
                (@adminRecordId IS NULL OR adminRecord.administration_record_id = @adminRecordId)
                AND
                (@routeOfAdminIdsCSV IS NULL OR ppo.route_of_admin IN (SELECT route_of_Admin from @routeOfAdminIds))
                AND
                (@medicationSourceId IS NULL OR ppo.alter_med_src = @medicationSourceId)
                AND
                (@pharmacyId IS NULL OR ppo.pharmacy_id = @pharmacyId)
                AND
                (@createdBy is NULL OR ppo.created_by = @createdBy)
                AND
				(@confirmedBy is NULL OR confuser.loginname = @confirmedBy)

                --AND
                -- do not show invalid category and administrative orders
                --ppo.order_category_id <> 1 AND ppo.order_category_id <> 3030
                AND
                (
                    (@orderDate IS NULL OR @orderDateoperator IS NULL)
                    OR
                    (
                        (@orderDateoperator = 0 AND ppo.order_date >= @orderDate AND ppo.order_date < @orderDate + 1)
                        OR (@orderDateoperator = 1 AND ppo.order_date >= @orderDate + 1)
                        OR (@orderDateoperator = -1 AND ppo.order_date < @orderDate)
                    )
                )
                AND
                (
                    (@startDate IS NULL OR @startDateoperator IS NULL)
                    OR
                    (
                        (@startDateoperator = 0 AND ppo.start_date >= @startDate AND ppo.start_date < @startDate + 1)
                        OR (@startDateoperator = 1  AND ppo.start_date >= @startDate + 1)
                        OR (@startDateoperator = -1 AND ppo.start_date < @startDate)
                    )
                )
                AND
                (
                    (@endDate IS NULL OR @endDateoperator IS NULL)
                    OR
                    (
                        (@endDateoperator = 0 AND ppo.end_date >= @endDate AND ppo.end_date < @endDate + 1)
                        OR (@endDateoperator = 1  AND (ppo.end_date >= @endDate + 1 OR ppo.end_date IS NULL))
                        OR (@endDateoperator = -1 AND ppo.end_date < @endDate)
                    )
                )
	            AND
	            (
	                (@discontinuedDate IS NULL OR @discontinuedDateoperator IS NULL)
	                OR
	                (
	                    (@discontinuedDateoperator = 0 AND ppo.discontinued_date >= @discontinuedDate AND ppo.discontinued_date < @discontinuedDate + 1)
	                    OR (@discontinuedDateoperator = 1  AND ppo.discontinued_date >= @discontinuedDate + 1)
	                    OR (@discontinuedDateoperator = -1 AND ppo.discontinued_date < @discontinuedDate)
	                )
	            )
				AND
	            (
	                --This condition is to handle historical orders case ie to filter historical orders only when the proc is called in that scenario
					--If @historicalOrdersOnly = 'N' => the proc IS NOT called for historical orders only scenario and therefore this condition should not prevent returing the order (by testing order endDate and discontinuedDate)
					--If @historicalOrdersOnly = 'Y' but @historicalOrdersOnlyPeriodStart IS NULL => the proc IS called for historical orders only scenario but WITH NO limit on the period therefore this condition should not prevent returning the order neither (by testing order endDate and discontinuedDate)
					--If @historicalOrdersOnly = 'Y' and @historicalOrdersOnlyPeriodStart IS NOT NULL => the proc IS called for historical orders only scenario and WITH limit on the period and therefore, in order to be returned, order should fall in the specified period (order endDate and discontinuedDate should verify the below conditions)
					(@historicalOrdersOnlyPeriodStart IS NULL OR @historicalOrdersOnly = 'N')
	                OR
					(
					(ppo.end_Date IS NULL OR ppo.end_Date > @historicalOrdersOnlyPeriodStart)
					AND (ppo.discontinued_Date IS NULL OR ppo.discontinued_Date > @historicalOrdersOnlyPeriodStart)
					)

	            )
	            AND
	            (
	                (@holdDate IS NULL OR @holdDateoperator IS NULL)
	                OR
	                (
	                    (@holdDateoperator = 0 AND ppo.hold_date >= @holdDate AND ppo.hold_date < @holdDate + 1)
	                    OR (@holdDateoperator = 1  AND ppo.hold_date >= @holdDate + 1)
	                    OR (@holdDateoperator = -1 AND ppo.hold_date < @holdDate)
	                )
	            )
	            AND
	            (
	                (@completedDate IS NULL OR @completedDateoperator IS NULL)
	                OR
	                (
	                    (@completedDateoperator = 0 AND ppo.end_date >= @completedDate AND ppo.end_date < @completedDate + 1)
	                    OR (@completedDateoperator = 1  AND ppo.end_date >= @completedDate + 1)
	                    OR (@completedDateoperator = -1 AND ppo.end_date < @completedDate)
	                )
	            )
	            AND
	            (
	                (@confirmedDate IS NULL OR @confirmedDateoperator IS NULL)
	                OR
	                (
	                    (@confirmedDateoperator = 0 AND useraudit.confirmed_date >= @confirmedDate AND useraudit.confirmed_date < @confirmedDate + 1)
	                    OR (@confirmedDateoperator = 1  AND useraudit.confirmed_date >= @confirmedDate + 1)
	                    OR (@confirmedDateoperator = -1 AND useraudit.confirmed_date < @confirmedDate)
	                )
	            )
                AND
                (@showLegacyOrder IS NULL OR (@showLegacyOrder='Y' AND ppone_phys_order_id IS NULL) OR (@showLegacyOrder='N' AND ppone_phys_order_id IS NOT NULL))

                    AND
					(@medication IS NULL OR ppo.description LIKE '%' + @medication + '%' OR (pos.description LIKE '%' + @medication + '%'AND pos.active = 'Y'))
                    AND
                    (@clientIdNumber IS NULL OR client_id_number = @clientIdNumber)
                    AND
                    (
                        @clientStatus IS NULL
                        --discharged
                        OR (@clientStatus = 0 AND discharge_date IS NOT NULL AND discharge_date <= @facilityDateTime)
                        --active
                        OR (@clientStatus = 1 AND (discharge_date IS NULL OR discharge_date > @facilityDateTime))
                    )
                    AND
                    (
	                    @medicationclassification IS NULL OR
	                    ppo.phys_order_id  IN
	                    (
	                        select * from @medicationclassificationTable
	                    )
                    )
                    AND (
                      (
                        @supplyStatusId IS NULL
                        AND @fromIntegratedPharmacy IS NULL
                        AND @medSrcTypeId IS NULL
                      )
                      OR (
                        ppo.phys_order_id IN (select * from @supplyCriteria)
                      )
                    )
                    AND
                    ( @physOrderId IS NULL OR ppo.phys_order_id = @physOrderId  )
					AND (physcon.deleted = CASE WHEN @includeRetired = 'Y' THEN physcon.deleted ELSE 'N' END  OR ppo.physician_id IS NULL OR physcon.deleted is NULL)

            ORDER BY ppo.revision_by desc


--PCC-26565: Any orders (regardless of status) with alerts should always show in orders chart
SET @step = 51
if (@alwaysShowOrderWithAlert = 'Y')
BEGIN
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert orders having alerts into cache - considering duplicated order id'

	INSERT INTO @ordersHavingAlerts
	SELECT DISTINCT
	ppo.phys_order_id
	FROM @orderData ppo
	INNER JOIN cr_alert ca WITH (NOLOCK) ON
											ca.fac_id = ppo.fac_id
											AND ca.client_id = ppo.client_id
											AND ca.triggered_item_id = ppo.phys_order_id
											AND ca.triggered_item_type = 'O'
											AND ca.resolved <> 'Y'
											AND ca.deleted = 'N'
	WHERE ppo.status = 3 -- Consider Completed orders only

if (@showOrdersWithIntegrationAlerts = 'Y')
	INSERT INTO @ordersHavingAlerts
	SELECT DISTINCT
	ppo.phys_order_id
	FROM @orderData ppo
	INNER JOIN cr_alert ca WITH (NOLOCK) ON
											ca.fac_id = ppo.fac_id
											AND ca.client_id = ppo.client_id
											AND ca.triggered_item_id = ppo.phys_order_id
											AND ca.triggered_item_type = 'M'
											AND ca.resolved <> 'Y'
											AND ca.deleted = 'N'


if(@showOrdersWithSupplyIntegrationAlerts = 'Y')
	INSERT INTO @ordersHavingAlerts
	SELECT DISTINCT
	ppo.phys_order_id
	FROM @orderData ppo
	INNER JOIN pho_order_supply s ON s.phys_order_id = ppo.phys_order_id
	INNER JOIN cr_alert ca WITH (NOLOCK) ON
											ca.fac_id = ppo.fac_id
											AND ca.client_id = ppo.client_id
											AND ca.triggered_item_id = s.order_supply_id
											AND ca.triggered_item_type = 'D'
											AND ca.resolved <> 'Y'
											AND ca.deleted = 'N'


IF @debug='Y'
    PRINT @status_text
    INSERT INTO @result
    SELECT distinct
			ppo.phys_order_id
        ,ppo.status
        ,ppo.relationship
        ,ppo.status_reason
        ,ppo.fac_id
        ,ppo.client_id
        ,ppo.diet_type
        ,ppo.diet_texture
        ,ppo.diet_supplement
        ,ppo.fluid_consistency
        ,ppo.alter_med_src
        ,ppo.nurse_pharm_notes
        ,ppo.created_by
        ,ppo.created_by_longname
        ,ppo.created_date
        ,ppo.date_ordered
        ,ppo.calculated_description
        ,ppo.related_generic
        ,ppo.dispense_as_written
        ,ppo.directions
		,ppo.strength
        ,ppo.drug_strength
        ,ppo.drug_strength_uom
        ,ppo.discontinued_date
        ,ppo.end_date
        ,ppo.hold_date
        ,ppo.hold_date_end
        ,ppo.last_reorder_date
        ,ppo.order_type_id
        ,ppo.order_category_id
        ,ppo.order_category_description
        ,ppo.family_portal_sort_order
        ,ppo.order_date
        ,ppo.order_status
        ,ppo.physician_id
        ,ppo.reorder
        ,ppo.revision_by
        ,ppo.revision_date
        ,ppo.edited_date
        ,ppo.route_of_admin
        ,ppo.start_date
        ,ppo.order_verified
        ,ppo.next_refill_date
        ,ppo.do_not_fill
        ,ppo.first_documented
        ,ppo.origin_id
        ,ppo.controlled_substance_code
        ,ppo.pharmacy_id
        ,ppo.communication_method
        ,ppo.legacy_order
        ,ppo.discharge_date
        ,ppo.client_id_number
        ,ppo.resident_last_name
        ,ppo.resident_first_name
        ,ppo.orig_phys_order_id
        ,ppo.pho_ext_lib_id
        ,ppo.pho_ext_lib_med_id
        ,ppo.pho_ext_lib_med_ddid
        ,ppo.ext_lib_rxnorm_id
		,null
		,null
		,null
		,ppo.vendor_phys_order_id
		,ppo.advanced_directive
		,ppo.end_date
		,ppo.linked_set_id
		,ppo.linked_set_name
		,ppo.order_class_id
           FROM
            @orderData ppo
			INNER JOIN @orderCategoryIds oc
				ON oc.order_category_id = ppo.order_category_id
			INNER JOIN @ordersHavingAlerts oha ON oha.phys_order_id = ppo.phys_order_id
			LEFT JOIN contact physcon ON physcon.contact_id = ppo.physician_id
             WHERE
				oha.phys_order_id not in ( select phys_order_id from @result )
				AND (physcon.deleted = CASE WHEN @includeRetired = 'Y' THEN physcon.deleted ELSE 'N' END OR ppo.physician_id IS NULL OR physcon.deleted is NULL)
                --AND
                -- do not show invalid category and administrative orders
                --ppo.order_category_id <> 1 AND ppo.order_category_id <> 3030

            ORDER BY ppo.revision_by desc
END

SET @step = 6
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert struckout orders into cache = "' + CONVERT(VARCHAR(1), @includeStruckOutOrders) + '"';
IF @debug='Y'
    PRINT @status_text;
	IF @includeStruckOutOrders = 'Y'
	BEGIN
		WITH AUDIT AS
		(
			SELECT
				ppo.phys_order_id 'phys_order_id'
				 ,4  'status'
				 ,NULL	as relationship
				 ,NULL  as status_reason
				 , ppo.fac_id 'fac_id'
				 , ppo.client_id 'client_id'
				 , ppo.diet_type 'diet_type'
				 , ppo.diet_texture 'diet_texture'
				 , ppo.diet_supplement 'diet_supplement'
				 , ppo.fluid_consistency 'fluid_consistency'
				 , ppo.alter_med_src 'alter_med_src'
				 , ppo.created_by 'created_by'
				 --, createdBySu.long_username 'created_by_longname'
				 , ppo.created_date 'created_date'
				 , ppo.date_ordered 'date_ordered'
				/* , case when ppo.order_category_id=3031 then diettype.item_description
							 when ppo.order_category_id=3032 then dietsup.item_description
							 when ppo.order_category_id=3023 then diettype.item_description
							 when ppo.order_category_id=3033 then 'Enteral Feed'
							 else ppo.description
						end 'description'*/
				 , ppo.related_generic 'related_generic'
				 , ppo.dispense_as_written 'dispense_as_written'
				 , ppo.directions 'directions'
				 , ppo.strength
				 , ppo.drug_strength 'drug_strength'
				 , ppo.drug_strength_uom 'drug_strength_uom'
				 , ppo.discontinued_date 'discontinued_date'
				 , ppo.end_date 'end_date'
				 , ppo.hold_date 'hold_date'
				 , ppo.hold_date_end 'hold_date_end'
				 , ppo.last_reorder_date 'last_reorder_date'
				 , ppo.order_type_id 'order_type_id'
				 , ppo.order_category_id 'order_category_id'
				-- , ordercat.category_desc  'order_category_description'
				 , ppo.order_date 'order_date'
				 , ppo.order_status 'order_status'
				 , ppo.physician_id 'physician_id'
				 , ppo.reorder 'reorder'
				 , ppo.revision_by 'revision_by'
				 , ppo.revision_date 'revision_date'
				 , ppo.revision_date 'edited_date'
				 , ppo.route_of_admin 'route_of_admin'
				 , ppo.start_date 'start_date'
				 , isnull(ppo.order_verified, 'Y') 'order_verified'
				 , ppo.next_refill_date 'next_refill_date'
				 , ppo.do_not_fill 'do_not_fill'
				 , ppo.first_documented 'first_documented'
				 , ppo.origin_id 'origin_id'
				 , ppo.controlled_substance_code 'controlled_substance_code'
				 , ppo.pharmacy_id 'pharmacy_id'
				 , ppo.communication_method 'communication_method'
				-- , CASE WHEN ppone.phys_order_id is null THEN 'Y' ELSE 'N' END  'legacy_order'
				 , c.discharge_date 'discharge_date'
				 , c.client_id_number 'client_id_number'
				 , c.last_name 'resident_last_name'
				 , c.first_name 'resident_first_name'
				 , ppo.orig_phys_order_id 'orig_phys_order_id'
			   --  , lib.pho_ext_lib_id
			   --  , lib.pho_ext_lib_med_id
				 , ppo.strikeout_date
				 , ppo.strikeout_by
			   --  , strike_code.item_description 'strikeout_reason_description'
  	     		 , ppo.vendor_phys_order_id
  			  --	 , isnull(pstd.advanced_directive, 'N') 'advanced_directive'

		--added
				,ppo.std_order_id
				,ppo.active_flag
				,ppo.description
				,ppo.strikeout_reason_code
				,c.first_name
				,c.last_name
				,order_class_id
			FROM
					pho_phys_order_audit ppo WITH (NOLOCK)
					INNER JOIN @clientInfo c
						ON c.client_id = ppo.client_id
					INNER JOIN @orderStatus os
						on  os.status = 4
			WHERE
					ppo.event_type = 'S'
					--required
					AND ppo.fac_id = @facIdLocal
					AND c.fac_id = @facIdLocal
					AND ppo.order_class_id = @orderClassId_local
		)

		INSERT INTO @result
		SELECT distinct adt.phys_order_id 'phys_order_id'
				 ,4 'status'
				 ,NULL
				 ,NULL
				 , adt.fac_id 'fac_id'
				 , adt.client_id 'client_id'
				 , adt.diet_type 'diet_type'
				 , adt.diet_texture 'diet_texture'
				 , adt.diet_supplement 'diet_supplement'
				 , adt.fluid_consistency 'fluid_consistency'
				 , adt.alter_med_src 'alter_med_src'
				 , null
				 , adt.created_by 'created_by'
				 , createdBySu.long_username 'created_by_longname'
				 , adt.created_date 'created_date'
				 , adt.date_ordered 'date_ordered'
				 , case when adt.order_category_id=3031 then diettype.item_description
							 when adt.order_category_id=3032 then dietsup.item_description
							 when adt.order_category_id=3023 then diettype.item_description
							 when adt.order_category_id=3033 then 'Enteral Feed'
							 else adt.description
						end 'description'
				 , adt.related_generic 'related_generic'
				 , adt.dispense_as_written 'dispense_as_written'
				 , adt.directions 'directions'
				 , adt.strength
				 , adt.drug_strength 'drug_strength'
				 , adt.drug_strength_uom 'drug_strength_uom'
				 , adt.discontinued_date 'discontinued_date'
				 , adt.end_date 'end_date'
				 , adt.hold_date 'hold_date'
				 , adt.hold_date_end 'hold_date_end'
				 , adt.last_reorder_date 'last_reorder_date'
				 , adt.order_type_id 'order_type_id'
				 , adt.order_category_id 'order_category_id'
				 , ordercat.category_desc  'order_category_description'
				 , ordercat.family_portal_sort_order 'family_portal_sort_order'
				 , adt.order_date 'order_date'
				 , adt.order_status 'order_status'
				 , adt.physician_id 'physician_id'
				 , adt.reorder 'reorder'
				 , adt.revision_by 'revision_by'
				 , adt.revision_date 'revision_date'
				 , adt.revision_date 'edited_date'
				 , adt.route_of_admin 'route_of_admin'
				 , adt.start_date 'start_date'
				 , isnull(adt.order_verified, 'Y') 'order_verified'
				 , adt.next_refill_date 'next_refill_date'
				 , adt.do_not_fill 'do_not_fill'
				 , adt.first_documented 'first_documented'
				 , adt.origin_id 'origin_id'
				 , adt.controlled_substance_code 'controlled_substance_code'
				 , adt.pharmacy_id 'pharmacy_id'
				 , adt.communication_method 'communication_method'
				 , CASE WHEN ppone.phys_order_id is null THEN 'Y' ELSE 'N' END  'legacy_order'
				 , adt.discharge_date 'discharge_date'
				 , adt.client_id_number 'client_id_number'
				 , adt.last_name 'resident_last_name'
				 , adt.first_name 'resident_first_name'
				 , adt.orig_phys_order_id 'orig_phys_order_id'
				 , lib.pho_ext_lib_id
				 , lib.pho_ext_lib_med_id
				 , lib.pho_ext_lib_med_ddid
				 , lib.ext_lib_rxnorm_id

				 , adt.strikeout_date
				 , adt.strikeout_by
				 , strike_code.item_description 'strikeout_reason_description'
  	     		 , adt.vendor_phys_order_id
				 , case
					when pso.std_order_id is not null and (pso.advanced_directive=1) then 'Y'
					when pstd.std_phys_order_id is not null and (pstd.advanced_directive='Y') then 'Y'
					else 'N'
				  end as 'advanced_directive'
  	      		 ,adt.end_date
				 ,null
				 ,null
				 ,adt.order_class_id
				FROM AUDIT adt
					/*pho_phys_order_audit ppo WITH (NOLOCK)
					INNER JOIN @clientInfo c
						ON c.client_id = ppo.client_id
					INNER JOIN @orderStatus os
						on  os.status = 4*/
					INNER JOIN @communicationMethodIds cm
						ON cm.method_id = isnull(adt.communication_method, 3027)
					INNER JOIN @orderCategoryIds oc
						ON oc.order_category_id = adt.order_category_id
					LEFT JOIN pho_order_type orderType  WITH (NOLOCK)
        				ON adt.order_type_id = orderType.order_type_id
					LEFT JOIN pho_order_supply pos
        				ON adt.phys_order_id = pos.phys_order_id
					LEFT JOIN pho_administration_record  adminRecord WITH (NOLOCK)
        				ON orderType.administration_record_id = adminRecord.administration_record_id
					LEFT JOIN pho_phys_order_new_entry ppone WITH (NOLOCK)
						ON ppone.phys_order_id = adt.phys_order_id
					LEFT JOIN pho_order_ext_lib_med_ref lib WITH (NOLOCK)
						ON lib.phys_order_id = adt.phys_order_id
					LEFT JOIN COMMON_CODE strike_code WITH (NOLOCK)
						ON strike_code.item_id = adt.strikeout_reason_code
					LEFT JOIN pho_phys_order_useraudit useraudit WITH (NOLOCK)
							ON useraudit.phys_order_id = adt.phys_order_id
					LEFT JOIN cp_sec_user_audit confuser  WITH (NOLOCK)
							ON confuser.cp_sec_user_audit_id = useraudit.confirmed_by_audit_id
					LEFT JOIN pho_std_phys_order pstd WITH (NOLOCK)
						ON pstd.std_phys_order_id = adt.std_order_id
					LEFT JOIN pho_std_order pso WITH (NOLOCK)
						ON pso.std_order_id = adt.std_order_id
					LEFT JOIN PHO_ORDER_CATEGORY ordercat WITH (NOLOCK)
        				ON adt.order_category_id = ordercat.order_category_id
        			LEFT JOIN sec_user createdBySu  WITH (NOLOCK)
        				ON createdBySu.loginname = adt.created_by
					-- for sorting on description
					LEFT JOIN COMMON_CODE diettype WITH (NOLOCK)
						ON adt.diet_type = diettype.item_id
					LEFT JOIN COMMON_CODE dietsup WITH (NOLOCK)
						ON adt.diet_supplement = dietsup.item_id
					LEFT JOIN CONTACT physcon
					ON adt.physician_id = physcon.contact_id

					WHERE
					/*ppo.event_type = 'S'

					--required
					AND adt.fac_id = @facIdLocal
					AND c.fac_id = @facIdLocal
					AND*/
					(@providerId IS NULL OR adt.pharmacy_id = @providerId)
					AND
					(@orderedById IS NULL OR adt.physician_id = @orderedById OR adt.physician_id = @oldOrderById)
					AND
					(@orderTypeId IS NULL OR adt.order_type_id = @orderTypeId)
					AND
					(@adminRecordId IS NULL OR adminRecord.administration_record_id = @adminRecordId)
					AND
					(@routeOfAdminIdsCSV IS NULL OR adt.route_of_admin IN (SELECT route_of_Admin from @routeOfAdminIds))
					AND
					(@medicationSourceId IS NULL OR adt.alter_med_src = @medicationSourceId)
					AND
					(@pharmacyId IS NULL OR adt.pharmacy_id = @pharmacyId)
					AND
					(@createdBy is NULL OR adt.created_by = @createdBy)
					AND
					(@confirmedBy is NULL OR confuser.loginname = @confirmedBy)

					--AND
					-- do not show invalid category and administrative orders
					--ppo.order_category_id <> 1 AND ppo.order_category_id <> 3030
					AND
					(
						(@orderDate IS NULL OR @orderDateoperator IS NULL)
						OR
						(
							(@orderDateoperator = 0 AND adt.order_date >= @orderDate AND adt.order_date < @orderDate + 1)
							OR (@orderDateoperator = 1 AND adt.order_date >= @orderDate + 1)
							OR (@orderDateoperator = -1 AND adt.order_date < @orderDate)
						)
					)
					AND
					(
						(@startDate IS NULL OR @startDateoperator IS NULL)
						OR
						(
							(@startDateoperator = 0 AND adt.start_date >= @startDate AND adt.start_date < @startDate + 1)
							OR (@startDateoperator = 1  AND adt.start_date >= @startDate + 1)
							OR (@startDateoperator = -1 AND adt.start_date < @startDate)
						)
					)
					AND
					(
						(@endDate IS NULL OR @endDateoperator IS NULL)
						OR
						(
							(@endDateoperator = 0 AND adt.end_date >= @endDate AND adt.end_date < @endDate + 1)
							OR (@endDateoperator = 1  AND (adt.end_date >= @endDate + 1 OR adt.end_date IS NULL))
							OR (@endDateoperator = -1 AND adt.end_date < @endDate)
						)
					)
					AND
					(@showLegacyOrder IS NULL OR (@showLegacyOrder='Y' AND ppone.phys_order_id IS NULL) OR (@showLegacyOrder='N' AND ppone.phys_order_id IS NOT NULL))

						AND
						(@medication IS NULL OR adt.description LIKE '%' + @medication + '%' OR (pos.description LIKE '%' + @medication + '%'AND pos.active = 'Y'))
						AND
						(@clientIdNumber IS NULL OR adt.client_id_number = @clientIdNumber)
						AND
						(
							@clientStatus IS NULL
							--discharged
							OR (@clientStatus = 0 AND adt.discharge_date IS NOT NULL AND adt.discharge_date <= @facilityDateTime)
							--active
							OR (@clientStatus = 1 AND (adt.discharge_date IS NULL OR adt.discharge_date > @facilityDateTime))
						)
						AND
						(
							@medicationclassification IS NULL OR
							adt.phys_order_id  IN
							(
								select * from @medicationclassificationTable
							)
						)
						AND (
						  (
							@supplyStatusId IS NULL
							AND @fromIntegratedPharmacy IS NULL
							AND @medSrcTypeId IS NULL
						  )
						  OR (
							adt.phys_order_id IN (select * from @supplyCriteria)
						  )
						)
						AND
						( @physOrderId IS NULL OR adt.phys_order_id = @physOrderId  )
						AND
						(isnull(adt.active_flag, 'Y') = 'Y')
						AND (physcon.deleted = CASE WHEN @includeRetired = 'Y' THEN physcon.deleted ELSE 'N' END OR adt.physician_id IS NULL OR physcon.deleted is NULL)
				ORDER BY adt.revision_by desc
	END

SET @step = 7
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Do pagination'
IF @debug='Y'
    PRINT @status_text

select @num_records = count(*) from @result

-- when page number is 2 and there is only one page
-- hur 34499
if  @pageSize > 0 and (@pageSize * (@pageNumber-1)) >= @num_records
begin
	set @pageNumber = 1
end

IF (@sortByColumn = 'end_date')
BEGIN
	update  r
		set r.end_date_filter = r.discontinued_date from @result r where r.discontinued_date is not null
END

IF @sortByOrder='desc'
BEGIN
	;with tmp as
	(
		select row_number() over(ORDER BY
									 case
										when @sortByColumn = 'resident_last_name' then resident_last_name
										when @sortByColumn = 'description' then description
										when @sortByColumn = 'status' then CONVERT(varchar(50),status)
										when @sortByColumn = 'order_category_description' then order_category_description
										when @sortByColumn = 'created_date' then CONVERT(varchar(50),created_date,112)
										when @sortByColumn = 'created_by_longname' then created_by_longname
										when @sortByColumn = 'revision_date' then CONVERT(varchar(50),edited_date,112)
										when @sortByColumn = 'start_date' then CONVERT(varchar(50),start_date,112)
										when @sortByColumn = 'end_date' then CONVERT(varchar(50),end_date_filter,112)
										when @sortByColumn = 'family_portal_sort_order' then CONVERT(varchar(50),family_portal_sort_order)
										else CONVERT(varchar(50),revision_date,112)
									end
									desc) as rn from @result
	)
		-- hur 34499
		delete from tmp where @pageSize > 0 and (rn <= (@pageSize * (@pageNumber-1)) or rn > (@pageSize * @pageNumber))
END
ELSE
BEGIN
	;with tmp as
	(
		select row_number() over(ORDER BY
										case
										when @sortByColumn = 'resident_last_name' then resident_last_name
										when @sortByColumn = 'description' then description
										when @sortByColumn = 'status' then CONVERT(varchar(50),status)
										when @sortByColumn = 'order_category_description' then order_category_description
										when @sortByColumn = 'created_date' then CONVERT(varchar(50),created_date,112)
										when @sortByColumn = 'created_by_longname' then created_by_longname
										when @sortByColumn = 'start_date' then CONVERT(varchar(50),start_date,112)
										when @sortByColumn = 'end_date' then CONVERT(varchar(50),end_date_filter,112)
										when @sortByColumn = 'revision_date' then CONVERT(varchar(50),edited_date,112)
										when @sortByColumn = 'family_portal_sort_order' then CONVERT(varchar(50),family_portal_sort_order)
										else CONVERT(varchar(50),revision_date,112)
									end
									asc ) as rn from @result
	)
		-- hur 34499
		delete from tmp where @pageSize > 0 and (rn <= (@pageSize * (@pageNumber-1)) or rn > (@pageSize * @pageNumber))
END


SET @step = 7
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Select allergies for given page of orders'
IF @debug='Y'
    PRINT @status_text

--Do this near the end so we can avoid having to join onto the pho_phys_order and pho_phys_order_audit table directly
--Here we can just use the "page" to get only the needed allergies
IF(@drugAllergyCheckEnabled='Y')
BEGIN

 INSERT INTO @physOrderAllergies
 SELECT DISTINCT r.phys_order_id
  FROM @result r
  LEFT JOIN pho_order_supply pos on pos.phys_order_id=r.phys_order_id AND (pos.active = 'Y' and (pos.status=3 or pos.status=4 or pos.status=8)) AND pos.deleted = 'N' -- Only consider active and ("processed by pharmacy", "on hand" or reordered) supplies
  LEFT JOIN pho_phys_order_allergy_acknowledgement pa on pa.phys_order_id = r.phys_order_id
  LEFT JOIN pho_order_supply_allergy posa on posa.order_supply_id = pos.order_supply_id
  INNER JOIN allergy a on (a.allergy_id = pa.allergy_id or a.allergy_id=posa.allergy_id) AND a.client_id=@clientId
 WHERE (status_id=1 or a.status_id=3) AND (resolved_date is null OR resolved_date > @facilityDateTime)


END

SET @step = 7.1
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Select related Drugs for a given page of orders'
IF @debug='Y'
    PRINT @status_text

--Do this near the end so we can avoid having to join onto the pho_phys_order and pho_phys_order_audit table directly
--Here we can just use the "page" to get only the needed related drugs

IF(@drugInteractionEnabled='Y')
BEGIN
 INSERT INTO @physOrderDrugInteraction
 SELECT DISTINCT r.phys_order_id , pda.severity_code
  FROM @result r
  LEFT JOIN pho_order_supply pos on pos.phys_order_id=r.phys_order_id AND (pos.active = 'Y' and (pos.status=3 or pos.status=4 or pos.status=8)) AND pos.deleted = 'N' -- Only consider active and ("processed by pharmacy", "on hand" or reordered) supplies
  INNER JOIN pho_phys_order_drug_acknowledgement pda on pda.phys_order_id = r.phys_order_id
END

IF(@blackBoxEnabled='Y')
BEGIN
 INSERT INTO @physOrderBlackbox
 SELECT DISTINCT r.phys_order_id
  FROM @result r
  LEFT JOIN pho_order_supply pos on pos.phys_order_id=r.phys_order_id AND (pos.active = 'Y' and (pos.status=3 or pos.status=4 or pos.status=8)) AND pos.deleted = 'N' -- Only consider active and ("processed by pharmacy", "on hand" or reordered)supplies
  INNER JOIN pho_phys_order_blackbox_acknowledgement pba on pba.phys_order_id = r.phys_order_id
END

IF(@doseCheckEnabled='Y')
BEGIN
  INSERT INTO @physOrderDoseCheck
  SELECT DISTINCT r.phys_order_id,pba.over_dose
  FROM @result r
  INNER JOIN pho_phys_order_dose_check_acknowledgement pba on pba.phys_order_id = r.phys_order_id
END

IF(@drugInteractionEnabled='Y' or @blackBoxEnabled='Y' or @doseCheckEnabled='Y')
BEGIN
  INSERT INTO @physOrderNoDrugProtocolCheck
  SELECT DISTINCT r.phys_order_id
  FROM @result r
  INNER JOIN pho_phys_order_no_drug_protocol_checks ndpc on ndpc.phys_order_id = r.phys_order_id
END


SET @step = 8

    /****************************************
    return final result
    ****************************************/
    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Return orders'
    IF @debug='Y'
        PRINT @status_text
    SELECT physorder.*

         , isnull(tpocs.pharmacy_confirmation_sent, 0) AS pharmacy_confirmation_sent
         , isnull(tpos.shipped, 0) AS shipped
         , ordercat.category_desc AS order_category_description
         , ordercat.family_portal_sort_order AS family_portal_sort_order
         , physcon.first_name AS physician_first_name
         , physcon.last_name AS physician_last_name
         , dietsup.item_description AS diet_supplement_description
         , diettexture.item_description AS diet_texture_description
         , diettype.item_description AS diet_type_description
         , fluidcon.item_description AS fluid_consistency_description
         , route.item_description AS route_description
         , adminRecord.short_description AS administration_record_short_description
         , altAdminRecord.short_description AS alt_administration_record_short_description
         , isnull(createdBySu.long_username, physorder.created_by) 'created_by_longname'
         , isnull(revisionBySu.long_username, physorder.created_by) 'revision_by_longname'
         , isnull(useraudit.created_by_audit_id, 0) AS created_by_audit_id
         , isnull(useraudit.edited_by_audit_id, 0) AS edited_by_audit_id
         , edituser.long_username AS edited_by_long
         , edituser.position_description AS edited_by_position
         , edituser.designation_desc AS edited_by_designation
         , createuser.long_username AS created_by_audit_long
         , createuser.position_description AS created_by_position
         , createuser.designation_desc AS created_by_designation
         , useraudit.confirmed_date
         , isnull(useraudit.confirmed_by_audit_id, 0) AS confirmed_by_audit_id
         , confuser.long_username AS confirmed_by_long
         , confuser.position_description AS confirmed_by_position
         , confuser.designation_desc AS confirmed_by_designation
         , eef.name as pharmacy_name
         , poa.phys_order_id AS allergy_phys_order_id
         , pob.phys_order_id AS blackbox_phys_order_id
         , pdc.phys_order_id AS dose_check_phys_order_id
         , pdc.over_dose AS over_dose_value
         , ndpc.phys_order_id as no_drug_protocol_check_phys_order_id
         ,ua.long_username as signedByName
         ,ISNULL((case when ua.designation_desc = '' THEN NULL ELSE ua.designation_desc end),ua.position_description) as signedByCredential
         ,os.signature_date as signedDate
         ,at.description as authenticationTypeDescription
         ,ss.description as sourceTypeDescription
         ,os.authentication_type_id as authenticationTypeId
         ,os.signature_type_id as signatureTypeId
         ,os.source_type_id as sourceTypeId
         ,nctrlsc.new_controlled_substance_code as new_controlled_substance_code
         ,ppoe.sign_contact_id as digitallySigned
         ,oq.quantity as prescription_quantity
         ,oq.unit_of_measure as prescription_quantity_uom
         ,oq.no_of_refills as prescription_no_of_refills
         ,ti.orig_phys_order_id as original_ti_phys_order_id

        FROM
            @result physorder
        LEFT JOIN (SELECT physorder.phys_order_id
                        , convert(BIT, count(physorder.phys_order_id)) AS pharmacy_confirmation_sent
                       FROM
                           pho_pharmacy_order pharmorder
                       INNER JOIN @result physorder
                           ON (pharmorder.phys_order_id = physorder.phys_order_id OR pharmorder.phys_order_id = physorder.orig_phys_order_id)
                       WHERE
                           pharmorder.fac_id = @facIdLocal
                           AND --active orders
                           physorder.status = 1
                           AND pharmorder.created_date > isnull(physorder.last_reorder_date, physorder.date_ordered)
                       GROUP BY
                           physorder.phys_order_id) tpocs
            ON tpocs.phys_order_id = physorder.phys_order_id
        LEFT JOIN (SELECT physorder.phys_order_id AS phys_order_id
                        , convert(BIT, count(physorder.phys_order_id)) AS shipped
                       FROM
                           pho_pharmacy_order pharmorder
                       INNER JOIN @result physorder
                           ON (pharmorder.phys_order_id = physorder.phys_order_id OR pharmorder.phys_order_id = physorder.orig_phys_order_id)
                       WHERE
                           pharmorder.fac_id = @facIdLocal
                           AND pharmorder.created_date > physorder.last_reorder_date
                           AND pharmorder.receive_status <> 7 --WeTypePhoReceiveStatus.PCC_ORDER_COMPLETE
                           AND physorder.reorder = 'Y'
                       GROUP BY
                           physorder.phys_order_id) tpos
            ON tpos.phys_order_id = physorder.phys_order_id
        LEFT JOIN PHO_ORDER_TYPE ordertype
            ON physorder.order_type_id = ordertype.order_type_id
        LEFT JOIN PHO_ADMINISTRATION_RECORD adminRecord
            ON ordertype.administration_record_id = adminRecord.administration_record_id
        LEFT JOIN PHO_ADMINISTRATION_RECORD altAdminRecord
            ON ordertype.alt_administration_record_id = altAdminRecord.administration_record_id -- PCC-7725 add alt admin record
        LEFT JOIN CONTACT physcon
            ON physorder.physician_id = physcon.contact_id
        LEFT JOIN PHO_ORDER_CATEGORY ordercat
            ON ordertype.order_category_id = ordercat.order_category_id
        LEFT JOIN COMMON_CODE diettype
            ON physorder.diet_type = diettype.item_id
        LEFT JOIN COMMON_CODE diettexture
            ON physorder.diet_texture = diettexture.item_id
        LEFT JOIN COMMON_CODE [route]
            ON physorder.route_of_admin = route.item_id
        LEFT JOIN COMMON_CODE dietsup
            ON physorder.diet_supplement = dietsup.item_id
        LEFT JOIN COMMON_CODE fluidcon
            ON physorder.fluid_consistency = fluidcon.item_id
        LEFT JOIN sec_user createdBySu
            ON createdBySu.loginname = physorder.created_by
        LEFT JOIN sec_user revisionBySu
            ON revisionBySu.loginname = physorder.revision_by
        LEFT JOIN pho_phys_order_useraudit useraudit
            ON useraudit.phys_order_id = physorder.phys_order_id
        LEFT JOIN cp_sec_user_audit edituser
            ON edituser.cp_sec_user_audit_id = useraudit.edited_by_audit_id
        LEFT JOIN cp_sec_user_audit createuser
            ON createuser.cp_sec_user_audit_id = useraudit.created_by_audit_id
        LEFT JOIN cp_sec_user_audit confuser
            ON confuser.cp_sec_user_audit_id = useraudit.confirmed_by_audit_id
        LEFT JOIN emc_ext_facilities eef
          ON eef.ext_fac_id = physorder.pharmacy_id
        LEFT JOIN @physOrderAllergies poa ON poa.phys_order_id= physorder.phys_order_id
        LEFT JOIN @physOrderBlackbox pob ON pob.phys_order_id= physorder.phys_order_id
        LEFT JOIN @physOrderDoseCheck pdc ON pdc.phys_order_id = physorder.phys_order_id
        LEFT JOIN @physOrderNoDrugProtocolCheck ndpc ON ndpc.phys_order_id = physorder.phys_order_id

        LEFT JOIN pho_phys_order_sign os on os.phys_order_id = physorder.phys_order_id
        LEFT JOIN cp_sec_user_audit ua ON ua.cp_sec_user_audit_id = os.cp_sec_user_audit_id  --and os.phys_order_id = ?
        LEFT JOIN order_sign_authentication_type at on at.authentication_type_id = os.authentication_type_id
        LEFT JOIN order_sign_source_type ss on ss.source_type_id = os.source_type_id
        LEFT JOIN order_sign_signature_type st on st.signature_type_id = os.signature_type_id
        LEFT JOIN pho_phys_order_new_ctrlsubstancecode nctrlsc on nctrlsc.phys_order_id=physorder.phys_order_id
        LEFT JOIN pho_phys_order_esignature ppoe on ppoe.phys_order_id=physorder.phys_order_id
        LEFT JOIN pho_phys_order_quantity_info oq on oq.phys_order_id=physorder.phys_order_id
        LEFT JOIN pho_phys_order_ti ti on ti.phys_order_id = physorder.phys_order_id

SET @step = 9

SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return supplies '
    IF @debug='Y'
        PRINT @status_text

    -- supplies
    select pos.phys_order_id,
        pos.order_supply_id,
        pos.description as supply_description,
        pos.directions as supply_directions,
        pos.date_dispensed as date_dispensed,
        pos.last_received_date as supply_received_date,
		pos.received_date as supply_physical_received_date,
        pos.med_src_type_id as supply_med_src_type_id,
        pos.pharmacy_id as supply_pharmacy_id,
        eef.name as supply_pharmacy_name,
        pos.reordering as supply_reordering,
        pos.status AS supply_status,
        pos.new_supply_flag as supply_new_supply_flag,
        pos.last_reorder_date as supply_last_reorder_date,
        pos.disp_code as supply_disp_code,
        pos.pharm_nurse_notes as pharm_nurse_notes,
        pos.nurse_pharm_notes as nurse_pharm_notes,
        pos.disp_package_identifier as supply_disp_package_identifier,
        pos.controlled_substance_code as supply_controlled_substance_code,
        pos.prescription as supply_prescription,
        pos.do_not_fill as supply_do_not_fill,
        pos.inventory_on_hand as inventory_on_hand,
        pos.next_refill_date as next_refill_date,
        psd.pharmacy_order_id as pharmacy_order_id,
        CASE  WHEN ip.pharmacy_id IS NULL THEN 'N' ELSE 'Y' END 'integrated_pharmacy',
        pos.active as supply_active,
        mmdb.dbo.fn_pho_getImageFilenameByNDC(pos.drug_code) as imageFileName, -- PCC-33017
        pos.drug_code as drug_code
    FROM pho_order_supply pos
        INNER JOIN  @result result ON [result].phys_order_id = pos.phys_order_id
        LEFT JOIN emc_ext_facilities eef ON eef.ext_fac_id = pos.pharmacy_id
        left join pho_supply_dispense psd on psd.order_supply_id = pos.order_supply_id and psd.deleted='N'
        LEFT JOIN @integratedPharmacies ip
                    ON ip.pharmacy_id = pos.pharmacy_id
    WHERE (pos.active = 'Y' or pos.active = 'N') AND pos.deleted = 'N'
    ORDER BY pos.created_date DESC

SET @step = 10

SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return Administrative orders'
    IF @debug='Y'
        PRINT @status_text


-- administrative orders
select vpao.*, secuser.long_username 'created_by_long' , secuser.designation_desc as created_by_designation, ccc.item_description as created_by_position
,csua.long_username confirmed_by_username, csua.position_description as confirmed_by_position, csua.designation_desc as confirmed_by_designation, ua.confirmed_date as confirmed_date
FROM view_pho_administrative_order vpao
inner JOIN @result r ON r.phys_order_id = vpao.standard_phys_order_id
left join SEC_USER secuser on secuser.loginname = vpao.created_by
left join common_code ccc on ccc.item_id = secuser.position_id
left join pho_admin_order_useraudit ua ON ua.admin_order_id = vpao.admin_order_id
left join cp_sec_user_audit csua on csua.cp_sec_user_audit_id = ua.confirmed_by_audit_id
ORDER BY vpao.revision_date  DESC



/**
may have to revisit column selection
**/
    SET @step = 11
    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Return Schedules'
    IF @debug='Y'
      PRINT @status_text;

	WITH ORDER_SCHEDULES AS
	(
		SELECT
			vps.phys_order_id, vps.order_schedule_id, vps.order_schedule_start_date 'start_date', psd.last_admin_user, psd.last_admin_date, vps.order_schedule_end_date 'end_date', vps.end_date_type, vps.end_date_duration_type,
			vps.end_date_duration, vps.reassessment_required,  vps.schedule_directions, vps.additional_directions, vps.schedule_template, vps.schedule_type,
			vps.alternate_dose, vps.schedule_sliding_scale_id, vps.apply_remove_flag,
			vps.date_start,
			vps.date_stop,
			vps.dose_uom_id,
			vps.dose,
			vps.indications_for_use,
			vps.quantity_uom_id,
			vps.prn_admin,
			vps.prn_admin_units,
			vps.prn_admin_value,
			vps.apply_to,
			CASE WHEN oss.order_schedule_id is not null  THEN 1 ELSE 0 END as custom_sliding_scale_exists,
			vps.std_freq_id,
			vps.revision_date
		FROM view_pho_schedule vps
			LEFT OUTER JOIN dw_pho_order_schedule psd
				ON psd.order_schedule_id = vps.order_schedule_id
			LEFT JOIN pho_order_sliding_scale_range oss
				ON @includeSlidingScale='Y' AND oss.order_schedule_id=vps.order_schedule_id
			INNER JOIN @result r
				ON r.phys_order_id = vps.phys_order_id
		GROUP BY
			vps.phys_order_id, vps.order_schedule_id, vps.order_schedule_start_date, psd.last_admin_user, psd.last_admin_date, vps.order_schedule_end_date, vps.end_date_type, vps.end_date_duration_type,
			vps.end_date_duration, vps.reassessment_required,  vps.schedule_directions, vps.additional_directions, vps.schedule_template, vps.schedule_type,
			vps.alternate_dose, vps.schedule_sliding_scale_id,
			oss.order_schedule_id,
			vps.apply_remove_flag,
			vps.date_start,
			vps.date_stop,
			vps.dose_uom_id,
			vps.dose,
			vps.indications_for_use,
			vps.quantity_uom_id,
			vps.prn_admin,
			vps.prn_admin_units,
			vps.prn_admin_value,
			vps.apply_to,
			vps.std_freq_id,
			vps.revision_date
	)
	-- return: combine with schedules for struck-out orders
		SELECT * FROM ORDER_SCHEDULES
		UNION ALL
			SELECT
				psa.phys_order_id, psa.order_schedule_id, psa.schedule_start_date 'start_date', psd.last_admin_user, psd.last_admin_date, psa.schedule_end_date 'end_date', psa.schedule_end_date_type_id 'end_date_type', psa.schedule_duration_type_id 'end_date_duration_type',
				psa.schedule_duration 'end_date_duration', psa.reassessment_required,  psa.schedule_directions, psa.additional_directions, psa.schedule_template, psa.schedule_type,
				psa.alternate_dose_value 'alternate_dose', psa.sliding_scale_id 'schedule_sliding_scale_id', psa.apply_remove_flag,
				psa.date_start,
				psa.date_stop,
				psa.dose_uom_id,
				psa.dose_value 'dose',
				psa.indications_for_use,
				psa.quantity_uom_id,
				psa.prn_admin,
				psa.prn_admin_units,
				psa.prn_admin_value,
				psa.apply_to,
				CASE WHEN oss.order_schedule_id is not null  THEN 1 ELSE 0 END as custom_sliding_scale_exists,
				psa.std_freq_id,
				psa.revision_date
			FROM pho_order_schedule_audit psa
				INNER JOIN
				(
					SELECT MAX(posa.AUDIT_ID) 'latest_audit_id' FROM pho_order_schedule_audit posa
					INNER JOIN @result r ON r.phys_order_id = posa.phys_order_id AND r.status = 4
					GROUP BY posa.order_schedule_id
				) latest_schedule_audit ON latest_schedule_audit.latest_audit_id = PSA.audit_id
				INNER JOIN @orderStatus os	-- filter down to struck-out orders
					ON  os.status = 4
				LEFT OUTER JOIN dw_pho_order_schedule psd
					ON psd.order_schedule_id = psa.order_schedule_id
				LEFT JOIN pho_order_sliding_scale_range oss
					ON @includeSlidingScale='Y' AND oss.order_schedule_id=psa.order_schedule_id
				INNER JOIN @result r
					ON r.phys_order_id = psa.phys_order_id AND r.status = 4
			WHERE @includeStruckOutOrders = 'Y'
			GROUP BY
				psa.phys_order_id, psa.order_schedule_id, psa.schedule_start_date, psd.last_admin_user, psd.last_admin_date, psa.schedule_end_date, psa.schedule_end_date_type_id, psa.schedule_duration_type_id,
				psa.schedule_duration, psa.reassessment_required,  psa.schedule_directions, psa.additional_directions, psa.schedule_template, psa.schedule_type,
				psa.alternate_dose_value, psa.sliding_scale_id,
				oss.order_schedule_id,
				psa.apply_remove_flag,
				psa.date_start,
				psa.date_stop,
				psa.dose_uom_id,
				psa.dose_value,
				psa.indications_for_use,
				psa.quantity_uom_id,
				psa.prn_admin,
				psa.prn_admin_units,
				psa.prn_admin_value,
				psa.apply_to,
				psa.std_freq_id,
				psa.revision_date


     SET @step = 12

     SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return alerts '
     IF @debug='Y'
        PRINT @status_text

     /* ALERTS */
		SELECT PHYSORDER.PHYS_ORDER_ID   'phys_order_id',
               PHYSORDER.CLIENT_ID       'client_id',
               ALERT.ALERT_ID            'alert_id',
               ALERT.DESCRIPTION         'alert_desc',
               ALERT.MODULE              'module',
               ALERT.CREATED_DATE        'alert_created_date',
               ALERT.EFFECTIVE_DATE      'effective_date',
               ALERT.TRIGGERED_ITEM_ID   'triggered_item_id',
               ALERT.TRIGGERED_ITEM_TYPE 'triggered_item_type',
               ALERT.RESOLVED            'resolved',
               ALERT.RESOLVED_BY         'resolved_by',
			   CATITC.TRIGGERED_ITEM_TYPE_CATEGORY_ID 'triggered_item_type_category_id'
        FROM   @result PHYSORDER
               LEFT OUTER JOIN CR_ALERT ALERT
                 ON ALERT.TRIGGERED_ITEM_ID = PHYSORDER.PHYS_ORDER_ID
					and alert.fac_id = @facIdLocal
					and ( @clientIdLocal is null or alert.client_id=@clientIdLocal )
                    AND ALERT.TRIGGERED_ITEM_TYPE IN ('O', 'M') AND ALERT.RESOLVED <> 'Y' AND ALERT.deleted = 'N'
				LEFT OUTER JOIN CR_ALERT_TRIGGERED_ITEM_TYPE_CATEGORY CATITC
				 ON CATITC.ALERT_ID = ALERT.alert_id
		WHERE ALERT.ALERT_ID IS NOT NULL
        ORDER  BY ALERT.EFFECTIVE_DATE ASC


     SET @step = 13

     SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return the total number of records '
     IF @debug='Y'
        PRINT @status_text

     select @num_records as num_records

      SET @step = 14

     SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return alerts for Supplies '
     IF @debug='Y'
        PRINT @status_text

     /* ALERTS */
            SELECT PHYSORDER.PHYS_ORDER_ID   'phys_order_id',
               PHYSORDER.CLIENT_ID       'client_id',
               POS.ORDER_SUPPLY_ID        'order_supply_id',
               ALERT.ALERT_ID            'alert_id',
               ALERT.DESCRIPTION         'alert_desc',
               ALERT.MODULE              'module',
               ALERT.CREATED_DATE        'alert_created_date',
               ALERT.EFFECTIVE_DATE      'effective_date',
               ALERT.TRIGGERED_ITEM_ID   'triggered_item_id',
               ALERT.TRIGGERED_ITEM_TYPE 'triggered_item_type',
               ALERT.RESOLVED            'resolved',
               ALERT.RESOLVED_BY         'resolved_by'
        	FROM   pho_order_supply POS
                 LEFT JOIN @result PHYSORDER ON PHYSORDER.PHYS_ORDER_ID = POS.PHYS_ORDER_ID and (@clientIdLocal is null or PHYSORDER.client_id=@clientIdLocal )
               	 LEFT JOIN CR_ALERT ALERT ON ALERT.TRIGGERED_ITEM_ID = POS.ORDER_SUPPLY_ID and alert.fac_id = @facIdLocal and ALERT.client_id = PHYSORDER.client_id


       		 WHERE (
                           -- Only Show Pharmacy initated alerts
                           ALERT.TRIGGERED_ITEM_TYPE = 'C'
                                                OR ALERT.TRIGGERED_ITEM_TYPE = 'O'
                                                OR ALERT.TRIGGERED_ITEM_TYPE = 'D'
                                                OR ALERT.TRIGGERED_ITEM_TYPE = 'T'
                                         )
                                  AND ALERT.deleted = 'N'
       		 ORDER  BY ALERT.EFFECTIVE_DATE ASC

    SELECT r.phys_order_id, poda.severity_code
    FROM @result r
     INNER JOIN @physOrderDrugInteraction poda ON poda.phys_order_id= r.phys_order_id

    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Done'
    IF @debug='Y'
        PRINT @status_text
    SET @status_code = 0
    GOTO PgmSuccess
END TRY
--error trapping
BEGIN CATCH
    SELECT @error_code = @@error, @status_text = 'Error at step:'+convert(varchar(3),@step)+', '+ERROR_MESSAGE()

    SET @status_code = 1

    GOTO PgmAbend

END CATCH

--program success return
PgmSuccess:

IF @status_code = 0
BEGIN
    IF @debug='Y' PRINT 'Successfull execution of stored procedure'
    RETURN @status_code
END

--program failure return
PgmAbend:

IF @debug='Y' PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '   ' + convert(varchar(26),getdate())
    IF @debug='Y' PRINT 'Error code: '+convert(varchar(3),@error_code) + '; Error description:    ' +@status_text
    RETURN @status_code

GO
GRANT EXECUTE ON sproc_pho_list_residentchart TO public
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_pho_list_residentchart.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_residentchart.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_residentchart_v2.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*****************************************************************************************************
**  Created By:
**  Created Date:
**
**	Purpose:  To return a list of Physician Orders.
**			 Please note that this stored procedure is a copy of 'sproc_pho_list_residentchart' but has all MMDB references removed.
**
**
**	Params:
**			@facId
**			@clientId
**			@facilityDateTime
**			@orderCategoryIdsCSV
**			@orderStatusCSV
**			@startDateoperator
**			@startDate
***			@endDateoperator
**			@endDate
**			@orderDateoperator
**			@orderDate
**			@createdBy
**			@orderedById
**			@orderTypeId
**			@adminRecordId
**			@routeOfAdminIdsCSV
**			@communicationMethodIdsCSV
**			@medicationSourceId
**			@pharmacyId
**			@providerId
**			@showLegacyOrder
**			@clientIdNumber
**			@clientStatus
**			@unit
**			@floor
**			@completedDate
**			@completedDateoperator
**			@discontinuedDate
**			@discontinuedDateoperator
**			@confirmedDate datetime,
**			@confirmedDateoperator
**			@confirmedBy
**			@medication
**			@medicationclassification
**			@holdDate
**			@holdDateoperator
**			@supplyStatusId
**			@fromIntegratedPharmacy
**			@medSrcTypeId
**			@physOrderId
**			@narcoticsOnly     - Narcotics order or not, 'Y' or 'N'
**          @alwaysShowOrderWithAlert
**			@orderLinkedOption	- (1) None, (2) Only, (3) Both
**			@orderClassId	- smallint (-1) All (1) Institutional order, (2) Discharge order
**			@includeRetired	- Show deleted physicians or not , 'Y' or 'N' 
**			@includeSlidingScale - show sliding scale information or not, 'Y' or 'N'. Defaulted to 'N'.
**			@historicalOrdersOnly - get historical orders only or not, 'Y' or 'N'. Defaulted to 'N'
**			@historicalOrdersOnlyPeriodStart - start of period to get historical orders for, if null get all historical orders
**			@debug          - Debug param, 'Y' or 'N'
**			@status_code    - SP execution flag, 0 for success.
**			@status_text    - SP error text if error occurs.
**
**  Special Instructions:  Run view_pho_order stsus first before running this
**	sproc during the build process.
**
**  Revision History:
**  2012-09-06        PCC-32548   Feng  Xia      added a new search criteria for showing only narcotics drugs
**  2012-04-03        PCC-29069   Nabil Hamade   changed order by from revision_date to edited_date for orders list
**  2016-04-04        PCC-92113   Ramin Shojaei Add condition to include deleted (retired) physician in the result set
**  2016-11-17 		  PCC-105022  Veerpal Khanuja	Added schedule_sliding_scale_id and flag custom_sliding_scale_exists in result set for schedules.
**  2016-11-17 		  PCC-105019  Veerpal Khanuja	Added alternate_dose in result set for schedules.
**	2017-01-23		  PCC-107915  Devika Bapat		Added apply_remove_flag in result set for schedules.
**	2017-03-08		  PCC-110558  Devika Bapat		Added date_start, date_stop, dose_uom_id, dose, indications_for_use, 
													quantity_uom_id, prn_admin, prn_admin_units, prn_admin_value, for schedules. 
**	2017-04-06		  PCC-113549  Devika Bapat		Added apply_to in result set for schedules.
**	2017-11-08		  CORE-5680   Elias Ghanem		Added condition to select historical orders only based on the historicalOrdersOnly and historicalOrdersOnlyPeriodStart parameters.
**  2018-01-03		  CORE-7999   Hao Liu           Added support to filter by old medical professional id if new id provided
**  2018-12-18		  CORE-24715  Samuel Martey     Changed the return block to return the schedules for struck-out orders as well to build directions from them.
**  2019-01-02		  CORE-24715  Samuel Martey     Optimize cases for selecting struck-out orders. Do not select when not requested in the union query
**  2019-03-11		  CORE-35559  Henry Jin			Added join to the table cr_alert_triggered_item_type_category when fecthing alerts.  
**  2019-07-17		  CORE-46275  Elias Ghanem		Return alerts of type 'O' or 'M' instead of only 'O'. Also modify the sorting of the returned result set to be
**													ASC instead of DESC. The sorting modification will not affect the final result displayed to the user since the Java code
**													handling the result set has been modified accordingly.  
**  2019-08-01		  CORE-43789  Elias Ghanem		Add configuration parameters to return orders having alerts of type M or having supplies with alerts of type D regardless of their status
**  2020/09/03 		  CORE-71858  Elias Ghanem 		When computing if order has Allergy, D2D or blackBox alerts, include alerts for supplies even even if the supplies are in Processed By Pharmacy status (3) not only if 
**													they are On Hand
**	2021-01-22  	  CORE-83505  Elias Ghanem      Add revision_date field to the schedules result set
**  2021-11-18 		  CORE-97119  Sree Naghasundharam  Created this new stored procedure 'sproc_pho_list_residentchart_v2' and Removed MMDB references
******************************************************************************************************************************************************/
IF EXISTS (SELECT *
               FROM
                   dbo.sysobjects
               WHERE
                   id = object_id(N'[dbo].[sproc_pho_list_residentchart_v2]')
                   AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
    DROP PROCEDURE [dbo].[sproc_pho_list_residentchart_v2]

SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[sproc_pho_list_residentchart_v2]   @facId                        INT, --required
                                                        @clientId                     INT, --required
                                                        @facilityDateTime             DATETIME, --required
                                                        @orderCategoryIdsCSV          varchar(100), -- required comma seperated list of categegory id
                                                        @orderStatusCSV               varchar(100),
                                                        @startDateoperator            INT = 0, --0 equal to, -1 less than, 1 greater than
                                                        @startDate                    DATETIME, -- date to compare,
                                                        @endDateoperator              INT = 0, --0 equal to, -1 less than, 1 greater than
                									    @endDate                      DATETIME, -- date to compare,
                                                        @orderDateoperator            INT = 0, --0 equal to, -1 less than, 1 greater than
                                                        @orderDate                    DATETIME, -- date to compare,
                                                        @createdBy                    varchar(60),
                                                        @orderedById int,
                                                        @orderTypeId int,
                                                        @adminRecordId int,
                                                        @routeOfAdminIdsCSV varchar(50),
                                                        @communicationMethodIdsCSV varchar(50), -- required comma seperated list of communication method id
                                                        @medicationSourceId int,
                                                        @pharmacyId int,
                                                        @providerId int,
                                                        @showLegacyOrder char(1), -- Null both , Y - show only legacy order, N - show only new orders
                                                        @clientIdNumber varchar(100),
                                                        @clientStatus int,
                                                        @unit int,
                                                        @floor int,
                                                        @completedDate datetime,
                                                        @completedDateoperator int = 0, --0 equal to, -1 less than, 1 greater than
                                                        @discontinuedDate datetime,
                                                        @discontinuedDateoperator int = 0, --0 equal to, -1 less than, 1 greater than
                                                        @confirmedDate datetime,
                                                        @confirmedDateoperator int = 0, --0 equal to, -1 less than, 1 greater than
                                                        @confirmedBy varchar(100),
                                                        @medication varchar(200),
                                                        @medicationclassification varchar(200),
                                                        @holdDate datetime,
                                                        @holdDateoperator int = 0, --0 equal to, -1 less than, 1 greater than
                                                        @supplyStatusId     int,
                                                        @fromIntegratedPharmacy char(1),
                                                        @medSrcTypeId       int,
                                                        @physOrderId int,
                                                        @pageSize int,
                                                        @pageNumber int,
                                                        @sortByColumn varchar(100),
                                                        @sortByOrder  varchar(10),
                                                        @narcoticsOnly     char(1)  = 'N',
                                                        @alwaysShowOrderWithAlert char(1) = 'N',
														@orderLinkedOption	int,
														@orderClassId		smallint, -- required
														@pharmacyNCPDP varchar(10),
														@includeRetired char(1) = 'Y',
														@includeSlidingScale char(1)='N',
														@historicalOrdersOnly char(1) = 'N',
														@historicalOrdersOnlyPeriodStart datetime,
														@debug              char(1)  = 'N',
														@status_code        int  = 0 out,
                                                        @status_text        varchar(3000) out
                                                          --useful when debugging within sqlserver studio



/***********************************************************************************************

Purpose:
This procedure provides data shown on Resident' Order Chart
This procedure does not use VIEW_PHO_PHYS_ORDER

*************************************************************************************************/

AS
BEGIN TRY
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

DECLARE @step                       			int,
        @error_code                 			int,
        @num_records							int,
		@facIdLocal								int,
		@clientIdLocal							int,
		@drugAllergyCheckEnabled    			char,
		@drugInteractionEnabled					char,
		@doseCheckEnabled						char,
        @blackBoxEnabled						char,
		@orderClassId_local         			smallint,
		@pharmacyNCPDP_local					varchar(10),
		@oldOrderById							int,
		@includeStruckOutOrders					char,
		@showOrdersWithIntegrationAlerts 		varchar(1),
		@showOrdersWithSupplyIntegrationAlerts 	varchar(1)

set @clientIdLocal = @clientId
set @facIdLocal = @facId
SET @step = 0
SET @error_code = 0
SET @orderClassId_local = @orderClassId
SET @pharmacyNCPDP_local = @pharmacyNCPDP
SET @showOrdersWithIntegrationAlerts = 'Y'
SET @showOrdersWithSupplyIntegrationAlerts = 'Y'

SELECT @drugAllergyCheckEnabled=ISNULL(value,'N') FROM configuration_parameter WHERE name='enable_drug_allergy_check' AND value='Y' AND fac_id=@facId
SELECT @drugInteractionEnabled=ISNULL(value,'N') FROM configuration_parameter WHERE name='enable_drug_interaction' AND value='Y' AND fac_id=@facId
SELECT @doseCheckEnabled=ISNULL(value,'N') FROM configuration_parameter WHERE name='enable_dose_check' AND value='Y' AND fac_id=@facId
SELECT @blackBoxEnabled=ISNULL(value,'N') FROM configuration_parameter WHERE name='enable_black_box' AND value='Y' AND fac_id=@facId
SELECT @showOrdersWithIntegrationAlerts=ISNULL(value,'Y') FROM configuration_parameter WHERE name='show_orders_with_integration_alerts' AND value='N' AND fac_id=@facId
SELECT @showOrdersWithSupplyIntegrationAlerts=ISNULL(value,'Y') FROM configuration_parameter WHERE name='show_orders_with_supply_integration_alerts' AND value='N' AND fac_id=@facId

SET @oldOrderById = dbo.fn_medprof_getOldMedicalProfessionalId(@orderedById, @facId)

    DECLARE @result TABLE
	--create table #result
    (

        phys_order_id int not null PRIMARY KEY
        ,status int
        ,relationship int
        ,status_reason int
        ,fac_id int NOT NULL
        ,client_id int NOT NULL
        ,diet_type int
        ,diet_texture int
        ,diet_supplement int
        ,fluid_consistency int
        ,alter_med_src int
        ,nurse_pharm_notes varchar(512)
        ,created_by varchar(60)
        ,created_by_longname varchar(100)
        ,created_date datetime
        ,date_ordered datetime
        ,description varchar(500)
        ,related_generic varchar(250)
        ,dispense_as_written varchar(1)
        ,directions varchar(1000)
		,strength varchar(30)
        ,drug_strength varchar(100)
        ,drug_strength_uom varchar(10)
        ,discontinued_date datetime
        ,end_date datetime
        ,hold_date datetime
        ,hold_date_end datetime
        ,last_reorder_date datetime
        ,order_type_id int
        ,order_category_id int
        ,order_category_description varchar(250)
        ,family_portal_sort_order tinyint
        ,order_date datetime
        ,order_status int
        ,physician_id int
        ,reorder varchar(1)
        ,revision_by varchar(60)
        ,revision_date datetime
        ,edited_date datetime
        ,route_of_admin int
        ,start_date datetime
        ,order_verified varchar(1)
        ,next_refill_date datetime
        ,do_not_fill varchar(1)
        ,first_documented datetime
        ,origin_id int
        ,controlled_substance_code varchar(50)
        ,pharmacy_id int
        ,communication_method int
        ,legacy_order varchar(1)
        ,discharge_date datetime
        ,client_id_number varchar(35)
        ,resident_last_name varchar(50)
        ,resident_first_name varchar(50)
        ,orig_phys_order_id int
        ,pho_ext_lib_id int
        ,pho_ext_lib_med_id int
        ,pho_ext_lib_med_ddid int
        ,ext_lib_rxnorm_id varchar(10)
        ,strikeout_date datetime
        ,strikeout_by varchar(60)
		,strikeout_reason_code varchar(254)
		,vendor_phys_order_id varchar(30)
		,advanced_directive varchar(1)
		,end_date_filter datetime
		,linked_set_id int
		,linked_set_name varchar(100)
		,order_class_id tinyint
    )

	declare @orderData table
    (
        phys_order_id int not null PRIMARY KEY
        ,status int
        ,relationship int
        ,status_reason int
        ,fac_id int NOT NULL
        ,client_id int NOT NULL
        ,diet_type int
        ,diet_texture int
        ,diet_supplement int
        ,fluid_consistency int
        ,alter_med_src int
        ,nurse_pharm_notes varchar(512)
        ,created_by varchar(60)
        ,created_by_longname varchar(100)
        ,created_date datetime
        ,date_ordered datetime
        ,calculated_description varchar(500)
        ,related_generic varchar(250)
        ,dispense_as_written varchar(1)
        ,directions varchar(1000)
		,strength varchar(30)
        ,drug_strength varchar(100)
        ,drug_strength_uom varchar(10)
        ,discontinued_date datetime
        ,end_date datetime
        ,hold_date datetime
        ,hold_date_end datetime
        ,last_reorder_date datetime
        ,order_type_id int
        ,order_category_id int
        ,order_category_description varchar(250)
        ,family_portal_sort_order tinyint
        ,order_date datetime
        ,order_status int
        ,physician_id int
        ,reorder varchar(1)
        ,revision_by varchar(60)
        ,revision_date datetime
        ,edited_date datetime
        ,route_of_admin int
        ,start_date datetime
        ,order_verified varchar(1)
        ,next_refill_date datetime
        ,do_not_fill varchar(1)
        ,first_documented datetime
        ,origin_id int
        ,controlled_substance_code varchar(50)
        ,pharmacy_id int
        ,communication_method int
        ,legacy_order varchar(1)
        ,discharge_date datetime
        ,client_id_number varchar(35)
        ,resident_last_name varchar(50)
        ,resident_first_name varchar(50)
        ,orig_phys_order_id int
        ,pho_ext_lib_id int
        ,pho_ext_lib_med_id int
        ,pho_ext_lib_med_ddid int
        ,ext_lib_rxnorm_id varchar(10)
		,vendor_phys_order_id varchar(30)
		,advanced_directive varchar(1)
		, confirmed_by_audit_id int
       , ppone_phys_order_id int
		,description varchar(500)
		,linked_set_id int
		,linked_set_name varchar(100)
		,order_class_id tinyint
    )

   	declare @vpos table (
	[phys_order_id] [int] NOT NULL,
	[fac_id] [int] NOT NULL,
	[order_status] [int] NOT NULL,
	[order_relationship] [int] NULL,
	[status_reason] int NULL
	)

    DECLARE @routeOfAdminIds TABLE
    (
        route_of_admin int  not null
    )

    DECLARE @orderCategoryIds TABLE
    (
        order_category_id int  not null
    )

    DECLARE @communicationMethodIds TABLE
    (
        method_id int  not null
    )

    DECLARE @orderStatus TABLE
    (
        [status] int  not null
    )

    DECLARE @integratedPharmacies TABLE
    (
        pharmacy_id int not null
    )

    DECLARE @supplyCriteria TABLE
    (
        phys_order_id int not null
    )

	  DECLARE @medicationClassificationIds TABLE
    (
        medication_classification_id varchar(10) not null
    )

    DECLARE @physOrderAllergies TABLE
    (
      phys_order_id int  NOT NULL
    )

    DECLARE @physOrderDrugInteraction TABLE
    (
      phys_order_id int  NOT NULL,
      severity_code varchar(1)
    )

    DECLARE @physOrderBlackbox TABLE
    (
      phys_order_id int  NOT NULL
    )

    DECLARE @physOrderDoseCheck TABLE
    (
      phys_order_id int  NOT NULL,
      over_dose varchar(1)
    )

    DECLARE @physOrderNoDrugProtocolCheck TABLE
    (
      phys_order_id int  NOT NULL
    )

	DECLARE @dischargePharmacyNCPDP TABLE
    (
        discharge_pharm_phys_order_id int not null
    )

	DECLARE @ordersHavingAlerts TABLE
	(
		phys_order_id int  NOT NULL
	)

SET @step = 1
    INSERT INTO @orderCategoryIds (order_category_id)
    select * from dbo.Split(@orderCategoryIdsCSV, ',')
	delete from @orderCategoryIds where order_category_id=1 or order_category_id=3030
SET @step = 2
    INSERT INTO @communicationMethodIds (method_id)
    select * from dbo.Split(@communicationMethodIdsCSV, ',')
SET @step = 3
    INSERT INTO @routeOfAdminIds (route_of_admin)
    select * from dbo.Split(replace(@routeOfAdminIdsCSV,'_',','), ',')
SET @step = 4
    INSERT INTO @orderStatus (status)
    select * from dbo.Split(@orderStatusCSV, ',');
	SET @includeStruckOutOrders = CASE WHEN EXISTS (SELECT os.status FROM @orderStatus os WHERE status = 4) THEN 'Y' ELSE 'N' END;
SET @step = 5
    INSERT INTO @medicationClassificationIds (medication_classification_id)
    select * from dbo.Split(@medicationclassification, ',')

SET @step = 41
	INSERT INTO @integratedPharmacies (pharmacy_id)
	select distinct extFacId from (
		SELECT mp.ext_fac_id as extFacId
			FROM message_profile mp WITH (NOLOCK)
			INNER JOIN lib_message_profile lmp WITH (NOLOCK)
				ON lmp.message_profile_id = mp.message_profile_id
			       AND lmp.deleted = 'N' and lmp.is_enabled='Y'
			WHERE mp.is_enabled = 'Y' and mp.is_integrated_pharmacy='Y'
			AND mp.fac_id = @facIdLocal
			AND mp.message_protocol_id = 12
			GROUP BY mp.ext_fac_id
		UNION
		SELECT distinct mi.internal_id as extFacId
			FROM map_identifier mi WITH (NOLOCK)
			INNER JOIN lib_message_profile libmp WITH (NOLOCK)
			ON libmp.vendor_code = mi.vendor_code
			AND libmp.deleted = 'N'
			INNER JOIN message_profile mp WITH (NOLOCK)
			ON libmp.message_profile_id = mp.message_profile_id
			WHERE mi.map_type_id = 3 and mp.fac_id = @facIdLocal and  mi.fac_id = @facIdLocal
	) a where extFacId is not null

-- put all criteria related to pho_order_supply in here so that we
-- can make sure they interact correctly and we don't need a hundred
-- different subqueries in the main query, also only populate it if
-- we're going to need it
SET @step = 42
    IF @supplyStatusId IS NOT NULL
          OR @fromIntegratedPharmacy IS NOT NULL
          OR @medSrcTypeId IS NOT NULL
    BEGIN
      INSERT INTO @supplyCriteria (phys_order_id)
        SELECT phys_order_id
          FROM pho_order_supply WITH (NOLOCK)
          WHERE (active = 'Y' OR active = 'N')
            AND deleted = 'N'
            AND (@supplyStatusId IS NULL OR status = @supplyStatusId)
            AND (
              @fromIntegratedPharmacy IS NULL
              OR (
                @fromIntegratedPharmacy = 'Y'
                AND pharmacy_id IN (select * from @integratedPharmacies)
              )
              OR (
                @fromIntegratedPharmacy = 'N'
                AND pharmacy_id NOT IN (select * from @integratedPharmacies)
              )
            )
            AND (@medSrcTypeId IS NULL OR med_src_type_id = @medSrcTypeId)
    END

set @step = 43
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Function call'
IF @debug='Y'
PRINT @status_text

DECLARE @now datetime
set @now = dbo.fn_facility_getCurrentTime(@facIdLocal)

insert into @vpos
exec sproc_pho_getOrderStatus  @facIdLocal,@clientIdLocal,@physOrderId,@now,'N',@debug,@status_code out,@status_text out

SET @step = 5
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Start getting med classification'
IF @debug='Y'
    PRINT @status_text


	declare @medicationclassificationTable table
	(
		phys_order_id	int
	)

	if( @medicationclassification is not null )
	BEGIN
		insert into @medicationclassificationTable
		SELECT distinct poelmr.phys_order_id from pho_order_ext_lib_med_ref poelmr WITH (NOLOCK) INNER JOIN
		(
			SELECT poelc.phys_order_ext_lib_rec_id, pho_ext_lib_class_id 'class_id' from pho_order_ext_lib_cls poelc WITH (NOLOCK)
			UNION
			SELECT poelc.phys_order_ext_lib_rec_id, pho_ext_lib_sub_class_id 'class_id' from pho_order_ext_lib_cls poelc WITH (NOLOCK)
		) classes ON classes.phys_order_ext_lib_rec_id = poelmr.phys_order_ext_lib_rec_id
		INNER JOIN @medicationClassificationIds mclassids on classes.class_id = mclassids.medication_classification_id
    INNER JOIN @vpos vpos on vpos.phys_order_id = poelmr.phys_order_id
	END


SET @step = 5
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert orders/client/mpi data.'
IF @debug='Y'
    PRINT @status_text

declare @clientInfo table
(
	fac_id int,
	client_id int,
	discharge_date datetime,
	client_id_number varchar(35),
	first_name	varchar(50),
	last_name	varchar(50)
)
insert into @clientInfo ( 	fac_id , client_id , discharge_date , client_id_number,first_name, last_name )
select distinct
	c.fac_id,
	c.client_id,
	 c.discharge_date
     , c.client_id_number
     , m.last_name
     , m.first_name
from
	clients c
	INNER JOIN mpi  m  WITH (NOLOCK) ON m.mpi_id = c.mpi_id
where
c.client_id = @clientIdLocal




SET @step = 5
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Get common data for queries.'
IF @debug='Y'
    PRINT @status_text

IF(@orderClassId_local > -1)
BEGIN
	insert into @orderData
	select
		distinct ppo.phys_order_id
				 ,vpos.order_status
				 ,vpos.order_relationship
				 ,vpos.status_reason
				 , ppo.fac_id
				 , ppo.client_id
				 , ppo.diet_type
				 , ppo.diet_texture
				 , ppo.diet_supplement
				 , ppo.fluid_consistency
				 , ppo.alter_med_src
				 , ppo.nurse_pharm_notes
				 , ppo.created_by
				 , createdBySu.long_username
				 , ppo.created_date
				 , ppo.date_ordered
				 , case when ppo.order_category_id=3031 then diettype.item_description
							 when ppo.order_category_id=3032 then dietsup.item_description
							 when ppo.order_category_id=3023 then diettype.item_description
							 when ppo.order_category_id=3033 then 'Enteral Feed'
							 else ppo.description
						end 'calculated_description'
				 , ppo.related_generic
				 , ppo.dispense_as_written
				 , ppo.directions
				 , ppo.strength
				 , ppo.drug_strength
				 , ppo.drug_strength_uom
				 , ppo.discontinued_date
				 , ppo.end_date
				 , ppo.hold_date
				 , ppo.hold_date_end
				 , ppo.last_reorder_date
				 , ppo.order_type_id
				 , ppo.order_category_id
				 , ordercat.category_desc
				 , ordercat.family_portal_sort_order
				 , ppo.order_date
				 , ppo.order_status
				 , ppo.physician_id
				 , ppo.reorder
				 , ppo.revision_by
				 , ppo.revision_date
				 , CASE WHEN useraudit.edited_date is null THEN ppo.revision_date ELSE useraudit.edited_date END  'useraudit.edited_date'
				 , ppo.route_of_admin
				 , ppo.start_date
				 , isnull(ppo.order_verified, 'Y') 'order_verified'
				 , ppo.next_refill_date
				 , ppo.do_not_fill
				 , ppo.first_documented
				 , ppo.origin_id
				 , ppo.controlled_substance_code
				 , ppo.pharmacy_id
				 , ppo.communication_method
				 , CASE WHEN ppone.phys_order_id is null THEN 'Y' ELSE 'N' END  'ppone.phys_order_id'
				 , c.discharge_date
				 , c.client_id_number
				 , c.last_name
				 , c.first_name
				 , ppo.orig_phys_order_id
				 , lib.pho_ext_lib_id
				 , lib.pho_ext_lib_med_id
				 , lib.pho_ext_lib_med_ddid
				 , lib.ext_lib_rxnorm_id
				 , ppo.vendor_phys_order_id
				 , case
					when pso.std_order_id is not null and (pso.advanced_directive=1) then 'Y'
					when pstd.std_phys_order_id is not null and (pstd.advanced_directive='Y') then 'Y'
					else 'N'
				  end as 'advanced_directive'
				, confirmed_by_audit_id
				, ppone.phys_order_id
				, ppo.description
				, ls.linked_set_id
				, ls.set_description
				, ppo.order_class_id
	from
		@clientInfo c
		INNER JOIN pho_phys_order ppo WITH (NOLOCK)
			ON c.client_id = ppo.client_id
		INNER JOIN @vpos vpos
			ON vpos.phys_order_id = ppo.phys_order_id
		LEFT JOIN pho_phys_order_new_entry ppone WITH (NOLOCK)
			ON ppone.phys_order_id = ppo.phys_order_id
		LEFT JOIN pho_order_ext_lib_med_ref lib WITH (NOLOCK)
			ON lib.phys_order_id = ppo.phys_order_id AND lib.deleted='N'
		LEFT JOIN pho_std_phys_order pstd WITH (NOLOCK)
			ON pstd.std_phys_order_id = ppo.std_order_id
		LEFT JOIN pho_std_order pso WITH (NOLOCK)
			ON pso.std_order_id = ppo.std_order_id
		LEFT JOIN pho_phys_order_useraudit useraudit WITH (NOLOCK)
			ON useraudit.phys_order_id = ppo.phys_order_id
		LEFT JOIN PHO_ORDER_CATEGORY ordercat WITH (NOLOCK)
     		ON ppo.order_category_id = ordercat.order_category_id
		LEFT JOIN sec_user createdBySu  WITH (NOLOCK)
     		ON createdBySu.loginname = ppo.created_by
		LEFT JOIN COMMON_CODE diettype WITH (NOLOCK)
			ON ppo.diet_type = diettype.item_id
		LEFT JOIN COMMON_CODE dietsup WITH (NOLOCK)
			ON ppo.diet_supplement = dietsup.item_id
		LEFT JOIN pho_linked_set_item lsi on lsi.phys_order_id=ppo.phys_order_id
		LEFT JOIN pho_linked_set ls on ls.linked_set_id=lsi.linked_set_id

	where
		( @physOrderId IS NULL OR ppo.phys_order_id = @physOrderId  )
		AND (isnull(ppo.active_flag, 'Y') = 'Y')
		AND
			(
				(@narcoticsOnly = 'N')
				OR
				(
					ppo.controlled_substance_code IS NOT NULL AND LTRIM(RTRIM(ppo.controlled_substance_code)) IN ('2','3','4','5','6','99')
				)
			)
		AND (@orderLinkedOption=3 or (@orderLinkedOption=2 and lsi.phys_order_id=ppo.phys_order_id)
			or (@orderLinkedOption=1 and lsi.phys_order_id is null))
		AND order_class_id = @orderClassId_local
END
ELSE -- get both Institutional orders and Discharge orders
BEGIN
	insert into @orderData
	select
		distinct ppo.phys_order_id
				 ,vpos.order_status
				 ,vpos.order_relationship
				 ,vpos.status_reason
				 , ppo.fac_id
				 , ppo.client_id
				 , ppo.diet_type
				 , ppo.diet_texture
				 , ppo.diet_supplement
				 , ppo.fluid_consistency
				 , ppo.alter_med_src
				 , ppo.nurse_pharm_notes
				 , ppo.created_by
				 , createdBySu.long_username
				 , ppo.created_date
				 , ppo.date_ordered
				 , case when ppo.order_category_id=3031 then diettype.item_description
							 when ppo.order_category_id=3032 then dietsup.item_description
							 when ppo.order_category_id=3023 then diettype.item_description
							 when ppo.order_category_id=3033 then 'Enteral Feed'
							 else ppo.description
						end 'calculated_description'
				 , ppo.related_generic
				 , ppo.dispense_as_written
				 , ppo.directions
				 , ppo.strength
				 , ppo.drug_strength
				 , ppo.drug_strength_uom
				 , ppo.discontinued_date
				 , ppo.end_date
				 , ppo.hold_date
				 , ppo.hold_date_end
				 , ppo.last_reorder_date
				 , ppo.order_type_id
				 , ppo.order_category_id
				 , ordercat.category_desc
				 , ordercat.family_portal_sort_order
				 , ppo.order_date
				 , ppo.order_status
				 , ppo.physician_id
				 , ppo.reorder
				 , ppo.revision_by
				 , ppo.revision_date
				 , CASE WHEN useraudit.edited_date is null THEN ppo.revision_date ELSE useraudit.edited_date END  'useraudit.edited_date'
				 , ppo.route_of_admin
				 , ppo.start_date
				 , isnull(ppo.order_verified, 'Y') 'order_verified'
				 , ppo.next_refill_date
				 , ppo.do_not_fill
				 , ppo.first_documented
				 , ppo.origin_id
				 , ppo.controlled_substance_code
				 , ppo.pharmacy_id
				 , ppo.communication_method
				 , CASE WHEN ppone.phys_order_id is null THEN 'Y' ELSE 'N' END  'ppone.phys_order_id'
				 , c.discharge_date
				 , c.client_id_number
				 , c.last_name
				 , c.first_name
				 , ppo.orig_phys_order_id
				 , lib.pho_ext_lib_id
				 , lib.pho_ext_lib_med_id
         , lib.pho_ext_lib_med_ddid
         , lib.ext_lib_rxnorm_id
				 , ppo.vendor_phys_order_id
				 , case
					when pso.std_order_id is not null and (pso.advanced_directive=1) then 'Y'
					when pstd.std_phys_order_id is not null and (pstd.advanced_directive='Y') then 'Y'
					else 'N'
				  end as 'advanced_directive'
				, confirmed_by_audit_id
				, ppone.phys_order_id
				, ppo.description
				, ls.linked_set_id
				, ls.set_description
				, ppo.order_class_id
	from
		@clientInfo c
		INNER JOIN pho_phys_order ppo WITH (NOLOCK)
			ON c.client_id = ppo.client_id
		INNER JOIN @vpos vpos
			ON vpos.phys_order_id = ppo.phys_order_id
		LEFT JOIN pho_phys_order_new_entry ppone WITH (NOLOCK)
			ON ppone.phys_order_id = ppo.phys_order_id
		LEFT JOIN pho_order_ext_lib_med_ref lib WITH (NOLOCK)
			ON lib.phys_order_id = ppo.phys_order_id AND lib.deleted='N'
		LEFT JOIN pho_std_phys_order pstd WITH (NOLOCK)
			ON pstd.std_phys_order_id = ppo.std_order_id
		LEFT JOIN pho_std_order pso WITH (NOLOCK)
			ON pso.std_order_id = ppo.std_order_id
		LEFT JOIN pho_phys_order_useraudit useraudit WITH (NOLOCK)
			ON useraudit.phys_order_id = ppo.phys_order_id
		LEFT JOIN PHO_ORDER_CATEGORY ordercat WITH (NOLOCK)
     		ON ppo.order_category_id = ordercat.order_category_id
		LEFT JOIN sec_user createdBySu  WITH (NOLOCK)
     		ON createdBySu.loginname = ppo.created_by
		LEFT JOIN COMMON_CODE diettype WITH (NOLOCK)
			ON ppo.diet_type = diettype.item_id
		LEFT JOIN COMMON_CODE dietsup WITH (NOLOCK)
			ON ppo.diet_supplement = dietsup.item_id
		LEFT JOIN pho_linked_set_item lsi on lsi.phys_order_id=ppo.phys_order_id
		LEFT JOIN pho_linked_set ls on ls.linked_set_id=lsi.linked_set_id

	where
		( @physOrderId IS NULL OR ppo.phys_order_id = @physOrderId  )
		AND (isnull(ppo.active_flag, 'Y') = 'Y')
		AND
			(
				(@narcoticsOnly = 'N')
				OR
				(
					ppo.controlled_substance_code IS NOT NULL AND LTRIM(RTRIM(ppo.controlled_substance_code)) IN ('2','3','4','5','6','99')
				)
			)
		AND (@orderLinkedOption=3 or (@orderLinkedOption=2 and lsi.phys_order_id=ppo.phys_order_id)
			or (@orderLinkedOption=1 and lsi.phys_order_id is null))
END

-- remove the orders from @orderData that does not match the discharge order pharmacy only when discharge order and when the pharmacy search is provided
IF(@pharmacyNCPDP_local is not null)
BEGIN
	insert into @dischargePharmacyNCPDP
	select s.phys_order_id from pho_phys_order_discharge_snapshot s
	inner join @orderData o on o.phys_order_id = s.phys_order_id and o.order_class_id = 2
	where ncpdp_identifier = @pharmacyNCPDP_local

	delete from @orderData where order_class_id = 2 and phys_order_id NOT IN (select discharge_pharm_phys_order_id from @dischargePharmacyNCPDP)
END

SET @step = 5
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert non struckout orders into cache'
IF @debug='Y'
    PRINT @status_text
    INSERT INTO @result
    SELECT
		distinct
		 ppo.phys_order_id
        ,ppo.status
        ,ppo.relationship
        ,ppo.status_reason
        ,ppo.fac_id
        ,ppo.client_id
        ,ppo.diet_type
        ,ppo.diet_texture
        ,ppo.diet_supplement
        ,ppo.fluid_consistency
        ,ppo.alter_med_src
        ,ppo.nurse_pharm_notes
        ,ppo.created_by
        ,ppo.created_by_longname
        ,ppo.created_date
        ,ppo.date_ordered
        ,ppo.calculated_description
        ,ppo.related_generic
        ,ppo.dispense_as_written
        ,ppo.directions
		,ppo.strength
        ,ppo.drug_strength
        ,ppo.drug_strength_uom
        ,ppo.discontinued_date
        ,ppo.end_date
        ,ppo.hold_date
        ,ppo.hold_date_end
        ,ppo.last_reorder_date
        ,ppo.order_type_id
        ,ppo.order_category_id
        ,ppo.order_category_description
        ,ppo.family_portal_sort_order
        ,ppo.order_date
        ,ppo.order_status
        ,ppo.physician_id
        ,ppo.reorder
        ,ppo.revision_by
        ,ppo.revision_date
        ,ppo.edited_date
        ,ppo.route_of_admin
        ,ppo.start_date
        ,ppo.order_verified
        ,ppo.next_refill_date
        ,ppo.do_not_fill
        ,ppo.first_documented
        ,ppo.origin_id
        ,ppo.controlled_substance_code
        ,ppo.pharmacy_id
        ,ppo.communication_method
        ,ppo.legacy_order
        ,ppo.discharge_date
        ,ppo.client_id_number

        ,ppo.resident_last_name
        ,ppo.resident_first_name
        ,ppo.orig_phys_order_id
        ,ppo.pho_ext_lib_id
        ,ppo.pho_ext_lib_med_id
        ,ppo.pho_ext_lib_med_ddid
        ,ppo.ext_lib_rxnorm_id
		,null
		,null
		,null
		,ppo.vendor_phys_order_id
		,ppo.advanced_directive
        ,ppo.end_date
		,ppo.linked_set_id
		,ppo.linked_set_name
		,ppo.order_class_id
           FROM
				@orderData ppo
				INNER JOIN @orderStatus os
					on  os.status = ppo.status
				INNER JOIN @communicationMethodIds cm
					ON cm.method_id = isnull(ppo.communication_method, 3027)
				INNER JOIN @orderCategoryIds oc
					ON oc.order_category_id = ppo.order_category_id
				LEFT JOIN pho_order_type orderType WITH (NOLOCK)
            		ON ppo.order_type_id = orderType.order_type_id
				LEFT JOIN pho_order_supply pos
        			ON ppo.phys_order_id = pos.phys_order_id
				LEFT JOIN pho_phys_order_useraudit  useraudit
				    on useraudit.phys_order_id = ppo.phys_order_id
				LEFT JOIN pho_administration_record  adminRecord WITH (NOLOCK)
            		ON orderType.administration_record_id = adminRecord.administration_record_id
				LEFT JOIN cp_sec_user_audit confuser  WITH (NOLOCK)
					ON confuser.cp_sec_user_audit_id = ppo.confirmed_by_audit_id
				LEFT JOIN contact physcon ON physcon.contact_id = ppo.physician_id
            WHERE

                (@providerId IS NULL OR ppo.pharmacy_id = @providerId)
                AND
                (@orderedById IS NULL OR ppo.physician_id = @orderedById OR ppo.physician_id = @oldOrderById)
                AND
                (@orderTypeId IS NULL OR ppo.order_type_id = @orderTypeId)
                AND
                (@adminRecordId IS NULL OR adminRecord.administration_record_id = @adminRecordId)
                AND
                (@routeOfAdminIdsCSV IS NULL OR ppo.route_of_admin IN (SELECT route_of_Admin from @routeOfAdminIds))
                AND
                (@medicationSourceId IS NULL OR ppo.alter_med_src = @medicationSourceId)
                AND
                (@pharmacyId IS NULL OR ppo.pharmacy_id = @pharmacyId)
                AND
                (@createdBy is NULL OR ppo.created_by = @createdBy)
                AND
				(@confirmedBy is NULL OR confuser.loginname = @confirmedBy)

                --AND
                -- do not show invalid category and administrative orders
                --ppo.order_category_id <> 1 AND ppo.order_category_id <> 3030
                AND
                (
                    (@orderDate IS NULL OR @orderDateoperator IS NULL)
                    OR
                    (
                        (@orderDateoperator = 0 AND ppo.order_date >= @orderDate AND ppo.order_date < @orderDate + 1)
                        OR (@orderDateoperator = 1 AND ppo.order_date >= @orderDate + 1)
                        OR (@orderDateoperator = -1 AND ppo.order_date < @orderDate)
                    )
                )
                AND
                (
                    (@startDate IS NULL OR @startDateoperator IS NULL)
                    OR
                    (
                        (@startDateoperator = 0 AND ppo.start_date >= @startDate AND ppo.start_date < @startDate + 1)
                        OR (@startDateoperator = 1  AND ppo.start_date >= @startDate + 1)
                        OR (@startDateoperator = -1 AND ppo.start_date < @startDate)
                    )
                )
                AND
                (
                    (@endDate IS NULL OR @endDateoperator IS NULL)
                    OR
                    (
                        (@endDateoperator = 0 AND ppo.end_date >= @endDate AND ppo.end_date < @endDate + 1)
                        OR (@endDateoperator = 1  AND (ppo.end_date >= @endDate + 1 OR ppo.end_date IS NULL))
                        OR (@endDateoperator = -1 AND ppo.end_date < @endDate)
                    )
                )
	            AND
	            (
	                (@discontinuedDate IS NULL OR @discontinuedDateoperator IS NULL)
	                OR
	                (
	                    (@discontinuedDateoperator = 0 AND ppo.discontinued_date >= @discontinuedDate AND ppo.discontinued_date < @discontinuedDate + 1)
	                    OR (@discontinuedDateoperator = 1  AND ppo.discontinued_date >= @discontinuedDate + 1)
	                    OR (@discontinuedDateoperator = -1 AND ppo.discontinued_date < @discontinuedDate)
	                )
	            )
				AND
	            (
	                --This condition is to handle historical orders case ie to filter historical orders only when the proc is called in that scenario
					--If @historicalOrdersOnly = 'N' => the proc IS NOT called for historical orders only scenario and therefore this condition should not prevent returing the order (by testing order endDate and discontinuedDate)
					--If @historicalOrdersOnly = 'Y' but @historicalOrdersOnlyPeriodStart IS NULL => the proc IS called for historical orders only scenario but WITH NO limit on the period therefore this condition should not prevent returning the order neither (by testing order endDate and discontinuedDate)
					--If @historicalOrdersOnly = 'Y' and @historicalOrdersOnlyPeriodStart IS NOT NULL => the proc IS called for historical orders only scenario and WITH limit on the period and therefore, in order to be returned, order should fall in the specified period (order endDate and discontinuedDate should verify the below conditions)
					(@historicalOrdersOnlyPeriodStart IS NULL OR @historicalOrdersOnly = 'N')
	                OR
					(
					(ppo.end_Date IS NULL OR ppo.end_Date > @historicalOrdersOnlyPeriodStart)
					AND (ppo.discontinued_Date IS NULL OR ppo.discontinued_Date > @historicalOrdersOnlyPeriodStart)
					)

	            )
	            AND
	            (
	                (@holdDate IS NULL OR @holdDateoperator IS NULL)
	                OR
	                (
	                    (@holdDateoperator = 0 AND ppo.hold_date >= @holdDate AND ppo.hold_date < @holdDate + 1)
	                    OR (@holdDateoperator = 1  AND ppo.hold_date >= @holdDate + 1)
	                    OR (@holdDateoperator = -1 AND ppo.hold_date < @holdDate)
	                )
	            )
	            AND
	            (
	                (@completedDate IS NULL OR @completedDateoperator IS NULL)
	                OR
	                (
	                    (@completedDateoperator = 0 AND ppo.end_date >= @completedDate AND ppo.end_date < @completedDate + 1)
	                    OR (@completedDateoperator = 1  AND ppo.end_date >= @completedDate + 1)
	                    OR (@completedDateoperator = -1 AND ppo.end_date < @completedDate)
	                )
	            )
	            AND
	            (
	                (@confirmedDate IS NULL OR @confirmedDateoperator IS NULL)
	                OR
	                (
	                    (@confirmedDateoperator = 0 AND useraudit.confirmed_date >= @confirmedDate AND useraudit.confirmed_date < @confirmedDate + 1)
	                    OR (@confirmedDateoperator = 1  AND useraudit.confirmed_date >= @confirmedDate + 1)
	                    OR (@confirmedDateoperator = -1 AND useraudit.confirmed_date < @confirmedDate)
	                )
	            )
                AND
                (@showLegacyOrder IS NULL OR (@showLegacyOrder='Y' AND ppone_phys_order_id IS NULL) OR (@showLegacyOrder='N' AND ppone_phys_order_id IS NOT NULL))

                    AND
					(@medication IS NULL OR ppo.description LIKE '%' + @medication + '%' OR (pos.description LIKE '%' + @medication + '%'AND pos.active = 'Y'))
                    AND
                    (@clientIdNumber IS NULL OR client_id_number = @clientIdNumber)
                    AND
                    (
                        @clientStatus IS NULL
                        --discharged
                        OR (@clientStatus = 0 AND discharge_date IS NOT NULL AND discharge_date <= @facilityDateTime)
                        --active
                        OR (@clientStatus = 1 AND (discharge_date IS NULL OR discharge_date > @facilityDateTime))
                    )
                    AND
                    (
	                    @medicationclassification IS NULL OR
	                    ppo.phys_order_id  IN
	                    (
	                        select * from @medicationclassificationTable
	                    )
                    )
                    AND (
                      (
                        @supplyStatusId IS NULL
                        AND @fromIntegratedPharmacy IS NULL
                        AND @medSrcTypeId IS NULL
                      )
                      OR (
                        ppo.phys_order_id IN (select * from @supplyCriteria)
                      )
                    )
                    AND
                    ( @physOrderId IS NULL OR ppo.phys_order_id = @physOrderId  )
					AND (physcon.deleted = CASE WHEN @includeRetired = 'Y' THEN physcon.deleted ELSE 'N' END  OR ppo.physician_id IS NULL OR physcon.deleted is NULL)

            ORDER BY ppo.revision_by desc


--PCC-26565: Any orders (regardless of status) with alerts should always show in orders chart
SET @step = 51
if (@alwaysShowOrderWithAlert = 'Y')
BEGIN
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert orders having alerts into cache - considering duplicated order id'

	INSERT INTO @ordersHavingAlerts
	SELECT DISTINCT
	ppo.phys_order_id
	FROM @orderData ppo
	INNER JOIN cr_alert ca WITH (NOLOCK) ON
											ca.fac_id = ppo.fac_id
											AND ca.client_id = ppo.client_id
											AND ca.triggered_item_id = ppo.phys_order_id
											AND ca.triggered_item_type = 'O'
											AND ca.resolved <> 'Y'
											AND ca.deleted = 'N'
	WHERE ppo.status = 3 -- Consider Completed orders only

if (@showOrdersWithIntegrationAlerts = 'Y')
	INSERT INTO @ordersHavingAlerts
	SELECT DISTINCT
	ppo.phys_order_id
	FROM @orderData ppo
	INNER JOIN cr_alert ca WITH (NOLOCK) ON
											ca.fac_id = ppo.fac_id
											AND ca.client_id = ppo.client_id
											AND ca.triggered_item_id = ppo.phys_order_id
											AND ca.triggered_item_type = 'M'
											AND ca.resolved <> 'Y'
											AND ca.deleted = 'N'


if(@showOrdersWithSupplyIntegrationAlerts = 'Y')
	INSERT INTO @ordersHavingAlerts
	SELECT DISTINCT
	ppo.phys_order_id
	FROM @orderData ppo
	INNER JOIN pho_order_supply s ON s.phys_order_id = ppo.phys_order_id
	INNER JOIN cr_alert ca WITH (NOLOCK) ON
											ca.fac_id = ppo.fac_id
											AND ca.client_id = ppo.client_id
											AND ca.triggered_item_id = s.order_supply_id
											AND ca.triggered_item_type = 'D'
											AND ca.resolved <> 'Y'
											AND ca.deleted = 'N'


IF @debug='Y'
    PRINT @status_text
    INSERT INTO @result
    SELECT distinct
			ppo.phys_order_id
        ,ppo.status
        ,ppo.relationship
        ,ppo.status_reason
        ,ppo.fac_id
        ,ppo.client_id
        ,ppo.diet_type
        ,ppo.diet_texture
        ,ppo.diet_supplement
        ,ppo.fluid_consistency
        ,ppo.alter_med_src
        ,ppo.nurse_pharm_notes
        ,ppo.created_by
        ,ppo.created_by_longname
        ,ppo.created_date
        ,ppo.date_ordered
        ,ppo.calculated_description
        ,ppo.related_generic
        ,ppo.dispense_as_written
        ,ppo.directions
		,ppo.strength
        ,ppo.drug_strength
        ,ppo.drug_strength_uom
        ,ppo.discontinued_date
        ,ppo.end_date
        ,ppo.hold_date
        ,ppo.hold_date_end
        ,ppo.last_reorder_date
        ,ppo.order_type_id
        ,ppo.order_category_id
        ,ppo.order_category_description
        ,ppo.family_portal_sort_order
        ,ppo.order_date
        ,ppo.order_status
        ,ppo.physician_id
        ,ppo.reorder
        ,ppo.revision_by
        ,ppo.revision_date
        ,ppo.edited_date
        ,ppo.route_of_admin
        ,ppo.start_date
        ,ppo.order_verified
        ,ppo.next_refill_date
        ,ppo.do_not_fill
        ,ppo.first_documented
        ,ppo.origin_id
        ,ppo.controlled_substance_code
        ,ppo.pharmacy_id
        ,ppo.communication_method
        ,ppo.legacy_order
        ,ppo.discharge_date
        ,ppo.client_id_number
        ,ppo.resident_last_name
        ,ppo.resident_first_name
        ,ppo.orig_phys_order_id
        ,ppo.pho_ext_lib_id
        ,ppo.pho_ext_lib_med_id
        ,ppo.pho_ext_lib_med_ddid
        ,ppo.ext_lib_rxnorm_id
		,null
		,null
		,null
		,ppo.vendor_phys_order_id
		,ppo.advanced_directive
		,ppo.end_date
		,ppo.linked_set_id
		,ppo.linked_set_name
		,ppo.order_class_id
           FROM
            @orderData ppo
			INNER JOIN @orderCategoryIds oc
				ON oc.order_category_id = ppo.order_category_id
			INNER JOIN @ordersHavingAlerts oha ON oha.phys_order_id = ppo.phys_order_id
			LEFT JOIN contact physcon ON physcon.contact_id = ppo.physician_id
             WHERE
				oha.phys_order_id not in ( select phys_order_id from @result )
				AND (physcon.deleted = CASE WHEN @includeRetired = 'Y' THEN physcon.deleted ELSE 'N' END OR ppo.physician_id IS NULL OR physcon.deleted is NULL)
                --AND
                -- do not show invalid category and administrative orders
                --ppo.order_category_id <> 1 AND ppo.order_category_id <> 3030

            ORDER BY ppo.revision_by desc
END

SET @step = 6
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Insert struckout orders into cache = "' + CONVERT(VARCHAR(1), @includeStruckOutOrders) + '"';
IF @debug='Y'
    PRINT @status_text;
	IF @includeStruckOutOrders = 'Y'
	BEGIN
		WITH AUDIT AS
		(
			SELECT
				ppo.phys_order_id 'phys_order_id'
				 ,4  'status'
				 ,NULL	as relationship
				 ,NULL  as status_reason
				 , ppo.fac_id 'fac_id'
				 , ppo.client_id 'client_id'
				 , ppo.diet_type 'diet_type'
				 , ppo.diet_texture 'diet_texture'
				 , ppo.diet_supplement 'diet_supplement'
				 , ppo.fluid_consistency 'fluid_consistency'
				 , ppo.alter_med_src 'alter_med_src'
				 , ppo.created_by 'created_by'
				 --, createdBySu.long_username 'created_by_longname'
				 , ppo.created_date 'created_date'
				 , ppo.date_ordered 'date_ordered'
				/* , case when ppo.order_category_id=3031 then diettype.item_description
							 when ppo.order_category_id=3032 then dietsup.item_description
							 when ppo.order_category_id=3023 then diettype.item_description
							 when ppo.order_category_id=3033 then 'Enteral Feed'
							 else ppo.description
						end 'description'*/
				 , ppo.related_generic 'related_generic'
				 , ppo.dispense_as_written 'dispense_as_written'
				 , ppo.directions 'directions'
				 , ppo.strength
				 , ppo.drug_strength 'drug_strength'
				 , ppo.drug_strength_uom 'drug_strength_uom'
				 , ppo.discontinued_date 'discontinued_date'
				 , ppo.end_date 'end_date'
				 , ppo.hold_date 'hold_date'
				 , ppo.hold_date_end 'hold_date_end'
				 , ppo.last_reorder_date 'last_reorder_date'
				 , ppo.order_type_id 'order_type_id'
				 , ppo.order_category_id 'order_category_id'
				-- , ordercat.category_desc  'order_category_description'
				 , ppo.order_date 'order_date'
				 , ppo.order_status 'order_status'
				 , ppo.physician_id 'physician_id'
				 , ppo.reorder 'reorder'
				 , ppo.revision_by 'revision_by'
				 , ppo.revision_date 'revision_date'
				 , ppo.revision_date 'edited_date'
				 , ppo.route_of_admin 'route_of_admin'
				 , ppo.start_date 'start_date'
				 , isnull(ppo.order_verified, 'Y') 'order_verified'
				 , ppo.next_refill_date 'next_refill_date'
				 , ppo.do_not_fill 'do_not_fill'
				 , ppo.first_documented 'first_documented'
				 , ppo.origin_id 'origin_id'
				 , ppo.controlled_substance_code 'controlled_substance_code'
				 , ppo.pharmacy_id 'pharmacy_id'
				 , ppo.communication_method 'communication_method'
				-- , CASE WHEN ppone.phys_order_id is null THEN 'Y' ELSE 'N' END  'legacy_order'
				 , c.discharge_date 'discharge_date'
				 , c.client_id_number 'client_id_number'
				 , c.last_name 'resident_last_name'
				 , c.first_name 'resident_first_name'
				 , ppo.orig_phys_order_id 'orig_phys_order_id'
			   --  , lib.pho_ext_lib_id
			   --  , lib.pho_ext_lib_med_id
				 , ppo.strikeout_date
				 , ppo.strikeout_by
			   --  , strike_code.item_description 'strikeout_reason_description'
  	     		 , ppo.vendor_phys_order_id
  			  --	 , isnull(pstd.advanced_directive, 'N') 'advanced_directive'

		--added
				,ppo.std_order_id
				,ppo.active_flag
				,ppo.description
				,ppo.strikeout_reason_code
				,c.first_name
				,c.last_name
				,order_class_id
			FROM
					pho_phys_order_audit ppo WITH (NOLOCK)
					INNER JOIN @clientInfo c
						ON c.client_id = ppo.client_id
					INNER JOIN @orderStatus os
						on  os.status = 4
			WHERE
					ppo.event_type = 'S'
					--required
					AND ppo.fac_id = @facIdLocal
					AND c.fac_id = @facIdLocal
					AND ppo.order_class_id = @orderClassId_local
		)

		INSERT INTO @result
		SELECT distinct adt.phys_order_id 'phys_order_id'
				 ,4 'status'
				 ,NULL
				 ,NULL
				 , adt.fac_id 'fac_id'
				 , adt.client_id 'client_id'
				 , adt.diet_type 'diet_type'
				 , adt.diet_texture 'diet_texture'
				 , adt.diet_supplement 'diet_supplement'
				 , adt.fluid_consistency 'fluid_consistency'
				 , adt.alter_med_src 'alter_med_src'
				 , null
				 , adt.created_by 'created_by'
				 , createdBySu.long_username 'created_by_longname'
				 , adt.created_date 'created_date'
				 , adt.date_ordered 'date_ordered'
				 , case when adt.order_category_id=3031 then diettype.item_description
							 when adt.order_category_id=3032 then dietsup.item_description
							 when adt.order_category_id=3023 then diettype.item_description
							 when adt.order_category_id=3033 then 'Enteral Feed'
							 else adt.description
						end 'description'
				 , adt.related_generic 'related_generic'
				 , adt.dispense_as_written 'dispense_as_written'
				 , adt.directions 'directions'
				 , adt.strength
				 , adt.drug_strength 'drug_strength'
				 , adt.drug_strength_uom 'drug_strength_uom'
				 , adt.discontinued_date 'discontinued_date'
				 , adt.end_date 'end_date'
				 , adt.hold_date 'hold_date'
				 , adt.hold_date_end 'hold_date_end'
				 , adt.last_reorder_date 'last_reorder_date'
				 , adt.order_type_id 'order_type_id'
				 , adt.order_category_id 'order_category_id'
				 , ordercat.category_desc  'order_category_description'
				 , ordercat.family_portal_sort_order 'family_portal_sort_order'
				 , adt.order_date 'order_date'
				 , adt.order_status 'order_status'
				 , adt.physician_id 'physician_id'
				 , adt.reorder 'reorder'
				 , adt.revision_by 'revision_by'
				 , adt.revision_date 'revision_date'
				 , adt.revision_date 'edited_date'
				 , adt.route_of_admin 'route_of_admin'
				 , adt.start_date 'start_date'
				 , isnull(adt.order_verified, 'Y') 'order_verified'
				 , adt.next_refill_date 'next_refill_date'
				 , adt.do_not_fill 'do_not_fill'
				 , adt.first_documented 'first_documented'
				 , adt.origin_id 'origin_id'
				 , adt.controlled_substance_code 'controlled_substance_code'
				 , adt.pharmacy_id 'pharmacy_id'
				 , adt.communication_method 'communication_method'
				 , CASE WHEN ppone.phys_order_id is null THEN 'Y' ELSE 'N' END  'legacy_order'
				 , adt.discharge_date 'discharge_date'
				 , adt.client_id_number 'client_id_number'
				 , adt.last_name 'resident_last_name'
				 , adt.first_name 'resident_first_name'
				 , adt.orig_phys_order_id 'orig_phys_order_id'
				 , lib.pho_ext_lib_id
				 , lib.pho_ext_lib_med_id
				 , lib.pho_ext_lib_med_ddid
				 , lib.ext_lib_rxnorm_id

				 , adt.strikeout_date
				 , adt.strikeout_by
				 , strike_code.item_description 'strikeout_reason_description'
  	     		 , adt.vendor_phys_order_id
				 , case
					when pso.std_order_id is not null and (pso.advanced_directive=1) then 'Y'
					when pstd.std_phys_order_id is not null and (pstd.advanced_directive='Y') then 'Y'
					else 'N'
				  end as 'advanced_directive'
  	      		 ,adt.end_date
				 ,null
				 ,null
				 ,adt.order_class_id
				FROM AUDIT adt
					/*pho_phys_order_audit ppo WITH (NOLOCK)
					INNER JOIN @clientInfo c
						ON c.client_id = ppo.client_id
					INNER JOIN @orderStatus os
						on  os.status = 4*/
					INNER JOIN @communicationMethodIds cm
						ON cm.method_id = isnull(adt.communication_method, 3027)
					INNER JOIN @orderCategoryIds oc
						ON oc.order_category_id = adt.order_category_id
					LEFT JOIN pho_order_type orderType  WITH (NOLOCK)
        				ON adt.order_type_id = orderType.order_type_id
					LEFT JOIN pho_order_supply pos
        				ON adt.phys_order_id = pos.phys_order_id
					LEFT JOIN pho_administration_record  adminRecord WITH (NOLOCK)
        				ON orderType.administration_record_id = adminRecord.administration_record_id
					LEFT JOIN pho_phys_order_new_entry ppone WITH (NOLOCK)
						ON ppone.phys_order_id = adt.phys_order_id
					LEFT JOIN pho_order_ext_lib_med_ref lib WITH (NOLOCK)
						ON lib.phys_order_id = adt.phys_order_id
					LEFT JOIN COMMON_CODE strike_code WITH (NOLOCK)
						ON strike_code.item_id = adt.strikeout_reason_code
					LEFT JOIN pho_phys_order_useraudit useraudit WITH (NOLOCK)
							ON useraudit.phys_order_id = adt.phys_order_id
					LEFT JOIN cp_sec_user_audit confuser  WITH (NOLOCK)
							ON confuser.cp_sec_user_audit_id = useraudit.confirmed_by_audit_id
					LEFT JOIN pho_std_phys_order pstd WITH (NOLOCK)
						ON pstd.std_phys_order_id = adt.std_order_id
					LEFT JOIN pho_std_order pso WITH (NOLOCK)
						ON pso.std_order_id = adt.std_order_id
					LEFT JOIN PHO_ORDER_CATEGORY ordercat WITH (NOLOCK)
        				ON adt.order_category_id = ordercat.order_category_id
        			LEFT JOIN sec_user createdBySu  WITH (NOLOCK)
        				ON createdBySu.loginname = adt.created_by
					-- for sorting on description
					LEFT JOIN COMMON_CODE diettype WITH (NOLOCK)
						ON adt.diet_type = diettype.item_id
					LEFT JOIN COMMON_CODE dietsup WITH (NOLOCK)
						ON adt.diet_supplement = dietsup.item_id
					LEFT JOIN CONTACT physcon
					ON adt.physician_id = physcon.contact_id

					WHERE
					/*ppo.event_type = 'S'

					--required
					AND adt.fac_id = @facIdLocal
					AND c.fac_id = @facIdLocal
					AND*/
					(@providerId IS NULL OR adt.pharmacy_id = @providerId)
					AND
					(@orderedById IS NULL OR adt.physician_id = @orderedById OR adt.physician_id = @oldOrderById)
					AND
					(@orderTypeId IS NULL OR adt.order_type_id = @orderTypeId)
					AND
					(@adminRecordId IS NULL OR adminRecord.administration_record_id = @adminRecordId)
					AND
					(@routeOfAdminIdsCSV IS NULL OR adt.route_of_admin IN (SELECT route_of_Admin from @routeOfAdminIds))
					AND
					(@medicationSourceId IS NULL OR adt.alter_med_src = @medicationSourceId)
					AND
					(@pharmacyId IS NULL OR adt.pharmacy_id = @pharmacyId)
					AND
					(@createdBy is NULL OR adt.created_by = @createdBy)
					AND
					(@confirmedBy is NULL OR confuser.loginname = @confirmedBy)

					--AND
					-- do not show invalid category and administrative orders
					--ppo.order_category_id <> 1 AND ppo.order_category_id <> 3030
					AND
					(
						(@orderDate IS NULL OR @orderDateoperator IS NULL)
						OR
						(
							(@orderDateoperator = 0 AND adt.order_date >= @orderDate AND adt.order_date < @orderDate + 1)
							OR (@orderDateoperator = 1 AND adt.order_date >= @orderDate + 1)
							OR (@orderDateoperator = -1 AND adt.order_date < @orderDate)
						)
					)
					AND
					(
						(@startDate IS NULL OR @startDateoperator IS NULL)
						OR
						(
							(@startDateoperator = 0 AND adt.start_date >= @startDate AND adt.start_date < @startDate + 1)
							OR (@startDateoperator = 1  AND adt.start_date >= @startDate + 1)
							OR (@startDateoperator = -1 AND adt.start_date < @startDate)
						)
					)
					AND
					(
						(@endDate IS NULL OR @endDateoperator IS NULL)
						OR
						(
							(@endDateoperator = 0 AND adt.end_date >= @endDate AND adt.end_date < @endDate + 1)
							OR (@endDateoperator = 1  AND (adt.end_date >= @endDate + 1 OR adt.end_date IS NULL))
							OR (@endDateoperator = -1 AND adt.end_date < @endDate)
						)
					)
					AND
					(@showLegacyOrder IS NULL OR (@showLegacyOrder='Y' AND ppone.phys_order_id IS NULL) OR (@showLegacyOrder='N' AND ppone.phys_order_id IS NOT NULL))

						AND
						(@medication IS NULL OR adt.description LIKE '%' + @medication + '%' OR (pos.description LIKE '%' + @medication + '%'AND pos.active = 'Y'))
						AND
						(@clientIdNumber IS NULL OR adt.client_id_number = @clientIdNumber)
						AND
						(
							@clientStatus IS NULL
							--discharged
							OR (@clientStatus = 0 AND adt.discharge_date IS NOT NULL AND adt.discharge_date <= @facilityDateTime)
							--active
							OR (@clientStatus = 1 AND (adt.discharge_date IS NULL OR adt.discharge_date > @facilityDateTime))
						)
						AND
						(
							@medicationclassification IS NULL OR
							adt.phys_order_id  IN
							(
								select * from @medicationclassificationTable
							)
						)
						AND (
						  (
							@supplyStatusId IS NULL
							AND @fromIntegratedPharmacy IS NULL
							AND @medSrcTypeId IS NULL
						  )
						  OR (
							adt.phys_order_id IN (select * from @supplyCriteria)
						  )
						)
						AND
						( @physOrderId IS NULL OR adt.phys_order_id = @physOrderId  )
						AND
						(isnull(adt.active_flag, 'Y') = 'Y')
						AND (physcon.deleted = CASE WHEN @includeRetired = 'Y' THEN physcon.deleted ELSE 'N' END OR adt.physician_id IS NULL OR physcon.deleted is NULL)
				ORDER BY adt.revision_by desc
	END

SET @step = 7
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Do pagination'
IF @debug='Y'
    PRINT @status_text

select @num_records = count(*) from @result

-- when page number is 2 and there is only one page
-- hur 34499
if  @pageSize > 0 and (@pageSize * (@pageNumber-1)) >= @num_records
begin
	set @pageNumber = 1
end

IF (@sortByColumn = 'end_date')
BEGIN
	update  r
		set r.end_date_filter = r.discontinued_date from @result r where r.discontinued_date is not null
END

IF @sortByOrder='desc'
BEGIN
	;with tmp as
	(
		select row_number() over(ORDER BY
									 case
										when @sortByColumn = 'resident_last_name' then resident_last_name
										when @sortByColumn = 'description' then description
										when @sortByColumn = 'status' then CONVERT(varchar(50),status)
										when @sortByColumn = 'order_category_description' then order_category_description
										when @sortByColumn = 'created_date' then CONVERT(varchar(50),created_date,112)
										when @sortByColumn = 'created_by_longname' then created_by_longname
										when @sortByColumn = 'revision_date' then CONVERT(varchar(50),edited_date,112)
										when @sortByColumn = 'start_date' then CONVERT(varchar(50),start_date,112)
										when @sortByColumn = 'end_date' then CONVERT(varchar(50),end_date_filter,112)
										when @sortByColumn = 'family_portal_sort_order' then CONVERT(varchar(50),family_portal_sort_order)
										else CONVERT(varchar(50),revision_date,112)
									end
									desc) as rn from @result
	)
		-- hur 34499
		delete from tmp where @pageSize > 0 and (rn <= (@pageSize * (@pageNumber-1)) or rn > (@pageSize * @pageNumber))
END
ELSE
BEGIN
	;with tmp as
	(
		select row_number() over(ORDER BY
										case
										when @sortByColumn = 'resident_last_name' then resident_last_name
										when @sortByColumn = 'description' then description
										when @sortByColumn = 'status' then CONVERT(varchar(50),status)
										when @sortByColumn = 'order_category_description' then order_category_description
										when @sortByColumn = 'created_date' then CONVERT(varchar(50),created_date,112)
										when @sortByColumn = 'created_by_longname' then created_by_longname
										when @sortByColumn = 'start_date' then CONVERT(varchar(50),start_date,112)
										when @sortByColumn = 'end_date' then CONVERT(varchar(50),end_date_filter,112)
										when @sortByColumn = 'revision_date' then CONVERT(varchar(50),edited_date,112)
										when @sortByColumn = 'family_portal_sort_order' then CONVERT(varchar(50),family_portal_sort_order)
										else CONVERT(varchar(50),revision_date,112)
									end
									asc ) as rn from @result
	)
		-- hur 34499
		delete from tmp where @pageSize > 0 and (rn <= (@pageSize * (@pageNumber-1)) or rn > (@pageSize * @pageNumber))
END


SET @step = 7
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Select allergies for given page of orders'
IF @debug='Y'
    PRINT @status_text

--Do this near the end so we can avoid having to join onto the pho_phys_order and pho_phys_order_audit table directly
--Here we can just use the "page" to get only the needed allergies
IF(@drugAllergyCheckEnabled='Y')
BEGIN

 INSERT INTO @physOrderAllergies
 SELECT DISTINCT r.phys_order_id
  FROM @result r
  LEFT JOIN pho_order_supply pos on pos.phys_order_id=r.phys_order_id AND (pos.active = 'Y' and (pos.status=3 or pos.status=4 or pos.status=8)) AND pos.deleted = 'N' -- Only consider active and ("processed by pharmacy", "on hand" or reordered) supplies
  LEFT JOIN pho_phys_order_allergy_acknowledgement pa on pa.phys_order_id = r.phys_order_id
  LEFT JOIN pho_order_supply_allergy posa on posa.order_supply_id = pos.order_supply_id
  INNER JOIN allergy a on (a.allergy_id = pa.allergy_id or a.allergy_id=posa.allergy_id) AND a.client_id=@clientId
 WHERE (status_id=1 or a.status_id=3) AND (resolved_date is null OR resolved_date > @facilityDateTime)


END

SET @step = 7.1
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Select related Drugs for a given page of orders'
IF @debug='Y'
    PRINT @status_text

--Do this near the end so we can avoid having to join onto the pho_phys_order and pho_phys_order_audit table directly
--Here we can just use the "page" to get only the needed related drugs

IF(@drugInteractionEnabled='Y')
BEGIN
 INSERT INTO @physOrderDrugInteraction
 SELECT DISTINCT r.phys_order_id , pda.severity_code
  FROM @result r
  LEFT JOIN pho_order_supply pos on pos.phys_order_id=r.phys_order_id AND (pos.active = 'Y' and (pos.status=3 or pos.status=4 or pos.status=8)) AND pos.deleted = 'N' -- Only consider active and ("processed by pharmacy", "on hand" or reordered) supplies
  INNER JOIN pho_phys_order_drug_acknowledgement pda on pda.phys_order_id = r.phys_order_id
END

IF(@blackBoxEnabled='Y')
BEGIN
 INSERT INTO @physOrderBlackbox
 SELECT DISTINCT r.phys_order_id
  FROM @result r
  LEFT JOIN pho_order_supply pos on pos.phys_order_id=r.phys_order_id AND (pos.active = 'Y' and (pos.status=3 or pos.status=4 or pos.status=8)) AND pos.deleted = 'N' -- Only consider active and ("processed by pharmacy", "on hand" or reordered)supplies
  INNER JOIN pho_phys_order_blackbox_acknowledgement pba on pba.phys_order_id = r.phys_order_id
END

IF(@doseCheckEnabled='Y')
BEGIN
  INSERT INTO @physOrderDoseCheck
  SELECT DISTINCT r.phys_order_id,pba.over_dose
  FROM @result r
  INNER JOIN pho_phys_order_dose_check_acknowledgement pba on pba.phys_order_id = r.phys_order_id
END

IF(@drugInteractionEnabled='Y' or @blackBoxEnabled='Y' or @doseCheckEnabled='Y')
BEGIN
  INSERT INTO @physOrderNoDrugProtocolCheck
  SELECT DISTINCT r.phys_order_id
  FROM @result r
  INNER JOIN pho_phys_order_no_drug_protocol_checks ndpc on ndpc.phys_order_id = r.phys_order_id
END


SET @step = 8

    /****************************************
    return final result
    ****************************************/
    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Return orders'
    IF @debug='Y'
        PRINT @status_text
    SELECT physorder.*

         , isnull(tpocs.pharmacy_confirmation_sent, 0) AS pharmacy_confirmation_sent
         , isnull(tpos.shipped, 0) AS shipped
         , ordercat.category_desc AS order_category_description
         , ordercat.family_portal_sort_order AS family_portal_sort_order
         , physcon.first_name AS physician_first_name
         , physcon.last_name AS physician_last_name
         , dietsup.item_description AS diet_supplement_description
         , diettexture.item_description AS diet_texture_description
         , diettype.item_description AS diet_type_description
         , fluidcon.item_description AS fluid_consistency_description
         , route.item_description AS route_description
         , adminRecord.short_description AS administration_record_short_description
         , altAdminRecord.short_description AS alt_administration_record_short_description
         , isnull(createdBySu.long_username, physorder.created_by) 'created_by_longname'
         , isnull(revisionBySu.long_username, physorder.created_by) 'revision_by_longname'
         , isnull(useraudit.created_by_audit_id, 0) AS created_by_audit_id
         , isnull(useraudit.edited_by_audit_id, 0) AS edited_by_audit_id
         , edituser.long_username AS edited_by_long
         , edituser.position_description AS edited_by_position
         , edituser.designation_desc AS edited_by_designation
         , createuser.long_username AS created_by_audit_long
         , createuser.position_description AS created_by_position
         , createuser.designation_desc AS created_by_designation
         , useraudit.confirmed_date
         , isnull(useraudit.confirmed_by_audit_id, 0) AS confirmed_by_audit_id
         , confuser.long_username AS confirmed_by_long
         , confuser.position_description AS confirmed_by_position
         , confuser.designation_desc AS confirmed_by_designation
         , eef.name as pharmacy_name
         , poa.phys_order_id AS allergy_phys_order_id
         , pob.phys_order_id AS blackbox_phys_order_id
         , pdc.phys_order_id AS dose_check_phys_order_id
         , pdc.over_dose AS over_dose_value
         , ndpc.phys_order_id as no_drug_protocol_check_phys_order_id
         ,ua.long_username as signedByName
         ,ISNULL((case when ua.designation_desc = '' THEN NULL ELSE ua.designation_desc end),ua.position_description) as signedByCredential
         ,os.signature_date as signedDate
         ,at.description as authenticationTypeDescription
         ,ss.description as sourceTypeDescription
         ,os.authentication_type_id as authenticationTypeId
         ,os.signature_type_id as signatureTypeId
         ,os.source_type_id as sourceTypeId
         ,nctrlsc.new_controlled_substance_code as new_controlled_substance_code
         ,ppoe.sign_contact_id as digitallySigned
         ,oq.quantity as prescription_quantity
         ,oq.unit_of_measure as prescription_quantity_uom
         ,oq.no_of_refills as prescription_no_of_refills
         ,ti.orig_phys_order_id as original_ti_phys_order_id

        FROM
            @result physorder
        LEFT JOIN (SELECT physorder.phys_order_id
                        , convert(BIT, count(physorder.phys_order_id)) AS pharmacy_confirmation_sent
                       FROM
                           pho_pharmacy_order pharmorder
                       INNER JOIN @result physorder
                           ON (pharmorder.phys_order_id = physorder.phys_order_id OR pharmorder.phys_order_id = physorder.orig_phys_order_id)
                       WHERE
                           pharmorder.fac_id = @facIdLocal
                           AND --active orders
                           physorder.status = 1
                           AND pharmorder.created_date > isnull(physorder.last_reorder_date, physorder.date_ordered)
                       GROUP BY
                           physorder.phys_order_id) tpocs
            ON tpocs.phys_order_id = physorder.phys_order_id
        LEFT JOIN (SELECT physorder.phys_order_id AS phys_order_id
                        , convert(BIT, count(physorder.phys_order_id)) AS shipped
                       FROM
                           pho_pharmacy_order pharmorder
                       INNER JOIN @result physorder
                           ON (pharmorder.phys_order_id = physorder.phys_order_id OR pharmorder.phys_order_id = physorder.orig_phys_order_id)
                       WHERE
                           pharmorder.fac_id = @facIdLocal
                           AND pharmorder.created_date > physorder.last_reorder_date
                           AND pharmorder.receive_status <> 7 --WeTypePhoReceiveStatus.PCC_ORDER_COMPLETE
                           AND physorder.reorder = 'Y'
                       GROUP BY
                           physorder.phys_order_id) tpos
            ON tpos.phys_order_id = physorder.phys_order_id
        LEFT JOIN PHO_ORDER_TYPE ordertype
            ON physorder.order_type_id = ordertype.order_type_id
        LEFT JOIN PHO_ADMINISTRATION_RECORD adminRecord
            ON ordertype.administration_record_id = adminRecord.administration_record_id
        LEFT JOIN PHO_ADMINISTRATION_RECORD altAdminRecord
            ON ordertype.alt_administration_record_id = altAdminRecord.administration_record_id -- PCC-7725 add alt admin record
        LEFT JOIN CONTACT physcon
            ON physorder.physician_id = physcon.contact_id
        LEFT JOIN PHO_ORDER_CATEGORY ordercat
            ON ordertype.order_category_id = ordercat.order_category_id
        LEFT JOIN COMMON_CODE diettype
            ON physorder.diet_type = diettype.item_id
        LEFT JOIN COMMON_CODE diettexture
            ON physorder.diet_texture = diettexture.item_id
        LEFT JOIN COMMON_CODE [route]
            ON physorder.route_of_admin = route.item_id
        LEFT JOIN COMMON_CODE dietsup
            ON physorder.diet_supplement = dietsup.item_id
        LEFT JOIN COMMON_CODE fluidcon
            ON physorder.fluid_consistency = fluidcon.item_id
        LEFT JOIN sec_user createdBySu
            ON createdBySu.loginname = physorder.created_by
        LEFT JOIN sec_user revisionBySu
            ON revisionBySu.loginname = physorder.revision_by
        LEFT JOIN pho_phys_order_useraudit useraudit
            ON useraudit.phys_order_id = physorder.phys_order_id
        LEFT JOIN cp_sec_user_audit edituser
            ON edituser.cp_sec_user_audit_id = useraudit.edited_by_audit_id
        LEFT JOIN cp_sec_user_audit createuser
            ON createuser.cp_sec_user_audit_id = useraudit.created_by_audit_id
        LEFT JOIN cp_sec_user_audit confuser
            ON confuser.cp_sec_user_audit_id = useraudit.confirmed_by_audit_id
        LEFT JOIN emc_ext_facilities eef
          ON eef.ext_fac_id = physorder.pharmacy_id
        LEFT JOIN @physOrderAllergies poa ON poa.phys_order_id= physorder.phys_order_id
        LEFT JOIN @physOrderBlackbox pob ON pob.phys_order_id= physorder.phys_order_id
        LEFT JOIN @physOrderDoseCheck pdc ON pdc.phys_order_id = physorder.phys_order_id
        LEFT JOIN @physOrderNoDrugProtocolCheck ndpc ON ndpc.phys_order_id = physorder.phys_order_id

        LEFT JOIN pho_phys_order_sign os on os.phys_order_id = physorder.phys_order_id
        LEFT JOIN cp_sec_user_audit ua ON ua.cp_sec_user_audit_id = os.cp_sec_user_audit_id  --and os.phys_order_id = ?
        LEFT JOIN order_sign_authentication_type at on at.authentication_type_id = os.authentication_type_id
        LEFT JOIN order_sign_source_type ss on ss.source_type_id = os.source_type_id
        LEFT JOIN order_sign_signature_type st on st.signature_type_id = os.signature_type_id
        LEFT JOIN pho_phys_order_new_ctrlsubstancecode nctrlsc on nctrlsc.phys_order_id=physorder.phys_order_id
        LEFT JOIN pho_phys_order_esignature ppoe on ppoe.phys_order_id=physorder.phys_order_id
        LEFT JOIN pho_phys_order_quantity_info oq on oq.phys_order_id=physorder.phys_order_id
        LEFT JOIN pho_phys_order_ti ti on ti.phys_order_id = physorder.phys_order_id

SET @step = 9

SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return supplies '
    IF @debug='Y'
        PRINT @status_text

    -- supplies
    select pos.phys_order_id,
        pos.order_supply_id,
        pos.description as supply_description,
        pos.directions as supply_directions,
        pos.date_dispensed as date_dispensed,
        pos.last_received_date as supply_received_date,
		pos.received_date as supply_physical_received_date,
        pos.med_src_type_id as supply_med_src_type_id,
        pos.pharmacy_id as supply_pharmacy_id,
        eef.name as supply_pharmacy_name,
        pos.reordering as supply_reordering,
        pos.status AS supply_status,
        pos.new_supply_flag as supply_new_supply_flag,
        pos.last_reorder_date as supply_last_reorder_date,
        pos.disp_code as supply_disp_code,
        pos.pharm_nurse_notes as pharm_nurse_notes,
        pos.nurse_pharm_notes as nurse_pharm_notes,
        pos.disp_package_identifier as supply_disp_package_identifier,
        pos.controlled_substance_code as supply_controlled_substance_code,
        pos.prescription as supply_prescription,
        pos.do_not_fill as supply_do_not_fill,
        pos.inventory_on_hand as inventory_on_hand,
        pos.next_refill_date as next_refill_date,
        psd.pharmacy_order_id as pharmacy_order_id,
        CASE  WHEN ip.pharmacy_id IS NULL THEN 'N' ELSE 'Y' END 'integrated_pharmacy',
        pos.active as supply_active,
        '' as imageFileName, -- PCC-33017
        pos.drug_code as drug_code
    FROM pho_order_supply pos
        INNER JOIN  @result result ON [result].phys_order_id = pos.phys_order_id
        LEFT JOIN emc_ext_facilities eef ON eef.ext_fac_id = pos.pharmacy_id
        left join pho_supply_dispense psd on psd.order_supply_id = pos.order_supply_id and psd.deleted='N'
        LEFT JOIN @integratedPharmacies ip
                    ON ip.pharmacy_id = pos.pharmacy_id
    WHERE (pos.active = 'Y' or pos.active = 'N') AND pos.deleted = 'N'
    ORDER BY pos.created_date DESC

SET @step = 10

SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return Administrative orders'
    IF @debug='Y'
        PRINT @status_text


-- administrative orders
select vpao.*, secuser.long_username 'created_by_long' , secuser.designation_desc as created_by_designation, ccc.item_description as created_by_position
,csua.long_username confirmed_by_username, csua.position_description as confirmed_by_position, csua.designation_desc as confirmed_by_designation, ua.confirmed_date as confirmed_date
FROM view_pho_administrative_order vpao
inner JOIN @result r ON r.phys_order_id = vpao.standard_phys_order_id
left join SEC_USER secuser on secuser.loginname = vpao.created_by
left join common_code ccc on ccc.item_id = secuser.position_id
left join pho_admin_order_useraudit ua ON ua.admin_order_id = vpao.admin_order_id
left join cp_sec_user_audit csua on csua.cp_sec_user_audit_id = ua.confirmed_by_audit_id
ORDER BY vpao.revision_date  DESC



/**
may have to revisit column selection
**/
    SET @step = 11
    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Return Schedules'
    IF @debug='Y'
      PRINT @status_text;

	WITH ORDER_SCHEDULES AS
	(
		SELECT
			vps.phys_order_id, vps.order_schedule_id, vps.order_schedule_start_date 'start_date', psd.last_admin_user, psd.last_admin_date, vps.order_schedule_end_date 'end_date', vps.end_date_type, vps.end_date_duration_type,
			vps.end_date_duration, vps.reassessment_required,  vps.schedule_directions, vps.additional_directions, vps.schedule_template, vps.schedule_type,
			vps.alternate_dose, vps.schedule_sliding_scale_id, vps.apply_remove_flag,
			vps.date_start,
			vps.date_stop,
			vps.dose_uom_id,
			vps.dose,
			vps.indications_for_use,
			vps.quantity_uom_id,
			vps.prn_admin,
			vps.prn_admin_units,
			vps.prn_admin_value,
			vps.apply_to,
			CASE WHEN oss.order_schedule_id is not null  THEN 1 ELSE 0 END as custom_sliding_scale_exists,
			vps.std_freq_id,
			vps.revision_date
		FROM view_pho_schedule vps
			LEFT OUTER JOIN dw_pho_order_schedule psd
				ON psd.order_schedule_id = vps.order_schedule_id
			LEFT JOIN pho_order_sliding_scale_range oss
				ON @includeSlidingScale='Y' AND oss.order_schedule_id=vps.order_schedule_id
			INNER JOIN @result r
				ON r.phys_order_id = vps.phys_order_id
		GROUP BY
			vps.phys_order_id, vps.order_schedule_id, vps.order_schedule_start_date, psd.last_admin_user, psd.last_admin_date, vps.order_schedule_end_date, vps.end_date_type, vps.end_date_duration_type,
			vps.end_date_duration, vps.reassessment_required,  vps.schedule_directions, vps.additional_directions, vps.schedule_template, vps.schedule_type,
			vps.alternate_dose, vps.schedule_sliding_scale_id,
			oss.order_schedule_id,
			vps.apply_remove_flag,
			vps.date_start,
			vps.date_stop,
			vps.dose_uom_id,
			vps.dose,
			vps.indications_for_use,
			vps.quantity_uom_id,
			vps.prn_admin,
			vps.prn_admin_units,
			vps.prn_admin_value,
			vps.apply_to,
			vps.std_freq_id,
			vps.revision_date
	)
	-- return: combine with schedules for struck-out orders
		SELECT * FROM ORDER_SCHEDULES
		UNION ALL
			SELECT
				psa.phys_order_id, psa.order_schedule_id, psa.schedule_start_date 'start_date', psd.last_admin_user, psd.last_admin_date, psa.schedule_end_date 'end_date', psa.schedule_end_date_type_id 'end_date_type', psa.schedule_duration_type_id 'end_date_duration_type',
				psa.schedule_duration 'end_date_duration', psa.reassessment_required,  psa.schedule_directions, psa.additional_directions, psa.schedule_template, psa.schedule_type,
				psa.alternate_dose_value 'alternate_dose', psa.sliding_scale_id 'schedule_sliding_scale_id', psa.apply_remove_flag,
				psa.date_start,
				psa.date_stop,
				psa.dose_uom_id,
				psa.dose_value 'dose',
				psa.indications_for_use,
				psa.quantity_uom_id,
				psa.prn_admin,
				psa.prn_admin_units,
				psa.prn_admin_value,
				psa.apply_to,
				CASE WHEN oss.order_schedule_id is not null  THEN 1 ELSE 0 END as custom_sliding_scale_exists,
				psa.std_freq_id,
				psa.revision_date
			FROM pho_order_schedule_audit psa
				INNER JOIN
				(
					SELECT MAX(posa.AUDIT_ID) 'latest_audit_id' FROM pho_order_schedule_audit posa
					INNER JOIN @result r ON r.phys_order_id = posa.phys_order_id AND r.status = 4
					GROUP BY posa.order_schedule_id
				) latest_schedule_audit ON latest_schedule_audit.latest_audit_id = PSA.audit_id
				INNER JOIN @orderStatus os	-- filter down to struck-out orders
					ON  os.status = 4
				LEFT OUTER JOIN dw_pho_order_schedule psd
					ON psd.order_schedule_id = psa.order_schedule_id
				LEFT JOIN pho_order_sliding_scale_range oss
					ON @includeSlidingScale='Y' AND oss.order_schedule_id=psa.order_schedule_id
				INNER JOIN @result r
					ON r.phys_order_id = psa.phys_order_id AND r.status = 4
			WHERE @includeStruckOutOrders = 'Y'
			GROUP BY
				psa.phys_order_id, psa.order_schedule_id, psa.schedule_start_date, psd.last_admin_user, psd.last_admin_date, psa.schedule_end_date, psa.schedule_end_date_type_id, psa.schedule_duration_type_id,
				psa.schedule_duration, psa.reassessment_required,  psa.schedule_directions, psa.additional_directions, psa.schedule_template, psa.schedule_type,
				psa.alternate_dose_value, psa.sliding_scale_id,
				oss.order_schedule_id,
				psa.apply_remove_flag,
				psa.date_start,
				psa.date_stop,
				psa.dose_uom_id,
				psa.dose_value,
				psa.indications_for_use,
				psa.quantity_uom_id,
				psa.prn_admin,
				psa.prn_admin_units,
				psa.prn_admin_value,
				psa.apply_to,
				psa.std_freq_id,
				psa.revision_date


     SET @step = 12

     SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return alerts '
     IF @debug='Y'
        PRINT @status_text

     /* ALERTS */
		SELECT PHYSORDER.PHYS_ORDER_ID   'phys_order_id',
               PHYSORDER.CLIENT_ID       'client_id',
               ALERT.ALERT_ID            'alert_id',
               ALERT.DESCRIPTION         'alert_desc',
               ALERT.MODULE              'module',
               ALERT.CREATED_DATE        'alert_created_date',
               ALERT.EFFECTIVE_DATE      'effective_date',
               ALERT.TRIGGERED_ITEM_ID   'triggered_item_id',
               ALERT.TRIGGERED_ITEM_TYPE 'triggered_item_type',
               ALERT.RESOLVED            'resolved',
               ALERT.RESOLVED_BY         'resolved_by',
			   CATITC.TRIGGERED_ITEM_TYPE_CATEGORY_ID 'triggered_item_type_category_id'
        FROM   @result PHYSORDER
               LEFT OUTER JOIN CR_ALERT ALERT
                 ON ALERT.TRIGGERED_ITEM_ID = PHYSORDER.PHYS_ORDER_ID
					and alert.fac_id = @facIdLocal
					and ( @clientIdLocal is null or alert.client_id=@clientIdLocal )
                    AND ALERT.TRIGGERED_ITEM_TYPE IN ('O', 'M') AND ALERT.RESOLVED <> 'Y' AND ALERT.deleted = 'N'
				LEFT OUTER JOIN CR_ALERT_TRIGGERED_ITEM_TYPE_CATEGORY CATITC
				 ON CATITC.ALERT_ID = ALERT.alert_id
		WHERE ALERT.ALERT_ID IS NOT NULL
        ORDER  BY ALERT.EFFECTIVE_DATE ASC


     SET @step = 13

     SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return the total number of records '
     IF @debug='Y'
        PRINT @status_text

     select @num_records as num_records

      SET @step = 14

     SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' return alerts for Supplies '
     IF @debug='Y'
        PRINT @status_text

     /* ALERTS */
            SELECT PHYSORDER.PHYS_ORDER_ID   'phys_order_id',
               PHYSORDER.CLIENT_ID       'client_id',
               POS.ORDER_SUPPLY_ID        'order_supply_id',
               ALERT.ALERT_ID            'alert_id',
               ALERT.DESCRIPTION         'alert_desc',
               ALERT.MODULE              'module',
               ALERT.CREATED_DATE        'alert_created_date',
               ALERT.EFFECTIVE_DATE      'effective_date',
               ALERT.TRIGGERED_ITEM_ID   'triggered_item_id',
               ALERT.TRIGGERED_ITEM_TYPE 'triggered_item_type',
               ALERT.RESOLVED            'resolved',
               ALERT.RESOLVED_BY         'resolved_by'
        	FROM   pho_order_supply POS
                 LEFT JOIN @result PHYSORDER ON PHYSORDER.PHYS_ORDER_ID = POS.PHYS_ORDER_ID and (@clientIdLocal is null or PHYSORDER.client_id=@clientIdLocal )
               	 LEFT JOIN CR_ALERT ALERT ON ALERT.TRIGGERED_ITEM_ID = POS.ORDER_SUPPLY_ID and alert.fac_id = @facIdLocal and ALERT.client_id = PHYSORDER.client_id


       		 WHERE (
                           -- Only Show Pharmacy initated alerts
                           ALERT.TRIGGERED_ITEM_TYPE = 'C'
                                                OR ALERT.TRIGGERED_ITEM_TYPE = 'O'
                                                OR ALERT.TRIGGERED_ITEM_TYPE = 'D'
                                                OR ALERT.TRIGGERED_ITEM_TYPE = 'T'
                                         )
                                  AND ALERT.deleted = 'N'
       		 ORDER  BY ALERT.EFFECTIVE_DATE ASC

    SELECT r.phys_order_id, poda.severity_code
    FROM @result r
     INNER JOIN @physOrderDrugInteraction poda ON poda.phys_order_id= r.phys_order_id

    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Done'
    IF @debug='Y'
        PRINT @status_text
    SET @status_code = 0
    GOTO PgmSuccess
END TRY
--error trapping
BEGIN CATCH
    SELECT @error_code = @@error, @status_text = 'Error at step:'+convert(varchar(3),@step)+', '+ERROR_MESSAGE()

    SET @status_code = 1

    GOTO PgmAbend

END CATCH

--program success return
PgmSuccess:

IF @status_code = 0
BEGIN
    IF @debug='Y' PRINT 'Successfull execution of stored procedure'
    RETURN @status_code
END

--program failure return
PgmAbend:

IF @debug='Y' PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '   ' + convert(varchar(26),getdate())
    IF @debug='Y' PRINT 'Error code: '+convert(varchar(3),@error_code) + '; Error description:    ' +@status_text
    RETURN @status_code

GO
GRANT EXECUTE ON sproc_pho_list_residentchart_v2 TO public
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_pho_list_residentchart_v2.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_pho_list_residentchart_v2.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_populatePhoControlledSubstanceCodeRescreeningTable.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ===============================================================================================================================
--
-- Purpose: The purpose of this procedure is to load all pnids, ddids and old_substance_codes
--           into the temp table pho_controlled_substance_code_rescreening, with drugs from all orders and templates
--
--
-- Target ENVIRONMENT: BOTH
--
--  Special Instructions:
--
--	Params:
--
--			@debug          - Debug param, 'Y' or 'N'
--			@status_code    - SP execution flag, 0 for success.
--			@status_text    - SP error text if error occurs.
--
-- Change History:
--   Author			    Date		 Comment
-- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--	 Patrick Campbell   10/27/2021	 Created.
--   Jarek Zawojski     11/08/2021   Added PNID to the logic
-- ======================================================================================================================================================================================

IF EXISTS (select * from dbo.sysobjects where id = object_id(N'[dbo].[sproc_populatePhoControlledSubstanceCodeRescreeningTable]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[sproc_populatePhoControlledSubstanceCodeRescreeningTable]
GO

create
proc sproc_populatePhoControlledSubstanceCodeRescreeningTable
(
	@debug char(1)  = 'N',
	@status_code int out,
	@status_text varchar(3000) out
)
as
begin

SET NOCOUNT ON

BEGIN TRY
DECLARE @step			int,
		@error_code		int


IF(@debug='Y') begin Print 'BEGIN STEP upload pinds, ddids and old_controlled_substance_codes onto pho_controlled_substance_code_rescreening' + ' ' + convert(varchar(26),getdate(),109) end
DELETE FROM pho_controlled_substance_code_rescreening where pnid is not null

INSERT INTO pho_controlled_substance_code_rescreening(pnid, ddid, old_controlled_substance_code)
    (SELECT ref.pho_ext_lib_med_id,
            IIF(ISNULL(ref.pho_ext_lib_med_ddid, -1) < 1, -1, ref.pho_ext_lib_med_ddid),
            max(po.controlled_substance_code)
     FROM pho_phys_order po
              INNER JOIN pho_order_ext_lib_med_ref ref
                         ON ref.phys_order_id = po.phys_order_id
                             AND ref.deleted = 'N' AND
                            ref.pho_ext_lib_med_id IS NOT NULL
              LEFT JOIN pho_order_queue qo
                        ON qo.phys_order_id = ref.phys_order_id
                            AND qo.deleted = 'N' AND qo.promoted_date IS NULL
              LEFT JOIN pho_order_clinical_review cr
                        ON cr.phys_order_id = po.phys_order_id AND cr.reviewed_date IS NULL
              LEFT JOIN pho_phys_order_esignature esig
                        ON esig.phys_order_id = po.phys_order_id and esig.sign_user_id IS NULL
     WHERE ref.pho_ext_lib_med_id > 0
     GROUP BY ref.pho_ext_lib_med_id,
              IIF(ISNULL(ref.pho_ext_lib_med_ddid, -1) < 1, -1, ref.pho_ext_lib_med_ddid));

INSERT INTO pho_controlled_substance_code_rescreening(pnid, ddid, old_controlled_substance_code)
    (SELECT pso.ext_lib_med_id,
            IIF(ISNULL(pso.ext_lib_med_ddid, -1) < 1, -1, pso.ext_lib_med_ddid),
            max(cast(pso.controlled_substance_code as varchar))
     FROM pho_std_order pso
     WHERE NOT EXISTS(SELECT 1
                      FROM pho_controlled_substance_code_rescreening csc
                      WHERE csc.pnid = pso.ext_lib_med_id
                        and csc.ddid = IIF(ISNULL(pso.ext_lib_med_ddid, -1) < 1, -1, pso.ext_lib_med_ddid))
       and pso.ext_lib_med_id is not null
       and pso.ext_lib_med_id > 0
     GROUP BY pso.ext_lib_med_id, pso.ext_lib_med_ddid);

SELECT pnid, ddid, old_controlled_substance_code from pho_controlled_substance_code_rescreening;

    if(@debug='Y') begin Print 'END STEP select controlled substance code, number of returned rows: ' + convert(varchar(10), @@ROWCOUNT, 109) + ', ' + convert(varchar(26),getdate(),109) end

END TRY

--error trapping
BEGIN CATCH

SELECT @error_code = @@error
     , @status_text = ERROR_MESSAGE()

    SET @status_code = 1

	GOTO PgmAbend

END CATCH

--program success return
PgmSuccess:
IF @status_code = 0
BEGIN
	IF @debug='Y' PRINT 'Successful execution of stored procedure'
	RETURN @status_code
END

--program failure return
PgmAbend:
IF @debug='Y' PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '	' + convert(varchar(26),getdate())
IF @debug='Y' PRINT 'Error code: '+convert(varchar(3),@step) + '; Error description:	' +@status_text
RETURN @status_code

END
GO

GRANT EXECUTE ON sproc_populatePhoControlledSubstanceCodeRescreeningTable TO PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_populatePhoControlledSubstanceCodeRescreeningTable.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_populatePhoControlledSubstanceCodeRescreeningTable.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_pcc_poc_getScheduleDetails.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- PCC-52769:			script to create sproc_prp_pcc_poc_getScheduleDetails  
--						
-- 
-- Written By:         Rolly Sanchez
-- Changes By:			
-- Reviewed By:         
-- 
-- Script Type:         DML 
-- Target DB Type:      Client
-- Target ENVIRONMENT:  BOTH (US/CA) 
-- 
-- 
-- Re-Runable:          YES 
-- 
-- Description of Script : Create sproc_prp_pcc_poc_getScheduleDetails Procedure 
--							was clone from pcc_poc_getScheduleDetails for service tracking report

-- =================================================================================
-- =================================================================================
-- REVISION HISTORY
-- DATE			NAME				JIRA        VERSION		DESCRIPTION
-- 2014-02-19	Rolly Sanchez		PCC-52769	3.7.3		Initial creation
-- 2014-02-24	Ritch Moore			PCC-52769	3.7.3		Removed shift_id filtering on Qshift and revised date filtering on same.


-- =================================================================================

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_prp_pcc_poc_getScheduleDetails' and ROUTINE_TYPE = 'PROCEDURE' ) 
   drop procedure [dbo].[sproc_prp_pcc_poc_getScheduleDetails]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.sproc_prp_pcc_poc_getScheduleDetails
(
@facID_param int,
@shiftID_param int,
@myPositionID_param int,
@assignmentID_param int,
@unitID_param int,
@selectedPositionID_param int,
@shiftStartTime_param datetime,
@shiftEndTime_param datetime,
@stdInts_param varchar(8000),
@clientID_param int,
@localStartTime_param datetime,
@localEndTime_param datetime,
@max_details_param int = 2147483647,
@include_prn_param bit = 1,
@debug				char(1)  = 'N',
@status_code		int	out,
@status_text		varchar(3000) out
)

/*
sample execution script

exec sproc_prp_pcc_poc_getScheduleDetails
      1,
      -1,--@vShiftId,--@shiftID_param int,
      -1,--@myPositionID_param int,
      -1,--@assignmentID_param int,
      -1,--@unitID_param int,
      -1,--@selectedPositionID_param int,
      '2014-01-26 00:00:00',--@vStartDate,--'2014-01-26 00:00:00',--@shiftStartTime_param datetime,
      '2014-02-01 23:59:59',--@vEndDate,--'2014-02-01 23:59:59'--@shiftEndTime_param datetime,
      NULL,--'7445,7455,7465',--@stdInts_param varchar(8000),
      -1,--@clientID_param int,
      '2014-01-26 00:00:00',--@vStartDate,--'2014-01-26 00:00:00',--@localStartTime_param datetime,
      '2014-02-01 23:59:59',--@vEndDate,--'2014-02-01 23:59:59'--@localEndTime_param datetime,
      Null,--@max_details_param int = 2147483647,
      1,--@include_prn_param bit = 1,
      'N',--@debug                        char(1)  = 'N',
      Null,--@status_code           int   out,
      Null--@status_text            varchar(3000) out


*/
as
begin

SET NOCOUNT ON


DECLARE
@facID int,
@shiftID int,
@myPositionID int,
@assignmentID int,
@unitID int,
@selectedPositionID int,
@shiftStartTime datetime,
@shiftEndTime datetime,
@stdInts varchar(8000),
@clientID int,
@localStartTime datetime,
@localEndTime DATETIME,
@max_details int,
@include_prn bit,
@vStep int,
@vgsStepStartTime datetime,
@vgsStepEndTime datetime

SELECT
@facID = @facID_param,
@shiftID = @shiftID_param,
@myPositionID = @myPositionID_param,
@assignmentID = @assignmentID_param,
@unitID = @unitID_param,
@selectedPositionID = @selectedPositionID_param,
@shiftStartTime = @shiftStartTime_param,
@shiftEndTime = @shiftEndTime_param,
@stdInts = @stdInts_param,
@clientID = @clientID_param,
@localStartTime = @localStartTime_param,
@localEndTime = @localEndTime_param,
@max_details = CASE WHEN @max_details_param > 0 THEN @max_details_param ELSE 2147483647 END,
@include_prn = CASE @include_prn_param WHEN 0 THEN 0 ELSE 1 END


DECLARE @isCDN SMALLINT
SELECT @isCDN = CASE WHEN ( 'CDN' = (SELECT facility_type FROM dbo.facility WHERE fac_id = @facID) )
									THEN
									(
										1
									)
									ELSE
									(
										0
									) END

DECLARE @timeZone INT
SELECT @timeZone = (SELECT time_zone FROM dbo.facility WHERE fac_id = @facID)

if (@selectedPositionID IS NULL)
  set @selectedPositionID = -1

-------------------------------------------------------------------
--Schedule type constants
-------------------------------------------------------------------
declare @STYPE_PRN int
declare @STYPE_MD  int
set @STYPE_PRN = 8
set @STYPE_MD  = 11

-------------------------------------------------------------------
--select to get the assignments.
-------------------------------------------------------------------
declare @ASSIGNMENTS table (pho_assignment_id int)

-------------------------------------------------------------------
--select to get the list of clients
-------------------------------------------------------------------

select @vStep = 10
set @vgsStepStartTime = GETDATE()
if @debug='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Gathering clients ' + convert(varchar(26),getdate(),109)

DECLARE @CLIENTS table
(
	id_key int IDENTITY(1,1),
	client_id INT,
	photo_small VARCHAR(55),
	mpi_id INT,
	current_census_id INT,
	current_care_plan_id INT,
	client_id_number VARCHAR(35),
	admission_date DATETIME,
	discharge_date DATETIME,
	bed_id INT,
	bed_desc VARCHAR(30),
	room_desc VARCHAR(60),
	unit_desc VARCHAR(35),
	unit_id INT,
	fac_id INT,
	effective_date datetime,
	ineffective_date datetime
	,
	PRIMARY KEY (client_id, id_key)
)

INSERT INTO @CLIENTS
SELECT
	client.client_id,
	client.photo_small AS photo_small,
	mpi_id,
	current_census_id,
	current_care_plan_id,
	client_id_number,
	admission_date,
	discharge_date,
	bed.bed_id as bed_id,
	bed.bed_desc AS bed_desc,
	room.Room_Desc AS room_desc,
	unit.unit_desc AS unit_desc,
	unit.unit_id AS unit_id,
	client.fac_id,
	census.effective_date,
	census.ineffective_date
FROM
	dbo.CENSUS_ITEM census
	INNER JOIN dbo.CLIENTS client with (nolock) ON
				client.client_id = census.client_id AND (client.deleted = 'N')
	INNER JOIN
	(
		SELECT bed_id FROM dbo.pho_assignment_beds with (nolock) 
		WHERE @assignmentID > 0 -- A
			AND pho_assignment_id = @assignmentID
		UNION ALL
		SELECT pab.bed_id
		FROM dbo.pho_assignment_group_assoc grpAssoc with (nolock) 
			INNER JOIN dbo.pho_assignment_group_assign grpAsgn with (nolock) ON grpAssoc.pho_assignment_group_id = grpAsgn.pho_assignment_group_id
			INNER JOIN pho_assignment_beds pab with (nolock) ON pab.pho_assignment_id = grpAsgn.pho_assignment_id
		WHERE
			grpAssoc.std_shift_id    = @shiftID
			AND grpAssoc.position_id = @myPositionID
			AND grpAssoc.fac_id      = @facID
			AND (@assignmentID =-1 AND @unitID IS NULL) -- B
		UNION ALL
		SELECT -9999
			WHERE (
				@assignmentID <= 0 -- NOT(A)
				AND NOT (@assignmentID =-1 AND @unitID IS NULL) -- NOT(B)
			) OR @assignmentID IS NULL
	) assignmentBeds ON
				census.bed_id = assignmentBeds.bed_id or assignmentBeds.bed_id=-9999
	INNER JOIN dbo.BED bed with (nolock) ON
				census.fac_id = bed.fac_id AND census.bed_id = bed.bed_id
	INNER JOIN dbo.ROOM room with (nolock) ON
				bed.fac_id = room.fac_id AND bed.room_id = room.room_id
	INNER JOIN dbo.UNIT unit with (nolock) ON
				room.fac_id = unit.fac_id AND room.unit_id = unit.unit_id
WHERE
	census.fac_id = @facID
	AND census.deleted = 'N'
	AND (@unitID IS NULL or @unitID=-1 OR room.unit_id = @unitID)
	AND client.admission_date <= @shiftEndTime
	AND (@clientid=-1)
	AND census.effective_date < @shiftEndTime
	AND @shiftStartTime <= (
								CASE WHEN ( census.ineffective_date IS NULL )
								THEN (@shiftStartTime)
								ELSE
								(
									CASE WHEN ( @isCDN = 1 )
									THEN
									(
										DATEADD(hh
										,-1* @timeZone
										,convert(datetime, convert(varchar(4), datepart(yyyy, census.ineffective_date))
											+ '-' + convert(varchar(2), datepart(MM, census.ineffective_date))
											+ '-' + convert(varchar(2), datepart(dd, census.ineffective_date))
											+ ' 23:59:59'
											)
										)
									)
									ELSE
									(
										DATEADD(hh
										,-1* @timeZone
										,census.ineffective_date
										)
									) END
								) END
							)
UNION ALL
SELECT
	client.client_id,
	client.photo_small AS photo_small,
	mpi_id,
	current_census_id,
	current_care_plan_id,
	client_id_number,
	admission_date,
	discharge_date,
	bed.bed_id as bed_id,
	bed.bed_desc AS bed_desc,
	room.Room_Desc AS room_desc,
	unit.unit_desc AS unit_desc,
	unit.unit_id AS unit_id,
	client.fac_id,
	census.effective_date,
	census.ineffective_date
FROM
	dbo.CENSUS_ITEM census with (nolock)
	INNER JOIN dbo.CLIENTS client with (nolock) ON
				client.client_id = census.client_id AND (client.deleted = 'N')
	INNER JOIN
	(
		SELECT bed_id FROM dbo.pho_assignment_beds with (nolock)
		WHERE @assignmentID > 0 -- A
			AND pho_assignment_id = @assignmentID
		UNION ALL
		SELECT pab.bed_id
		FROM dbo.pho_assignment_group_assoc grpAssoc with (nolock)
			INNER JOIN dbo.pho_assignment_group_assign grpAsgn with (nolock) ON grpAssoc.pho_assignment_group_id = grpAsgn.pho_assignment_group_id
			INNER JOIN pho_assignment_beds pab with (nolock) ON pab.pho_assignment_id = grpAsgn.pho_assignment_id
		WHERE
			grpAssoc.std_shift_id    = @shiftID
			AND grpAssoc.position_id = @myPositionID
			AND grpAssoc.fac_id      = @facID
			AND (@assignmentID =-1 AND @unitID IS NULL) -- B
		UNION ALL
		SELECT -9999
			WHERE (
				@assignmentID <= 0 -- NOT(A)
				AND NOT (@assignmentID =-1 AND @unitID IS NULL) -- NOT(B)
			) OR @assignmentID IS NULL
	) assignmentBeds ON
				census.bed_id = assignmentBeds.bed_id or assignmentBeds.bed_id=-9999
	INNER JOIN dbo.BED bed with (nolock) ON
				census.fac_id = bed.fac_id AND census.bed_id = bed.bed_id
	INNER JOIN dbo.ROOM room with (nolock) ON
				bed.fac_id = room.fac_id AND bed.room_id = room.room_id
	INNER JOIN dbo.UNIT unit with (nolock) ON
				room.fac_id = unit.fac_id AND room.unit_id = unit.unit_id
WHERE
	census.fac_id = @facID
	AND census.deleted = 'N'
	AND (@unitID IS NULL or @unitID=-1 OR room.unit_id = @unitID)
	AND client.admission_date <= @shiftEndTime
	AND (client.client_id = @clientID)
	AND census.effective_date < @shiftEndTime
	AND @shiftStartTime <= (
								CASE WHEN ( census.ineffective_date IS NULL )
								THEN (@shiftStartTime)
								ELSE
								(
									CASE WHEN ( @isCDN = 1 )
									THEN
									(
										DATEADD(hh
										,-1* @timeZone
										,convert(datetime, convert(varchar(4), datepart(yyyy, census.ineffective_date))
											+ '-' + convert(varchar(2), datepart(MM, census.ineffective_date))
											+ '-' + convert(varchar(2), datepart(dd, census.ineffective_date))
											+ ' 23:59:59'
											)
										)
									)
									ELSE
									(
										DATEADD(hh
										,-1* @timeZone
										,census.ineffective_date
										)
									) END
								) END
							)

set @vgsStepEndTime=GETDATE()
if @debug='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 20
set @vgsStepStartTime = GETDATE()
if @debug='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Gathering schedules ' + convert(varchar(26),getdate(),109)

DECLARE @TEMP_SCHEDULES table
(
	id_key int IDENTITY(1,1),
	first_name varchar (50),
	last_name  varchar(50),
	bed_id  int,
	bed_desc  varchar(30),
	discharge_date datetime,
	client_id_number  varchar(35),
	photo_small  varchar(55),
	room_desc  varchar(60),
	unit_id  int,
	unit_desc  varchar(35) ,
	admission_date  datetime,
	client_id  int,
	effective_date datetime,
	ineffective_date datetime,
	current_row  varchar(1),
	intervention_desc  varchar(2000),
	date_initiated datetime,
	std_intervention_id  int,
	require_time_tracking bit,
	baseline_time smallint,
	intervention_id  int,
	schedule_id  int,
	schedule_type  int,
	std_shift_ids  varchar(500),
	start_time	varchar(4)	,
    end_time	varchar(4)	,
	xxminutes  int,
	fac_id  int ,
	date_of_month int,
	PRIMARY KEY (fac_id, schedule_id, id_key)
)



if(@debug='Y') begin Print  'BEGIN STEP select schedules		' + ' ' + convert(varchar(26),getdate(),109)end
if  @stdInts IS NOT NULL
	begin
		-------------------------------------------------------------------
		--select to get the list of tasks and schedule ids FOR SPECIFIC std intervention ids.
		-------------------------------------------------------------------
		INSERT INTO @TEMP_SCHEDULES(
		first_name ,last_name,bed_id ,bed_desc ,discharge_date,client_id_number ,photo_small,
        room_desc ,unit_id ,unit_desc ,admission_date ,client_id ,effective_date,ineffective_date,current_row,intervention_desc,
        date_initiated ,std_intervention_id  ,require_time_tracking ,baseline_time,intervention_id ,
        schedule_id ,schedule_type ,std_shift_ids  ,xxminutes ,fac_id ,date_of_month,start_time,end_time)
		SELECT
			mpi.first_name AS first_name ,
			mpi.last_name AS last_name ,
			client.bed_id as bed_id,
			client.bed_desc AS bed_desc,
			client.discharge_date AS discharge_date,
			client.client_id_number AS client_id_number ,
			client.photo_small AS photo_small ,
			client.Room_Desc AS room_desc ,
			client.unit_id as unit_id,
			client.unit_desc AS unit_desc ,
			client.admission_date AS admission_date ,
			intervention.clientID AS client_id ,
			client.effective_date ,
			client.ineffective_date,
			intervention.current_row AS current_row ,
			intervention.text1 AS intervention_desc ,
			intervention.date_initiated AS date_initiated ,
			intervention.std_intervention_id AS std_intervention_id ,
			cpstdi.require_time_tracking AS require_time_tracking ,
			intervention.baseline_time AS baseline_time ,
			schedule.intervention_id AS intervention_id ,
			schedule.schedule_id AS schedule_id ,
			schedule.schedule_type AS schedule_type ,
			schedule.std_shift_ids AS std_shift_ids ,
			schedule.xxminutes AS xxminutes ,
			schedule.fac_id AS fac_id,
			schedule.date_of_month AS date_of_month,
			schedule.start_time,
			schedule.end_time
		FROM
			@CLIENTS client
			INNER JOIN dbo.CP_REV_INTERVENTION intervention with (nolock) on
						intervention.fac_id = client.fac_id
						and intervention.clientID = client.client_id and intervention.current_row='Y'
			INNER JOIN (select value from pcc__csvToTableOfInt(@stdInts)) as stdInterIds on
						stdInterIds.value = intervention.std_intervention_id
			left JOIN dbo.CP_STD_INTERVENTION cpstdi with (nolock) on
						cpstdi.std_intervention_id = intervention.std_intervention_id and cpstdi.poc_flowsheet='Y' 
			INNER JOIN dbo.MPI mpi with (nolock) ON
						client.mpi_id = mpi.mpi_id
			INNER JOIN dbo.CP_SCHEDULE  schedule with (nolock) ON
						schedule.fac_Id = intervention.fac_id
						and schedule.intervention_id = intervention.gen_intervention_id and schedule.fac_id=@facId
			LEFT JOIN dbo.CP_REV_NEED need with (nolock) ON
						intervention.fac_id = need.fac_id
						and intervention.need_id = need.need_id
						AND need.care_plan_id = client.current_care_plan_id
						AND need.current_row = 'Y'
		WHERE
			schedule.fac_id					= @facId
			and intervention.fac_id			= @facId
			and isnull(schedule.retired_date, @shiftStartTime) >= @shiftStartTime
			and intervention.flowsheet		= 'Y'
			and (schedule.schedule_type=40 or isnull(intervention.resolved_date,@shiftEndTime)>@shiftStartTime)
			AND
			(
				@selectedPositionID				= -1
				OR intervention.position_id		= @selectedPositionID
				OR intervention.position_id_2	= @selectedPositionID
				OR intervention.position_id_3	= @selectedPositionID
				OR intervention.position_id_4	= @selectedPositionID
				OR intervention.position_id_5	= @selectedPositionID
			)
			and isnull(intervention.deleted,'N')	= 'N'
			and isnull(schedule.deleted,'N')		= 'N'
			and isnull(need.deleted,'N')			= 'N'
			and 1= case when (isnull(cpstdi.require_time_tracking,0)=1 or isnull(intervention.require_time_tracking,0)=1) then 1 else 0 end 
	end
-------------------------------------------------------------------
else -- end if.
-------------------------------------------------------------------
	begin
		-------------------------------------------------------------------
		--select to get the list of tasks and schedule ids with NO std intervention ids.
		-------------------------------------------------------------------
		INSERT INTO @TEMP_SCHEDULES(
		first_name ,last_name,bed_id ,bed_desc ,discharge_date,client_id_number ,photo_small,
        room_desc ,unit_id ,unit_desc ,admission_date ,client_id ,effective_date,ineffective_date,current_row,intervention_desc,
        date_initiated ,std_intervention_id  ,require_time_tracking ,baseline_time,intervention_id ,
        schedule_id ,schedule_type ,std_shift_ids  ,xxminutes ,fac_id ,date_of_month,start_time,end_time)
		SELECT
			mpi.first_name AS first_name ,
			mpi.last_name AS last_name ,
			client.bed_id as bed_id,
			client.bed_desc AS bed_desc,
			client.discharge_date AS discharge_date,
			client.client_id_number AS client_id_number ,
			client.photo_small AS photo_small ,
			client.Room_Desc AS room_desc ,
			client.unit_id as unit_id,
			client.unit_desc AS unit_desc ,
			client.admission_date AS admission_date ,
			intervention.clientID AS client_id ,
			client.effective_date ,
			client.ineffective_date,
			intervention.current_row AS current_row ,
			intervention.text1 AS intervention_desc ,
			intervention.date_initiated AS date_initiated ,
			intervention.std_intervention_id AS std_intervention_id ,
			cpstdi.require_time_tracking AS require_time_tracking ,
			intervention.baseline_time AS baseline_time ,
			schedule.intervention_id AS intervention_id ,
			schedule.schedule_id AS schedule_id ,
			schedule.schedule_type AS schedule_type ,
			schedule.std_shift_ids AS std_shift_ids ,
			schedule.xxminutes AS xxminutes ,
			schedule.fac_id AS fac_id,
			schedule.date_of_month AS date_of_month,
			schedule.start_time,
			schedule.end_time
		FROM
			@CLIENTS client
			INNER JOIN dbo.CP_REV_INTERVENTION intervention with (nolock) ON
						intervention.fac_id = client.fac_id and
						intervention.clientID = client.client_id and intervention.current_row='Y'
			left JOIN dbo.CP_STD_INTERVENTION cpstdi with (nolock) on
						cpstdi.std_intervention_id = intervention.std_intervention_id and cpstdi.poc_flowsheet='Y' 
			INNER JOIN dbo.CP_SCHEDULE  schedule with (nolock) ON
						schedule.fac_Id = intervention.fac_id
						and schedule.intervention_id = intervention.gen_intervention_id and schedule.fac_id=@facId
			INNER JOIN dbo.MPI mpi with (nolock) ON
						client.mpi_id = mpi.mpi_id
			left JOIN dbo.CP_REV_NEED need with (nolock) ON
						intervention.fac_id = need.fac_id
						and intervention.need_id = need.need_id
						AND need.care_plan_id = client.current_care_plan_id
						AND need.current_row = 'Y'
		where
			schedule.fac_id					= @facId
			and intervention.fac_id			= @facId
			and isnull(schedule.retired_date, @shiftStartTime) >= @shiftStartTime
			and intervention.flowsheet		= 'Y'
			and (schedule.schedule_type=40 or  isnull(intervention.resolved_date,@shiftEndTime)>@shiftStartTime)
			AND
			(
				@selectedPositionID				= -1
				OR intervention.position_id		= @selectedPositionID
				OR intervention.position_id_2	= @selectedPositionID
				OR intervention.position_id_3	= @selectedPositionID
				OR intervention.position_id_4	= @selectedPositionID
				OR intervention.position_id_5	= @selectedPositionID
			)
			and isnull(intervention.deleted,'N')		= 'N'
			and isnull(schedule.deleted,'N')		= 'N'
			and isnull(need.deleted,'N')			= 'N'
			and 1= case when (isnull(cpstdi.require_time_tracking,0)=1 or isnull(intervention.require_time_tracking,0)=1) then 1 else 0 end 

	end
--*****************************************************************
--*****************************************************************
-- End of if/else for selecting schedules
--*****************************************************************
--*****************************************************************
set @vgsStepEndTime=GETDATE()
if @debug='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'


if @debug='Y' select * from @TEMP_SCHEDULES

--****************************************************************
--****************************************************************
-- Duration
--****************************************************************
--****************************************************************
select @vStep = 30
if(@debug='Y') begin Print  'BEGIN STEP select Duration		' + ' ' + convert(varchar(26),getdate(),109)end


---****************************************************************
select @vStep = 40
set @vgsStepStartTime = GETDATE()
if @debug='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Final Select ' + convert(varchar(26),getdate(),109)

if( (select dbo.fn_cp_poc_determineDataView(@shiftStartTime)) = 1 )
BEGIN
	if  @stdInts IS NOT NULL
	BEGIN
		select
			TOP (@max_details)
			schedules.*,
			schedule_detail_id,
			detail.std_shift_id	,
			detail.shift_date,
			schedule_date as schedule_date,
			detail.schedule_end_date	,
			documentation_id	,
			completed_date		,
			strikeout_date		,
			entered_date		,
			task_time			,
			case
				when sr.std_question_id is not null then
					sr.std_question_id
				when dr.std_question_id is not null then
					dr.std_question_id
				else
					null
			end as std_question_id,
			case
				when sr.item_value_id is not null then
					sr.item_value_id
				when dr.item_value_id is not null then
					dr.item_value_id
				else
					null
			end as item_value_id,
			case
				when sr.item_value is not null then
					sr.item_value
				when dr.item_value is not null then
					dr.item_value
				else
					null
			end as item_value,
			cp_sec_user_audit_id,
			struckout_cp_sec_user_audit_id

		from
			@TEMP_SCHEDULES schedules
			INNER JOIN view_prp_cp_active_doc_poc_proc detail with (nolock) ON
					detail.fac_id = schedules.fac_id
					AND detail.schedule_id = schedules.schedule_id
			
			LEFT JOIN cp_scheduled_response sr with (nolock) ON
					sr.cp_scheduled_documentation_id = substring(detail.documentation_id, 0, charindex('_S', detail.documentation_id))
			LEFT JOIN cp_duration_response dr with (nolock) ON
					dr.cp_duration_documentation_id = substring(detail.documentation_id, 0, charindex('_D', detail.documentation_id))
		where
			detail.fac_id = @facID
			and (schedules.schedule_type <> 8 OR @shiftEndTime >= isnull(DATEADD(
					second,
					CAST(SUBSTRING(detail.shift_start_time, 1, 2) AS INT)*60*60 + CAST(SUBSTRING(detail.shift_start_time, 3, 2) AS INT)*60 + 1, -- shift_start_time_in_sec_plus_1
					DATEADD(day, DATEDIFF(day, 0, schedules.date_initiated), 0) -- date_initiated_no_time
					), @shiftEndTime)
				) -- for PRN, shift's end time is after the start of shift on initiated date
			and isnull(detail.shift_date,@shiftStartTime) >= @shiftStartTime
			and isnull(detail.shift_date,@shiftStartTime) <= @shiftEndTime 
			and (isnull(detail.schedule_date,@shiftStartTime)	<	@shiftEndTime --scheduled & duration
			)
			and isnull(detail.schedule_end_date, isnull(detail.schedule_date,@shiftStartTime) )	>=	@shiftStartTime --scheduled & duration
			and (@include_prn = 1 OR schedules.schedule_type <> 8)
			and (schedules.schedule_type != 40 or strikeout_date IS NULL)

		ORDER BY schedules.client_id, schedules.schedule_id
	END
	ELSE
	BEGIN
		select
			TOP (@max_details)
			schedules.*,
			schedule_detail_id,
			detail.std_shift_id	,
			detail.shift_date,
			schedule_date as schedule_date,
			detail.schedule_end_date	,
			documentation_id	,
			completed_date		,
			strikeout_date		,
			entered_date,
			task_time,
			cp_sec_user_audit_id,
			struckout_cp_sec_user_audit_id

		from
			--#TEMP_SCHEDULES schedules
			@TEMP_SCHEDULES schedules
			INNER JOIN view_prp_cp_active_doc_poc_proc detail with (nolock) on
					detail.fac_id = schedules.fac_id
					and detail.schedule_id = schedules.schedule_id
			
		where
			detail.fac_id = @facID
			and (schedules.schedule_type <> 8 OR @shiftEndTime >= isnull(DATEADD(
					second,
					CAST(SUBSTRING(detail.shift_start_time, 1, 2) AS INT)*60*60 + CAST(SUBSTRING(detail.shift_start_time, 3, 2) AS INT)*60 + 1, -- shift_start_time_in_sec_plus_1
					DATEADD(day, DATEDIFF(day, 0, schedules.date_initiated), 0) -- date_initiated_no_time
					), @shiftEndTime)
				) -- for PRN, shift's end time is after the start of shift on initiated date
			and isnull(detail.shift_date,@shiftStartTime) >= dateadd(dd,-1, @shiftStartTime)
			and isnull(detail.shift_date,@shiftStartTime) <= @shiftEndTime 
			and (isnull(detail.schedule_date,@shiftStartTime)	<	dateadd(dd,1,@shiftEndTime)  --scheduled & duration
			)
			and isnull(detail.schedule_end_date, isnull(detail.schedule_date,@shiftStartTime) )	>=	@shiftStartTime --scheduled & duration
			and detail.schedule_date>=detail.schedule_date
			and (@include_prn = 1 OR schedules.schedule_type <> 8)
			and (schedules.schedule_type != 40 or strikeout_date IS NULL)

		ORDER BY schedules.client_id, schedules.schedule_id
	END
END
ELSE
BEGIN
	if  @stdInts IS NOT NULL
	BEGIN
		select
			TOP (@max_details)
			schedules.*,
			schedule_detail_id	,
			detail.std_shift_id	,
			detail.shift_date,
			schedule_date as schedule_date,
			detail.schedule_end_date	,
			documentation_id	,
			completed_date		,
			strikeout_date		,
			entered_date		,
			task_time			,
			case
				when sr.std_question_id is not null then
					sr.std_question_id
				when dr.std_question_id is not null then
					dr.std_question_id
				else
					null
			end as std_question_id,
			case
				when sr.item_value_id is not null then
					sr.item_value_id
				when dr.item_value_id is not null then
					dr.item_value_id
				else
					null
			end as item_value_id,
			case
				when sr.item_value is not null then
					sr.item_value
				when dr.item_value is not null then
					dr.item_value
				else
					null
			end as item_value,
			detail.cp_sec_user_audit_id,
			detail.struckout_cp_sec_user_audit_id


		from
			@TEMP_SCHEDULES schedules
			INNER JOIN view_prp_cp_all_doc_poc_proc detail with (nolock) on
					detail.fac_id = schedules.fac_id
					and detail.schedule_id = schedules.schedule_id
			LEFT JOIN cp_scheduled_response sr with (nolock) ON
					sr.cp_scheduled_documentation_id = substring(detail.documentation_id, 0, charindex('_S', detail.documentation_id))
			LEFT JOIN cp_duration_response dr with (nolock) ON
					dr.cp_duration_documentation_id = substring(detail.documentation_id, 0, charindex('_D', detail.documentation_id))
			LEFT JOIN cp_scheduled_response_history srh with (nolock) ON
					srh.cp_scheduled_documentation_history_id = substring(detail.documentation_id, 0, charindex('_S', detail.documentation_id))
			LEFT JOIN cp_duration_response_history drh with (nolock) ON
					drh.cp_duration_documentation_history_id = substring(detail.documentation_id, 0, charindex('_D', detail.documentation_id))

		where
			detail.fac_id = @facID
			and (schedules.schedule_type <> 8 OR @shiftEndTime >= isnull(DATEADD(
					second,
					CAST(SUBSTRING(detail.shift_start_time, 1, 2) AS INT)*60*60 + CAST(SUBSTRING(detail.shift_start_time, 3, 2) AS INT)*60 + 1, -- shift_start_time_in_sec_plus_1
					DATEADD(day, DATEDIFF(day, 0, schedules.date_initiated), 0) -- date_initiated_no_time
					), @shiftEndTime)
				) -- for PRN, shift's end time is after the start of shift on initiated date
			and isnull(detail.shift_date,@shiftStartTime) >= @shiftStartTime
			and isnull(detail.shift_date,@shiftStartTime) <= @shiftEndTime 
			and (isnull(detail.schedule_date,@shiftStartTime)	<	@shiftEndTime --scheduled & duration
			)
			and isnull(detail.schedule_end_date, isnull(detail.schedule_date,@shiftStartTime) )	>=	@shiftStartTime --scheduled & duration
			and (@include_prn = 1 OR schedules.schedule_type <> 8)

		ORDER BY schedules.client_id, schedules.schedule_id
	END
	ELSE
	BEGIN
		select
			TOP (@max_details)
			schedules.*,
			schedule_detail_id	,
			detail.std_shift_id	,
			detail.shift_date,
			schedule_date as schedule_date,
			detail.schedule_end_date	,
			documentation_id	,
			completed_date		,
			strikeout_date		,
			entered_date,
			task_time,
			cp_sec_user_audit_id as cp_sec_user_audit_id ,
			struckout_cp_sec_user_audit_id as struckout_cp_sec_user_audit_id

		from
			@TEMP_SCHEDULES schedules
			INNER JOIN view_prp_cp_all_doc_poc_proc detail with (nolock) on
					detail.fac_id = schedules.fac_id
					and detail.schedule_id = schedules.schedule_id
 
		where
			detail.fac_id = @facID
			and (schedules.schedule_type <> 8 OR @shiftEndTime >= isnull(DATEADD(
					second,
					CAST(SUBSTRING(detail.shift_start_time, 1, 2) AS INT)*60*60 + CAST(SUBSTRING(detail.shift_start_time, 3, 2) AS INT)*60 + 1, -- shift_start_time_in_sec_plus_1
					DATEADD(day, DATEDIFF(day, 0, schedules.date_initiated), 0) -- date_initiated_no_time
					), @shiftEndTime)
				) -- for PRN, shift's end time is after the start of shift on initiated date
			and isnull(detail.shift_date,@shiftStartTime) >= dateadd(dd,-1, @shiftStartTime)
			and isnull(detail.shift_date,@shiftStartTime) <= @shiftEndTime 
			and (isnull(detail.schedule_date,@shiftStartTime)	<	dateadd(dd,1,@shiftEndTime)  --scheduled & duration
			)
			and isnull(detail.schedule_end_date, isnull(detail.schedule_date,@shiftStartTime) )	>=	@shiftStartTime --scheduled & duration
			and (@include_prn = 1 OR schedules.schedule_type <> 8)

		ORDER BY schedules.client_id, schedules.schedule_id
	END
END

set @vgsStepEndTime=GETDATE()
if @debug='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

end
go

grant execute on dbo.sproc_prp_pcc_poc_getScheduleDetails to public
go



GO

print 'C_Branch/04_StoredProcedures/sproc_prp_pcc_poc_getScheduleDetails.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_pcc_poc_getScheduleDetails.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_ocpc_uda_report.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- PCC-38320       :   script to create sproc_prp_rl_ocpc_uda_report Procedure  
--						-- 
-- Written By:          Ritch Moore
-- Reviewed By:         
-- 
-- Script Type:         DML 
-- Target DB Type:      Client
-- Target ENVIRONMENT:  BOTH (US/CA) 
-- 
-- 
-- Re-Runable:          YES 
-- 
-- Description of Script : Create sproc_prp_rl_ocpc_uda_report Procedure for UDA reporting
-- 
-- Special Instruction: This version only works from version 3.7.6 and up

-- 

-- =================================================================================

/***********************************************************************************
Revision History:
2013-03-05  Ritch Moore		Initial creation of this stored proc
2013-04-16  Ritch Moore		PCC-42472 Moved 'Blank (skip pattern)' filter to resolve disabled question issue
2013-05-22	Ritch Moore		PCC-42684 Set @vLocationWithUnit ='1' for Unit inclusion in location
2013-05-30	Ritch Moore		PCC-43034 Add section_sequence column
2013-06-05	Ritch Moore		PCC-43235 Added additional sort by to include std_question_no,std_subquestion_no, std_subquestion_AB
								plus handling of '' std_subquestion_no ordering
2013-06-12	Ritch Moore		PCC-43028 Format date responses (control_type=dte) to be mm/dd/yyyy
2013-09-03	Ritch Moore		PCC-43639 Added dynamic UDA header logic
2013-09-03	Ritch Moore		PCC-43622 Corrected 'no date' issue
2013-09-03	Ritch Moore		PCC-44041 Added logic for dttm date format
2013-09-03	Ritch Moore		PCC-44317 Added logic for lang (language lookup)
2013-09-04	Rick Penton		PCC-44042 Added logic for Skin Body diagram control (bdy and gbdy)
2013-09-05	Rick Penton		PCC-44319 Added logic for Admission/Readmission Date (ad)
2013-09-05	Rick Penton		PCC-46695 return configuration parameter for facepain_use_cartoon
2013-09-09	Rick Penton		PCC-44322 Added logic for Transfer/Discharge Details (to)
2013-09-10	Ritch Moore		PCC-44295 Added fields for section and group nums
2013-09-11	Rick Penton		PCC-44354 Added logic for Immunization (iFlu, iPneu, and iTet) controls
2013-09-13	Rick Penton		PCC-44333 Added logic for Advance Directive control (adir) and Resident Contact (cnt) control
2013-09-16	Rick Penton		PCC-47112 Fix bug re: ad control only works in facilities with 12 hour clock
2013-09-17	Ritch Moore		PCC-46881 Added empty resident for blank report for blank dynamic header data
2013-09-19	Rick Penton		PCC-47171 Fix bug re: Number of blank rows in response grid not correct
2013-09-23	Rick Penton		PCC-44284 handle character sort of multi-part character and numeric values
2013-09-26	Ritch Moore		PCC-43639 Ensured that Allergy and Diagnosis header elemenst always come last
2013-09-26	Ritch Moore		PCC-47214 Lookup and set uda_asst_type variable when only uda_assess_id filter is passed
2013-10-02	Rick Penton		PCC-47728 Fix Question sequence
2013-10-03	Rick Penton		PCC-48114 Performance improvement - send header only when needed
2013-10-04	Rick Penton		PCC-48006 Fix bug re: If resident doesn't have diagnosis then should display message 'No Medical Diagnosis Found' 
2013-10-07	Rick Penton		PCC-44040 Added logic for Horizontal Checkbox (hck) control
2013-10-07	Rick Penton		PCC-48028 Fix bug re: Instruction control always displayed on report even if "Include on Report" is unchecked
2013-10-08	Rick Penton		PCC-48010 Fix bug re: Score and Category in header fields are not displayed on report output when selected in assessment header configuration 
2013-10-08	Rick Penton		PCC-47762 Fix bug re: Header element's fields overlap each other
2013-10-10	Rick Penton		PCC-48010 Fix bug re: "Score: Total ADL Score" and "Category for: Total ADL Score" header fields are not displayed on report output when selected in assessment header configuration
2013-10-10	Rick Penton		PCC-48239 Fix bug re: Diagnoses field in header displays "No Medical Diagnosis Found" on blank report
2013-10-15	Rick Penton		PCC-48333 Fix bug re: Group title is missing on blank report output
2013-10-15	Rick Penton		PCC-48231 Fix bug re: displays all assessments's results when there are multiple instances of same assessment type for same resident
2013-10-16	Rick Penton		PCC-48514 Fix bug re: Report does not display data for assessment type "Bowel & Bladder Continence" even if data exist
2013-10-16	Rick Penton		PCC-48553 Fix bug re: Question split and displayed twice on report for assessment type "Continence Care"
2013-10-18	Rick Penton		PCC-48644 Fix bug re: Data not displayed for "Agitation Assessment" caused by overflow exception
2013-10-24	Rick Penton		PCC-48695 Add support for question groups for 2-column layout style
2013-10-24	Rick Penton		PCC-48842 Fix bug re: Time is not displayed on report as part of Effective Date in header
2013-10-25	Rick Penton		PCC-48721 Fix bug re: Only prints completed sections of multi-section report
2013-10-25	Rick Penton		PCC-48919 Fix bug re: Report printed from assessment's history section in resident's chart doesn't return data
2013-10-25	Rick Penton		PCC-48695 Fix bug re: Add group_no to sort sequence
2013-10-28	Rick Penton		PCC-48695 Fix bug re: Add minutes and  seconds to Strike Out Date
2013-11-08	Rick Penton		PCC-49396 Fix bug re: Assessment header displayed as "nullnullnull" when blank report run with a client_id <> -1
2013-11-13	Rick Penton		PCC-49744 Fix bug re: Multiple Issues with Pain Assessment
2013-11-13	Rick Penton		PCC-49798 Fix bug re: Date time value is not populated on report output with date time control
2013-11-13	Rick Penton		PCC-49797 Fix bug re: SQL error on report output for "AHSLLC- OLD Triage Nursing Assessment"
2013-11-14	Rick Penton		PCC-49826 Fix bug re: SQL error on reprot output for "Nutrition Assessment 2008" form both clinical and Admin module
2013-11-14	Rick Penton		PCC-49869 Fix bug re: Data not displayed on text box control when in 2 columns
2013-11-15	Rick Penton		PCC-49912 Fix bug re: Java Exception for "Fall Risk Assessment" on CDN environments
2013-11-19	Rick Penton		PCC-50026 Handle multiple facilities for emc
2013-11-20	Rick Penton		PCC-50016 Fix bug re: Resident name is not displayed on PCC Standard Form
2013-11-20	Rick Penton		PCC-50061 Support two column layout for all control types
2013-11-21	Rick Penton		PCC-50083 Fix bug re: Horizontal radio buttons not displayed on the report when there is no response
2013-11-22	Rick Penton		PCC-50218 Fix bug re: Pain Faces not displayed on report output when no response selected
2013-11-25	Rick Penton		PCC-50047 Return bdy and gbdy result in one row when in C2 column group
2013-11-25	Rick Penton		PCC-49879 Fix bug re: Question sequence incorrect for "Nutrition Assessment 2008"
2013-11-26	Rick Penton		PCC-50047 Support for two column blank report
2013-11-27	Rick Penton		PCC-50511 Support for new 'payer' control
2013-12-02	Rick Penton		PCC-50611 Fix bug re: Horizontal radio buttons control does not display on report with 2 column lay out
2013-12-03	Rick Penton		PCC-50662 Change to bdy and gbdy control appearing in two column question groups
2013-12-10	Rick Penton		PCC-50962 Fix bug re: Java exception on report when run for assessment with all control types in 2 column lay-out
2013-12-12	Rick Penton		PCC-50998 Fix bug re: displayed 3 times for all questions for "Braden Scale for Predicting Pressure Sore Risk" assessment
2013-12-12	Rick Penton		PCC-50603 Change handling of cmb and rad controls when in side-by-side (C1) layout
2013-12-12	Rick Penton		PCC-51147 Fix bug re: Resident Identifier control displayed multiple times on blank report with side by side layout)
2013-12-12	Rick Penton		PCC-50962 Fix bug re: Java exception on report when run for assessment with all control types in 2 column lay-out
2014-03-10	Rolly Sanchez	PCC-53474 (3.7.4) added icd 10 support
2014-04-07	Rick Penton		PCC-50660 (3.7.4) Fix bug re: Printing UDA assessment from IRM the system displays " No resident found with the current filter criteria"
2014-04-10  Rolly Sanchez	PCC-53474 (3.7.4) rollback icd 10 changes
2014-09-15	Rolly Sanchez	PCC-63848 (3.7.5) Custom Assessments UDA Reports conversion sproc changes
2014-09-24	Rolly Sanchez	PCC-53392 (3.7.5) Add care plan control, mcs and mcsh (multi select check box)
2014-09-29	Rolly Sanchez	PCC-51746 (3.7.5) Special Instruction throws error on very long special instructions
2014-10-02	Rolly Sanchez	PCC-63846 (3.7.5) get the latest assessment if run from print chart
2014-10-06	Rolly Sanchez	PCC-64746 (3.7.5) Fixed hck sorting
2014-10-15	Rolly Sanchez	PCC-64551 (3.7.5.1) Faces Pain Scale Diagram Response Options Not Displayed Correctly in Two Column Layout 
2014-10-23	Rolly Sanchez	PCC-65663 (3.7.5.1) handle duplicate output
2014-10-29	Rolly Sanchez	PCC-66208 (3.7.5.1)	Custom Assessment (UDA) Report: Planning and Tasks control issues
2014-11-04	Rolly Sanchez	PCC-66309 (3.7.5.1) return diagnosis control as text box
2014-11-10	Rolly Sanchez	PCC-66813 (3.7.5.2) Return image
2014-11-18	Rolly Sanchez	PCC-67272 (3.7.5.2) Drop down control always display only selected response regardless of "Print Short Version" configuration
2014-11-19	Rolly Sanchez	PCC-58264 (3.7.5.2) Return 1 row to handle no data found
2014-11-19	Rolly Sanchez	PCC-67275 (3.7.5.2) MCS and MCSH does not show on short version
2014-11-21	Rolly Sanchez	PCC-66708 (3.7.5.2) Report displayed "No Data Found" for care plan control when no care plan items are added to Planning and Tasks
2014-11-27	Rolly Sanchez	PCC-64416 (3.7.5.2) Return only selected care plan regardless of configuration
												text formatting for header
2014-12-01	Rolly Sanchez	PCC-67801 (3.7.6)	support new UDA architecture
2014-12-02	Rolly Sanchez	PCC-67893 (3.7.5.2) Fixed body diagram issue
												fixed messed short version
2014-12-04	Rolly Sanchez	PCC-67433 (3.7.6)	Support multiple custom score and category
2014-12-05	Rolly Sanchez	PCC-68053 (3.7.6) date filter has a day extra 
2014-12-09	Rolly Sanchez	PCC-68176 (3.7.6) jrxml issue when no data found
2015-01-02	Rolly Sanchez	PCC-68503 (3.7.6) Add show hide capability on blank report
2015-01-02	Rolly Sanchez	PCC-56392 (3.7.6) Add show hide capability on populated report
2015-01-14	Rolly Sanchez	PCC-69179 (3.7.6) Return double qoute for allergy as this is being handled by jrxml
2015-01-26	Rolly Sanchez	PCC-70000 (3.7.6) Disable rules applied even if its disabled
2015-03-03	Rolly Sanchez	PCC-71993 (3.7.6.1) duplicate picklist
2015-03-11	Rolly Sanchez	PCC-72667 (3.7.6.1) Some show/hide rule does not on the report
2015-03-18	Dom Christie	PCC-72177 (3.7.7) Implemented ICD 10 by passing the current date to the diagnosis function.
2015-03-26	Steve Lo		PCC-73530 (3.7.6.2) Fixed issue with date formatting on 'ad' control type
2015-04-01	Rolly Sanchez	PCC-73855 (3.7.6.2) fixed error when running Sunrise SEHA V1.2 report 
2015-05-12	Rolly Sanchez	PCC-75129 (3.7.7) support Chinese characters
2015-05-27	Kunle Adeniyi	PCC-72829 (3.7.7.1) Fixed print issue when printing assessments default to short version print that contain serveral long picklist items
2015-06-24	Kunle Adeniyi	PCC-72829 (3.7.7.1) Fixed broken uses cases for mcs in step 121
2015-07-03	Rolly Sanchez	PCC-77209 (3.7.7.1) Handle body diagram incomplete question key
2015-09-02	Rolly Sanchez	PCC-81302 (3.7.8)	added new filter for MDS and UDA Assessments
2015-09-28	Rolly Sanchez	PCC-82874 (3.7.8)   treat struck out as OR condition
2015-09-30	Rolly Sanchez	PCC-79646 (3.7.8.1)	Text format not displaying correctly on the report
2015-12-08	Rolly Sanchez	PCC-78877 (3.7.8.2) Question and picklist were missing from the report
2016-07-28	Rolly Sanchez	PCC-98699 (3.7.10.2) UDA: PCC Standard Form Does Not Print Out the "<" Character
2016-09-13 Rolly Sanchez	PCC-101394 (3.7.11) added Code Status Control Type
2016-09-29 Rolly Sanchez	PCC-101238 (3.7.11.1) The PCC Standard Form for UDA displays actual HTML tags instead of rendering them properly on the report
2016-10-27 Rolly Sanchez	PCC-103337 (3.7.11.1) Implement date standard
2016-10-31	Rolly Sanchez	PCC-103405 (3.7.11.1) Implement dynamic term for care plan controll 
2016-11-03	Rolly Sanchez	PCC-104290	(3.7.11.1) return Task in plural 
2016-11-23	Rolly Sanchez		PCC-105564		3.7.12	Update framework related to UK local terminology
2016-11-24	Rolly Sanchez		PCC-104871		3.7.12	Get Goal Term from Term configuration
2016-12-22	Katya Niakhai	PCC-103604	3.7.12	UDA report: Amendments/checks for rendering of new control
2017-01-09	Katya Niakhai	PCC-106754	3.7.12	Skin & Wound: Framework to Print the Wound Assessment with Attached Image
2017-01-10	Katya Niakhai	PCC-103604	3.7.12	UDA report: Amendments/checks for rendering of new control
2017-01-17	Rolly Sanchez	PCC-85308	3.7.12	fixed duplicated data
2017-01-19	Katya Niakhai	PCC-103604	3.7.12	UDA report: Amendments/checks for rendering of new control: two column layout
2017-01-26	Katya Niakhai	PCC-103604	3.7.12	UDA report: Amendments/checks for rendering of new control: escape special characters for ams_key
2017-01-31	Katya Niakhai	PCC-103604	3.7.12	UDA report: Amendments/checks for rendering of new control: escape double quotes in ams_key
2017-03-03	Katya Niakhai	PCC-100266	3.7.12.1	UDA: Error received when printing UDA in resident chart due to text box question having too many characters
2017-03-07	Rolly Sanchez	PCC-98987	3.7.12.1	UDA: An error is generated when printing due to unclear child response(s)
2017-03-09	Rolly Sanchez	PCC-111263 3.7.12.1 EPUAP new skin body diagram
2017-04-04	Katya Niakhai	adjustment for rules that have multiple parents for 1 child. Need to show up child question if any of the parents have qualified response; Commented out clean up;
							added old cp controls 'ads','dev','mus','gen','risk' to split logic so that rules for them will work

2017-04-19	Rolly Sanchez	PCC-112998/113001		3.7.12.2	Support rules for care profile and WV controls
2017-05-03	Rolly Sanchez	PCC-115485		3.7.12.2	Recommit on this jira 
2017-10-16	Rolly Sanchez	CORE-2951		3.7.14.1	Only get the latest pick list item
2017-11-20	Rolly Sanchez	CORE-2735		3.7.15		SP return duplicate record on care plan show/hide rules on the same question with multiple check box pick list
2018-02-01	Rolly Sanchez	CORE-9393		3.7.15.1	changed delimiter for care plan (cp) control type for 2 column (c2) 
2018-03-21	Rolly Sanchez	CORE-2890		3.7.15.2	Change logic to get pick_list_id from std_questions view instead of as_atd_pick_list table. This table dont have all the picklist
2018-05-14  Katya Niakhai	CORE-13591		3.7.15.3	When printing Skin and Wound Assessment, Report must not include hidden fields 
2018-05-16  Austin Peddle   CORE-13820      3.7.15.3    Allow PCC Standard Assessment printing from CRM side of application
2020-11-05  Sean Toohey     CORE-76339      4.3.2	    Assessment Report timing out
2021-08-23  Richard Liu     CORE-91409      4.4.6		convert the signed_date facility time zone.

***********************************************************************************/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_prp_rl_ocpc_uda_report' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE dbo.sproc_prp_rl_ocpc_uda_report
END
GO


Create Procedure dbo.sproc_prp_rl_ocpc_uda_report

  @report_id int 
, @fac_id varchar(max)
, @is_emc  bit = '0'
, @field_list varchar(max)   = NULL --- which fields to display ( CSV of report_column_ids), it does not send the fields which are not over-writable
, @filter_list varchar(max)  = NULL --- which filters are on ( list of filtername=CSV of Selected ids from value_list for eg 'order_category=3022,3023;communication_method=3025;'
, @sort_list varchar(max)    = NULL --- which are the sort ( list of report_sort_level_id = report_sort_by_id ; report_sort_level_id = report_sort_by_id )
, @num_rec int = 0
, @execution_user_login varchar(60)
, @rows_returned int out
, @debug_me char(1)  = '0'
, @status_code int  out 
, @status_text varchar(3000) out
/********************************************************************************
Purpose: To get a list of fields to display for custom reporting model

						   
Declare  @rows_ret int		,@statuscode int		,@statustext varchar(3000)
exec dbo.sproc_prp_rl_ocpc_uda_report
 @report_id =  '-57'
,@fac_id =  '10'
,@field_list = ''
,@filter_list =  'client_id=370936;client_unit=-1;client_floor=-1;client_status=-1;uda_asst_type=10046;uda_incl_disabled_qs=1;is_blank=0;uda_assessment_status=1'
,@sort_list =  '0=-1'
, @num_rec = 0
,@execution_user_login =  'pcc-sanchr'
,@rows_returned = null
,@debug_me = 'N'
,@status_code = null
,@status_text = null

Select @rows_ret, @statuscode int, @statustext

**********************************************************************************/

as
Begin


SET NOCOUNT ON;
--declare Standard local variables required for any store proc
DECLARE  @vStep int
		,@vErr varchar(max)
		,@vdelim char(1)
		,@vCharNewLine  char(2)
	    ,@vSeparator char(6)
		,@vSeparator2 char(6)
		,@vSeparator3 char(6) -- between columns of two column report
		,@vReportDate datetime
		,@vRowCount int

--Facility Related variables, also used in capturing execution Statistics 
Declare @vFacIDs varchar(max)		
Declare @PRP_FacList as table(FacId int)
Declare @vFacWarningMsg varchar(max) --- to know whether it the returned list is restricted

----Local Variables
DECLARE @vReportId int
	, @vFieldList varchar(max)
	, @vFilterList varchar(max)
	, @vSortList varchar(max)
    , @vGroupList varchar(max)
	, @vFacId int
	, @vFacName varchar(500)
	, @vFacAddress varchar(max)
	, @vRegId int
	, @vrecnum int
	, @vCountryName varchar(260)
	, @vCountryCode char(2)

----	, @vAgingStrategyID smallint ---variable that will define where to retrieve the data (rolly)
	, @visemc bit
	, @vSP_ClientId int
	, @vstd_assess_id int 
	, @vreport_date_filter datetime
	, @vfil_start_end_date_range_d1 datetime
	, @vfil_start_end_date_range_d2 datetime
	, @vshort_version bit
	, @vincl_strikeout bit
	, @vincl_disabled_qs bit
	, @vis_blank bit
	, @vHeaderColumnCount int
	, @vIdsInHeader bit
	, @vIdsInSubHeader bit
	, @vConfig_facepain_use_cartoon char(1)
	, @vSingleClient bit
	, @maxcharlen int
	, @uda_title varchar(200)
	, @cnt_result INT
	, @min_clientid INT
	, @uda_assess_status varchar(75)
	, @vTermTask		varchar(1000)
	, @vTermTasks		varchar(1000)
	, @vTermIntervention		varchar(1000)
	, @vTermFocus		varchar(1000)
	, @vTermGoal		varchar(1000)
	, @vdateFormatStyle smallint
	, @vgoal_flag							tinyint = 1
	, @vtermErrorMsg varchar(max)
;
----------Governor and Statistics Variables
Declare  @vgsThresholdRowCount int
		,@vgsEstimatedRowsReturned  int
		,@vgsEstimateFrom char(1)
		,@vgsSampleSize smallint

		,@vgsFacCount int
		,@vgsClientCount int
		,@vgsAccountCount int
		,@vgsPayerCount int
		,@vgsMonthCount int--		
		
		,@vgsFacID varchar(max)		
		,@vgsClientId varchar(max)
		,@vgsPayerId varchar(max)
		,@vgsAccountId varchar(max)

		,@vgsParamName1 varchar(50) --- fields selected
		,@vgsParamValue1 varchar(1500) 

		,@vgsParamName2 varchar(50) ---filters applied
		,@vgsParamValue2 varchar(1500) 

		,@vgsParamName3 varchar(50) --- sorting option selected
		,@vgsParamValue3 varchar(1500) 

		,@vgsParamName4 varchar(50) --- grouping option selected
		,@vgsParamValue4 varchar(1500) 

		,@vgsStepStartTime datetime
		,@vgsStepEndTime datetime

-----Governor and Statistics Variables 
Declare  @vgs_program_name varchar(200)
		 ,@vgs_start_time datetime
		 ,@vgs_execution_user varchar(60)
		 ,@vgs_fill_end_time datetime
		 ,@vGeneric_statuscode int 
		 ,@vGeneric_statustext varchar(3000)

------TERMINOLOGY VARIABLES and COMMON VARIABLES FOR A FAC 
declare @vTermClient varchar(50)
	, @vTermClients varchar(50)
	, @vTermFacility varchar(50)
	, @vTermFacilities varchar(50)
	, @vTermAdmission varchar(50)
	, @vTermAdmissions varchar(50)
	, @vTermDischarge varchar(50)
	, @vTermDischarges varchar(50)
	, @vTermRoom varchar(50)
	, @vTermRooms varchar(50)
	, @vTermAdvDirective varchar(50)
	----MRN Variables for header
	, @vMRNId int
	, @vMRNDesc varchar(100)

-----variables for each column in the report
Declare  @vSort1 varchar(100)
		,@vSort2 varchar(100)
		,@vSort3 varchar(100)
		,@vSort4 varchar(100) --- max of four sort level

		------Header and footer of the report and header/footer group
		,@vFooter varchar(50)
		,@vHeader varchar(50)

		,@vP1  varchar(100) ---- page level header column name
		,@vP2  varchar(100) ---- page level header column name
		,@vP3  varchar(100) ---- page level header column name
		,@vP4  varchar(100) ---- page level header column name
		,@vP5  varchar(100) ---- page level header column name
		,@vP6  varchar(100) ---- page level header column name
		,@vP7  varchar(100) ---- page level header column name
		,@vP8  varchar(100) ---- page level header column name
		,@vP9  varchar(100) ---- page level header column name
		,@vP10  varchar(100) ---- page level header column name
		,@vP11  varchar(100) ---- page level header column name
		,@vP12  varchar(100) ---- page level header column name
		,@vP13  varchar(100) ---- page level header column name
		,@vP14  varchar(100) ---- page level header column name
		,@vP15  varchar(100) ---- page level header column name
		,@vP16  varchar(100) ---- page level header column name
		,@vP17  varchar(100) ---- page level header column name
		,@vP18  varchar(100) ---- page level header column name
		,@vP19  varchar(100) ---- page level header column name
		,@vP20  varchar(100) ---- page level header column name

		,@vSubP1  varchar(100) ---- page level header column name
		,@vSubP2  varchar(100) ---- page level header column name
		,@vSubP3  varchar(100) ---- page level header column name
		,@vSubP4  varchar(100) ---- page level header column name
		,@vSubP5  varchar(100) ---- page level header column name
		,@vSubP6  varchar(100) ---- page level header column name
		,@vSubP7  varchar(100) ---- page level header column name
		,@vSubP8  varchar(100) ---- page level header column name
		,@vSubP9  varchar(100) ---- page level header column name
		,@vSubP10  varchar(100) ---- page level header column name
		,@vSubP11  varchar(100) ---- page level header column name
		,@vSubP12  varchar(100) ---- page level header column name
		,@vSubP13  varchar(100) ---- page level header column name
		,@vSubP14  varchar(100) ---- page level header column name
		,@vSubP15  varchar(100) ---- page level header column name
		,@vSubP16  varchar(100) ---- page level header column name
		,@vSubP17  varchar(100) ---- page level header column name
		,@vSubP18  varchar(100) ---- page level header column name
		,@vSubP19  varchar(100) ---- page level header column name
		,@vSubP20  varchar(100) ---- page level header column name

		,@vP1_disp_name varchar(100) --- display name for group header
		,@vP2_disp_name varchar(100) --- display name for group header
		,@vP3_disp_name varchar(100) --- display name for group header
		,@vP4_disp_name varchar(100) --- display name for group header
		,@vP5_disp_name varchar(100) --- display name for group header
		,@vP6_disp_name varchar(100) --- display name for group header
		,@vP7_disp_name varchar(100) --- display name for group header
		,@vP8_disp_name varchar(100) --- display name for group header
		,@vP9_disp_name varchar(100) --- display name for group header
		,@vP10_disp_name varchar(100) --- display name for group header
		,@vP11_disp_name varchar(100) --- display name for group header
		,@vP12_disp_name varchar(100) --- display name for group header
		,@vP13_disp_name varchar(100) --- display name for group header
		,@vP14_disp_name varchar(100) --- display name for group header
		,@vP15_disp_name varchar(100) --- display name for group header
		,@vP16_disp_name varchar(100) --- display name for group header
		,@vP17_disp_name varchar(100) --- display name for group header
		,@vP18_disp_name varchar(100) --- display name for group header
		,@vP19_disp_name varchar(100) --- display name for group header
		,@vP20_disp_name varchar(100) --- display name for group header

		,@vSubP1_disp_name varchar(100) --- display name for group header
		,@vSubP2_disp_name varchar(100) --- display name for group header
		,@vSubP3_disp_name varchar(100) --- display name for group header
		,@vSubP4_disp_name varchar(100) --- display name for group header
		,@vSubP5_disp_name varchar(100) --- display name for group header
		,@vSubP6_disp_name varchar(100) --- display name for group header
		,@vSubP7_disp_name varchar(100) --- display name for group header
		,@vSubP8_disp_name varchar(100) --- display name for group header
		,@vSubP9_disp_name varchar(100) --- display name for group header
		,@vSubP10_disp_name varchar(100) --- display name for group header
		,@vSubP11_disp_name varchar(100) --- display name for group header
		,@vSubP12_disp_name varchar(100) --- display name for group header
		,@vSubP13_disp_name varchar(100) --- display name for group header
		,@vSubP14_disp_name varchar(100) --- display name for group header
		,@vSubP15_disp_name varchar(100) --- display name for group header
		,@vSubP16_disp_name varchar(100) --- display name for group header
		,@vSubP17_disp_name varchar(100) --- display name for group header
		,@vSubP18_disp_name varchar(100) --- display name for group header
		,@vSubP19_disp_name varchar(100) --- display name for group header
		,@vSubP20_disp_name varchar(100) --- display name for group header

		,@vPHDR1  varchar(50) ---- page level group 1 header type
		, @vAll_disp_name varchar(2200)
		, @vClientidnumberIndex int

--		,@vGID  varchar(50)
--		,@vG1   varchar(50)
--		,@vG2   varchar(50)
--		,@vG3   varchar(50)
--
--		,@vG1_disp_name varchar(100)
--		,@vG2_disp_name varchar(100)
--		,@vG3_disp_name varchar(100)---max of three group levels are supported		

		---data intensive columns flag
		,@vLocationWithUnit bit 


DECLARE @vfil_client_id bit
	,@vfil_client_status smallint -- one value at a time
	,@vfil_floor bit
	,@vfil_unit bit
	,@vfil_std_assess_id bit
	--- non metadata filters
	,@vfil_uda_assess_id int
	,@vis_from_print_chart bit
	,@is_crm bit

	
DECLARE @spaceDate varchar(12) = '<space>Date:'; 
DECLARE @brScale varchar(10) = '<BR>Scale:'; 

DECLARE @lenSpaceDate int; --length of @space and following space
DECLARE @lenBrScale int; --length of @br and following space



Declare @reportingdays smallint;

CREATE TABLE #PRP_Multi_Value_Filters (filter_name varchar(100), filter_value varchar(32));

-- this temp table is created for performance purpose

CREATE TABLE #PRP_as_response
			( 	assess_response_id bigint 
			, assess_id int, question_key varchar(100)
			, item_value varchar(2000)
			, revision_date datetime
			, pick_list_id int
			, sub_item_value varchar(25)
			, first_val varchar(2000)
			, second_val varchar(10)
			)




CREATE TABLE #PRP_Assess_Filter (
			 std_assess_id int
			,client_id int
			,assess_id int
			,effective_date datetime
			)

CREATE TABLE #PRP_Results (
			fac_id int
			, std_assess_id int 
			, client_id int
			, assess_id int 
			, assess_date datetime
			, assessment_type varchar(55)
			, uda varchar(600)
			, section_title varchar(600)
			, section_sequence int
			, group_no varchar(6)
			, group_title varchar(254)
			, group_text varchar(1000)
			, group_layout_style varchar(5)
			, section_code varchar(10)
			, question_key varchar(100)
			, sequence int
			, std_question_no varchar(50)
			, std_subquestion_no varchar(50)	--must handle 2 controls (6 x 2) plus separator (6)
			, std_subquestion_AB varchar(50)
			, question_title varchar(2006)		--must handle 2 controls (1000 x 2) plus separator (6)
			, question_text varchar(2006)		--must handle 2 controls (1000 x 2) plus separator (6)
			, control_type varchar(50)			--must handle 2 controls ((5+2) x 2) plus separator (6)
			, control_length int
			, response_required char(1)
			, pick_list_id int
			, pick_list_name varchar(80)		--must handle 2 controls (35 x 2) plus separator (6)
			, pick_list_value varchar(max) 
			, pick_list_description varchar(max)
			, pick_list_sequence  varchar(max)			
			, pick_list_value_effective_date smalldatetime
			, pick_list_value_ineffective_date smalldatetime
			, assess_type_code varchar(10)
			, assess_status varchar(75)
			, resp_item_value varchar(max)
			, response varchar(max)
			, score float
			, score_category varchar(50)
			, strikeout_flag char(1)
			, strikeout_by varchar(60)
			, strikeout_date datetime
			, strikeout_reason varchar(60)
			, include_signature_section_flag char(1)
			, signed_by varchar(500)
			, signed_date datetime
			, cust_hdr varchar(max)
			, cust_sub_hdr varchar(max)
			, cust_hdr_long VARCHAR(MAX)
			, cust_sub_hdr_long varchar(max)
			, rnum int
			, unique_question int
			, was_merge BIT
			, print_s varchar(50)
			, ams_key varchar(max)
			, file_metadata_id varchar(max)
			, visual char
			, ordr int
);




Create table #PRP_SubHeaderUnq (header_item varchar(254),display_name varchar(254), sequence int);

Create table #PRP_HeaderUnq (header_item varchar(254),display_name varchar(254), sequence int);

CREATE TABLE #care_profile_question(
	question_id smallint,
	category_id tinyint,
	question_text varchar(80),
	question_key varchar(100),
	question_type_id tinyint,
	parent_question_id smallint,
	group_order smallmoney,
	display_order smallmoney,
	seq smallint,
	subkey varchar(12)
	)
	-- show hide and disable assessment rules
	create table #prp_ShowHideDisable_rules
			(std_question_id	int 
			, pick_list_id int
			, question_key	varchar(100)
			, section_code	varchar(100)
			, group_text varchar(1000)
			,std_question_no varchar(50)
			,std_subquestion_no varchar(50)
			,std_subquestion_ab varchar(50)
			,title varchar(1000)
			,consistency_rule_id int
			,control_type varchar(50)
			,group_title varchar(300)
			, enabled_flag varchar(5)
			, question_key_info varchar(100)
			,question_text	varchar(max)
			,question_key_sbj varchar(100)
			,item_id int
			,rules_description varchar(50)
			,range_orig varchar(50)
			, range1 varchar(50)
			, range2 varchar(50)
			, item_description varchar(800)
			, question_key_obj varchar(100)
			)
--	The next three tables contain data to support the Body Part control 
--	This table should probably eventually be persisted database table
declare @prp_body_site 
	table (
			  body_site_id int
			, description varchar(100)
		  )

declare @prp_body_type 
	table (
			  body_type_id int
			, description varchar(100)
		  )
declare @prp_body_stage 
	table (
			  body_stage_id int
			, description varchar(100)
			-- This table has a third column for a longer description of the stage that is not required for this report so is 
			-- omitted from the table variable but should be added if this table is ever persisted in the database.
		  )

declare @prp_body_stage_egbdy 
	table (
			  body_stage_id int
			, description varchar(100)
			-- This table has a third column for a longer description of the stage that is not required for this report so is 
			-- omitted from the table variable but should be added if this table is ever persisted in the database.
		  )

INSERT INTO @prp_body_site (body_site_id, description)
		SELECT 0,  '1) Top of Scalp'
UNION	SELECT 1,  '2) Right ear'
UNION	SELECT 2,  '3) Left ear'
UNION	SELECT 3,  '4) Face'
UNION	SELECT 4,  '5) Back of head'
UNION	SELECT 5,  '6) Right shoulder (front)'
UNION	SELECT 6,  '7) Left shoulder (front)'
UNION	SELECT 7,  '8) Right shoulder (rear)'
UNION	SELECT 8,  '9) Left shoulder (rear)'
UNION	SELECT 9,  '10) Right scapula'
UNION	SELECT 10, '11) Left scapula'
UNION	SELECT 11, '12) Chest'
UNION	SELECT 12, '13) Vertebrae (upper-mid)'
UNION	SELECT 13, '14) Abdomen'
UNION	SELECT 14, '15) Right antecubital'
UNION	SELECT 15, '16) Left antecubital'
UNION	SELECT 16, '17) Right elbow'
UNION	SELECT 17, '18) Left elbow'
UNION	SELECT 18, '19) Right iliac crest (front)'
UNION	SELECT 19, '20) Left iliac crest (front)'
UNION	SELECT 20, '21) Right iliac crest (rear)'
UNION	SELECT 21, '22) Left iliac crest (rear)'
UNION	SELECT 22, '23) Coccyx'
UNION	SELECT 23, '24) Groin'
UNION	SELECT 24, '25) Right trochanter (hip)'
UNION	SELECT 25, '26) Left trochanter (hip)'
UNION	SELECT 26, '27) Right hand (palm)'
UNION	SELECT 27, '28) Left hand (palm)'
UNION	SELECT 28, '29) Right hand (back)'
UNION	SELECT 29, '30) Left hand (back)'
UNION	SELECT 30, '31) Right buttock'
UNION	SELECT 31, '32) Left buttock'
UNION	SELECT 32, '33) Right thigh (front)'
UNION	SELECT 33, '34) Left thigh (front)'
UNION	SELECT 34, '35) Right thigh (rear)'
UNION	SELECT 35, '36) Left thigh (rear)'
UNION	SELECT 36, '37) Right knee (front)'
UNION	SELECT 37, '38) Left knee (front)'
UNION	SELECT 38, '39) Right knee (rear)'
UNION	SELECT 39, '40) Left knee (rear)'
UNION	SELECT 40, '41) Right lower leg (front)'
UNION	SELECT 41, '42) Left lower leg (front)'
UNION	SELECT 42, '43) Right lower leg (rear)'
UNION	SELECT 43, '44) Left lower leg (rear)'
UNION	SELECT 44, '45) Right ankle (inner)'
UNION	SELECT 45, '46) Left ankle (inner)'
UNION	SELECT 46, '47) Right ankle (outer)'
UNION	SELECT 47, '48) Left ankle (outer)'
UNION	SELECT 48, '49) Right heel'
UNION	SELECT 49, '50) Left heel'
UNION	SELECT 50, '51) Right toe(s)'
UNION	SELECT 51, '52) Left toe(s)'
UNION	SELECT 52, '53) Sacrum'
UNION	SELECT 53, '54) Left gluteal fold'
UNION	SELECT 54, '55) Right gluteal fold'





INSERT INTO @prp_body_type (body_type_id, description)
		SELECT 0, 'Pressure'
UNION	SELECT 1, 'Vascular'
UNION	SELECT 2, 'Bruising'
UNION	SELECT 3, 'Skin Tear'
UNION	SELECT 4, 'Scar'
UNION	SELECT 5, 'Surgical Incision'
UNION	SELECT 6, 'Burn'
UNION	SELECT 7, 'Rash'
UNION	SELECT 8, 'IV/Sub q/Implanted Port'
UNION	SELECT 9, 'Blister'





INSERT INTO @prp_body_stage (body_stage_id, description)
		SELECT 0, 'I'
UNION	SELECT 1, 'II'
UNION	SELECT 2, 'III'
UNION	SELECT 3, 'IV'
UNION	SELECT 4, 'Unstageable'
UNION	SELECT 5, 'N/A'
UNION	SELECT 6, 'Suspected Deep Tissue Injury'


INSERT INTO @prp_body_stage_egbdy (body_stage_id, description)
		 SELECT 0, 'EPUAP - Grade  1'
UNION	SELECT 1, 'EPUAP - Grade  2'
UNION	SELECT 2, 'EPUAP - Grade  3'
UNION	SELECT 3, 'EPUAP - Grade  4'
UNION	SELECT 4, 'Moisture Lesions'



insert into #care_profile_question
select 
	question_id,
	category_id,
	case 
	when question_key = 'A_2_1' then 'Upper Dental Appliance'
	when question_key = 'A_2_2' then 'Lower Dental Appliance'
	when question_key = 'A_6_1' then 'Other (Auxiliary Devices and Services):'
	when question_key = 'B_3_2' then 'Other (Devices and Treatments):' 
	when question_key = 'C_3_2'	then 'Other (Risk Alerts):' 
	when question_key = 'D_1_4' then 'Other (Impairments - Musculoskeletal):' 
	when question_key =  'E_1_6' then 'Other (Impairments - General):' 
	when question_key =  'K_1_10' then 'Other (Special Care):' 
	else question_text
	end as question_text,
	question_key,
	question_type_id,
	parent_question_id,
	group_order,
	display_order,
	row_number () over (partition by category_id order by group_order, display_order) as seq,
	case 
		when question_key = 'A_1_2' then '#hearing'
		when question_key = 'A_2_1' then '#dentalupper'
		when question_key = 'A_2_2' then '#dentallower'
		when question_key = 'B_1_2' then '#bladder'
		when question_key = 'B_2_1' then '#nebulizer'
		when question_key = 'B_2_2' then '#oxygen'--'#l_per_min'
		when question_key = 'C_1_5' then '#bearing'
		when question_key = 'A_6_1' then '#ao' --'#auxother'
		when question_key = 'B_3_2' then '#do'--'#devother'
		when question_key = 'C_3_2' then '#ro'--'#riskother'
		when question_key = 'D_1_4' then '#mo' --'#muscother'
		when question_key = 'E_1_6' then '#so' --'#genother'		
		when question_key = 'K_1_5' then '#bp' --'#bdpayment' for Bundled Payment Program'
		when question_key = 'K_1_10' then '#co' --'#specother' for special care other'
		
		--to handle subquestions
		when question_key = 'A_1_2_1' then 'L'
		when question_key = 'A_1_2_2' then 'R'
		when question_key = 'A_2_1_1' then 'UP'
		when question_key = 'A_2_1_2' then 'UF'
		when question_key = 'A_2_2_1' then 'LP'
		when question_key = 'A_2_2_2' then 'LF'
		when question_key = 'B_1_2_1' then 'C'
		when question_key = 'B_1_2_2' then 'N'
		when question_key = 'B_2_1_1' then 'C'
		when question_key = 'B_2_1_2' then 'N'
		--O2 question
		when question_key = 'B_2_2_1' then ''
		when question_key = 'B_2_2_2' then 'C'
		when question_key = 'B_2_2_3' then 'N'
		when question_key = 'C_1_5_1' then 'L'
		when question_key = 'C_1_5_2' then 'R'
	end as subkey
from [WESREFERENCE].dbo.care_profile_question p with (nolock)



----client Access Varaibles
declare @client_id varchar(max)
Declare @vClientIDs varchar(max)		
Declare @vClientWarningMsg varchar(max)--- to know whether it the returned list is restricted

CREATE TABLE #clients( 
		  client_id int
		, client_name varchar(200) 
		, admission_date varchar(10)
		, initial_admission_date varchar(10)
		, discharge_date varchar(10)
		, deceased_date varchar(10)
		, allergy varchar(1000)
		, location varchar(500)
		, date_of_birth varchar(10)
		, client_physician_id varchar(15) --- required for building grouping id 
		, client_physician varchar(100)
		, client_language varchar(254)
		, client_title varchar(254)
		, mrn_number varchar(50)
		, client_id_number varchar(35)
		, pho_assignment_id int
		, assignment varchar(15)  -----this is used for Med Admin audit report
		, sex char(1)
	    , bed_id int
        , hasAllergy char(1)
	    , hasBed char(1)
    	, hasDOB char(1)
	    , hasGender char(1)
		, ids varchar(max)
		, subids varchar(max)
);

CREATE TABLE #PRP_localterm
	(
            fac_id int
		, name varchar(100)
		, value varchar(1000)
		, status_code int
		, status_text varchar(max)
	);


BEGIN TRY

	Set @status_code = 0   ---- Status Code 0 = Success, 1 = Exception
	set @status_text = null;
	set @rows_returned = 0;
	Set @vgs_program_name  = Object_name(@@ProcID);  ---Current Store Proc Name
	Set @vgs_start_time = getdate();
	Set @vgs_execution_user = @execution_user_login;
	Set @vLocationWithUnit ='1'

	if @debug_me='Y' Print 'Executing store proc :  ' + @vgs_program_name  +' '+ convert(varchar(26),getdate(),109)

	select @vStep = 0
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Setting local variables ' + convert(varchar(26),getdate(),109)

	--set Standard variables
	set @vdelim = ','
	set @vCharNewLine  = Char(13) + char(10);
	set @vSeparator = 'ZYXWVU';
	set @vSeparator2 = 'UVWXYZ';
	set @vSeparator3 = 'Z-XU#Y';
	SELECT @lenSpaceDate = LEN(@spaceDate)+1, @lenBrScale = LEN(@brScale)+1;

	-- handle emc case of list of facilities
	if @is_emc = 1
		if charindex(',', @fac_id) <> 0
			set @fac_id = '-1'

	----Parameter Sniffing - use local variables when they are used in a where clause
	SET @vReportId    = @report_id;
	SET @vFacID		  = @fac_id;
	SET @vReportDate  = @vgs_start_time ; ---curent time
	SET @vFieldList   = @field_list;
	SET @vFilterList  = @filter_list;
	SET @vrecnum	  = @num_rec;


	select @vStep = 10
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Validating Input Parameters  ' +  convert(varchar(26),getdate(),109)

	----Validate all input parameters
	if (
		@report_id is null 
		or @fac_id is NULL 
		or @execution_user_login is null
		)
	begin
		set @vErr = 'One or more of the following input parameters is invalid... '
					+ ' @fac_id=' + isnull(convert(varchar(10),@fac_id),'null/empty')
					+  ' @report_id=' + isnull(convert(varchar(10),@report_id),'null/empty')
					+ ', @execution_user_login=' + isnull(@execution_user_login,'null/empty')
	

		RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);
	end



	select	@vRegId = fac.regional_id, 
			@vFacName = fac.name, 
			@vFacAddress = ltrim(rtrim(isnull(fac.address1,''))) 
				+ ', ' + ltrim(rtrim(isnull(fac.address2,''))) 
				+ ', ' + ltrim(rtrim(isnull(fac.city,''))) 
				+ ', ' + ltrim(rtrim(isnull(fac.prov,''))) 
				+ ', ' + ltrim(rtrim(isnull(fac.pc,''))) 
				+ ', ' + ltrim(rtrim(isnull(cntry.item_description,'')))
	from dbo.facility fac with (nolock)
	left JOIN dbo.common_code cntry with (nolock) ON fac.country_id = cntry.item_id
	where fac.fac_id=@vFacID


	select 
		@vCountryCode = cntry_code.ISO_Country_Alpha_2_Code
	from dbo.facility fac with (nolock)
	inner join dbo.sec_user sec with (nolock)
	on fac.fac_id = sec.fac_id
	left JOIN dbo.common_code cntry with (nolock) ON fac.country_id = cntry.item_id
	left outer join wesreference.dbo.country cntry_code with (nolock)
	on cntry.item_description = cntry_code.ISO_Country_Name
	where sec.loginname = @vgs_execution_user



	set  @vdateFormatStyle = dbo.fn_localized_dateformat_style(@vCountryCode, 1)


	-- Local terminology
	-- error on this call will not force the SP to catch block. the error msg will be part of the final output
	insert into #PRP_localterm
	exec dbo.sproc_prp_local_terminology 	@vFacId , @vgoal_flag;
	
	if @debug_me='Y' select * from #PRP_localterm


	select @vtermErrorMsg = status_text from #PRP_localterm where status_code = 1
	select @vTermTask = value from #prp_localterm where name = 'term_tsk'
	select @vTermTasks = value from #prp_localterm where name = 'term_tsk'
	select @vTermIntervention = value from #prp_localterm where name = 'term_intrvntn'
	select @vTermFocus = value from #prp_localterm where name = 'term_fcs'
	select @vTermGoal = value from #prp_localterm where name = 'term_gol'

	--set @vtermErrorMsg = 'Err 0123'
	--set @status_code = 0

	select @vTermTask = dbo.fn_format_local_term('term_tsk', @vTermTask, 1,0,0) + ': '
	 ,@vTermIntervention = dbo.fn_format_local_term('term_intrvntn', @vTermIntervention, 1,0,0)  + ': '
	 ,@vTermFocus = dbo.fn_format_local_term('term_fcs', @vTermFocus, 1,0,0)  + ': '
	 ,@vTermGoal = dbo.fn_format_local_term('term_gol', @vTermGoal, 1,0,0)  + ': '
	 , @vTermTasks = dbo.fn_format_local_term('term_tsk', @vTermTasks, 1,1,0) + ': '

	select @vFacAddress=replace(replace(replace(replace(@vFacAddress,', , , , , ',', '), ', , , , ',', '), ', , , ',', '), ', , ',', ')
	select @vFacAddress= CASE WHEN left(@vFacAddress,1)=',' THEN RIGHT(@vFacAddress,(LEN(@vFacAddress)-2)) ELSE @vFacAddress end

	SET @vSortList	  = '';
	SET @vGroupList   = '';
	
	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' select @vCountryCode as CountryCode

	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	
	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	Select @vStep = 20;
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Getting user access fac list ' + convert(varchar(26),getdate(),109);

	Select @vFacIds = fac_id
		  ,@vFacWarningMsg = msg
	From  dbo.fn_prp_get_facility_access_list_delim_irm(@fac_id,@vgs_execution_user); ---filter the fac list with user access
																					  ---note that this report can be called from irm
	--facilities warnings
	if @vFacWarningMsg is NOT NULL --- NOT NULL stands for restricted facilities access warning message
	Begin
		Set @status_code = 2 ; ----Set it warning
		Set @status_text = isnull(@status_text,'') + @vFacWarningMsg ;
	End 
	
	--fill facids into @PRP_FacList 
	select @vFacId = Cast(items as int) from dbo.Split(@vFacIds,@vdelim);  ----Only one FacId is expected at a time
	if @@ROWCOUNT = 0  ---- only if there is any FacCount proceed with getting Client list 
	BEGIN
		if @status_code = 0 Set @status_code = 3;
		RaisError( @status_text,11,1);
	END 

	if @debug_me='Y' Print 'STEP ' + convert(varchar(20), @vStep) + 'facilities returned : [' + @vFacIds + '] Facility access warning message [' + @vFacWarningMsg + ']' + convert(varchar(26),getdate(),109);
	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep = 30;
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Getting Meta Data ' + convert(varchar(26),getdate(),109);

/***************************************************************************
					GET META DATA SECTION
***************************************************************************/

	---- Create metadata temp tables ----

Create table #PRP_Filters (filter_name varchar(100), filter_value varchar(max));
--Create table #PRP_Report_Metadata_FieldstoDisplay (col_seq tinyint, column_name varchar(100), column_width smallint, output_sequence decimal(6,3), display_name varchar(200) );
--Create table #PRP_Report_Metadata_Grouping (group_level varchar(10), column_name varchar(100), display_name varchar(200), ref_report_sort_by_id int );
Create table #PRP_Report_Metadata_Sorting (seq tinyint, sort_by_name varchar(100));
Create table #PRP_Header (item_id int, id_type_id int, id_description varchar(254),header_item varchar(254),display_name varchar(254), sequence int);
Create table #PRP_SubHeader (item_id int, id_type_id int, id_description varchar(254),header_item varchar(254),display_name varchar(254), sequence int);

	---- Populate metadata temp tables ----


Select @vTermFacility= term_facility
		, @vTermClient = term_client
		, @vTermAdmission = term_admission
			from [dbo].fn_prp_get_terminology(@vFacID,@is_emc ) where fac_id = @vFacID


	INSERT INTO #PRP_Report_Metadata_Sorting
	Select row_number() OVER ( ORDER BY refsortlevel.sequence)  seq
		   , refsortby.sort_by_name 
		From dbo.prp_report rep with (nolock)
		inner JOIN dbo.prp_rm_report rm WITH (NOLOCK )
			on rep.report_id = rm.custom_report_id

		inner join dbo.prp_ref_report refrep with (nolock)
			on refrep.ref_report_id = rep.ref_report_id
		
		inner join dbo.prp_ref_report_sort_level refrepsortlevel with (nolock)
			on  refrepsortlevel.ref_report_id = refrep.ref_report_id 

		inner join dbo.prp_ref_sort_level refsortlevel with (nolock)
			on refsortlevel.ref_sort_level_id = refrepsortlevel.ref_sort_level_id

		inner join dbo.prp_ref_report_sort_by refrepsortby with (nolock)
			on refrepsortby.ref_report_sort_level_id =  refrepsortlevel.ref_report_sort_level_id 

		inner join dbo.prp_ref_sort_by refsortby with (nolock)
			on refsortby.ref_sort_by_id = refrepsortby.ref_sort_by_id

		left outer join dbo.prp_report_sort_level repsortlevel with (nolock)
			on repsortlevel.report_id = rep.report_id 
			and repsortlevel.ref_report_sort_level_id = refrepsortlevel.ref_report_sort_level_id 

		left outer join dbo.prp_report_sort_by repsortby with (nolock)
			on  repsortby.report_sort_level_id = repsortlevel.report_sort_level_id  
			and repsortby.ref_report_sort_by_id = refrepsortby.ref_report_sort_by_id
	
		left Outer join ( 	Select Cast(Left(Items,Charindex('=',Items)-1) as smallint) as ref_sort_level_id 
							,Cast(right(Items, len(Items)-Charindex('=',Items))  as int) as ref_sort_by_id  
							from dbo.Split(@sort_list,';')) sort_list
				on sort_list.ref_sort_level_id = refsortlevel.ref_sort_level_id
				and sort_list.ref_sort_by_id  = refsortby.ref_sort_by_id

		Where rm.report_id = @vReportId
		and (( repsortlevel.overwrite_run_time='0' and repsortby.default_sort_by_for_level = '1')
			 or	
			 ( refrepsortlevel.overwrite_design_time ='0' and refrepsortby.default_sort_by_for_level = '1') 
			  or 
			 (sort_list.ref_sort_level_id is not NULL and repsortby.report_sort_by_id is not null)
			)


INSERT into #PRP_Filters
	Select Left(Items,Charindex('=',Items)-1),right(Items, len(Items)-Charindex('=',Items))  from dbo.Split(@vFilterList,';')
	UNION
	Select refcol.column_name as filter_name, repfilter.filter_value
		From dbo.prp_report_filter 	  repfilter    with (nolock)
			inner join	dbo.prp_ref_report_filter refrepfilter with (nolock) 
				on repfilter.ref_report_filter_id = refrepfilter.ref_report_filter_id
			inner join	dbo.prp_ref_column	refcol	with (nolock) 
				on refcol.ref_column_id	= refrepfilter.ref_column_id
			inner JOIN dbo.prp_rm_report rm WITH (NOLOCK)
				on rm.custom_report_id = repfilter.report_id 
	Where rm.report_id =  @vReportId 
		and repfilter.run_time_option = '0'


if @debug_me='Y' Print 'BEGIN STEP ' +  convert(varchar(20), @vStep)  + 'Header and footer information... ' + convert(varchar(26),getdate(),109)


	Select @vheader = hdr1.[object_name]
			, @vFooter = left( ftr.[object_name],8)
	from dbo.prp_report rep with (nolock)
	inner JOIN dbo.prp_rm_report rm WITH (NOLOCK ) ON rm.custom_report_id = rep.report_id 
	Left Join dbo.prp_ref_report_object refrepobject1 with (nolock) on refrepobject1.ref_report_object_id = rep.p1_header_id
	Left Join dbo.prp_ref_object hdr1 with (nolock) on refrepobject1.ref_object_id = hdr1.ref_object_id

	Left Join dbo.prp_ref_report_object refrepobject  with (nolock) on refrepobject.ref_report_object_id = rep.footer_id
	Left Join dbo.prp_ref_object ftr with (nolock) on refrepobject.ref_object_id = ftr.ref_object_id

	where rm.report_id = @vReportId

	Set @vgsParamName4  = 'Selected Grouping Options'
	Set @vgsParamValue4 = ''--isnull(@vP1,'') + isnull(@vP2,'') + isnull(@vP3,'') +isnull(@vG1,'') + isnull(@vG2,'') + isnull(@vG3,'');

	Set @vgsParamName2 = 'Selected Filters'
	Set @vgsParamValue2 =isnull( @vFilterList,'');


	---- retreive sort metadata from temp tables ----

	Select @vSort1 = Case when seq = 1 then sort_by_name else @vSort1 end
		  ,@vSort2 = Case when seq = 2 then sort_by_name else @vSort2 end
		  ,@vSort3 = Case when seq = 3 then sort_by_name else @vSort3 end -- could be commented
--		  ,@vSort4 = Case when seq = 4 then sort_by_name else @vSort4 end -- could be commented
	from #PRP_Report_Metadata_Sorting order by seq;


	Set @vgsParamName3 = 'Selected Sorting Options'
	Set @vgsParamValue3 = 	isnull(@vSort1,'') + isnull(@vSort2,'') + isnull(@vSort3,'') + + isnull(@vSort4,'');

	-- get facility default for face pain diagram
	select @vConfig_facepain_use_cartoon = [value] from dbo.configuration_parameter with (NOLOCK) where name='facepain_use_cartoon' and fac_id=@vFacId
	set @vConfig_facepain_use_cartoon = ISNULL(@vConfig_facepain_use_cartoon,'N')

/***************************************************************************
					END OF GET META DATA SECTION
***************************************************************************/
	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep = 40
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Deciding MRN number ' + convert(varchar(26),getdate(),109)

	-------------------------------------------------------------
	-- Deciding MRN number 
	-------------------------------------------------------------
	--declare @vMRNId varchar(50)
	declare @FinMRNId varchar(50)
	set @finmrnid = null

		select @vMRNDesc = case when cfg.hc_no_id=-2 then 'Client Id Number' else hid.description end 
			  ,@vMRNId = cfg.hc_no_id 
            from   dbo.ar_configuration cfg with (nolock)
            left join dbo.facility fac with (nolock) on fac.fac_id = cfg.fac_id
            left join dbo.id_type hid with (nolock) on cfg.hc_no_id = hid.id_type_id
                  and ( ( hid.fac_id = @vFacId
                              and hid.state_code is null
                              and ( hid.reg_id is null
                                       or hid.reg_id = -1 ) )
                           or hid.fac_id = -1
                           or ( hid.reg_id = fac.regional_id
                                    and hid.state_code is null )
                           or ( hid.state_code = fac.prov
                                    and ( hid.reg_id = fac.regional_id
                                             or hid.reg_id is null
                                             or hid.reg_id = -1 ) )
                                and hid.deleted = 'N' )
            left join dbo.id_type sid with (nolock) on cfg.ssn_id = sid.id_type_id
                  and ( ( sid.fac_id = @vFacId
                              and sid.state_code is null
                              and ( sid.reg_id is null or sid.reg_id = -1 )
               )
              or sid.fac_id = -1
              or ( sid.reg_id = fac.regional_id
                  and sid.state_code is null )
              or ( sid.state_code = fac.prov
                                    and ( sid.reg_id = fac.regional_id
                                             or sid.reg_id is null
                                             or sid.reg_id = -1 ) )
                                and sid.deleted = 'N' )
    where  cfg.fac_id = @vFacId and cfg.deleted = 'N'

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep = 50
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' shredding filter id values ' + convert(varchar(26),getdate(),109)
--	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' start date ' + cast( @vfil_schedule_date as varchar(20)) + ' end date ' + cast( cast( @vfil_schedule_date2 as varchar(20)) as varchar(20))
 
	Set @vgsParamName1 = 'Not required'
	Set @vgsParamValue1 = 	''


	---Non metadata filters---
	SELECT @vfil_uda_assess_id = filter_value from #PRP_Filters where filter_name = 'uda_assess_id' and filter_value not in ('-1' ,'ALL','');
	SELECT @vis_from_print_chart = filter_value from #PRP_Filters where filter_name = 'is_from_print_chart' and filter_value = '1';
	SELECT @is_crm = filter_value from #PRP_Filters where filter_name = 'is_crm';

	IF @is_crm IS NULL
		set @is_crm = 0;

	---NON INTEGER VALUES AND SINGLE SELECTION

	SELECT @vfil_client_status = filter_value from #PRP_Filters where filter_name = 'client_status';  ---'client_status' --- -1 Both , 0 current, 1 discharged
	
	-----DATE TIME

	SELECT @vreport_date_filter = filter_value
	from #PRP_Filters where filter_name = 'uda_rev_since';

--	if @debug_me='Y' Print '@vreport_date_filter = ' +  isnull(convert(varchar(26),@vreport_date_filter,109),'filter not found') 

	;with tb
			as
			( 
				select d.items, row_number() over (order by (select 0)) as row_num from #PRP_Filters a
				cross apply (select items from dbo.split(isnull(Stuff(a.filter_value, charindex(',,',a.filter_value),2,',12/30/9999,'),a.filter_value),',' )) d
				where a.filter_name = 'uda_date_rnge'

			)
		select 
			 @vfil_start_end_date_range_d1 = (case when row_num = 1 then items else @vfil_start_end_date_range_d1 end )
			,@vfil_start_end_date_range_d2 = (case when row_num = 2 then dateadd(dd,1,items) else @vfil_start_end_date_range_d2 end )
--			,@vfil_start_end_date_range_review  = '1'
		from tb

	if @debug_me='Y' Print '@vfil_start_end_date_range_d1 = ' +  isnull(convert(varchar(26),@vfil_start_end_date_range_d1,109),'filter not found') 
	if @debug_me='Y' Print '@vfil_start_end_date_range_d2 = ' +  isnull(convert(varchar(26),@vfil_start_end_date_range_d2,109),'filter not found') 

	---shred column filters value for all integers value
	Insert into #PRP_Multi_Value_Filters
	Select  a.filter_name, b.items
	from #PRP_Filters a
	cross apply ( Select items from dbo.split(a.filter_value,@vDelim)) b
	where b.Items not in ('-1' ,'ALL','') and a.filter_name in (/*'client_id'   because client security is included abd hence handled differently */ 
	'client_floor'
	, 'uda_asst_type' 
	, 'client_unit'
	, 'uda_assessment_status'
	);


	Create Clustered Index _temp_filters_idx on #PRP_Multi_Value_Filters( filter_name, filter_value) ;

	if @debug_me='Y' SELECT * FROM #PRP_Multi_Value_Filters

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep = 60
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' determining which filters are used ' + convert(varchar(26),getdate(),109)

	if Exists( select 1 from #PRP_Multi_Value_Filters where filter_name = 'client_floor')				SET @vfil_floor = '1';
--	if Exists( select 1 from #PRP_Multi_Value_Filters where filter_name = 'std_assess_id')	SET @vfil_std_assess_id= '1';
	if Exists( select 1 from #PRP_Multi_Value_Filters where filter_name = 'client_unit')				SET @vfil_unit = '1';

	SET @client_id = (Select filter_value from #PRP_Filters where filter_name = 'client_id');
	if  @client_id is null Set @client_id = '-1';

	SET @vis_blank = (Select isnull(filter_value,'0') from #PRP_Filters where filter_name = 'is_blank');
		
	if @vis_blank is null set @vis_blank=0

--	if @debug_me='Y' print '@vis_blank value is '+ltrim(rtrim(str(@vis_blank)))

	SET @vshort_version = (Select filter_value from #PRP_Filters where filter_name = 'uda_print_shrt_ver');

--	if @debug_me='Y' print '@vshort_version value is '+ltrim(rtrim(str(isnull(@vshort_version,0))))

	SET @vincl_disabled_qs = (Select filter_value from #PRP_Filters where filter_name = 'uda_incl_disabled_qs');
	if @vincl_disabled_qs is null set @vincl_disabled_qs=0;

--	if @debug_me='Y' print '@vincl_disabled_qs value is '+ltrim(rtrim(str(@vincl_disabled_qs)))

	SET @vincl_strikeout = (Select filter_value from #PRP_Filters where filter_name = 'uda_Incl_struckout_assmts');

--	if @debug_me='Y' print '@vincl_strikeout value is '+ltrim(rtrim(str(@vincl_strikeout)))

	SET @vstd_assess_id = (Select filter_value from #PRP_Filters where filter_name = 'uda_asst_type');

--	if @debug_me='Y' print '@vstd_assess_id value is '+ltrim(rtrim(str(@vstd_assess_id)))

	-- get the assessment name 
	-- this was added to return uda if no data found
	
	select @uda_title = dbo.fn_scape_characters(
	  [description] ,'<')

	from dbo.as_std_assessment where std_assess_id = @vstd_assess_id


/***************************************************************************
					Check for call from history transfer
***************************************************************************/
	-- if this assessment is for a different client or facilty (as when called from the
	-- transfer history) then change the client_id and fac_id for the rest of the SPROC
	if @vfil_uda_assess_id IS NOT NULL
	begin
		SELECT @vFacId = fac_id, @client_id = client_id FROM dbo.as_assessment WITH (NOLOCK) WHERE assess_id = @vfil_uda_assess_id
	end


	if @vfil_uda_assess_id is not null and @vstd_assess_id is null
	begin
		select @vstd_assess_id = std_assess_id from dbo.as_assessment with (NOLOCK) where assess_id=@vfil_uda_assess_id
	end

	if @vfil_uda_assess_id is not null and @client_id ='-1'
	begin

		select @client_id = client_id from dbo.as_assessment with (NOLOCK) where assess_id=@vfil_uda_assess_id

	end

	if @vis_blank = 1 set @client_id = '-1'

	If @client_id='-1' set @vSingleClient=0 else set @vSingleClient=1;

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep = 70;
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Getting UDA Header & SubHeader columns ' + convert(varchar(26),getdate(),109);
	
	insert INTO #PRP_Header (item_id,id_type_id,id_description,display_name, sequence)
	SELECT assh.item_id,assh.id_type_id,idtype.description, ltrim(rtrim(ccode.item_description)),sequence_no --row_number() OVER (order by sequence_no) as row_num
	FROM dbo.AS_STD_ASSESS_HEADER assh
	LEFT JOIN dbo.COMMON_CODE ccode ON assh.item_id = ccode.item_id AND (ccode.deleted = 'N')  
	LEFT JOIN dbo.ID_TYPE idtype ON assh.id_type_id = idtype.id_type_id AND (idtype.deleted = 'N')  
	WHERE (((assh.std_assess_id  =  @vstd_assess_id  AND (assh.main_enabled  =  'Y' OR 
	(assh.main_enabled  =  'U'  AND assh.id_type_id  =  '6' )) AND (idtype.fac_id  =  '-1'  OR idtype.fac_id  =  @vFacID  OR 
	idtype.fac_id IS NULL  OR idtype.reg_id  =  '-1'  OR idtype.reg_id  =  @vRegId ) AND (assh.id_type_id  =  '-1'   OR 
	(assh.id_type_id  <>  '-1'   AND idtype.description IS NOT NULL ))))) 
	ORDER BY  sequence_no--row_num

	Set @vHeaderColumnCount = @@ROWCOUNT ;

	update #PRP_Header SET header_item='client_name',display_name=@vTermClient where display_name='Client Name'
	update #PRP_Header SET header_item='client_number',display_name=@vTermClient+' Number' where display_name='Client Number'
	update #PRP_Header SET header_item='assess_date' where display_name='Effective Date'
	update #PRP_Header SET header_item='client_location' where display_name='Location'
	update #PRP_Header SET header_item='admission_date',display_name=@vTermAdmission where display_name='Admission Date'
	update #PRP_Header SET header_item='date_of_birth' where display_name='Date of Birth'
	update #PRP_Header SET header_item='sex' where display_name='Gender'
	update #PRP_Header SET header_item='client_language' where display_name='Primary Language'
	update #PRP_Header SET header_item='physician' where display_name='Physician'
	update #PRP_Header SET header_item='allergy', sequence=99 where display_name='Allergies'
	update #PRP_Header SET header_item='Diagnoses', sequence=100, display_name='Diagnoses' where display_name='Diagnosis'
	update #PRP_Header SET header_item='uda', sequence=98 where display_name='Title'
	update #PRP_Header SET header_item='assessment_type' where display_name='Type'
	update #PRP_Header SET header_item='facility_name',display_name=@vTermFacility where display_name='Facility Name'
	update #PRP_Header SET header_item='facility_address',display_name=@vTermFacility+' Address' where display_name='Facility Address'
	update #PRP_Header SET header_item='initial_admission_date',display_name='Initial '+@vTermAdmission where display_name='Initial Admission Date'
	update #PRP_Header SET header_item='score' where display_name='Score'
	update #PRP_Header SET header_item='score_category' where display_name='Category'
	update #PRP_Header SET header_item='ids' where display_name='Identifiers'

	if Exists( select 1 from #PRP_Header where display_name = 'Identifiers') SET @vIdsInHeader = '1';
	
	if not exists (SELECT 1 from #PRP_Header where header_item = 'uda' )
	begin
	insert INTO #PRP_Header (item_id,id_type_id,id_description,header_item, display_name, sequence)
			VALUES (7115, -1, null, 'uda','Title', 98)
	end 

	
	if @debug_me='Y' select '#PRP_Header', * from #PRP_Header 
	
	-- when client id number was selected it will be added to client name instead of separate item
	SELECT @vClientidnumberIndex = count(*) from #PRP_Header where header_item = 'client_number'
	delete FROM #PRP_Header where header_item = 'client_number'
	if @debug_me='Y' select @vClientidnumberIndex as '@vClientidnumberIndex' 

-- eliminate duplicate identifier rows for use when setting variables (we concactonate selected identifiers after #client table loading)

	insert INTO #PRP_HeaderUnq  (header_item,display_name,sequence)
	SELECT header_item,display_name,row_number() OVER (order by sequence) as row_num from
	(SELECT  header_item,display_name,sequence from #PRP_Header where display_name <> 'Identifiers'
	union all
	SELECT  top 1 header_item,display_name,sequence from #PRP_Header where display_name = 'Identifiers') temp
	order by row_num

	

	---- retreive page and grouping metadata from temp tables ----

	Select 
		   @vP1      = Case when sequence = 1 then header_item else @vP1 end
		  ,@vP2      = Case when sequence = 2 then header_item else @vP2 end
		  ,@vP3      = Case when sequence = 3 then header_item else @vP3 end
		  ,@vP4      = Case when sequence = 4 then header_item else @vP4 end
		  ,@vP5      = Case when sequence = 5 then header_item else @vP5 end
		  ,@vP6      = Case when sequence = 6 then header_item else @vP6 end
		  ,@vP7      = Case when sequence = 7 then header_item else @vP7 end
		  ,@vP8      = Case when sequence = 8 then header_item else @vP8 end
		  ,@vP9      = Case when sequence = 9 then header_item else @vP9 end
		  ,@vP10     = Case when sequence = 10 then header_item else @vP10 end
		  ,@vP11     = Case when sequence = 11 then header_item else @vP11 end
		  ,@vP12     = Case when sequence = 12 then header_item else @vP12 end
		  ,@vP13     = Case when sequence = 13 then header_item else @vP13 end
		  ,@vP14     = Case when sequence = 14 then header_item else @vP14 end
		  ,@vP15     = Case when sequence = 15 then header_item else @vP15 end
		  ,@vP16     = Case when sequence = 16 then header_item else @vP16 end
		  ,@vP17     = Case when sequence = 17 then header_item else @vP17 end
		  ,@vP18     = Case when sequence = 18 then header_item else @vP18 end
		  ,@vP19     = Case when sequence = 19 then header_item else @vP19 end
		  ,@vP20     = Case when sequence = 20 then header_item else @vP20 end

		  ,@vP1_disp_name      = Case when sequence = 1 then display_name else @vP1_disp_name end
		  ,@vP2_disp_name      = Case when sequence = 2 then display_name else @vP2_disp_name end
		  ,@vP3_disp_name      = Case when sequence = 3 then display_name else @vP3_disp_name end
		  ,@vP4_disp_name      = Case when sequence = 4 then display_name else @vP4_disp_name end
		  ,@vP5_disp_name      = Case when sequence = 5 then display_name else @vP5_disp_name end
		  ,@vP6_disp_name      = Case when sequence = 6 then display_name else @vP6_disp_name end
		  ,@vP7_disp_name      = Case when sequence = 7 then display_name else @vP7_disp_name end
		  ,@vP8_disp_name      = Case when sequence = 8 then display_name else @vP8_disp_name end
		  ,@vP9_disp_name      = Case when sequence = 9 then display_name else @vP9_disp_name end
		  ,@vP10_disp_name     = Case when sequence = 10 then display_name else @vP10_disp_name end
		  ,@vP11_disp_name     = Case when sequence = 11 then display_name else @vP11_disp_name end
		  ,@vP12_disp_name     = Case when sequence = 12 then display_name else @vP12_disp_name end
		  ,@vP13_disp_name     = Case when sequence = 13 then display_name else @vP13_disp_name end
		  ,@vP14_disp_name     = Case when sequence = 14 then display_name else @vP14_disp_name end
		  ,@vP15_disp_name     = Case when sequence = 15 then display_name else @vP15_disp_name end
		  ,@vP16_disp_name     = Case when sequence = 16 then display_name else @vP16_disp_name end
		  ,@vP17_disp_name     = Case when sequence = 17 then display_name else @vP17_disp_name end
		  ,@vP18_disp_name     = Case when sequence = 18 then display_name else @vP18_disp_name end
		  ,@vP19_disp_name     = Case when sequence = 19 then display_name else @vP19_disp_name end
		  ,@vP20_disp_name     = Case when sequence = 20 then display_name else @vP20_disp_name end
	from #PRP_HeaderUnq;

--begin subheader setup

	insert INTO #PRP_SubHeader (item_id,id_type_id,id_description,display_name, sequence)
	SELECT assh.item_id,assh.id_type_id,idtype.description, ltrim(rtrim(ccode.item_description)),sequence_no --row_number() OVER (order by sequence_no) as row_num
	FROM dbo.AS_STD_ASSESS_HEADER assh
	LEFT JOIN dbo.COMMON_CODE ccode ON assh.item_id = ccode.item_id AND (ccode.deleted = 'N')  
	LEFT JOIN dbo.ID_TYPE idtype ON assh.id_type_id = idtype.id_type_id AND (idtype.deleted = 'N')  
	WHERE assh.std_assess_id  =  @vstd_assess_id  AND assh.sub_enabled  =  'Y' AND (idtype.fac_id  =  '-1'  OR idtype.fac_id  =  @vFacID  OR 
	idtype.fac_id IS NULL  OR idtype.reg_id  =  '-1'  OR idtype.reg_id  =  @vRegId ) AND (assh.id_type_id  =  '-1'   OR 
	(assh.id_type_id  <>  '-1'   AND idtype.description IS NOT NULL ))
	ORDER BY  sequence_no --row_num

	update #PRP_SubHeader SET header_item='client_name',display_name=@vTermClient where display_name='Client Name'
	update #PRP_SubHeader SET header_item='client_number',display_name=@vTermClient+' Number' where display_name='Client Number'
	update #PRP_SubHeader SET header_item='assess_date' where display_name='Effective Date'
	update #PRP_SubHeader SET header_item='client_location' where display_name='Location'
	update #PRP_SubHeader SET header_item='admission_date',display_name=@vTermAdmission where display_name='Admission Date'
	update #PRP_SubHeader SET header_item='date_of_birth' where display_name='Date of Birth'
	update #PRP_SubHeader SET header_item='sex' where display_name='Gender'
	update #PRP_SubHeader SET header_item='client_language' where display_name='Primary Language'
	update #PRP_SubHeader SET header_item='physician' where display_name='Physician'
	update #PRP_SubHeader SET header_item='allergy', sequence=99 where display_name='Allergies'
	update #PRP_SubHeader SET header_item='Diagnoses', sequence=100, display_name='Diagnoses' where display_name='Diagnosis'
	update #PRP_SubHeader SET header_item='uda', sequence=98 where display_name='Title'
	update #PRP_SubHeader SET header_item='assessment_type' where display_name='Type'
	update #PRP_SubHeader SET header_item='facility_name',display_name=@vTermFacility where display_name='Facility Name'
	update #PRP_SubHeader SET header_item='facility_address',display_name=@vTermFacility+' Address' where display_name='Facility Address'
	update #PRP_SubHeader SET header_item='initial_admission_date',display_name='Initial '+@vTermAdmission where display_name='Initial Admission Date'
	update #PRP_SubHeader SET header_item='score' where display_name='Score'
	update #PRP_SubHeader SET header_item='score_category' where display_name='Category'
	update #PRP_SubHeader SET header_item='subids' where display_name='Identifiers'

	if Exists( select 1 from #PRP_SubHeader where display_name = 'Identifiers') SET @vIdsInSubHeader = '1';
	
	if not exists (SELECT 1 from #PRP_SubHeader where header_item = 'uda' )
	begin
	insert INTO #PRP_SubHeader (item_id,id_type_id,id_description,header_item, display_name, sequence)
		select item_id,id_type_id,id_description,header_item, display_name, sequence from  #PRP_Header where  header_item='uda'
	end 

	delete FROM #PRP_SubHeader where header_item = 'client_number'
	if @debug_me='Y' select '#PRP_SubHeader', * from #PRP_SubHeader 

	

-- eliminate duplicate identifier rows for use when setting variables (we concactonate selected identifiers after #client table loading)

	insert INTO #PRP_SubHeaderUnq  (header_item,display_name,sequence)
	SELECT header_item,display_name,row_number() OVER (order by sequence) as row_num from
	(SELECT  header_item,display_name,sequence from #PRP_SubHeader where display_name <> 'Identifiers'
	union all
	SELECT  top 1 header_item,display_name,sequence from #PRP_SubHeader where display_name = 'Identifiers') temp
	order by row_num

	


	---- retreive page and grouping metadata from temp tables ----

	Select 
		   @vSubP1      = Case when sequence = 1 then header_item else @vSubP1 end
		  ,@vSubP2      = Case when sequence = 2 then header_item else @vSubP2 end
		  ,@vSubP3      = Case when sequence = 3 then header_item else @vSubP3 end
		  ,@vSubP4      = Case when sequence = 4 then header_item else @vSubP4 end
		  ,@vSubP5      = Case when sequence = 5 then header_item else @vSubP5 end
		  ,@vSubP6      = Case when sequence = 6 then header_item else @vSubP6 end
		  ,@vSubP7      = Case when sequence = 7 then header_item else @vSubP7 end
		  ,@vSubP8      = Case when sequence = 8 then header_item else @vSubP8 end
		  ,@vSubP9      = Case when sequence = 9 then header_item else @vSubP9 end
		  ,@vSubP10     = Case when sequence = 10 then header_item else @vSubP10 end
		  ,@vSubP11     = Case when sequence = 11 then header_item else @vSubP11 end
		  ,@vSubP12     = Case when sequence = 12 then header_item else @vSubP12 end
		  ,@vSubP13     = Case when sequence = 13 then header_item else @vSubP13 end
		  ,@vSubP14     = Case when sequence = 14 then header_item else @vSubP14 end
		  ,@vSubP15     = Case when sequence = 15 then header_item else @vSubP15 end
		  ,@vSubP16     = Case when sequence = 16 then header_item else @vSubP16 end
		  ,@vSubP17     = Case when sequence = 17 then header_item else @vSubP17 end
		  ,@vSubP18     = Case when sequence = 18 then header_item else @vSubP18 end
		  ,@vSubP19     = Case when sequence = 19 then header_item else @vSubP19 end
		  ,@vSubP20     = Case when sequence = 20 then header_item else @vSubP20 end

		  ,@vSubP1_disp_name      = Case when sequence = 1 then display_name else @vSubP1_disp_name end
		  ,@vSubP2_disp_name      = Case when sequence = 2 then display_name else @vSubP2_disp_name end
		  ,@vSubP3_disp_name      = Case when sequence = 3 then display_name else @vSubP3_disp_name end
		  ,@vSubP4_disp_name      = Case when sequence = 4 then display_name else @vSubP4_disp_name end
		  ,@vSubP5_disp_name      = Case when sequence = 5 then display_name else @vSubP5_disp_name end
		  ,@vSubP6_disp_name      = Case when sequence = 6 then display_name else @vSubP6_disp_name end
		  ,@vSubP7_disp_name      = Case when sequence = 7 then display_name else @vSubP7_disp_name end
		  ,@vSubP8_disp_name      = Case when sequence = 8 then display_name else @vSubP8_disp_name end
		  ,@vSubP9_disp_name      = Case when sequence = 9 then display_name else @vSubP9_disp_name end
		  ,@vSubP10_disp_name     = Case when sequence = 10 then display_name else @vSubP10_disp_name end
		  ,@vSubP11_disp_name     = Case when sequence = 11 then display_name else @vSubP11_disp_name end
		  ,@vSubP12_disp_name     = Case when sequence = 12 then display_name else @vSubP12_disp_name end
		  ,@vSubP13_disp_name     = Case when sequence = 13 then display_name else @vSubP13_disp_name end
		  ,@vSubP14_disp_name     = Case when sequence = 14 then display_name else @vSubP14_disp_name end
		  ,@vSubP15_disp_name     = Case when sequence = 15 then display_name else @vSubP15_disp_name end
		  ,@vSubP16_disp_name     = Case when sequence = 16 then display_name else @vSubP16_disp_name end
		  ,@vSubP17_disp_name     = Case when sequence = 17 then display_name else @vSubP17_disp_name end
		  ,@vSubP18_disp_name     = Case when sequence = 18 then display_name else @vSubP18_disp_name end
		  ,@vSubP19_disp_name     = Case when sequence = 19 then display_name else @vSubP19_disp_name end
		  ,@vSubP20_disp_name     = Case when sequence = 20 then display_name else @vSubP20_disp_name end
	from #PRP_SubHeaderUnq;


	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

--end subheader setup

	-----getting the list of clients
	select @vStep = 80
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' getting list of clients ' + convert(varchar(26),getdate(),109)

	Select @vClientIDs = client_id
			  ,@vClientWarningMsg = msg
	From  dbo.fn_prp_get_client_access_list_delim(@client_id,@fac_id,@vgs_execution_user) ---filter the Client list with user access

	if @vClientWarningMsg is NOT NULL --- NOT NULL stands for restricted Client access warning message
	Begin
		Set @status_code = 2 ; ----Set it warning
		Set @status_text = Isnull(@status_text,'') + @vClientWarningMsg ;
	End 

	if isnull(@vClientIDs,'-1') <> '-1'  ----should not be null or -1, if null or -1 then it means there is no filter on clients
	BEGIN
		SET @vfil_client_id = '1'

		Insert into #PRP_Multi_Value_Filters
		Select 'client_id', items from dbo.split(@vClientIds,@vDelim) b
	END

	IF @is_crm=1
	begin
			Insert into #clients
		(
			  client_id 
			, client_name 
			, admission_date 
			, initial_admission_date
			, discharge_date 
			, deceased_date 
			, allergy 
			, location 
			, date_of_birth 
			, client_physician_id
			, client_physician
			, client_language
			, client_title
			, mrn_number 
			, client_id_number
			, sex
			, bed_id
			, hasAllergy
			, hasBed
			, hasDOB
			, hasGender
		)
		select assessment.client_id as client_id
			,rtrim( ltrim(rtrim(isnull(m.last_name,''))) + ', ' + ltrim(rtrim(isnull(m.first_name,'')))  )   
			as client_name

			, '' as admission_date
			, '' as initial_admission_date
			, '' as discharge_date
			, isnull(convert(varchar(10),m.deceased_date, @vdateFormatStyle),'')  as deceased_date

			, '' as allergy
			, '' as location
			
			, isnull(convert(varchar(10),m.date_of_birth, @vdateFormatStyle),'')  as date_of_birth

			, '' as client_physician_id
			, ''  as client_physician
			, isnull(lang.item_description,'') as client_language
			, isnull(ttl.item_description,'') as client_title
			, NULL as mrn_number
			, '' as client_id_number
			, isnull(m.sex,'') sex
			, '' as bed_id
			, 0 as hasAllergy
    		, 0 as hasBed
			, CASE WHEN (m.date_of_birth='' or  m.date_of_birth is null) THEN 0 ELSE 1 END hasDOB
    		, CASE WHEN (m.sex='' or  m.sex is null) THEN 0 ELSE 1 END hasGender 
		from dbo.scrm_lead_assessment a with (nolock)
		inner JOIN as_assessment assessment with (nolock)  ON assessment.assess_id = a.assess_id
		inner JOIN dbo.scrm_lead l with (nolock) on a.entity_id=l.entity_id
		inner JOIN dbo.mpi m with (nolock) on l.mpi_id = m.mpi_id
		left JOIN dbo.common_code lang WITH(NOLOCK) ON m.primary_lang_id=lang.item_id
		left JOIN dbo.common_code ttl WITH(NOLOCK) ON m.title=ttl.item_id 
		WHERE  a.assess_id=@vfil_uda_assess_id

		Set @vgsClientCount = @@ROWCOUNT ;  -------get the clients selected count
	end
	ELSE
		IF @vSingleClient=1
		begin
			Insert into #clients
			(
				  client_id 
				, client_name 
				, admission_date 
				, initial_admission_date
				, discharge_date 
				, deceased_date 
				, allergy 
				, location 
				, date_of_birth 
				, client_physician_id
				, client_physician
				, client_language
				, client_title
				, mrn_number 
				, client_id_number
				, sex
				, bed_id
				, hasAllergy
				, hasBed
				, hasDOB
				, hasGender
			)
			select  c.client_id
				 ,case when @vClientidnumberIndex = 0 then
				 rtrim( ltrim(rtrim(isnull(m.last_name,''))) + ', ' + ltrim(rtrim(isnull(m.first_name,'')))  )  
				 ELSE
				rtrim( ltrim(rtrim(isnull(m.last_name,''))) + ', ' + ltrim(rtrim(isnull(m.first_name,'')))  ) + ' (' + ltrim(rtrim(isnull(c.client_id_number,'')))+ ')' END 
				as client_name

	--			, rtrim( ltrim(rtrim(isnull(m.last_name,''))) + ', ' + ltrim(rtrim(isnull(m.first_name,''))) + ' ' + ltrim(rtrim(isnull(m.middle_name,''))) ) + ' (' + ltrim(rtrim(isnull(c.client_id_number,'')))+ ')' as client_name
			

				, isnull(convert(varchar(10),c.admission_date, @vdateFormatStyle),'')	as admission_date
				, isnull(convert(varchar(10),c.initial_admission_date, @vdateFormatStyle),'')	as initial_admission_date
				, isnull(convert(varchar(10),c.discharge_date, @vdateFormatStyle),'')	as discharge_date
				, isnull(convert(varchar(10),m.deceased_date, @vdateFormatStyle),'')  as deceased_date


				, Case when @vHeader = 'header_1' /* in (@vPHDR1,@vPHDR2, @vPHDR3)*/ then isnull(cla.allergy,'') else NULL end as allergy
				, Case when @vLocationWithUnit='1' then rtrim(ltrim(isnull(u.unit_desc,''))) + ' ' else '' end +
					 rtrim(ltrim(isnull(r.room_desc,'')))  + ' ' + rtrim(ltrim(isnull(b.bed_desc,''))) as location
			
			
				, isnull(convert(varchar(10),m.date_of_birth, @vdateFormatStyle),'')  as date_of_birth

				, convert(varchar,c.primary_physician_id) as client_physician_id
				, isnull(ct.last_name + ', ' ,'') + isnull( ct.first_name,'')  + ' ' + isnull(ct.middle_name,'')  as client_physician
				, isnull(lang.item_description,'') as client_language
				, isnull(ttl.item_description,'') as client_title
				, Case when @vMRNId = -2 then c.client_id_number 
					else NULL 
					end as mrn_number
				, isnull(c.client_id_number,'')
				, isnull(m.sex,'') sex
				, loc.bed_id 
				, CASE WHEN (cla.allergy ='To Be Determined' or  cla.allergy='' or cla.allergy is null) THEN 0 ELSE 1 END hasAllergy
    			, CASE WHEN (loc.bed_id=-1 or loc.bed_id is null) THEN 0 ELSE 1 END hasBed
				, CASE WHEN (m.date_of_birth='' or  m.date_of_birth is null) THEN 0 ELSE 1 END hasDOB
    			, CASE WHEN (m.sex='' or  m.sex is null) THEN 0 ELSE 1 END hasGender 
			from dbo.clients c with (nolock)
			inner join dbo.mpi m with (nolock) on c.mpi_id = m.mpi_id
			left JOIN dbo.common_code lang WITH(NOLOCK) ON m.primary_lang_id=lang.item_id
			left JOIN dbo.common_code ttl WITH(NOLOCK) ON m.title=ttl.item_id
			inner join dbo.clients_attribute cla with (nolock) on c.client_id = cla.client_id
	--		inner join ( Select * from 
			LEFT join ( Select * from 
							(select client_id, bed_id, payer_type, row_number() OVER (partition by client_id order by effective_date desc ) as row_num
								From dbo.view_prp_census with (nolock) where fac_id = @vFacId and (record_type = 'C' or record_type is null))  vw
							where row_num = 1
						) loc on c.client_id = loc.client_id and  (loc.payer_type IS NULL OR loc.payer_type <>'OutPatient')-- CDN payer_type is always empty string
		
			left join dbo.bed b with (nolock) on loc.bed_id=b.bed_id
			left join dbo.room r with (nolock) on b.room_id=r.room_id
			left join dbo.[floor] f with (nolock) on f.floor_id=r.floor_id
			left join dbo.unit u with (nolock) on  u.unit_id=r.unit_id
			left join dbo.contact ct WITH (NOLOCK) on ct.contact_id = c.primary_physician_id  
			WHERE  c.client_id=@client_id

			Set @vgsClientCount = @@ROWCOUNT ;  -------get the clients selected count
		end
		else if @vfil_client_status in (-1,1) and @vis_blank=0 ----ALL or discharged
		BEGIN
			Insert into #clients
			(
				  client_id 
				, client_name 
				, admission_date 
				, initial_admission_date
				, discharge_date 
				, deceased_date 
				, allergy 
				, location 
				, date_of_birth 
				, client_physician_id
				, client_physician
				, client_language
				, client_title
				, mrn_number 
				, client_id_number
				, sex
				, bed_id
				, hasAllergy
				, hasBed
				, hasDOB
				, hasGender
			)
			select  c.client_id
				,case when @vClientidnumberIndex = 0 then
				 rtrim( ltrim(rtrim(isnull(m.last_name,''))) + ', ' + ltrim(rtrim(isnull(m.first_name,'')))  )  
				 ELSE
				rtrim( ltrim(rtrim(isnull(m.last_name,''))) + ', ' + ltrim(rtrim(isnull(m.first_name,'')))  ) + ' (' + ltrim(rtrim(isnull(c.client_id_number,'')))+ ')' END 
				as client_name

	--			, rtrim( ltrim(rtrim(isnull(m.last_name,''))) + ', ' + ltrim(rtrim(isnull(m.first_name,''))) + ' ' + ltrim(rtrim(isnull(m.middle_name,''))) ) + ' (' + ltrim(rtrim(isnull(c.client_id_number,'')))+ ')' as client_name

				, isnull(convert(varchar(10),c.admission_date, @vdateFormatStyle),'')	as admission_date
				, isnull(convert(varchar(10),c.initial_admission_date, @vdateFormatStyle),'')	as initial_admission_date
				, isnull(convert(varchar(10),c.discharge_date, @vdateFormatStyle),'')	as discharge_date
				, isnull(convert(varchar(10),m.deceased_date, @vdateFormatStyle),'')  as deceased_date

				, Case when @vHeader = 'header_1' /* in (@vPHDR1,@vPHDR2, @vPHDR3)*/ then isnull(cla.allergy,'') else NULL end as allergy
				, Case when @vLocationWithUnit='1' then rtrim(ltrim(isnull(u.unit_desc,''))) + ' ' else '' end +
					 rtrim(ltrim(isnull(r.room_desc,'')))  + ' ' + rtrim(ltrim(isnull(b.bed_desc,''))) as location
			
				, isnull(convert(varchar(10),m.date_of_birth, @vdateFormatStyle),'')  as date_of_birth
	
				, convert(varchar,c.primary_physician_id) as client_physician_id
				, isnull(ct.last_name + ', ' ,'') + isnull( ct.first_name,'')  + ' ' + isnull(ct.middle_name,'')  as client_physician
				, isnull(lang.item_description,'') as client_language
				, isnull(ttl.item_description,'') as client_title
				, Case when @vMRNId = -2 then c.client_id_number 
					else NULL 
					end as mrn_number
				, isnull(c.client_id_number,'')
				, isnull(m.sex,'') sex
				, loc.bed_id 
				, CASE WHEN (cla.allergy ='To Be Determined' or  cla.allergy='' or cla.allergy is null) THEN 0 ELSE 1 END hasAllergy
    			, CASE WHEN (loc.bed_id=-1 or loc.bed_id is null) THEN 0 ELSE 1 END hasBed
				, CASE WHEN (m.date_of_birth='' or  m.date_of_birth is null) THEN 0 ELSE 1 END hasDOB
    			, CASE WHEN (m.sex='' or  m.sex is null) THEN 0 ELSE 1 END hasGender 
				from ( Select client_id, mpi_id, client_id_number 
								, admission_date
								, initial_admission_date
								, discharge_date
								, primary_physician_id
								, pharmacy_id

						from dbo.clients  with (nolock) 
					left join #PRP_Multi_Value_Filters fil_client_id		on fil_client_id.filter_name	= 'client_id'	and fil_client_id.filter_value = clients.client_id
					where clients.fac_id = @vFacID  and clients.deleted = 'N' 
						AND ((@vfil_client_id		= '1' and fil_client_id.filter_value is not null) or  @vfil_client_id is null )
						AND (@vfil_client_status = '-1' or clients.discharge_date is not null  ) 
				) c
			inner join dbo.mpi m with (nolock) on c.mpi_id = m.mpi_id
			left JOIN dbo.common_code lang WITH(NOLOCK) ON m.primary_lang_id=lang.item_id
			left JOIN dbo.common_code ttl WITH(NOLOCK) ON m.title=ttl.item_id
			inner join dbo.clients_attribute cla with (nolock) on c.client_id = cla.client_id		
			inner join ( Select * from 
							(select client_id, bed_id, payer_type, row_number() OVER (partition by client_id order by effective_date desc ) as row_num
								From dbo.view_prp_census with (nolock) where fac_id = @vFacId and (record_type = 'C' or record_type is null))  vw
							where row_num = 1
						) loc on c.client_id = loc.client_id and  (loc.payer_type IS NULL OR loc.payer_type <>'OutPatient')-- CDN payer_type is always empty string

			left join dbo.bed b with (nolock) on loc.bed_id=b.bed_id
			left join dbo.room r with (nolock) on b.room_id=r.room_id
			left join dbo.[floor] f with (nolock) on f.floor_id=r.floor_id
			left join dbo.unit u with (nolock) on  u.unit_id=r.unit_id
			left join dbo.contact ct WITH (NOLOCK) on ct.contact_id = c.primary_physician_id  
			Left join #PRP_Multi_Value_Filters fil_floor			on fil_floor.filter_name	= 'client_floor'					and fil_floor.filter_value = f.floor_id
			Left join #PRP_Multi_Value_Filters fil_unit				on fil_unit.filter_name		= 'client_unit'						and fil_unit.filter_value  = u.unit_id
			WHERE  ((@vfil_floor			= '1' and fil_floor.filter_value is not null) or @vfil_floor is null )
				AND ((@vfil_unit			= '1' and fil_unit.filter_value is not null) or @vfil_unit is null )


			Set @vgsClientCount = @@ROWCOUNT ;  -------get the clients selected count
		END
		ELSE IF @vfil_client_status not in (-1,1) and @vis_blank=0 -----ONLY Current clients
		BEGIN

			Insert into #clients
			(
				  client_id 
				, client_name 
				, admission_date 
				, initial_admission_date
				, discharge_date 
				, deceased_date 
				, allergy 
				, location 
				, date_of_birth 
				, client_physician_id
				, client_physician
				, client_language
				, client_title
				, mrn_number 
				, client_id_number
				, sex
				, bed_id
				, hasAllergy
				, hasBed
				, hasDOB
				, hasGender
			)
			select  c.client_id
				,case when @vClientidnumberIndex = 0 then
				 rtrim( ltrim(rtrim(isnull(m.last_name,''))) + ', ' + ltrim(rtrim(isnull(m.first_name,'')))  )  
				 ELSE
				rtrim( ltrim(rtrim(isnull(m.last_name,''))) + ', ' + ltrim(rtrim(isnull(m.first_name,'')))  ) + ' (' + ltrim(rtrim(isnull(c.client_id_number,'')))+ ')' END 
				as client_name

	--			, rtrim( ltrim(rtrim(isnull(m.last_name,''))) + ', ' + ltrim(rtrim(isnull(m.first_name,''))) + ' ' + ltrim(rtrim(isnull(m.middle_name,''))) ) + ' (' + ltrim(rtrim(isnull(c.client_id_number,'')))+ ')' as client_name
			
				, isnull(convert(varchar(10),c.admission_date, @vdateFormatStyle),'')	as admission_date
				, isnull(convert(varchar(10),c.initial_admission_date, @vdateFormatStyle),'')	as initial_admission_date
				, isnull(convert(varchar(10),c.discharge_date, @vdateFormatStyle),'')	as discharge_date
				, isnull(convert(varchar(10),m.deceased_date, @vdateFormatStyle),'')  as deceased_date

				, Case when @vHeader = 'header_1' /* in (@vPHDR1,@vPHDR2, @vPHDR3)*/ then isnull(cla.allergy,'') else NULL end as allergy
				, Case when @vLocationWithUnit='1' then rtrim(ltrim(isnull(loc.unit_desc,''))) + ' ' else '' end + 
						rtrim(ltrim(isnull(loc.room_desc,'')))  + ' ' + rtrim(ltrim(isnull(loc.bed_desc,''))) as location
			
		
				, isnull(convert(varchar(10),m.date_of_birth, @vdateFormatStyle),'')  as date_of_birth
			
				, convert(varchar,c.primary_physician_id) as client_physician_id
				, isnull(ct.last_name + ', ' ,'') + isnull( ct.first_name,'')  + ' ' + isnull(ct.middle_name,'')  as client_physician
				, isnull(lang.item_description,'') as client_language
				, isnull(ttl.item_description,'') as client_title
				, Case when @vMRNId = -2 then c.client_id_number 
					else NULL 
					end as mrn_number
				, isnull(c.client_id_number,'')
				, isnull(m.sex,'') as sex
				, loc.bed_id 
				, CASE WHEN (cla.allergy ='To Be Determined' or  cla.allergy='' or cla.allergy is null) THEN 0 ELSE 1 END hasAllergy
    			, CASE WHEN (loc.bed_id=-1 or loc.bed_id is null) THEN 0 ELSE 1 END hasBed
				, CASE WHEN (m.date_of_birth='' or  m.date_of_birth is null) THEN 0 ELSE 1 END hasDOB
    			, CASE WHEN (m.sex='' or  m.sex is null) THEN 0 ELSE 1 END hasGender 

			from dbo.clients c with (nolock)
			inner join dbo.mpi m with (nolock) on c.mpi_id = m.mpi_id
			left JOIN dbo.common_code lang WITH(NOLOCK) ON m.primary_lang_id=lang.item_id
			left JOIN dbo.common_code ttl WITH(NOLOCK) ON m.title=ttl.item_id		
			inner join dbo.view_prp_latest_client_census_current	loc	with (nolock ) on c.client_id = loc.client_id ---this view will only get current clients only.
			inner join dbo.clients_attribute cla with (nolock) on c.client_id = cla.client_id
			left join dbo.contact ct with (nolock)   on ct.contact_id = c.primary_physician_id  
			left join #PRP_Multi_Value_Filters fil_client_id		on fil_client_id.filter_name	= 'client_id'			and fil_client_id.filter_value = c.client_id
			Left join #PRP_Multi_Value_Filters fil_floor			on fil_floor.filter_name	= 'client_floor'					and fil_floor.filter_value = loc.floor_id
			Left join #PRP_Multi_Value_Filters fil_unit				on fil_unit.filter_name		= 'client_unit'						and fil_unit.filter_value  = loc.unit_id
			WHERE 	c.fac_id =  @vFacID	
				AND ((@vfil_client_id		= '1' and fil_client_id.filter_value is not null) or  @vfil_client_id is null )
				AND ((@vfil_floor			= '1' and fil_floor.filter_value is not null) or @vfil_floor is null )
				AND ((@vfil_unit			= '1' and fil_unit.filter_value is not null) or @vfil_unit is null )
				AND c.discharge_date is null
			Set @vgsClientCount = @@ROWCOUNT ;  -------get the clients selected count
		END
		ELSE IF @vis_blank=1 ----- Empty client for blank report
		BEGIN
			Insert into #clients
					(
						  client_id 
						, client_name 
						, admission_date 
						, initial_admission_date
						, discharge_date 
						, deceased_date 
						, allergy 
						, location 
						, date_of_birth 
						, client_physician
						, client_language
						, client_title
						, mrn_number 
						, client_id_number
						, sex
					)
			SELECT	0 as client_id
					, '' as client_name
					, '' as admission_date
					, '' as initial_admission_date
					, '' as discharge_date
					, '' as deceased_date
					, '' as allergy
					, '' as location
					, '' as date_of_birth
					, '' as client_physician
					, '' as client_language
					, '' as client_title
					, '' as mrn_number
					, '' as client_id_number
					, '' as sex
			Set @vgsClientCount = @@ROWCOUNT ;  -------get the clients selected count
		END

	IF @vgsClientCount=0 and @vis_blank=0
		Begin
			Set @status_code = 2 ; 
			Set @status_text = 'No residents found with the current filter criteria.'
			Raiserror( @status_text, 11, 1 );
		End 

	if @debug_me='Y'  select * from #clients


	CREATE CLUSTERED INDEX _tmp_idx_clients on #clients(client_id);

	---update MRN number for clients if @vMRNID <> -2 and one of the headers is header_1
	if (@vHeader = 'header_1' /*or @vPHDR2 = 'header_1' or @vPHDR3 = 'header_1'*/) AND ( @vMRNId <> -2) and @vis_blank=0-----
	BEGIN
	
		Update #clients SET mrn_number = ltrim(rtrim(vwClientIds.description)) 
			From #clients c
			inner join dbo.view_client_ids vwClientIds with (nolock) on vwClientIds.client_id  = c.client_id and id_type_id = @vMRNId 

	END

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(@vgsClientCount))+ ' rows in ' +ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep = 90
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' bulding client identifiers for header ' + convert(varchar(26),getdate(),109)

	IF @vIdsInHeader = 1 --dynamically concatenate all selected header identifier names and values
	BEGIN
		Update c SET c.ids = indents.ids 
		from #clients c
		inner JOIN (SELECT client_id, REPLACE(csv,'|',@vSeparator2) as ids
			from(
			SELECT distinct t.client_id, STUFF(
			(SELECT  '|' +id_description+@vSeparator+[description]
			FROM 
			(select cl.client_id,head.id_description,isnull(cids.description,'') as [description] FROM 
			#clients cl
			OUTER APPLY #PRP_Header head
			left join dbo.client_ids cids with (nolock) on cl.client_id=cids.client_id AND cids.deleted='N' AND  head.id_type_id=cids.id_type_id
			where head.display_name='Identifiers') s
			WHERE s.client_id = t.client_id
			FOR XML PATH('')),1,1,'') AS CSV
			FROM 
			(select cl.client_id,head.id_description,isnull(cids.description,'') as [description] FROM 
			#clients cl
			OUTER APPLY #PRP_Header head
			left join dbo.client_ids cids with (nolock) on cl.client_id=cids.client_id AND cids.deleted='N' AND  head.id_type_id=cids.id_type_id
			where head.display_name='Identifiers') t
			GROUP BY t.client_id) clids) indents ON c.client_id=indents.client_id
	END

	IF @vIdsInSubHeader = 1 --dynamically concatenate all selected header identifier names and values
	BEGIN
		Update c SET c.subids = indents.ids 
		from #clients c
		inner JOIN (SELECT client_id, REPLACE(csv,'|',@vSeparator2) as ids
			from(
			SELECT distinct t.client_id, STUFF(
			(SELECT  '|' +id_description+@vSeparator+[description]
			FROM 
			(select cl.client_id,head.id_description,isnull(cids.description,'') as [description] FROM 
			#clients cl
			OUTER APPLY #PRP_SubHeader head
			left join dbo.client_ids cids with (nolock) on cl.client_id=cids.client_id AND cids.deleted='N' AND  head.id_type_id=cids.id_type_id
			where head.display_name='Identifiers') s
			WHERE s.client_id = t.client_id
			FOR XML PATH('')),1,1,'') AS CSV
			FROM 
			(select cl.client_id,head.id_description,isnull(cids.description,'') as [description] FROM 
			#clients cl
			OUTER APPLY #PRP_SubHeader head
			left join dbo.client_ids cids with (nolock) on cl.client_id=cids.client_id AND cids.deleted='N' AND  head.id_type_id=cids.id_type_id
			where head.display_name='Identifiers') t
			GROUP BY t.client_id) clids) indents ON c.client_id=indents.client_id
	END

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	------Initializing Execution Statistics Varibales
	select @vStep = 100
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Initializing Execution Statistics Variables ' + convert(varchar(26),getdate(),109);

	Set @vgsFacCount = 0       --- it is fac level report
	Set @vgsPayerCount	= 0	;	 ---  No Payer information available
	SET @vgsAccountCount = 0 ;  ---- no account count is available
	Set @vgsMonthCount = 0; ----not a period based report so no month count
	Set @vgsClientCount = 0 ; ----no client relaetd information 

	Set @vgsFacID = NULL;
	Set @vgsClientId = NULL ;
	Set @vgsPayerId = NULL;
	Set @vgsAccountID = NULL ; 

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'


	-------------------------------------------------------------
	-- Inserting records in temp assess filter table.
	-------------------------------------------------------------

	select @vStep = 110
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Inserting records in temp assess filter table ' + convert(varchar(26),getdate(),109);

	if @vfil_uda_assess_id is not null
		-- a specific assessment has been specified so just put the one into the table
		begin
			insert INTO #PRP_Assess_Filter
			SELECT a.std_assess_id,
			a.client_id,
			a.assess_id,
			a.assess_date
			from dbo.as_assessment a WITH (NOLOCK)
			INNER JOIN #clients c on 
					a.client_id = c.client_id
				and a.assess_id = @vfil_uda_assess_id
			left outer join #PRP_Multi_Value_Filters mfl
				on mfl.filter_name = 'uda_assessment_status'
			where
				1 = (case when mfl.filter_value is null then 1
						  when 	mfl.filter_value = '1' and (a.status = 'In Progress' or a.status = 'Errors' ) then 1
						  when mfl.filter_value = '2' and a.status = 'Complete' then 1
						  when mfl.filter_value = '3' and a.status = 'Incomplete' then 1
						 else 0
					 end
					)

			set @vRowCount = @@rowcount
			set @vStep = 111
		end
	else

	if @vis_from_print_chart is null and (@vreport_date_filter is not null or @vfil_start_end_date_range_d1 is not null )
		-- when date filters are used, there are two cases - one for a specific client_id, and the other for all clients
		begin
			if @vSingleClient=1
				begin
					-- date filter and single client: all applicable assessments are returned
					
					insert INTO #PRP_Assess_Filter
					SELECT distinct
					assess.std_assess_id,
					assess.client_id,
					assess.assess_id,
					assess.assess_date
					from
					dbo.as_assessment assess WITH (NOLOCK)
					INNER JOIN #clients cl on assess.client_id=cl.client_id

					left outer join #PRP_Multi_Value_Filters mfl
					on mfl.filter_name = 'uda_assessment_status'
				where
					
						assess.deleted='N' 
					
					and
						(
							(((@vincl_strikeout='0' OR @vincl_strikeout IS NULL) AND isnull(assess.strikeout_flag,'N')='N' )
							and (
								(mfl.filter_value = '1' and (assess.status = 'In Progress' or assess.status = 'Errors' ))
								or 
								( mfl.filter_value = '2' and assess.status = 'Complete')
								or 
								(mfl.filter_value = '3' and assess.status = 'Incomplete')	
								))
							

						OR 
							(
							@vincl_strikeout='1'
							and (mfl.filter_value = '1' and (assess.status = 'In Progress' or assess.status = 'Errors' )
								or 
								( mfl.filter_value = '2' and assess.status = 'Complete')
								or 
								(mfl.filter_value = '3' and assess.status = 'Incomplete')	
								or 
								(assess.strikeout_flag = 'Y')
								)
							)
														
						)
						 
					AND
						(@vstd_assess_id = -1 or @vstd_assess_id is NULL or assess.std_assess_id = @vstd_assess_id)
					and
						((@vreport_date_filter is not NULL and assess.revision_date >= @vreport_date_filter)
						or  
						(@vreport_date_filter is NULL ))
					and
						((@vfil_start_end_date_range_d1 is not NULL and assess.assess_date >= @vfil_start_end_date_range_d1 AND assess.assess_date< @vfil_start_end_date_range_d2)
						or  
						(@vfil_start_end_date_range_d1 is NULL ))

					set @vRowCount = @@rowcount
					set @vStep = 112
				end
			else
				begin
					-- date filter and all clients: only most recent applicible assessments
					-- date filter and single client: all applicible assessments
					-- this is also applicable if the report is from print chart
						--(date filter and single client and print chart)
					

					; with MostRecent
					as
					( SELECT 
							assess.std_assess_id,
							assess.client_id,
							assess.assess_date, 
							assess.assess_id,
							row_number() OVER ( partition by assess.std_assess_id, assess.client_id, assess.status, isnull(assess.strikeout_flag,'N') ORDER BY assess.std_assess_id, assess.client_id, assess.status,assess.assess_date desc ) rnum
							from
							dbo.as_assessment assess WITH (NOLOCK)
							INNER JOIN #clients cl on assess.client_id=cl.client_id

							left outer join #PRP_Multi_Value_Filters mfl
							on mfl.filter_name = 'uda_assessment_status'
						where
							 assess.deleted='N' 
							and
								(
									(((@vincl_strikeout='0' OR @vincl_strikeout IS NULL) AND isnull(assess.strikeout_flag,'N')='N' )
									and (
										(mfl.filter_value = '1' and (assess.status = 'In Progress' or assess.status = 'Errors' ))
										or 
										( mfl.filter_value = '2' and assess.status = 'Complete')
										or 
										(mfl.filter_value = '3' and assess.status = 'Incomplete')	
										))
							

								OR 
									(
									@vincl_strikeout='1'
									and (mfl.filter_value = '1' and (assess.status = 'In Progress' or assess.status = 'Errors' )
										or 
										( mfl.filter_value = '2' and assess.status = 'Complete')
										or 
										(mfl.filter_value = '3' and assess.status = 'Incomplete')	
										or 
										(assess.strikeout_flag = 'Y')
										)
									)
														
								)


							AND
							(@vstd_assess_id = -1 or @vstd_assess_id is NULL or assess.std_assess_id = @vstd_assess_id)
							and
							((@vreport_date_filter is not NULL and assess.revision_date >= @vreport_date_filter)
							or  
							(@vreport_date_filter is NULL ))
							and
							((@vfil_start_end_date_range_d1 is not NULL and assess.assess_date >= @vfil_start_end_date_range_d1 AND assess.assess_date< @vfil_start_end_date_range_d2)
							or  
							(@vfil_start_end_date_range_d1 is NULL ))
							

					)


					INSERT INTO #PRP_Assess_Filter

					select std_assess_id, client_id,assess_id, assess_date from MostRecent 
						where 
						1 = ( case when @client_id = '-1' and	rnum = 1 then 1
									when @client_id <> '-1' then 1
									else 0
                              end
							  )


					set @vRowCount = @@rowcount
					set @vStep = 113
				end
		end
	else	 -- when date filters are NOT used, only the latest assessment is returned
		begin
			insert INTO #PRP_Assess_Filter
			SELECT a.std_assess_id,
			a.client_id,
			a.assess_id,
			a.assess_date
			from
				(SELECT 
				assess.std_assess_id,
				assess.client_id,
				max(assess.assess_date) as max_assess_date
				from
				dbo.as_assessment assess WITH (NOLOCK)
				INNER JOIN #clients cl on assess.client_id=cl.client_id

				left outer join #PRP_Multi_Value_Filters mfl
					on mfl.filter_name = 'uda_assessment_status'
				where
					assess.deleted='N' 
				and
						(
							(((@vincl_strikeout='0' OR @vincl_strikeout IS NULL) AND isnull(assess.strikeout_flag,'N')='N') 
							and (
								(mfl.filter_value = '1' and (assess.status = 'In Progress' or assess.status = 'Errors' ))
								or 
								( mfl.filter_value = '2' and assess.status = 'Complete')
								or 
								(mfl.filter_value = '3' and assess.status = 'Incomplete')	
								)
							)

						OR 
							(
							@vincl_strikeout='1'
							or (mfl.filter_value = '1' and (assess.status = 'In Progress' or assess.status = 'Errors' ))
								or 
								( mfl.filter_value = '2' and assess.status = 'Complete')
								or 
								(mfl.filter_value = '3' and assess.status = 'Incomplete')	
							)
														
						)

				AND
				(@vstd_assess_id = -1 or @vstd_assess_id is NULL or assess.std_assess_id = @vstd_assess_id)
				GROUP BY 
				assess.std_assess_id,
				assess.client_id
				) b

			INNER JOIN dbo.as_assessment a WITH (NOLOCK)
			 on a.client_id=b.client_id and a.std_assess_id=b.std_assess_id AND a.assess_date=b.max_assess_date

			set @vRowCount = @@rowcount
			set @vStep = 114
		end


	CREATE CLUSTERED INDEX _tmp_idx_prp_Assess_Filter on #PRP_Assess_Filter(assess_id, std_assess_id);

	if @debug_me = 'Y' select '#PRP_Assess_Filter' AS [#PRP_Assess_Filter], *, convert(varchar(20), @vStep) as steps from #PRP_Assess_Filter

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(@vRowCount)))+ ' rows in '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	insert into #prp_ShowHideDisable_rules
select distinct q.std_question_id, q.pick_list_id, q.question_key,
q.section_code,  stdqg.group_text, 
q.std_question_no, q.std_subquestion_no, q.std_subquestion_ab
, q.title, acr.consistency_rule_id
, q.control_type,
stdqg.group_title,
acr.enabled_flag,
acr.question_key_info,
 q.question_text,
acr.question_key_sbj,  
acr.item_id
, case when acr.item_id = 4110 then 'Show/hide'
			when acr.item_id = 4102 then 'Disable'
			else 'N/A'
			end as rules_description
, acrr.range
, case when CHARINDEX('thru', acrr.range,1) = 0 then acrr.range
		else SUBSTRING (acrr.range, 1, CHARINDEX('thru', acrr.range,1)-1 )
		end
, case when CHARINDEX('thru', acrr.range,1) = 0 then null
		else SUBSTRING (acrr.range,  CHARINDEX('thru', acrr.range,1) + 4, 10)
		end
, pl.item_description
, acr.question_key_obj
 from dbo.mirror_as_std_question q WITH (NOLOCK)
 inner join #PRP_Assess_Filter std
 on q.std_assess_id = std.std_assess_id
 LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON q.std_assess_id=stds.std_assess_id
 and q.section_code = stds.section_code
 left outer join dbo.as_std_question_group stdqg WITH (NOLOCK)
 on q.std_assess_id = stdqg.std_assess_id
 and q.section_code=stdqg.section_code and q.std_question_no=stdqg.std_question_no
				AND stds.section_code=stdqg.section_code
left outer join dbo.as_consistency_rule acr WITH (NOLOCK)
on q.std_assess_id = acr.std_assess_id
and q.question_key = acr.question_key_sbj
left outer join dbo.as_consistency_rule_range acrr WITH (NOLOCK)
on acr.consistency_rule_id = acrr.consistency_rule_id
left outer join dbo.mirror_as_std_pick_list_item pl WITH (NOLOCK)
		on  q.pick_list_id = pl.pick_list_id 
and pl.item_value = acrr.range
where  acrr.range_type = 0
and acr.item_id in (4110, 4102)
and acr.deleted = 'N'
order by  q.std_question_no

if @debug_me='Y' select '#prp_ShowHideDisable_rules', * from #prp_ShowHideDisable_rules


	-------------------------------------------------------------
	-- Inserting records in temp table.
	-------------------------------------------------------------

	set @vStep = 120
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'Step ' +  convert(varchar, @vStep)  + ' loading results table '  + convert(varchar(26),getdate(),109)

	set @vRowCount = 0

	if @vis_blank=1
		begin
		---------------------------------------------------------------------------------------------
		--	BLANK REPORT
		---------------------------------------------------------------------------------------------
			INSERT INTO #PRP_Results

			SELECT distinct 
			  @vFacID as fac_id
			, stda.std_assess_id
			, 0 as client_id
			, 0 as assess_id
			, NULL assess_date
			, '' as assessment_type
			, stda.description as UDA
			, stds.title as section_title
			, stds.sequence as section_sequence
			, stdqg.std_question_no
			, stdqg.group_title
			, stdqg.group_text
			, stdqg.layout_style
			, stds.section_code
			, stdq.question_key
			, stdq.sequence
			, stdq.std_question_no
			, stdq.std_subquestion_no
			, stdq.std_subquestion_AB
			, stdq.title
			, stdq.question_text
			, case when stdq.control_type in ( 'diag', 'cs') then 'txt' else stdq.control_type end as control_type
			, stdq.length
			, stdq.required
			, stdq.pick_list_id
			, stdpl.description as picklist_name
			, CASE WHEN stdqg.layout_style = 'C2' OR stdq.control_type = 'pop' OR stdq.control_type = 'radh' or stdq.control_type = 'mcsh'
												  OR (stdqg.layout_style = 'C1' AND (stdq.control_type = 'cmb' OR stdq.control_type = 'rad' /*or stdq.control_type = 'mcs'*/ ))
				   THEN pick_list_values ELSE stdpli.item_value END AS pick_list_value
			, CASE WHEN stdqg.layout_style = 'C2' OR stdq.control_type = 'pop' OR stdq.control_type = 'radh' or stdq.control_type = 'mcsh'
												  OR (stdqg.layout_style = 'C1' AND (stdq.control_type = 'cmb' OR stdq.control_type = 'rad' /* or stdq.control_type = 'mcs' */))
				   THEN pick_list_descriptions ELSE stdpli.item_description END AS pick_list_description
			, CASE WHEN stdqg.layout_style = 'C2' AND stdq.control_type = 'ams' 
				   THEN pick_list_sequences ELSE cast(stdpli.sequence as varchar(10)) END AS sequence
			, null as effective_date
			--, stdpli.effective_date
			, stdpli.ineffective_date
			, '' asassess_type_code
			, '' as status
			, '' as resp_item_value
			, case when stdq.control_type = 'pain' then @vConfig_facepain_use_cartoon + @vSeparator
					  when stdq.control_type = 'ams' and stdqg.layout_style <> 'C2' then isnull(cpqk.subkey,'')
					  when stdq.control_type = 'ams' and stdqg.layout_style = 'C2' then isnull(questions_subkeys,'')
					  else ''
			  end as response
			, null as score
			, '' as score_category
			, '' as strikeout_flag
			, '' as strikeout_by
			, Null as strikeout_date
			, '' as strikeout_reason
			, stda.include_signature_section_flag
			, '' as signed_by
			, Null as signed_date
			,  cust_hdr
			,  cust_sub_hdr
			, custom_header_long.cust_hdr_long
			, cust_sub_hdr_long

			, NULL as rnum
			, NULL as unique_question
			, NULL as was_merge
			, case when cr.question_key_obj is not NULL and cr.item_id = 4110 and cr.enabled_flag = 'Y' then '1' else '0' END as print_s
			, case when stdq.control_type = 'ams' and stdqg.layout_style <> 'C2' then isnull(cpqk.subkey,'')
					  when stdq.control_type = 'ams' and stdqg.layout_style = 'C2' then isnull(questions_subkeys,'')
			  end as ams_key			
			, NULL as file_metadata_id
			, stdq.visual
			, NULL as ordr

			FROM
					dbo.as_std_assessment stda WITH (NOLOCK)
			LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id and stda.std_assess_id=@vstd_assess_id
			INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON 
								stda.std_assess_id = stdq.std_assess_id 
							AND stds.section_code = stdq.section_code
			LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON 
								stdq.std_assess_id=stdqg.std_assess_id 
							AND stdq.section_code=stdqg.section_code 
							AND stdq.std_question_no=stdqg.std_question_no
							AND stds.section_code=stdqg.section_code
			LEFT JOIN dbo.as_std_pick_list stdpl WITH (NOLOCK) ON 
								stdq.pick_list_id = stdpl.pick_list_id
								AND stdq.control_type <> 'chk'
			LEFT JOIN dbo.mirror_as_std_pick_list_item stdpli WITH (NOLOCK) ON 
								stdq.pick_list_id = stdpli.pick_list_id 
							AND stdpli.item_description <> 'Blank (skip pattern)'
							AND (stdpli.ineffective_date is null or stdpli.ineffective_date >= @vReportDate)
--							AND (stdqg.layout_style <> 'C2' AND stdq.control_type <> 'pop' AND stdq.control_type <> 'radh')
							AND NOT (stdqg.layout_style = 'C2' OR stdq.control_type = 'pop' OR stdq.control_type = 'radh' or stdq.control_type = 'mcsh'
								 OR (stdqg.layout_style = 'C1' AND (stdq.control_type = 'cmb' OR stdq.control_type = 'rad' /*or stdq.control_type = 'mcs'*/ )))
			-- hide/show  or parent/child question
			left OUTER JOIN dbo.as_consistency_rule cr WITH (NOLOCK)
						ON stdq.std_assess_id = cr.std_assess_id
						and stdq.question_key = cr.question_key_obj
						and cr.item_id in ( 4102, 4110)
						and cr.deleted = 'N'
			LEFT JOIN #care_profile_question cpqk
						ON stdq.control_type in ('ams' ) 
						AND cpqk.question_text = stdpli.item_description

			--OUTER APPLY (	SELECT subkeys
			--				FROM	(	SELECT '%'+item_value + cpqsk.subkey
			--							FROM	dbo.mirror_as_std_pick_list_item stdpli WITH (NOLOCK)
			--							JOIN #care_profile_question cpqsk
			--							ON cpqsk.question_text = stdpli.item_description
			--							WHERE stdpl.pick_list_id = stdpli.pick_list_id 
			--							AND stdqg.layout_style = 'C2' 
			--								AND stdq.control_type = 'ams'
			--							ORDER BY stdpli.sequence
			--							FOR XML PATH ('')
			--						) AS questions (subkeys)
			--			) qsk (questions_subkeys)
				OUTER APPLY (	SELECT	STUFF(subkeys, 1, LEN(@vSeparator), '') 
								FROM (SELECT @vSeparator+isnull(cpqsk.subkey,'')+ 
										case 
											when cpqsk.subkey in ('#oxygen') then '%l_per_min%#%#other:%'  
											when cpqsk.subkey  in ('#ao') then '%#auxother:%' 
											when cpqsk.subkey  in ('#do') then '%#devother:%' 
											when cpqsk.subkey  in ('#ro') then '%#riskother:%' 
											when cpqsk.subkey  in ('#mo') then '%#muscother:%' 
											when cpqsk.subkey  in ('#so') then '%#genother:%' 
											when cpqsk.subkey  in ('#bp') then '%#bdpayment:%' 
											when cpqsk.subkey  in ('#co') then '%#specother:%' 
											else ''
										end 	
										FROM	dbo.mirror_as_std_pick_list_item stdpli WITH (NOLOCK)
										INNER JOIN #care_profile_question cpqsk
										ON cpqsk.question_text = stdpli.item_description
										WHERE stdq.pick_list_id = stdpli.pick_list_id 
											AND stdqg.layout_style = 'C2' 
											AND stdq.control_type = 'ams'
											AND (stdpli.ineffective_date is null or stdpli.ineffective_date >= @vReportDate)
										ORDER BY stdpli.sequence
										FOR XML PATH ('')
									) AS questions (subkeys)
							) qsk (questions_subkeys)	
			OUTER APPLY (	SELECT	 STUFF([values], 1, LEN(@vSeparator), '')
										--replace(
										--replace(
										--replace(STUFF([values], 1, LEN(@vSeparator), ''), '&amp;', '&')
										--, '&lt;','<')
										--, '&gt;','>')

										--STUFF([values], 1, LEN(@vSeparator), '')

							FROM	(	SELECT @vSeparator + stdpli.item_value
										FROM	dbo.mirror_as_std_pick_list_item stdpli WITH (NOLOCK)
										WHERE	stdq.pick_list_id = stdpli.pick_list_id 
											AND stdpli.item_description <> 'Blank (skip pattern)'
											AND (stdpli.ineffective_date is null or stdpli.ineffective_date >= @vReportDate)
--											AND (stdqg.layout_style = 'C2' OR stdq.control_type = 'pop' OR stdq.control_type = 'radh')
											AND (stdqg.layout_style = 'C2' OR stdq.control_type = 'pop' OR stdq.control_type = 'radh' or stdq.control_type = 'mcsh'
											 OR (stdqg.layout_style = 'C1' AND (stdq.control_type = 'cmb' OR stdq.control_type = 'rad' /*or stdq.control_type = 'mcs'*/ )))
										ORDER BY stdpli.sequence
										FOR XML PATH ('')
									) AS picklist ([values])
						) plv (pick_list_values)
						
			OUTER APPLY (	SELECT		STUFF(descriptions, 1, LEN(@vSeparator), '')
										--replace(
										--replace(
										--replace(STUFF(descriptions, 1, LEN(@vSeparator), ''), '&amp;', '&')
										--	, '&lt;','<')
										--	, '&gt;','>')
							FROM	(	SELECT @vSeparator + stdpli.item_description
										FROM	dbo.mirror_as_std_pick_list_item stdpli WITH (NOLOCK)
										WHERE	stdq.pick_list_id = stdpli.pick_list_id 
											AND stdpli.item_description <> 'Blank (skip pattern)'
											AND (stdpli.ineffective_date is null or stdpli.ineffective_date >= @vReportDate)
--											AND (stdqg.layout_style = 'C2' OR stdq.control_type = 'pop' OR stdq.control_type = 'radh')
											AND (stdqg.layout_style = 'C2' OR stdq.control_type = 'pop' OR stdq.control_type = 'radh' or stdq.control_type = 'mcsh'
											 OR (stdqg.layout_style = 'C1' AND (stdq.control_type = 'cmb' OR stdq.control_type = 'rad' /*or stdq.control_type = 'mcs'*/ )))
										ORDER BY stdpli.sequence
										FOR XML PATH ('')
									) AS picklist (descriptions)
						) pld (pick_list_descriptions)
			OUTER APPLY (	SELECT	 STUFF(seq, 1, LEN(@vSeparator), '')
							FROM	(	SELECT @vSeparator + cast(stdpli.sequence as varchar(10))
										FROM	dbo.mirror_as_std_pick_list_item stdpli WITH (NOLOCK)
										WHERE	stdq.pick_list_id = stdpli.pick_list_id 
											AND stdpli.item_description <> 'Blank (skip pattern)'
											AND (stdpli.ineffective_date is null or stdpli.ineffective_date >= @vReportDate)
											AND stdqg.layout_style = 'C2' 
											AND stdq.control_type = 'ams'
										ORDER BY stdpli.sequence
										FOR XML PATH ('')
									) AS picklist (seq)
						) pls (pick_list_sequences)
				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25

											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr 
							) custom_header

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr
							) custom_sub_header

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score:</b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category:</b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score:</b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category:</b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long

			WHERE 
				1 = CASE WHEN stdq.control_type <> 'inst' THEN 1 ELSE CASE WHEN stdq.electronic = 'Y' THEN 1 ELSE 0 END END
				--and 1 = (case when  cr.item_id = 4102 and cr.enabled_flag = 'N' then 0 else 1 end )

				

				AND	stdq.control_type <> 'bdy'
				AND	stdq.control_type <> 'gbdy'
				AND	stdq.control_type <> 'ebdy'
				AND	stdq.control_type <> 'adir'
				AND	stdq.control_type <> 'cnt'
				AND	stdq.control_type <> 'hck'
				AND	stdq.control_type <> 'payer'
				AND stdq.control_type <> 'ident'
				AND stdq.control_type <> 'cp'
				AND stdq.control_type <> 'payer'

			set @vRowCount = @vRowCount + @@rowcount


			if @debug_me='Y' select 'first load' as fl, * from #PRP_Results

		-- add in payer Controls
			INSERT INTO #PRP_Results
			SELECT 
			@vFacID as fac_id,
			stda.std_assess_id,
			0 as client_id,
			0 as assess_id,
			NULL assess_date,
			'' as assessment_type, 
			stda.description as UDA,
			stds.title as section_title,
			stds.sequence as section_sequence,
			stdqg.std_question_no,
			stdqg.group_title,
			stdqg.group_text,
			stdqg.layout_style,
			stds.section_code,
			stdq.question_key,
			stdq.sequence,
			stdq.std_question_no,
			stdq.std_subquestion_no,
			stdq.std_subquestion_AB,
			stdq.title,
			stdq.question_text,
			stdq.control_type,
			stdq.length,
			stdq.required,
			stdq.pick_list_id,
			null as picklist_name,			-- null for payer controls
			null as item_value,				-- null for payer controls
			null as item_description,		-- null for payer controls
			null as sequence,				-- null for payer controls
			null as effective_date,			-- null for payer controls
			null as ineffective_date,		-- null for payer controls
			'' asassess_type_code,
			'' as status,
			'' as resp_item_value,
			resp.response as response,
			null as score,
			'' as score_category,
			'' as strikeout_flag,
			'' as strikeout_by,
			Null as strikeout_date,
			'' as strikeout_reason,
			stda.include_signature_section_flag,
			'' as signed_by,
			Null as signed_date 
			, cust_hdr
			, cust_sub_hdr
			, cust_hdr_long
			, cust_sub_hdr_long
			, NULL as rnum
			, NULL as unique_question
			, NULL as was_merge
			, case when cr.question_key_obj is not NULL and cr.item_id = 4110 and cr.enabled_flag = 'Y' then '1' else '0' END as print_s
			, NULL as ams_key
			, NULL as file_metadata_id
			, stdq.visual
			, NULL as ordr
			FROM
				dbo.as_std_assessment stda WITH (NOLOCK)
				LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id and stda.std_assess_id=@vstd_assess_id
				INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON stda.std_assess_id=stdq.std_assess_id AND stds.section_code=stdq.section_code
				LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON stdq.std_assess_id=stdqg.std_assess_id and stdq.section_code=stdqg.section_code and stdq.std_question_no=stdqg.std_question_no
					AND stds.section_code=stdqg.section_code
				-- hide/show  or parent/child question
				left OUTER JOIN dbo.as_consistency_rule cr WITH (NOLOCK)
						ON stdq.std_assess_id = cr.std_assess_id
						and stdq.question_key = cr.question_key_obj
						and cr.item_id in ( 4102, 4110)
						and cr.deleted = 'N'

				OUTER APPLY		(SELECT	   @vSeparator
										 + @vSeparator 
										 + @vSeparator 
										 + @vSeparator 
										 + @vSeparator 
										 + @vSeparator 
										 + @vSeparator		-- 8 columns in the payer control
								 )resp (response)

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr 
							) custom_header
				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr
							) custom_sub_header

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score: </b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category: </b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score: </b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category: </b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long
			WHERE 
					stdq.control_type = 'payer'
					--and 1 = (case when  cr.item_id = 4102 and cr.enabled_flag = 'N' then 0 else 1 end )

			set @vRowCount = @vRowCount + @@rowcount


		-- add in Body Parts Controls (originally for layout_style = 'V', 'PV', or 'C1', this is now for all bdy and gbdy)
			insert INTO #PRP_Results
			SELECT 
			@vFacID as fac_id,
			stda.std_assess_id,
			0 as client_id,
			0 as assess_id,
			NULL assess_date,
			'' as assessment_type, 
			stda.description as UDA,
			stds.title as section_title,
			stds.sequence as section_sequence,
			stdqg.std_question_no,
			stdqg.group_title,
			stdqg.group_text,
			stdqg.layout_style,
			stds.section_code,
			stdq.question_key,
			stdq.sequence,
			stdq.std_question_no,
			stdq.std_subquestion_no,
			stdq.std_subquestion_AB,
			stdq.title,
			stdq.question_text,
			stdq.control_type,
			stdq.length,
			stdq.required,
			stdq.pick_list_id,
			null as picklist_name,			-- null for bdy and gbdy controls
			null as item_value,				-- null for bdy and gbdy controls
			null as item_description,		-- null for bdy and gbdy controls
			null as sequence,				-- null for bdy and gbdy controls
			null as effective_date,			-- null for bdy and gbdy controls
			null as ineffective_date,		-- null for bdy and gbdy controls
			'' asassess_type_code,
			'' as status,
			'' as resp_item_value,
			resp.response as response,
			null as score,
			'' as score_category,
			'' as strikeout_flag,
			'' as strikeout_by,
			Null as strikeout_date,
			'' as strikeout_reason,
			stda.include_signature_section_flag,
			'' as signed_by,
			Null as signed_date 
			, cust_hdr
			, cust_sub_hdr
			, cust_hdr_long
			, cust_sub_hdr_long
			, resp.num as rnum
			, NULL as unique_question
			, NULL as was_merge
			, case when cr.question_key_obj is not NULL and cr.item_id = 4110 and cr.enabled_flag = 'Y' then '1' else '0' END as print_s
			, NULL as ams_key
			, NULL as file_metadata_id
			, stdq.visual
			, NULL as ordr
			FROM
				dbo.as_std_assessment stda WITH (NOLOCK)
				LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id and stda.std_assess_id=@vstd_assess_id
				INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON stda.std_assess_id=stdq.std_assess_id AND stds.section_code=stdq.section_code
				LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON stdq.std_assess_id=stdqg.std_assess_id and stdq.section_code=stdqg.section_code and stdq.std_question_no=stdqg.std_question_no
					AND stds.section_code=stdqg.section_code
				-- hide/show  or parent/child question
				left OUTER JOIN dbo.as_consistency_rule cr WITH (NOLOCK)
						ON stdq.std_assess_id = cr.std_assess_id
						and stdq.question_key = cr.question_key_obj
						and cr.item_id in ( 4102, 4110)
						and cr.deleted = 'N'

				OUTER APPLY		(SELECT CASE stdq.control_type
											 WHEN 'bdy' THEN   @vSeparator
															 + @vSeparator 
															 + @vSeparator 
															 + @vSeparator 
															 + @vSeparator 
															 + @vSeparator 
															 + @vSeparator		-- 8 columns in the grid for bdy
											 WHEN 'gbdy' THEN  @vSeparator		-- 2 columns in the grid for gbdy
											 WHEN 'ebdy' THEN  @vSeparator		-- 2 columns in the grid for gbdy
										END AS response
										, num
								 FROM pcc_num_sequence WHERE num <= stdq.length
								 )resp
				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr 
							) custom_header
				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr
							) custom_sub_header

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score: </b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category: </b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score: </b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category: </b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long

			WHERE 
					(	stdq.control_type = 'bdy'
					OR	stdq.control_type = 'gbdy'
					OR	stdq.control_type = 'ebdy'
					)
				--and 1 = (case when  cr.item_id = 4102 and cr.enabled_flag = 'N' then 0 else 1 end )

--		The next line is commented out because we now want to return multiple rows for these controls in C2's also
--		(in addition to the marker control that will be returned in the single row
--				AND stdqg.layout_style <> 'C2'	

			set @vRowCount = @vRowCount + @@rowcount

		-- add in Body Parts Controls (layout_style = 'C2')
			INSERT INTO #PRP_Results
			SELECT 
			@vFacID as fac_id,
			stda.std_assess_id,
			0 as client_id,
			0 as assess_id,
			NULL assess_date,
			'' as assessment_type, 
			stda.description as UDA,
			stds.title as section_title,
			stds.sequence as section_sequence,
			stdqg.std_question_no,
			stdqg.group_title,
			stdqg.group_text,
			stdqg.layout_style,
			stds.section_code,
			stdq.question_key,
			stdq.sequence,
			stdq.std_question_no,
			stdq.std_subquestion_no,
			stdq.std_subquestion_AB,
			stdq.title,
			stdq.question_text,
			stdq.control_type,
			stdq.length,
			stdq.required,
			stdq.pick_list_id,
			null as picklist_name,			-- null for bdy and gbdy controls
			null as item_value,				-- null for bdy and gbdy controls
			null as item_description,		-- null for bdy and gbdy controls
			null as sequence,				-- null for bdy and gbdy controls
			null as effective_date,			-- null for bdy and gbdy controls
			null as ineffective_date,		-- null for bdy and gbdy controls
			'' asassess_type_code,
			'' as status,
			'' as resp_item_value,
			allbdy.resp_list as response,
			null as score,
			'' as score_category,
			'' as strikeout_flag,
			'' as strikeout_by,
			Null as strikeout_date,
			'' as strikeout_reason,
			stda.include_signature_section_flag,
			'' as signed_by,
			Null as signed_date 
			, cust_hdr
			, cust_sub_hdr
			, cust_hdr_long
			, cust_sub_hdr_long
			, NULL as rnum
			, NULL as unique_question
			, NULL as was_merge
			, case when cr.question_key_obj is not NULL and cr.item_id = 4110 and cr.enabled_flag = 'Y' then '1' else '0' END as print_s
			, NULL as ams_key
			, NULL as file_metadata_id
			, stdq.visual
			, NULL as ordr
			FROM
				dbo.as_std_assessment stda WITH (NOLOCK)
				LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id and stda.std_assess_id=@vstd_assess_id
				INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON stda.std_assess_id=stdq.std_assess_id AND stds.section_code=stdq.section_code
				LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON stdq.std_assess_id=stdqg.std_assess_id and stdq.section_code=stdqg.section_code and stdq.std_question_no=stdqg.std_question_no
					AND stds.section_code=stdqg.section_code
				-- hide/show  or parent/child question
				left OUTER JOIN dbo.as_consistency_rule cr WITH (NOLOCK)
						ON stdq.std_assess_id = cr.std_assess_id
						and stdq.question_key = cr.question_key_obj
						and cr.deleted = 'N'
						and cr.item_id in ( 4102, 4110)

				OUTER APPLY	
					(SELECT '' as resp_list) allbdy

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr 
							) custom_header
				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr
							) custom_sub_header
				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score: </b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category: </b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score: </b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category: </b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long
-----------------------------------------------------------------------------------------------------------------
--			The following code has been commented out in favour of returning empty string in this instance
--			but the original code has been retained because it is expected to be used at some future time when
--			the real bdy and gbdy controls (as opposed to these marker controls) are converted to returning one
--			row per control.
-----------------------------------------------------------------------------------------------------------------
--						(SELECT stuff(isnull(response_list,''),1, len(@vSeparator2),'') as resp_list
--						 FROM
--							(
--								SELECT	@vSeparator2 +
--										CASE stdq.control_type
--											 WHEN 'bdy' THEN   @vSeparator
--															 + @vSeparator 
--															 + @vSeparator 
--															 + @vSeparator 
--															 + @vSeparator 
--															 + @vSeparator 
--															 + @vSeparator		-- 8 columns in the grid for bdy
--											 WHEN 'gbdy' THEN  @vSeparator		-- 2 columns in the grid for gbdy
--									  END AS response
--									 FROM pcc_num_sequence WHERE num <= stdq.length
--								FOR XML PATH ('')
--							) yyy (response_list)
--						) allbdy
			WHERE 
					(stdq.control_type = 'bdy'
				OR	stdq.control_type = 'gbdy'
				OR	stdq.control_type = 'ebdy')
				AND stdqg.layout_style = 'C2'
				--and 1 = (case when  cr.item_id = 4102 and cr.enabled_flag = 'N' then 0 else 1 end )

			set @vRowCount = @vRowCount + @@rowcount


		-- add in Advanced Directives
			insert INTO #PRP_Results
			SELECT 
			@vFacID as fac_id,
			stda.std_assess_id,
			0 as client_id,
			0 as assess_id,
			NULL assess_date, 
			'' as assessment_type, 
			stda.description as UDA,
			stds.title as section_title,
			stds.sequence as section_sequence,
			stdqg.std_question_no,
			stdqg.group_title,
			stdqg.group_text,
			stdqg.layout_style,
			stds.section_code,
			stdq.question_key,
			stdq.sequence,
			stdq.std_question_no,
			stdq.std_subquestion_no,
			stdq.std_subquestion_AB,
			stdq.title,
			stdq.question_text,
			stdq.control_type,
			stdq.length,
			stdq.required,
			stdq.pick_list_id,
			null as picklist_name,			-- null for adir control
			null as item_value,				-- null for adir control
			null as item_description,		-- null for adir control
			null as sequence,				-- null for adir control
			null as effective_date,			-- null for adir control
			null as ineffective_date,		-- null for adir control
			'' asassess_type_code,
			'' as status,
			'' as resp_item_value,
			resp.response as response,
			null as score,
			'' as score_category,
			'' as strikeout_flag,
			'' as strikeout_by,
			Null as strikeout_date,
			'' as strikeout_reason,
			stda.include_signature_section_flag,
			'' as signed_by,
			Null as signed_date
			, cust_hdr
			, cust_sub_hdr
			, cust_hdr_long
			, cust_sub_hdr_long
			, NULL as rnum
			, NULL as unique_question
			, NULL as was_merge
			, case when cr.question_key_obj is not NULL and cr.item_id = 4110 and cr.enabled_flag = 'Y' then '1' else '0' END as print_s
			, NULL as ams_key
			, NULL as file_metadata_id
			, stdq.visual
			, NULL as ordr
			FROM
				dbo.as_std_assessment stda WITH (NOLOCK)
				LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id and stda.std_assess_id=@vstd_assess_id
				INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON stda.std_assess_id=stdq.std_assess_id AND stds.section_code=stdq.section_code
				LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON stdq.std_assess_id=stdqg.std_assess_id and stdq.section_code=stdqg.section_code and stdq.std_question_no=stdqg.std_question_no
					AND stds.section_code=stdqg.section_code
				-- hide/show  or parent/child question
				left OUTER JOIN dbo.as_consistency_rule cr WITH (NOLOCK)
						ON stdq.std_assess_id = cr.std_assess_id
						and stdq.question_key = cr.question_key_obj
						and cr.deleted = 'N'
						and cr.item_id in ( 4102, 4110)

				OUTER APPLY		(SELECT stuff(isnull(response_str,''),1, len(@vSeparator),'') as response     
								  FROM	(
										 SELECT  @vSeparator + ltrim(rtrim(description + @vSeparator + '0' ))
										 FROM wesreference.dbo.pho_std_advanced_directive adir WITH (NOLOCK)
											  FOR XML PATH ('')
										) ans (response_str)
								 )resp
				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr 
							) custom_header
				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr
							) custom_sub_header

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score: </b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category: </b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score: </b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category: </b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long

			WHERE 
					stdq.control_type = 'adir'
				--and 1 = (case when  cr.item_id = 4102 and cr.enabled_flag = 'N' then 0 else 1 end )

			set @vRowCount = @vRowCount + @@rowcount

	-- Add in Resident Contacts control
			insert INTO #PRP_Results
			SELECT 
			@vFacID as fac_id,
			stda.std_assess_id,
			0 as client_id,
			0 as assess_id,
			NULL assess_date, 
			'' as assessment_type, 
			stda.description as UDA,
			stds.title as section_title,
			stds.sequence as section_sequence,
			stdqg.std_question_no,
			stdqg.group_title,
			stdqg.group_text,
			stdqg.layout_style,
			stds.section_code,
			stdq.question_key,
			stdq.sequence,
			stdq.std_question_no,
			stdq.std_subquestion_no,
			stdq.std_subquestion_AB,
			stdq.title,
			stdq.question_text,
			stdq.control_type,
			stdq.length,
			stdq.required,
			stdq.pick_list_id,
			null as picklist_name,			-- null for cnt control
			null as item_value,				-- null for cnt control
			null as item_description,		-- null for cnt control
			null as sequence,				-- null for cnt control
			null as effective_date,			-- null for cnt control
			null as ineffective_date,		-- null for cnt control
			'' asassess_type_code,
			'' as status,
			'' as resp_item_value,
			resp.response as response,
			null as score,
			'' as score_category,
			'' as strikeout_flag,
			'' as strikeout_by,
			Null as strikeout_date,
			'' as strikeout_reason,
			stda.include_signature_section_flag,
			'' as signed_by,
			Null as signed_date
			, cust_hdr
			, cust_sub_hdr
			, cust_hdr_long
			, cust_sub_hdr_long
			, NULL as rnum
			, NULL as unique_question
			, NULL as was_merge
			, case when cr.question_key_obj is not NULL and cr.item_id = 4110 and cr.enabled_flag = 'Y' then '1' else '0' END as print_s
			, NULL as ams_key
			, NULL as file_metadata_id
			, stdq.visual
			, NULL as ordr
			FROM
			dbo.as_std_assessment stda WITH (NOLOCK)
			LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id and stda.std_assess_id=@vstd_assess_id
			INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON stda.std_assess_id=stdq.std_assess_id AND stds.section_code=stdq.section_code
			LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON stdq.std_assess_id=stdqg.std_assess_id and stdq.section_code=stdqg.section_code and stdq.std_question_no=stdqg.std_question_no
				AND stds.section_code=stdqg.section_code
				-- hide/show  or parent/child question
			left OUTER JOIN dbo.as_consistency_rule cr WITH (NOLOCK)
						ON stdq.std_assess_id = cr.std_assess_id
						and stdq.question_key = cr.question_key_obj
						and cr.item_id in ( 4102, 4110)
						and cr.deleted = 'N'

			OUTER APPLY		(SELECT @vSeparator + @vSeparator -- allow for missing name and phone numbers
									+ isnull(response_str,'') as response     
                              FROM	(
									 SELECT  @vSeparator + ltrim(rtrim(description + @vSeparator + '0' ))
									 FROM wesreference.dbo.common_code_standard_contact_type c_type WITH (NOLOCK)
                                          FOR XML PATH ('')
                                    ) ans (response_str)
                             )resp
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr 
							) custom_header
				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr
							) custom_sub_header

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score: </b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category: </b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score: </b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category: </b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long

			WHERE 
					stdq.control_type = 'cnt'
				--and 1 = (case when  cr.item_id = 4102 and cr.enabled_flag = 'N' then 0 else 1 end )

			set @vRowCount = @vRowCount + @@rowcount

	-- Add in hck controls
			insert INTO #PRP_Results
			SELECT 
			@vFacID as fac_id,
			stda.std_assess_id,
			0 as client_id,
			0 as assess_id,
			NULL assess_date, 
			'' as assessment_type, 
			stda.description as UDA,
			stds.title as section_title,
			stds.sequence as section_sequence,
			stdqg.std_question_no,
			stdqg.group_title,
			stdqg.group_text,
			stdqg.layout_style,
			stds.section_code,
			stdq.question_key,
			stdq.sequence,
			stdq.std_question_no,
			stdq.std_subquestion_no,
			stdq.std_subquestion_AB,
			stdq.title,
			stdq.question_text,
			stdq.control_type,
			stdq.length,
			stdq.required,
			stdq.pick_list_id,
			null as picklist_name,
			pick_list.[value] AS pick_list_value,
			null as item_description,
			null as sequence,
			null as effective_date,
			null as ineffective_date,
			'' asassess_type_code,
			'' as status,
			'' as resp_item_value,
			'' as response,
			null as score,
			'' as score_category,
			'' as strikeout_flag,
			'' as strikeout_by,
			Null as strikeout_date,
			'' as strikeout_reason,
			stda.include_signature_section_flag,
			'' as signed_by,
			Null as signed_date
			, cust_hdr
			, cust_sub_hdr
			, cust_hdr_long
			, cust_sub_hdr_long
			, NULL as rnum
			, NULL as unique_question
			, NULL as was_merge
			, case when cr.question_key_obj is not NULL and cr.item_id = 4110 and cr.enabled_flag = 'Y' then '1' else '0' END as print_s
			, NULL as ams_key
			, NULL as file_metadata_id
			, stdq.visual
			, NULL as ordr
			FROM
			dbo.as_std_assessment stda WITH (NOLOCK)
				LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id and stda.std_assess_id=@vstd_assess_id
				INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON stda.std_assess_id=stdq.std_assess_id AND stds.section_code=stdq.section_code
				LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON stdq.std_assess_id=stdqg.std_assess_id and stdq.section_code=stdqg.section_code and stdq.std_question_no=stdqg.std_question_no
					AND stds.section_code=stdqg.section_code
					-- hide/show  or parent/child question
				left OUTER JOIN dbo.as_consistency_rule cr WITH (NOLOCK)
						ON stdq.std_assess_id = cr.std_assess_id
						and stdq.question_key = cr.question_key_obj
						and cr.deleted = 'N'
						and cr.item_id in ( 4102, 4110)

				OUTER APPLY		(SELECT stuff(isnull(pick_list_value,''),1, len(@vSeparator),'') as [value]     
								  FROM	(
											SELECT @vSeparator + stdpli.item_value FROM dbo.as_std_pick_list stdpl WITH (NOLOCK)
											LEFT JOIN dbo.mirror_as_std_pick_list_item stdpli WITH (NOLOCK) ON 
														stdq.pick_list_id=stdpli.pick_list_id 
													AND stdpli.item_description<>'Blank (skip pattern)'
													AND (stdpli.ineffective_date is null or stdpli.ineffective_date >= @vReportDate)
											WHERE stdq.pick_list_id=stdpl.pick_list_id
													ORDER BY stdpli.sequence
											FOR XML PATH ('')
										) plv (pick_list_value)
								 ) pick_list
				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr 
							) custom_header
				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr
							) custom_sub_header

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score: </b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category: </b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score: </b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category: </b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long


			WHERE 
					stdq.control_type = 'hck'
					--and 1 = (case when  cr.item_id = 4102 and cr.enabled_flag = 'N' then 0 else 1 end )


			set @vRowCount = @vRowCount + @@rowcount



	-- Add in ident control
			INSERT INTO #PRP_Results
			SELECT 
				@vFacID as fac_id,
				stda.std_assess_id,
				0 as client_id,
				0 as assess_id,
				NULL assess_date, 
				'' as assessment_type, 
				stda.description as UDA,
				stds.title as section_title,
				stds.sequence as section_sequence,
				stdqg.std_question_no,
				stdqg.group_title,
				stdqg.group_text,
				stdqg.layout_style,
				stds.section_code,
				stdq.question_key,
				stdq.sequence,
				stdq.std_question_no,
				stdq.std_subquestion_no,
				stdq.std_subquestion_AB,
				stdq.title,
				stdq.question_text,
				stdq.control_type,
				stdq.length,
				stdq.required,
				stdq.pick_list_id,
				NULL as picklist_name,		-- null for ident control
				NULL AS item_value,			-- null for ident control
				NULL AS item_description,	-- null for ident control
				NULL AS sequence,			-- null for ident control
				NULL AS effective_date,		-- null for ident control
				NULL AS ineffective_date,	-- null for ident control
				'' asassess_type_code,
				'' as status,
				'' as resp_item_value,
				@vSeparator + ISNULL(type_id.format, '') as response,
			null as score,
			'' as score_category,
			'' as strikeout_flag,
			'' as strikeout_by,
			Null as strikeout_date,
			'' as strikeout_reason,
			stda.include_signature_section_flag,
			'' as signed_by,
			Null as signed_date
			, cust_hdr
			, cust_sub_hdr
			, cust_hdr_long
			, cust_sub_hdr_long
			, NULL as rnum
			, NULL as unique_question
			, NULL as was_merge
			, case when cr.question_key_obj is not NULL and cr.item_id = 4110 and cr.enabled_flag = 'Y' then '1' else '0' END as print_s
			, NULL as ams_key
			, NULL as file_metadata_id
			, stdq.visual
			, NULL as ordr
			FROM dbo.as_std_assessment stda WITH (NOLOCK)
			LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id and stda.std_assess_id=@vstd_assess_id
			INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON stda.std_assess_id=stdq.std_assess_id AND stds.section_code=stdq.section_code
			LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON stdq.std_assess_id=stdqg.std_assess_id and stdq.section_code=stdqg.section_code and stdq.std_question_no=stdqg.std_question_no
				AND stds.section_code=stdqg.section_code
				-- hide/show  or parent/child question
			left OUTER JOIN dbo.as_consistency_rule cr WITH (NOLOCK)
						ON stdq.std_assess_id = cr.std_assess_id
						and stdq.question_key = cr.question_key_obj
						and cr.deleted = 'N'
						and cr.item_id in ( 4102, 4110)

			LEFT JOIN dbo.id_type type_id WITH (NOLOCK) ON
								type_id.id_type_id = stdq.pick_list_id
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr 
							) custom_header
				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr
							) custom_sub_header
				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score: </b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category: </b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score: </b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category: </b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long


			WHERE 
					stdq.control_type = 'ident'
					--and 1 = (case when  cr.item_id = 4102 and cr.enabled_flag = 'N' then 0 else 1 end )

			set @vRowCount = @vRowCount + @@rowcount

			-- Add blank care plan control
		

			INSERT INTO #PRP_Results
			SELECT fac_id,
				std_assess_id,
				client_id,
				assess_id,
				assess_date, 
				assessment_type, 
				UDA,
				section_title,
				section_sequence,
				grp_std_question_no,
				group_title,
				group_text,
				layout_style,
				section_code,
				question_key,
				sequence,
				std_question_no,
				std_subquestion_no,
				std_subquestion_AB,
				CASE WHEN rnum = 1 /*or /*is_task = 'Y'*/  title = 'Other Tasks:' */ THEN isnull(
																
																	title
																	
																	
																	,'') ELSE '' end as title,
				question_text,
				control_type,
				[length],
				[required],
				pick_list_id,
				picklist_name,		-- null for ident control
				item_value,			-- null for ident control
				item_description,	-- null for ident control
				pick_list_sequence,			-- null for ident control
				effective_date,		-- null for ident control
				ineffective_date,	-- null for ident control
				assess_type_code,
				status,
				resp_item_value,
				response,
				--+isnull(trig_res.standard_description, 'Rolly')  
				score,
				score_category,
				strikeout_flag,
				strikeout_by,
				strikeout_date,
				strikeout_reason,
				include_signature_section_flag,
				signed_by,
				signed_date,
				cust_hdr,
				cust_sub_hdr,
				cust_hdr_long,
				cust_sub_hdr_long,
				rnum,
				unique_question,
				NULL,
				print_s,
				NULL, 
				NULL as file_metadata_id, 
				visual,
				ordr
			 from 
			 
			(SELECT TOP 100 PERCENT 
				@vFacID fac_id,
				stda.std_assess_id,
				'0' client_id,
				'0' assess_id,
				null assess_date, 
				'' as assessment_type, 
				stda.description as UDA,
				stds.title as section_title,
				stds.sequence as section_sequence,
				stdqg.std_question_no as grp_std_question_no,
				stdqg.group_title,
				stdqg.group_text,
				stdqg.layout_style,
				stds.section_code,
				stdq.question_key,
				stdq.sequence,
				stdq.std_question_no,
				stdq.std_subquestion_no,
				stdq.std_subquestion_AB,
				

				case WHEN stdi.is_task = 'Y' and isnull(stdq.question_text,'') <> '' 
						and (ncount.focus_text = isnull( @vTermFocus  + interv_parent.text1, @vTermFocus  + goal_parent.text1) 
							or COALESCE( @vTermFocus  + interv_parent.text1, @vTermFocus  + goal_parent.text1,'') = ''
							)then '<b>Other '+  @vTermTasks + '</b>'  
					WHEN ncount.focus_text = isnull(@vTermFocus  + interv_parent.text1, @vTermFocus + goal_parent.text1) THEN NULL  -- do not format this line
					--ELSE isnull('Focus: ' + interv_parent.text1, 'Focus: ' + goal_parent.text1) 

					ELSE isnull('<b>'+ @vTermFocus + '</b>' + case when substring(interv_parent.text1,1,1) = ' '  
								then STUFF(replace(replace(interv_parent.text1, char(10),''),char(13),''),1,1, '') 
								else ltrim(rtrim(replace(replace(interv_parent.text1, char(10),''),char(13),''))) end

								, '<b>' + @vTermFocus + '</b>' + case when substring(goal_parent.text1,1,1) = ' '  
									then STUFF(replace(replace(goal_parent.text1, char(10),''),char(13),''),1,1, '') 
									else ltrim(rtrim(replace(replace(goal_parent.text1, char(10),''),char(13),''))) end)
					END  as title /*question title*/,

				
				stdq.question_text,
				

				stdq.control_type,
				stdq.length,
				stdq.required,
				stdq.pick_list_id,
				NULL as picklist_name,		-- null for ident control
				coalesce(stdn.std_need_id,stdg.std_need_id,stdi.std_need_id,stdt.std_trigger_id)  AS item_value,
				 ''   AS item_description,	-- null for ident control
				NULL AS pick_list_sequence,			-- null for ident control
				NULL AS effective_date,		-- null for ident control
				NULL AS ineffective_date,	-- null for ident control
				NULL assess_type_code,
				NULL [status],
				'0'  as resp_item_value,

				 CASE WHEN stdt.trigger_type = 'N' THEN '<b>'+ @vTermFocus + '</b>' + stdn.text1
				 WHEN stdt.trigger_type = 'G' THEN '<b>' + @vTermGoal+'</b>'  + stdg.text1
				 WHEN stdt.trigger_type = 'I' THEN CASE WHEN stdi.is_task = 'Y' THEN '<b>'+ @vTermTask +' </b>' ELSE '<b>' + @vTermIntervention +' </b>' END + stdi.text1
				 ELSE ''
				 END   as response,
				
				null score,
				null as score_category,
				NULL  as strikeout_flag,
				NULL  as strikeout_by,
				null AS strikeout_date,
				NULL  as strikeout_reason,
				stda.include_signature_section_flag,
				null as signed_by,
				NULL  as signed_date
			,  cust_hdr
			,  cust_sub_hdr
			, cust_hdr_long
			, cust_sub_hdr_long
			, row_number()  OVER ( partition BY stda.std_assess_id, stdq.question_key 
								, COALESCE( ncount.focus_text, @vTermFocus + interv_parent.text1, @vTermFocus + goal_parent.text1)

						ORDER BY stda.std_assess_id, stdq.question_key, case WHEN stdi.is_task = 'Y' and isnull(stdq.question_text,'') <> '' 
							and (ncount.focus_text = isnull(@vTermFocus + interv_parent.text1, @vTermFocus + goal_parent.text1) 
								or COALESCE(@vTermFocus + interv_parent.text1, @vTermFocus + goal_parent.text1,'') = ''
								)then 'Other ' + @vTermTask 
					WHEN ncount.focus_text = isnull(@vTermFocus + interv_parent.text1, @vTermFocus + goal_parent.text1) THEN NULL 
					--ELSE isnull('Focus: ' + interv_parent.text1, 'Focus: ' + goal_parent.text1) 

					ELSE isnull('<b>'+@vTermFocus +'</b>' + case when substring(interv_parent.text1,1,1) = ' '  
									then STUFF(replace(replace(interv_parent.text1, char(10),''),char(13),''),1,1, '') 
									else ltrim(rtrim(replace(replace(interv_parent.text1, char(10),''),char(13),''))) end

								, '<b>' + @vTermFocus + '</b>' + case when substring(goal_parent.text1,1,1) = ' '  
									then STUFF(replace(replace(goal_parent.text1, char(10),''),char(13),''),1,1, '') 
									else ltrim(rtrim(replace(replace(goal_parent.text1, char(10),''),char(13),''))) end)end ) rnum
			, row_number()  OVER ( partition BY stda.std_assess_id, stdq.question_key 
								
						ORDER BY stda.std_assess_id, stdq.question_key, case WHEN stdi.is_task = 'Y' and isnull(stdq.question_text,'') <> '' 
							and (ncount.focus_text = isnull(@vTermFocus + interv_parent.text1, @vTermFocus + goal_parent.text1) 
								or COALESCE(@vTermFocus + interv_parent.text1, @vTermFocus + goal_parent.text1,'') = ''
								)then 'Other '+@vTermTask  
					WHEN ncount.focus_text = isnull(@vTermFocus + interv_parent.text1, @vTermFocus + goal_parent.text1) THEN NULL 

					ELSE isnull('<b>'+ @vTermFocus +'</b>' + case when substring(interv_parent.text1,1,1) = ' '  
									then STUFF(replace(replace(interv_parent.text1, char(10),''),char(13),''),1,1, '') 
									else ltrim(rtrim(replace(replace(interv_parent.text1, char(10),''),char(13),''))) end

								, '<b>'+@vTermFocus  +'</b>' + case when substring(goal_parent.text1,1,1) = ' '  
									then STUFF(replace(replace(goal_parent.text1, char(10),''),char(13),''),1,1, '') 
									else ltrim(rtrim(replace(replace(goal_parent.text1, char(10),''),char(13),''))) end)END ) unique_question
			,stdi.is_Task
			,  '0' print_s
			, stdq.visual
			, CASE WHEN stdt.trigger_type = 'G' THEN stdg.ordr
				 WHEN stdt.trigger_type = 'I' THEN stdi.ordr
				 ELSE NULL
				 END as ordr
			FROM  dbo.as_std_assessment stda WITH (NOLOCK) 
			 
			LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id --and  stda.std_assess_id =  @vstd_assess_id
			INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON stda.std_assess_id=stdq.std_assess_id AND stds.section_code=stdq.section_code
			left OUTER JOIN as_std_trigger stdt ON stdt.std_assess_id = stda.std_assess_id AND stdt.deleted = 'N'
																	and stdq.question_key = stdt.question_key
			LEFT JOIN cp_std_need stdn ON stdt.trigger_type = 'N' AND stdn.std_need_id = stdt.triggered_item_id
			LEFT JOIN cp_std_goal stdg ON stdt.trigger_type = 'G' AND stdg.std_goal_id = stdt.triggered_item_id
			LEFT JOIN cp_std_intervention stdi ON stdt.trigger_type = 'I' AND stdi.std_intervention_id = stdt.triggered_item_id
			left OUTER JOIN dbo.cp_std_need interv_parent WITH (NOLOCK) ON stdi.std_need_id = interv_parent.std_need_id 
			left OUTER JOIN dbo.cp_std_need goal_parent WITH (NOLOCK) ON stdg.std_need_id = goal_parent.std_need_id 
			LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON stdq.std_assess_id=stdqg.std_assess_id 
					and stdq.section_code=stdqg.section_code 
					and stdq.std_question_no=stdqg.std_question_no
					and stds.section_code=stdqg.section_code						

			outer apply ( SELECT  @vTermFocus + stdn.text1 as focus_text, stdn.std_need_id from dbo.as_std_trigger stt WITH (nolock)
							INNER JOIN dbo.cp_std_need stdna WITH (NOLOCK) ON stt.trigger_type = 'N' 
								
							where stt.std_assess_id = stda.std_assess_id
								AND stdna.std_need_id = stt.triggered_item_id
								AND stdna.std_need_id = stdn.std_need_id
							and stt.question_key = stdq.question_key
							and stt.deleted = 'N'
						) ncount	
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr 
							) custom_header
				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator +  '' + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator +  '' + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr
							) custom_sub_header
				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score: </b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category: </b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											WHERE stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Score: </b> <br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>'+ isnull(stds.description, '') + ' Category: </b> <br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											
											where	stds.std_assess_id = stda.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long

			WHERE stdq.control_type = 'cp'
				and stda.std_assess_id =  @vstd_assess_id
				and stdq.visual <> 'N'
				--and 1 = (case when cr.item_id is null then 1
				--		 when cr.item_id = 4110 and cr.enabled_flag = 'Y' then 1
				--		 when cr.item_id = 4102 and cr.enabled_flag = 'Y' then 1
				--		 else 0
				--		 end )

			) cp_data

			set @vRowCount = @@rowcount

			DELETE from #PRP_Results
			where visual = 'N'
		
			if  @vrowcount > 0
			begin

				-- update response to support c2 layout
					update rp
					SET rp.response =	question_tit.response_title	
						
					from #PRP_Results rp
					outer apply  ( SELECT ( SELECT re.response + @vseparator
												FROM #PRP_Results re WITH (NOLOCK)
												
												where	re.assess_id = rp.assess_id
													and re.question_key = rp.question_key
													and re.control_type = 'cp'
													and re.group_layout_Style = 'C2'
													order by re.unique_question
												
												FOR XML PATH ('')
											) response_title
							)question_tit
					where rp.control_type = 'cp'
						 and rp.group_layout_Style = 'C2';

					update rp
					SET rp.question_title = question_titl.q_title
						
					from #PRP_Results rp
					outer apply  ( SELECT ( SELECT case when re.question_title = '' then ' ' else re.question_title END  + @vseparator
													
												FROM #PRP_Results re WITH (NOLOCK)
												
												where	re.assess_id = rp.assess_id
													and re.question_key = rp.question_key
													and re.control_type = 'cp'
													and re.group_layout_Style = 'C2'
													order by re.unique_question

												FOR XML PATH ('')
											) q_title
								)question_titl
					where rp.control_type = 'cp'
						 and rp.group_layout_Style = 'C2';


					-- update response flag to support c2 layout
					update rp
					SET rp.resp_item_value = question_title.resp_item_value_title
					from #PRP_Results rp
					outer apply  ( SELECT ( SELECT re.resp_item_value + @vseparator
												FROM #PRP_Results re WITH (NOLOCK)
												
												where	re.assess_id = rp.assess_id
													and re.question_key = rp.question_key
													and re.control_type = 'cp'
													and re.group_layout_Style = 'C2'
													order by re.unique_question
												
												FOR XML PATH ('')
											) resp_item_value_title
							)question_title
					where rp.control_type = 'cp'
						 and rp.group_layout_Style = 'C2';

				DELETE from #PRP_Results
				where control_type = 'CP'
					and group_layout_Style = 'C2'
					and unique_question > 1

			end
	
		end -- end of blank report

	else
		begin
		---------------------------------------------------------------------------------------------
		--	POPULATED REPORT
		---------------------------------------------------------------------------------------------

		set @vStep = 121
		set @vgsStepStartTime=GETDATE()
		if @debug_me='Y' Print 'Step ' + convert(varchar(10),@vStep) + '.12 spliting selected answer insert ' + CONVERT(varchar(26), @vgsStepStartTime,109)  


		Create Clustered Index _prp_temp_PRP_as_response__AssessResponseId_idx on #PRP_as_response( assess_response_id) ;
		Create Index _prp_temp_PRP_as_response__AssessIdQuestionKey_idx on #PRP_as_response( assess_id,question_key ) ;

		insert INTO #PRP_as_response( assess_response_id , assess_id , question_key , item_value , revision_date )

		SELECT asr.assess_response_id , asr.assess_id , asr.question_key , b.items as item_value , asr.revision_date 
						FROM dbo.as_response asr WITH (NOLOCK)
						INNER JOIN #PRP_Assess_Filter af 
						ON af.assess_id = asr.assess_id 
						OUTER APPLY (SELECT items from dbo.Split(asr.item_value,',')) b

		insert INTO #PRP_as_response( assess_response_id , assess_id , question_key , item_value , revision_date, pick_list_id)
        SELECT asr.assess_response_id , asr.assess_id , asm.question_key , b.items as item_value ,asr.revision_date, 
			case when asm.control_type = 'ams' then asm.pick_list_id end as pick_list_id
                        FROM dbo.as_response asr WITH (NOLOCK)
                        INNER JOIN #PRP_Assess_Filter af 
                        ON af.assess_id = asr.assess_id 
                        inner join dbo.mirror_as_std_question asm with (nolock)
                                        ON asm.std_assess_id = af.std_assess_id
                                        and asm.question_key = asr.question_key
                        CROSS APPLY (SELECT items from dbo.Split(asr.item_value,'%')) b
                        where asm.control_type in ('ams','ther','spe','iso','comm','ads','dev','mus','gen','risk')

		update asm
		set asm.sub_item_value = ':'+sub.subkey
						FROM #PRP_as_response asm
						inner join 
						(SELECT ar.assess_id, ar.question_key, s.pick_list_id, s.item_value, 
							case when MIN(s.subkey)=MAX(s.subkey) then MIN(s.subkey)
								else MIN(s.subkey)+':'+MAX(s.subkey)
							end as subkey, 
							MIN(s.sub_item_values) as sub_item_values
							FROM #PRP_as_response ar
							inner join 
							(select pli.pick_list_id, pli.item_value, subq.subkey
								,cast (row_number () over (partition by pli.pick_list_id order by pli.sequence, subq.seq) as varchar(10)) as sub_item_values
								from dbo.mirror_as_std_pick_list_item pli with (nolock)
									left join #care_profile_question q
									ON pli.item_description = q.question_text
									left join #care_profile_question subq
									ON (subq.question_key = q.question_key or subq.question_key like q.question_key+'[_]'+'%')
								where pli.pick_list_id in (select ar2.pick_list_id from #PRP_as_response ar2)
								) s
							ON ar.pick_list_id = s.pick_list_id
							and ar.item_value = s.sub_item_values and ar.item_value <> s.item_value
						group by ar.assess_id, ar.question_key, s.pick_list_id, s.item_value
						) sub
						ON asm.pick_list_id = sub.pick_list_id
						and asm.assess_id = sub.assess_id
						and asm.question_key = sub.question_key
						and (asm.item_value = sub.sub_item_values or asm.item_value = sub.item_value)

-- we want to parse item_value in order to get a question response value
-- if item_value format is like '92<space>Date: 8/5/2011 15:30<BR>Scale: Wheelchair' then we find position of <space>Date and cut out what is before it
-- if item_value format is like '92' then we just copy it to firstVal
update asr
set asr.first_val = wv.firstval
	, asr.second_val = wv.secondval

	from 
		(select 
			r.assess_response_id,
			a.assess_id,
			q.question_key,
			item_value as value,
       
			case when control_type = 'bp' 
				then substring (substring (item_value,1,charindex(@spaceDate,item_value,0)),0,charindex('/',item_value,0))
			   
				else
					case when charindex(@spaceDate,item_value,0) <> 0
						then substring (item_value,0,charindex(@spaceDate,item_value,0)) 
						else item_value
				end
			end as firstVal, 

			case when control_type = 'bp' 
				then substring (substring (item_value,0,charindex(@spaceDate,item_value,0)),charindex('/',item_value,0)+1,len(substring (item_value,0,charindex(@spaceDate,item_value,0))) - charindex('/',substring (item_value,0,charindex(@spaceDate,item_value,0)),0))
				else null
			end as secondVal

      
		from dbo.as_assessment a with (nolock)
		join dbo.mirror_as_std_question q with (nolock)
		on a.std_assess_id = q.std_assess_id
		join dbo.as_response r with (nolock)
		on a.assess_id = r.assess_id and r.question_key = q.question_key
		inner join #PRP_Assess_Filter af
		on af.assess_id = r.assess_id) wv
		inner join #PRP_as_response asr 
		on wv.assess_response_id = asr.assess_response_id;




								
		if @debug_me='Y' select 'spliting response item_value', * from #PRP_as_response;
		

		if @debug_me='Y' Print 'Step ' + convert(varchar(10),@vStep) + '.12 spliting selected answer end insert ' + CONVERT(varchar(26), getdate(),109)
		 
		if (@vshort_version is null)
		BEGIN

			SELECT top 1 @vshort_version = 
			case when std.default_short_version = 'Y' then 1
			else 0 END
			 from dbo.as_std_assessment std with (NOLOCK)
					INNER join #PRP_Assess_Filter fl
					on std.std_assess_id = fl.std_assess_id

		END


	set @vStep = 121
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'Step ' + convert(varchar(10),@vStep) + ' first insert populated data; is short version = '  + convert(varchar(10),@vshort_version)			

			insert INTO #PRP_Results
			SELECT distinct
			  assess.fac_id
			, stda.std_assess_id
			, assess.client_id
			, assess.assess_id
			, assess.assess_date
			, asstype.description as assessment_type
			, stda.description as UDA
			, stds.title as section_title
			, stds.sequence as section_sequence
			, stdqg.std_question_no
			, stdqg.group_title
			, stdqg.group_text
			, stdqg.layout_style
			, stds.section_code
			, stdq.question_key
			, stdq.sequence
			, stdq.std_question_no
			, stdq.std_subquestion_no
			, stdq.std_subquestion_AB
			, stdq.title
			, stdq.question_text
			, case WHEN stdq.control_type in ( 'diag', 'cs') then 'txt' else  stdq.control_type end as control_type
			, stdq.length
			, stdq.required
			, stdq.pick_list_id

			, stdpl.description as picklist_name

			, CASE
				WHEN NOT (stdqg.layout_style = 'C2' OR stdq.control_type IN ('pop', 'radh', 'mcsh') OR (stdqg.layout_style = 'C1' AND stdq.control_type IN ('cmb', 'rad')  
						OR stdq.control_type in ('mcs','ams')))
					OR (stdqg.layout_style <> 'C2' AND stdq.control_type in ('mcs','ams'))
				THEN stdpli.item_value
						
				WHEN (stdqg.layout_style = 'C2' OR stdq.control_type IN ('pop', 'radh', 'mcsh') OR (stdqg.layout_style = 'C1' AND stdq.control_type IN ('cmb', 'rad'))) 
						AND (@vshort_version != 1)
				THEN pick_list_values

				WHEN (stdqg.layout_style = 'C2' OR stdq.control_type IN ('pop', 'radh', 'mcsh') OR (stdqg.layout_style = 'C1' AND stdq.control_type IN ('cmb', 'rad') 
							OR stdq.control_type in ('mcs','ams'))) 
						AND (@vshort_version = 1) 
						AND (stdq.control_type IN ('cmb','rad')) 
						AND (isnull(resp.item_value,'') = '')
				THEN pick_list_values

				WHEN (stdqg.layout_style = 'C2' OR stdq.control_type IN ('pop', 'radh', 'mcsh') OR (stdqg.layout_style = 'C1' AND stdq.control_type IN ('cmb', 'rad') 
							OR stdq.control_type in ('mcs','ams'))) 
						AND (@vshort_version = 1) 
						AND NOT (stdq.control_type IN ( 'mcsh', 'mcs','ams'))
				THEN case when resp.item_value is null or resp.item_value = '' then pick_list_values else  	resp.item_value end	
				--THEN ISNULL(resp.item_value,pick_list_values)
						
				WHEN (stdqg.layout_style = 'C2' OR stdq.control_type IN ('pop', 'radh', 'mcsh') OR (stdqg.layout_style = 'C1' AND stdq.control_type IN ('cmb', 'rad') 
							OR stdq.control_type in ('mcs','ams'))) 
						AND (@vshort_version = 1) 
						AND (stdq.control_type  IN ( 'mcsh', 'mcs','ams')) 
						AND (isnull(resp.item_value,'') = '')
				THEN pick_list_values

				WHEN (stdqg.layout_style = 'C2' OR stdq.control_type IN ('pop', 'radh', 'mcsh') OR (stdqg.layout_style = 'C1' AND stdq.control_type IN ('cmb', 'rad') 
							OR stdq.control_type in ('mcs'))) 
						AND (@vshort_version = 1) 
						AND	(stdq.control_type IN ( 'mcsh', 'mcs')) 
				THEN replace(isnull(resp.item_value, ''),',','ZYXWVU')	

				WHEN stdqg.layout_style = 'C2' 
						AND (@vshort_version = 1) 
						AND	(stdq.control_type IN ( 'ams'))
						AND isnull(ams_selected_pick_list,'')<>''
				THEN ams_selected_pick_list

				else 	pick_list_values										  
			END pick_list_value

			, CASE 
				WHEN NOT (stdqg.layout_style = 'C2' OR stdq.control_type IN ('pop', 'radh', 'mcsh') OR (stdqg.layout_style = 'C1' AND stdq.control_type IN ('cmb', 'rad') 
							OR stdq.control_type in ('mcs','ams')))
						OR (stdqg.layout_style <> 'C2' AND stdq.control_type in ('mcs','ams'))
				THEN stdpli.item_description
						
				WHEN (stdqg.layout_style = 'C2' OR stdq.control_type IN ('pop', 'radh', 'mcsh') OR (stdqg.layout_style = 'C1' AND stdq.control_type IN ('cmb', 'rad') 
							OR stdq.control_type in ('mcs','ams'))) 
						AND (@vshort_version != 1)
				THEN pick_list_descriptions

				WHEN (stdqg.layout_style = 'C2' OR stdq.control_type IN ('pop', 'radh', 'mcsh') OR (stdqg.layout_style = 'C1' AND stdq.control_type IN ('cmb', 'rad') 
							OR stdq.control_type in ('mcs','ams'))) 
						AND (@vshort_version = 1) 
						AND (stdq.control_type IN ('cmb','rad')) 
						AND (isnull(plresp.item_description,'') = '')
				THEN pick_list_descriptions

				WHEN (stdqg.layout_style = 'C2' OR stdq.control_type IN ('pop', 'radh', 'mcsh') OR (stdqg.layout_style = 'C1' AND stdq.control_type IN ('cmb', 'rad') 
							OR stdq.control_type in ('mcs','ams'))) 
						AND (@vshort_version = 1) 
						AND NOT (stdq.control_type IN ( 'mcsh', 'mcs','ams'))
				THEN isnull(plresp.item_description, pick_list_descriptions)

				WHEN (stdqg.layout_style = 'C2' OR stdq.control_type IN ('pop', 'radh', 'mcsh') OR (stdqg.layout_style = 'C1' AND stdq.control_type IN ('cmb', 'rad') 
							OR stdq.control_type in ('mcs'))) 
						AND (@vshort_version = 1) 
						AND (stdq.control_type IN ( 'mcsh', 'mcs')) 
						AND (isnull(mcs_selected_answer_descriptions,'') ='')
				THEN pick_list_descriptions
				
				WHEN (stdqg.layout_style = 'C2' OR stdq.control_type IN ('pop', 'radh', 'mcsh') OR (stdqg.layout_style = 'C1' AND stdq.control_type IN ('cmb', 'rad') 
							OR stdq.control_type in ('mcs'))) 
						AND (@vshort_version = 1) 
						AND (stdq.control_type IN ( 'mcsh', 'mcs')) 
				THEN isnull(mcs_selected_answer_descriptions, '')

				WHEN stdqg.layout_style = 'C2'
						AND @vshort_version = 1 
						AND stdq.control_type IN ('ams') 
						AND isnull(ams_selected_answer_descriptions,'') =''
				THEN pick_list_descriptions
							
				WHEN stdqg.layout_style = 'C2'
						AND @vshort_version = 1 
						AND stdq.control_type IN ('ams') 
				THEN isnull(ams_selected_answer_descriptions, '')							  
			END pick_list_description			
			--, case WHEN @vshort_version = 1 and (stdq.control_type in ( 'mcsh', 'mcs') ) then null else stdpli.sequence end
			, case WHEN  (stdq.control_type in ( 'mcsh') ) then null 
					WHEN stdqg.layout_style = 'C2' AND stdq.control_type = 'ams' AND (isnull(@vshort_version,0) <> 1 OR isnull(ams_selected_sequences,'') = '') THEN pick_list_sequences
					WHEN stdqg.layout_style = 'C2' AND stdq.control_type = 'ams' AND @vshort_version = 1 THEN ams_selected_sequences
			else cast(stdpli.sequence as varchar(10)) end

			, resp.revision_date 
			--, stdpli.effective_date cause duplicate
			, stdpli.ineffective_date
			, assess.assess_type_code
			, assess.status
			, CASE WHEN stdq.control_type IN ( 'mcsh', 'mcs', 'ams') and (resp.item_value = '' or resp.item_value is null) then ' '
					when resp.item_value IS NULL THEN '' ELSE resp.item_value END as resp_item_value

			, CASE WHEN stdq.control_type = 'ad'
						THEN CASE WHEN (select count(1) from dbo.split(resp.item_value, '|')) = 4
								  THEN  convert(varchar(10), convert(datetime,replace(replace(replace(stuff(resp.item_value, charindex('|', resp.item_value), 1, ' '), '|', ':'), ':P', ':00 P'), ':A', ':00 A')), @vdateFormatStyle)

									  + @vSeparator 
									  + substring(convert(varchar(16), convert(datetime,replace(replace(replace(stuff(resp.item_value, charindex('|', resp.item_value), 1, ' '), '|', ':'), ':P', ':00 P'), ':A', ':00 A')), 20), 12, 2)
									  + @vSeparator + 'T'
									  + substring(convert(varchar(16), convert(datetime,replace(replace(replace(stuff(resp.item_value, charindex('|', resp.item_value), 1, ' '), '|', ':'), ':P', ':00 P'), ':A', ':00 A')), 20), 15, 2)

								  WHEN (select count(1) from dbo.split(resp.item_value, '|')) = 3
								  THEN  convert(varchar(10), convert(datetime,replace(replace(stuff(resp.item_value, charindex('|', resp.item_value), 1, ' '), '|', ':') + ':00', '::', ':')), @vdateFormatStyle)

									  + @vSeparator 
									  + substring(convert(varchar(16), convert(datetime,replace(replace(stuff(resp.item_value, charindex('|', resp.item_value), 1, ' '), '|', ':') + ':00', '::', ':')), 20), 12, 2)
									  + @vSeparator + 'T'
									  + substring(convert(varchar(16), convert(datetime,replace(replace(stuff(resp.item_value, charindex('|', resp.item_value), 1, ' '), '|', ':') + ':00', '::', ':')), 20), 15, 2)
								  else ''
							 END
				   WHEN stdq.control_type = 'pain'
						THEN case when resp.item_value IS NULL OR resp.item_value = '' THEN @vConfig_facepain_use_cartoon + @vSeparator ELSE @vConfig_facepain_use_cartoon + @vSeparator + resp.item_value END
				   WHEN stdq.control_type = 'iFlu' or stdq.control_type = 'iPneu' or stdq.control_type = 'iTet' or stdq.control_type = 'iTb'
						THEN case when isdate(resp.item_value) = 1 then isnull(convert(varchar(10), convert(date,resp.item_value), @vdateFormatStyle),'') ELSE resp.item_value END
				   WHEN stdq.control_type = 'chk'
						THEN CASE WHEN resp.item_value IS NULL OR resp.item_value = '' THEN '0' ELSE resp.item_value END
				   WHEN stdq.control_type = 'dte' 
						THEN CASE WHEN resp.item_value IS NULL OR resp.item_value = '' THEN '' ELSE 
										case when isdate(resp.item_value) = 1 then 

												 isnull(convert(varchar(10), convert(date,resp.item_value), @vdateFormatStyle),'')
										else resp.item_value end 
								  END
				
				   WHEN stdq.control_type = 'dttm'
						THEN CASE WHEN resp.item_value IS NULL OR resp.item_value = '' THEN '' ELSE 
									 isnull(convert(varchar(10), convert(date,resp.item_value), @vdateFormatStyle),'')

									+ ' ' + CONVERT(CHAR(5),CONVERT(datetime, resp.item_value),114) 
									END
				   WHEN stdq.control_type IN ( 'mcsh', 'mcs')  THEN  
										case when mcs_selected_answer_descriptions is null or len(mcs_selected_answer_descriptions) < len(@vSeparator)  then ''
											else substring (mcs_selected_answer_descriptions, 1, len(mcs_selected_answer_descriptions) - len(@vSeparator))
										end
				  -- WHEN stdq.control_type IN ( 'ams')  THEN isnull(ams_selected_answer_descriptions, '')
				    WHEN stdq.control_type IN ( 'ams')  THEN  
										case when ams_selected_answer_descriptions is null or len(ams_selected_answer_descriptions) < len(@vSeparator) then ''
											else substring (ams_selected_answer_descriptions, 1, len(ams_selected_answer_descriptions) - len(@vSeparator))
										end

				   WHEN stdq.control_type in ('pulse','we','bp','resp','bs','o2','he','pnl', 'temp')  and charindex('<BR>', resp.item_value) > 0 /*and isnull(resp.item_value,'') <> ''*/ THEN

							 REPLACE(resp.item_value, 
										left(SUBSTRING(resp.item_value,  (CHARINDEX('space>Date:', resp.item_value,1)+11), (  CHARINDEX('<BR>', resp.item_value,1) - (CHARINDEX('space>Date:', resp.item_value,1)+11) )), ( len( SUBSTRING(resp.item_value,  (CHARINDEX('space>Date:', resp.item_value,1)+11), (  CHARINDEX('<BR>', resp.item_value,1) - (CHARINDEX('space>Date:', resp.item_value,1)+11) ))) - 5) )
							 ,
								  convert(varchar(10), convert(datetime, (left(SUBSTRING(resp.item_value,  (CHARINDEX('space>Date:', resp.item_value,1)+11), (  CHARINDEX('<BR>', resp.item_value,1) - (CHARINDEX('space>Date:', resp.item_value,1)+11) )), ( len( SUBSTRING(resp.item_value,  (CHARINDEX('space>Date:', resp.item_value,1)+11), (  CHARINDEX('<BR>', resp.item_value,1) - (CHARINDEX('space>Date:', resp.item_value,1)+11) ))) - 5) ))    ),  @vdateFormatStyle) + ' '
								  )

					WHEN stdq.control_type in ('pulse','we','bp','resp','bs','o2','he','pnl', 'temp')  and charindex('<BR>', resp.item_value) = 0 and isnull(resp.item_value,'') <> '' and resp.item_value <> 'null'  THEN
						case when len(resp.item_value) > 17 then
							 REPLACE(resp.item_value, 
										left( SUBSTRING(resp.item_value,  (CHARINDEX('space>Date:', resp.item_value,1)+11), 17),  len(SUBSTRING(resp.item_value,  (CHARINDEX('space>Date:', resp.item_value,1)+11), 17))- 5) 
							 ,
								  convert(varchar(10),  convert(datetime, (left( SUBSTRING(resp.item_value,  (CHARINDEX('space>Date:', resp.item_value,1)+11), 17),  len(SUBSTRING(resp.item_value,  (CHARINDEX('space>Date:', resp.item_value,1)+11), 17))- 5) )    ),  @vdateFormatStyle) + ' '
								  )
						end

					WHEN stdq.control_type in ('oa')  and charindex('||', resp.item_value) > 0  THEN

							REPLACE(resp.item_value

									, substring(resp.item_value, charindex('||', resp.item_value ) + 2, 10)
									, convert(varchar(10), convert(date, substring(resp.item_value, charindex('||', resp.item_value ) + 2, 10)) , @vdateFormatStyle)
									)

					WHEN stdq.control_type = 'dob' 
						THEN CASE WHEN resp.item_value IS NULL OR resp.item_value = '' THEN '' ELSE 
										case when isdate(resp.item_value) = 1 then 

												 isnull(convert(varchar(10), convert(date,resp.item_value), @vdateFormatStyle),'')
										else resp.item_value end 
								  END

					--SUBSTRING(resp.item_value,  (CHARINDEX('space>Date:', resp.item_value,1)+11), 17)

				   WHEN stdq.pick_list_id IS NULL	
						THEN CASE WHEN resp.item_value IS NULL OR resp.item_value = '' THEN '' ELSE resp.item_value END
				   ELSE CASE WHEN plresp.item_description IS NULL THEN '' ELSE plresp.item_description END
			  END as response

			
			, score.score
			, score.category as score_category
			, case when assess.strikeout_flag is null then 'N' else assess.strikeout_flag END as strikeout_flag
			, case when assess.strikeout_by IS NULL THEN '' ELSE assess.strikeout_by end as strikeout_by
			, dbo.fn_adjust_time_fac_time_zone(@vFacId, assess.strikeout_date)AS strikeout_date
			, case when assess.strikeout_desc IS NULL THEN '' ELSE assess.strikeout_desc end as strikeout_reason
			, stda.include_signature_section_flag
			, case when assess_sec.complete='Y' and assess_sec.completed_title is not null then assess_sec.completed_by+', '+assess_sec.completed_title 
				   when assess_sec.complete='Y' and assess_sec.completed_title is null then assess_sec.completed_by else '' end as signed_by
			, assess_sec.completed_date as signed_date
			, custom_header.cust_hdr
			, custom_sub_header.cust_sub_hdr
			, cust_hdr_long
			, cust_sub_hdr_long
			, NULL as rnum
			, NULL as unique_question
			, NULL as was_merge
			, '0' as print_s
			, CASE WHEN stdq.control_type = 'ams' and stdqg.layout_style <> 'C2' THEN isnull(cpqk.subkey,'')
					WHEN stdq.control_type = 'ams' and stdqg.layout_style = 'C2' THEN isnull(questions_subkeys,'')
			END ams_key
			, NULL as file_metadata_id
			, stdq.visual
			, NULL as ordr
			-- for show hide debugging purpose

			--, pick_list_descriptions
			--, stdq.question_key
			--, cr.question_key_sbj
			--, cr.question_key_obj
			--, cr.item_id
			--, cr.range_orig
			--, cr.range1
			--, cr.range2
			--, cr.control_type
			--, 'asr_split'
			--, asr_split.item_value
			--, asr_split.first_val
			--, asr_split.second_val
			--, asr_split.question_key
			
			FROM

				#PRP_Assess_Filter af
				INNER JOIN dbo.as_assessment assess WITH (NOLOCK) ON assess.assess_id=af.assess_id
				INNER JOIN dbo.as_std_assessment stda WITH (NOLOCK) ON stda.std_assess_id=af.std_assess_id
				LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id
				LEFT JOIN dbo.as_assessment_section assess_sec WITH (NOLOCK) ON assess.assess_id=assess_sec.assess_id AND stds.section_code=assess_sec.section_code
				INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON 
									stda.std_assess_id = stdq.std_assess_id 
								AND stds.section_code = stdq.section_code

				--left join #PRP_as_response resp

				LEFT JOIN dbo.as_response resp WITH (NOLOCK) 
					ON af.assess_id=resp.assess_id and stdq.question_key=resp.question_key

				LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON 
									stdq.std_assess_id=stdqg.std_assess_id 
								AND stdq.section_code=stdqg.section_code 
								AND stdq.std_question_no=stdqg.std_question_no
								AND stds.section_code=stdqg.section_code
				LEFT JOIN dbo.as_std_pick_list stdpl WITH (NOLOCK) ON 
									stdq.pick_list_id = stdpl.pick_list_id
								AND stdq.control_type <> 'chk'
				LEFT JOIN dbo.mirror_as_std_pick_list_item stdpli WITH (NOLOCK) ON 
									stdq.pick_list_id = stdpli.pick_list_id 

									and (stdq.control_type IN ( 'rad','mcs','cmb','mcsh','ams') OR resp.item_value = stdpli.item_value )

								AND stdpli.item_description <> 'Blank (skip pattern)'
								AND (resp.revision_date IS NULL OR resp.revision_date >= stdpli.effective_date)
								AND (resp.revision_date IS NULL OR resp.revision_date <= stdpli.ineffective_date OR stdpli.ineffective_date IS null)

								AND ((@vshort_version = 1 AND stdqg.layout_style = 'V' AND stdq.control_type in ('mcs','ams')) OR (
									NOT (stdqg.layout_style = 'C2' OR stdq.control_type = 'pop' OR stdq.control_type = 'radh' /*or stdq.control_type = 'mcsh'*/
									 OR (stdqg.layout_style = 'C1' AND (stdq.control_type = 'cmb' OR stdq.control_type = 'rad' )))
									 ))
				LEFT JOIN #care_profile_question cpqk
								ON stdq.control_type in ('ams') 
								AND cpqk.question_text = stdpli.item_description								
				OUTER APPLY (	SELECT	STUFF(subkeys, 1, LEN(@vSeparator), '') 
								FROM (SELECT @vSeparator+isnull(cpqsk.subkey,'')+ isnull(r.sub_item_value,'') + 
										case 
											when cpqsk.subkey in ('#oxygen') and charindex('l_per_min',resp.item_value) = 0 then isnull(resp.item_value,'')+'%l_per_min%#%#other:%'  
											when cpqsk.subkey  in ('#ao') and charindex('#auxother',resp.item_value) = 0 then isnull(resp.item_value,'')+'%#auxother:%' 
											when cpqsk.subkey  in ('#do') and charindex('#devother',resp.item_value) = 0 then isnull(resp.item_value,'')+'%#devother:%' 
											when cpqsk.subkey  in ('#ro') and charindex('#riskother',resp.item_value) = 0 then isnull(resp.item_value,'')+'%#riskother:%' 
											when cpqsk.subkey  in ('#mo') and charindex('#muscother',resp.item_value) = 0 then isnull(resp.item_value,'')+'%#muscother:%' 
											when cpqsk.subkey  in ('#so') and charindex('#genother',resp.item_value) = 0 then isnull(resp.item_value,'')+'%#genother:%'
											when cpqsk.subkey  in ('#bp') and charindex('#bdpayment',resp.item_value) = 0 then isnull(resp.item_value,'')+'%#bdpayment:%' 
											when cpqsk.subkey  in ('#co') and charindex('#specother',resp.item_value) = 0 then isnull(resp.item_value,'')+'%#specother:%' 											
											when cpqsk.subkey  in ('#oxygen','#ao','#do','#ro','#mo','#so','#co','#bp') then isnull(resp.item_value,'')
											else ''
										end 	
										FROM	dbo.mirror_as_std_pick_list_item stdpli WITH (NOLOCK)
										INNER JOIN #care_profile_question cpqsk
										ON cpqsk.question_text = stdpli.item_description

										LEFT JOIN #PRP_as_response r
										ON r.pick_list_id = stdpli.pick_list_id 
										AND r.assess_id = af.assess_id
										AND r.question_key = resp.question_key
										AND r.item_value = stdpli.item_value
										WHERE stdq.pick_list_id = stdpli.pick_list_id 
											AND stdqg.layout_style = 'C2' 
											AND stdq.control_type = 'ams'
											AND (
											(r.item_value is not null AND @vshort_version = 1) 
											OR resp.item_value not like '%[0-9]%'--in case no response - print all pick list items for short form									
											OR @vshort_version <> 1)
										ORDER BY stdpli.sequence
										FOR XML PATH ('')
									) AS questions (subkeys)
							) qsk (questions_subkeys)	
				OUTER APPLY (	SELECT	 STUFF([values], 1, LEN(@vSeparator), '')
										
								FROM	(	SELECT @vSeparator + stdpli.item_value
											FROM	dbo.mirror_as_std_pick_list_item stdpli WITH (NOLOCK)
											WHERE	stdq.pick_list_id = stdpli.pick_list_id 
												AND stdpli.item_description <> 'Blank (skip pattern)'
												AND (resp.revision_date IS NULL OR resp.revision_date >= stdpli.effective_date)
												AND (resp.revision_date IS NULL OR resp.revision_date <= stdpli.ineffective_date OR stdpli.ineffective_date IS null)
												AND (stdqg.layout_style = 'C2' OR stdq.control_type = 'pop' OR stdq.control_type = 'radh' or stdq.control_type = 'mcsh'
												  OR (stdqg.layout_style = 'C1' AND (stdq.control_type = 'cmb' OR stdq.control_type = 'rad' /*or stdq.control_type = 'mcs' or stdq.control_type = 'mcsh'*/)))
											ORDER BY stdpli.sequence
											FOR XML PATH ('')
										) AS picklist ([values])
							) plv (pick_list_values)

				OUTER APPLY (	SELECT STUFF(descriptions, 1, LEN(@vSeparator), '')
										

								FROM	(	SELECT @vSeparator + stdpli.item_description
											FROM	dbo.mirror_as_std_pick_list_item stdpli WITH (NOLOCK)
											WHERE	stdq.pick_list_id = stdpli.pick_list_id 
												AND stdpli.item_description <> 'Blank (skip pattern)'
												AND (resp.revision_date IS NULL OR resp.revision_date >= stdpli.effective_date)
												AND (resp.revision_date IS NULL OR resp.revision_date <= stdpli.ineffective_date OR stdpli.ineffective_date IS null)
												AND (stdqg.layout_style = 'C2' OR stdq.control_type = 'pop' OR stdq.control_type = 'radh' or stdq.control_type = 'mcsh'
												  OR (stdqg.layout_style = 'C1' AND (stdq.control_type = 'cmb' OR stdq.control_type = 'rad' /*or stdq.control_type = 'mcs' or stdq.control_type = 'mcsh'*/)))
											ORDER BY stdpli.sequence
											FOR XML PATH ('')
										) AS picklist (descriptions)
							) pld (pick_list_descriptions)
			OUTER APPLY (	SELECT	 STUFF(seq, 1, LEN(@vSeparator), '')
							FROM	(	SELECT @vSeparator + cast(stdpli.sequence as varchar(10))
										FROM	dbo.mirror_as_std_pick_list_item stdpli WITH (NOLOCK)
										WHERE	stdq.pick_list_id = stdpli.pick_list_id 
											AND stdpli.item_description <> 'Blank (skip pattern)'
											AND stdqg.layout_style = 'C2' 
											AND stdq.control_type = 'ams'
										ORDER BY stdpli.sequence
										FOR XML PATH ('')
									) AS picklist (seq)
						) pls (pick_list_sequences)
				OUTER APPLY (	SELECT	descriptions
				
								FROM	( SELECT   pli.item_description  + @vSeparator
											FROM (SELECT  b.items as item_value , asr.question_key , asr.assess_id 
														FROM dbo.as_response asr WITH (NOLOCK)
														CROSS APPLY (SELECT items from dbo.Split(asr.item_value,',')) b
													WHERE asr.assess_id = af.assess_id
													and (stdq.control_type = 'mcs' or stdq.control_type = 'mcsh')
													and resp.question_key = asr.question_key 

													) sel_ans 
											INNER JOIN dbo.mirror_as_std_pick_list_item pli WITH (NOLOCK)
													ON stdq.pick_list_id = pli.pick_list_id 
													and sel_ans.item_value = pli.item_value 
												order by pli.sequence

											FOR XML PATH ('')
										) AS selected_answer (descriptions)
							) mcs_ans (mcs_selected_answer_descriptions)

				OUTER APPLY (	SELECT	descriptions -- STUFF(descriptions, 1, LEN(@vSeparator), '')
								FROM	( SELECT   pli.item_description  + @vSeparator
											FROM (SELECT  asr.item_value , asr.question_key , asr.assess_id 
														FROM #PRP_as_response asr WITH (NOLOCK)
													WHERE asr.assess_id = af.assess_id
													and stdq.control_type = 'ams'
													and asr.question_key  = resp.question_key
													) sel_ans 
											INNER JOIN dbo.mirror_as_std_pick_list_item pli WITH (NOLOCK)
													ON stdq.pick_list_id = pli.pick_list_id 
													and sel_ans.item_value = pli.item_value 
												order by pli.sequence

											FOR XML PATH ('')
										) AS selected_answer (descriptions)
							) ams_ans (ams_selected_answer_descriptions)
				OUTER APPLY (	SELECT	 STUFF(seq, 1, LEN(@vSeparator), '')
								FROM	( SELECT @vSeparator + cast(pli.sequence as varchar(10))
											FROM (SELECT  asr.item_value, asr.question_key , asr.assess_id 
														FROM #PRP_as_response asr WITH (NOLOCK)
													WHERE asr.assess_id = af.assess_id
													and stdq.control_type = 'ams'
													and stdqg.layout_style = 'C2' 
													and @vshort_version = 1
													and resp.question_key = asr.question_key 

													) sel_ans 
											INNER JOIN dbo.mirror_as_std_pick_list_item pli WITH (NOLOCK)
													ON stdq.pick_list_id = pli.pick_list_id 
													and sel_ans.item_value = pli.item_value 
												order by pli.sequence

											FOR XML PATH ('')
										) AS selected_answer (seq)
							) ams_seq (ams_selected_sequences)
				OUTER APPLY (	SELECT	 STUFF(pl, 1, LEN(@vSeparator), '')
								FROM	( SELECT @vSeparator + pli.item_value
											FROM (SELECT  asr.item_value, asr.question_key , asr.assess_id 
														FROM #PRP_as_response asr WITH (NOLOCK)
													WHERE asr.assess_id = af.assess_id
													and stdq.control_type = 'ams'
													and stdqg.layout_style = 'C2' 
														AND (@vshort_version = 1) 
													and resp.question_key = asr.question_key 

													) sel_ans 
											INNER JOIN dbo.mirror_as_std_pick_list_item pli WITH (NOLOCK)
													ON stdq.pick_list_id = pli.pick_list_id 
													and sel_ans.item_value = pli.item_value 
												order by pli.sequence

											FOR XML PATH ('')
										) AS selected_answer (pl)
							) ams_pick_list (ams_selected_pick_list)
				LEFT JOIN dbo.as_std_assess_type asstype WITH (NOLOCK) ON 
									assess.std_assess_id = asstype.std_assess_id 
								AND assess.assess_type_code = asstype.assess_type_code 
				LEFT JOIN dbo.mirror_as_std_pick_list_item plresp WITH (NOLOCK) ON 
									stdq.pick_list_id = plresp.pick_list_id 
								AND resp.item_value = plresp.item_value
								AND (resp.revision_date IS NULL OR resp.revision_date >= plresp.effective_date)
								AND (resp.revision_date IS NULL OR resp.revision_date <= plresp.ineffective_date OR plresp.ineffective_date IS null)

				LEFT JOIN dbo.as_std_score stdscore  WITH (NOLOCK) ON 
									stda.std_assess_id = stdscore.std_assess_id
								AND stdscore.is_default = 'Y'
								AND stdscore.deleted = 'N'

				LEFT JOIN dbo.as_assessment_score score WITH (NOLOCK) ON 
							score.assess_id = assess.assess_id
								AND score.std_score_id = stdscore.std_score_id

				-- hide/show  or parent/child question
				left outer join #prp_ShowHideDisable_rules cr
					on stdq.question_key = cr.question_key_obj

					left OUTER JOIN #PRP_as_response asr_split
						ON af.assess_id = asr_split.assess_id 
						and asr_split.question_key = cr.question_key_sbj


				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
														ascr.assess_id = af.assess_id
													AND ascr.std_score_id = stds.std_score_id
											WHERE		af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr 
							) custom_header

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
												 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
											where	af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) < 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr
							) custom_sub_header

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
														ascr.assess_id = af.assess_id
													AND ascr.std_score_id = stds.std_score_id
											WHERE		af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
											where	af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long

			WHERE 

				(
					(
						@vshort_version = 1
						AND stdpl.pick_list_id is not NULL
						AND stdqg.layout_style in ('V','C1')												
						AND stdq.control_type in ('mcs') 
						AND mcs_ans.mcs_selected_answer_descriptions is not null
						AND charindex(stdpli.item_description+@vSeparator,mcs_ans.mcs_selected_answer_descriptions COLLATE Latin1_General_CS_AS) > 0
					)
					OR
					(
						@vshort_version = 1
						AND stdpl.pick_list_id is not NULL
						AND stdqg.layout_style in ('V','C1')												
						AND stdq.control_type in ('ams') 
						AND ams_ans.ams_selected_answer_descriptions is not null
						AND charindex(stdpli.item_description +@vSeparator ,ams_ans.ams_selected_answer_descriptions COLLATE Latin1_General_CS_AS) > 0
					)
					OR
					(
						@vshort_version = 1
						
						AND stdq.control_type  in ('rad','cmb')
						AND ((stdqg.layout_style = 'V' and (ltrim(resp.item_value) = stdpli.item_value or (stdpl.pick_list_id is not NULL  and (resp.item_value = '' or resp.item_value is null  ) ))) or 
							 (stdqg.layout_style = ( 'C1') or (resp.item_value = '' or resp.item_value is null  ) and stdpl.pick_list_id is not NULL )
							)
					)
					OR
					(
						@vshort_version = 1
						AND stdpl.pick_list_id is not NULL
						AND stdq.control_type in ('mcs', 'mcsh') 
						AND mcs_ans.mcs_selected_answer_descriptions is null
					)
					OR
					(
						@vshort_version = 1
						AND stdpl.pick_list_id is not NULL
						AND stdq.control_type in ('ams') 
						AND ams_ans.ams_selected_answer_descriptions is null
					)					

					OR (stdqg.layout_style not in ('V','C1') OR stdq.control_type not in ('mcs','rad','cmb','ams')) 							
					OR @vshort_version = 0 
					OR @vshort_version is null						
				)

				
				and
				-- show hide and disabled question
				-- if one of the cases is true and returns 0 then question will be hidden 
				-- if all cases are false and we have 1 as a result then question will be showed 

				1 = ( case when 
									cr.enabled_flag = 'Y' 
									and  @vincl_disabled_qs = 0				-- assessment flag "By Default Include Disabled Questions in Report"
									and isnull(cr.item_id, '') = 4102		-- disabled question
									and  cr.range1 = asr_split.first_val	-- value that triggers rule equal response value
								then 0 

								when cr.enabled_flag = 'Y' and not cr.control_type in ('pulse','we','bp','resp','bs','o2','he', 'temp','pnl', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null or ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.item_value))) then 0
								
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pulse','we','resp','bs','o2','he', 'temp', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)

											) then 0
							-- pain level
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pnl')  
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or ( ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.first_val)))
										
											) then 0

								-- blood pressure
								when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'sys'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)
										
											) then 0
									when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'dias'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.second_val)
														or convert(float,cr.range1) > convert(float,asr_split.second_val)
													)
										
											) then 0

								else 1 end
					)
					

					AND 1 = CASE WHEN stdq.control_type <> 'inst' THEN 1 ELSE CASE WHEN stdq.electronic = 'Y' THEN 1 ELSE 0 END END
					AND stdq.control_type <> 'bdy'
					AND stdq.control_type <> 'gbdy'
					AND	stdq.control_type <> 'ebdy'			
					AND stdq.control_type <> 'to'			
					AND stdq.control_type <> 'adir'			
					AND stdq.control_type <> 'cnt'			
					AND stdq.control_type <> 'hck'
					AND stdq.control_type <> 'ident'
					AND stdq.control_type <> 'cp'
					AND stdq.control_type <> 'payer'
		
			set @vRowCount = @@rowcount

			if @debug_me='Y' 		SELECT '#PRP_Results before upd',  * from #PRP_Results


		-- do an update to handle ams
			update r
			SET r.ams_key =  case 
					when r.ams_key in ('#oxygen') and charindex('l_per_min',r.resp_item_value) = 0 then r.ams_key + isnull(asr.sub_item_value,'') +isnull(r.resp_item_value,'')+'%l_per_min%#%#other:%'  
					when r.ams_key in ('#ao') and charindex('#auxother',r.resp_item_value) = 0 then r.ams_key + isnull(asr.sub_item_value,'') +isnull(r.resp_item_value,'')+'%#auxother:%' 
					when r.ams_key in ('#do') and charindex('#devother',r.resp_item_value) = 0 then r.ams_key + isnull(asr.sub_item_value,'') +isnull(r.resp_item_value,'')+'%#devother:%' 
					when r.ams_key in ('#ro') and charindex('#riskother',r.resp_item_value) = 0 then r.ams_key + isnull(asr.sub_item_value,'') +isnull(r.resp_item_value,'')+'%#riskother:%' 
					when r.ams_key in ('#mo') and charindex('#muscother',r.resp_item_value) = 0 then r.ams_key + isnull(asr.sub_item_value,'') +isnull(r.resp_item_value,'')+'%#muscother:%' 
					when r.ams_key in ('#so') and charindex('#genother',r.resp_item_value) = 0 then r.ams_key + isnull(asr.sub_item_value,'') +isnull(r.resp_item_value,'')+'%#genother:%'
					when r.ams_key in ('#bp') and charindex('#bdpayment',r.resp_item_value) = 0 then r.ams_key + isnull(asr.sub_item_value,'') +isnull(r.resp_item_value,'')+'%#bdpayment:%' 	
					when r.ams_key in ('#co') and charindex('#specother',r.resp_item_value) = 0 then r.ams_key + isnull(asr.sub_item_value,'') +isnull(r.resp_item_value,'')+'%#specother:%' 					
					when r.ams_key in ('#oxygen','#ao','#do','#ro','#mo','#so','#co','#bp') then r.ams_key + isnull(asr.sub_item_value,'') +isnull(r.resp_item_value,'')
					else r.ams_key + isnull(asr.sub_item_value,'') end 				
			from #PRP_Results r left join #PRP_as_response asr
			ON r.assess_id = asr.assess_id
			and r.question_key = asr.question_key
			and r.pick_list_value = asr.item_value
			and r.group_layout_style in ('C1','V')
			and r.control_type in  ('ams')

		-- do an update to handle mcs
			update r
			SET r.resp_item_value = 0
			from #PRP_Results r inner join #PRP_as_response asr
			ON r.assess_id = asr.assess_id
			and r.question_key = asr.question_key
			and r.group_layout_style = 'V'
			and r.control_type in  ('mcs','ams')

			update r
			SET r.resp_item_value = 1
			from #PRP_Results r inner join #PRP_as_response asr
			ON r.assess_id = asr.assess_id
			and r.question_key = asr.question_key
			and r.pick_list_value = asr.item_value
			and r.group_layout_style = 'V'
			and r.control_type in  ('mcs','ams')


		if @debug_me='Y' 		SELECT @vStep as step,  * from #PRP_Results

		set @vStep = 122
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'Step ' + convert(varchar(10),@vStep) + ' payer control insert' 

	-- Add in payer controls
			INSERT INTO #PRP_Results
			SELECT 
				assess.fac_id,
				stda.std_assess_id,
				assess.client_id,
				assess.assess_id,
				assess.assess_date, 
				asstype.description as assessment_type, 
				stda.description as UDA,
				stds.title as section_title,
				stds.sequence as section_sequence,
				stdqg.std_question_no,
				stdqg.group_title,
				stdqg.group_text,
				stdqg.layout_style,
				stds.section_code,
				stdq.question_key,
				stdq.sequence,
				stdq.std_question_no,
				stdq.std_subquestion_no,
				stdq.std_subquestion_AB,
				stdq.title,
				stdq.question_text,
				stdq.control_type,
				stdq.length,
				stdq.required,
				stdq.pick_list_id,
				NULL as picklist_name,		-- null for payer control
				NULL AS item_value,			-- null for payer control
				NULL AS item_description,	-- null for payer control
				NULL AS sequence,			-- null for payer control
				NULL AS effective_date,		-- null for payer control
				NULL AS ineffective_date,	-- null for payer control
				assess.assess_type_code,
				assess.status,
				NULL as resp_item_value,	-- null for payer control
				resp.response as response,
				score.score,
				score.category as score_category,
				case when assess.strikeout_flag is null then 'N' else assess.strikeout_flag END as strikeout_flag,
				case when assess.strikeout_by IS NULL THEN '' ELSE assess.strikeout_by end as strikeout_by,
				dbo.fn_adjust_time_fac_time_zone(@vFacId, assess.strikeout_date)AS strikeout_date,
				case when assess.strikeout_desc IS NULL THEN '' ELSE assess.strikeout_desc end as strikeout_reason,
				stda.include_signature_section_flag,
				case when assess_sec.complete='Y' and assess_sec.completed_title is not null then assess_sec.completed_by+', '+assess_sec.completed_title 
					when assess_sec.complete='Y' and assess_sec.completed_title is null then assess_sec.completed_by else '' end as signed_by,
				assess_sec.completed_date as signed_date
			, cust_hdr
			, cust_sub_hdr
			, cust_hdr_long
			, cust_sub_hdr_long
			, NULL as rnum
			, NULL as unique_question
			, NULL as was_merge
			, '0' as print_s
			, NULL as ams_key
			, NULL as file_metadata_id
			, stdq.visual
			, NULL as ordr
			FROM #PRP_Assess_Filter af
			INNER JOIN dbo.as_std_assessment stda WITH (NOLOCK) ON stda.std_assess_id=af.std_assess_id
			INNER JOIN dbo.as_assessment assess WITH (NOLOCK) ON assess.assess_id=af.assess_id
			LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id
			LEFT JOIN dbo.as_assessment_section assess_sec WITH (NOLOCK) ON assess.assess_id=assess_sec.assess_id AND stds.section_code=assess_sec.section_code
			INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON stda.std_assess_id=stdq.std_assess_id AND stds.section_code=stdq.section_code
			OUTER APPLY		(SELECT stuff(isnull(response_str,''),1, len(@vSeparator),'') as response     
                              FROM	
                                    (SELECT  @vSeparator + ltrim(rtrim(item_value))
                                          FROM dbo.as_response resp WITH (NOLOCK)
                                          WHERE		assess.assess_id = resp.assess_id 
												and resp.question_key LIKE '%' + stdq.question_key
												and resp.question_key <> stdq.question_key
                                          ORDER BY CASE LEFT(question_key, CHARINDEX(stdq.question_key, question_key) - 1)
														WHEN 'cn'     THEN 1
														WHEN 'pn'     THEN 2
														WHEN 'pno'    THEN 3
														WHEN 'ca1'    THEN 4
														WHEN 'ca2'    THEN 5
														WHEN 'plno'   THEN 6
														WHEN 'grpno'  THEN 7
														WHEN 's'      THEN 8
													END
                                          FOR XML PATH ('')
                                    ) ans (response_str)
                              )resp

			LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON stdq.std_assess_id=stdqg.std_assess_id and stdq.section_code=stdqg.section_code and stdq.std_question_no=stdqg.std_question_no
				AND stds.section_code=stdqg.section_code
			LEFT JOIN dbo.as_std_assess_type asstype WITH (NOLOCK) ON assess.std_assess_id = asstype.std_assess_id AND assess.assess_type_code = asstype.assess_type_code 

			LEFT JOIN dbo.as_std_score stdscore  WITH (NOLOCK) ON 
								stda.std_assess_id = stdscore.std_assess_id
							AND stdscore.is_default = 'Y'
							AND stdscore.deleted = 'N'

			LEFT JOIN dbo.as_assessment_score score WITH (NOLOCK) ON 
						score.assess_id = assess.assess_id
							AND score.std_score_id = stdscore.std_score_id
			-- hide/show  or parent/child question
			left outer join #prp_ShowHideDisable_rules cr
			on stdq.question_key = cr.question_key_obj

			left OUTER JOIN #PRP_as_response asr_split
				ON af.assess_id = asr_split.assess_id 
				and asr_split.question_key = cr.question_key_sbj


			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
										WHERE		af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
								  ) AS cust_hdr 
						) custom_header
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
												ascr.assess_id = af.assess_id
											AND ascr.std_score_id = stds.std_score_id
										where	af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
									) AS cust_sub_hdr
						) custom_sub_header
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
														ascr.assess_id = af.assess_id
													AND ascr.std_score_id = stds.std_score_id
											WHERE		af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
											where	af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long

			WHERE stdq.control_type = 'payer'
				and
				-- show hide and disabled question
				1 = ( case when 
									cr.enabled_flag = 'Y' 
									and  @vincl_disabled_qs = 0				-- assessment flag "By Default Include Disabled Questions in Report"
									and isnull(cr.item_id, '') = 4102		-- disabled question
									and  cr.range1 = asr_split.first_val	-- value that triggers rule equal response value
								then 0 

								when cr.enabled_flag = 'Y' and not cr.control_type in ('pulse','we','bp','resp','bs','o2','he', 'temp','pnl', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null or ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.item_value))) then 0
								
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pulse','we','resp','bs','o2','he', 'temp', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)

											) then 0
							-- pain level
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pnl')  
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or ( ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.first_val)))
										
											) then 0

								-- blood pressure
								when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'sys'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)
										
											) then 0
									when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'dias'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.second_val)
														or convert(float,cr.range1) > convert(float,asr_split.second_val)
													)
										
											) then 0

								else 1 end
					)
					
					

			set @vRowCount = @vRowCount + @@rowcount


		set @vStep = 123
		set @vgsStepStartTime=GETDATE()
		if @debug_me='Y' Print 'Step ' + convert(varchar(10),@vStep) + ' body parts insert' 
		if @debug_me='Y' SELECT * from #PRP_Results

	-- Add in Body Part controls (originally for layout_style = 'V', 'PV', or 'C1', this is now for all bdy and gbdy)
			INSERT INTO #PRP_Results
			SELECT 
				assess.fac_id,
				stda.std_assess_id,
				assess.client_id,
				assess.assess_id,
				assess.assess_date, 
				asstype.description as assessment_type, 
				stda.description as UDA,
				stds.title as section_title,
				stds.sequence as section_sequence,
				stdqg.std_question_no,
				stdqg.group_title,
				stdqg.group_text,
				stdqg.layout_style,
				stds.section_code,
				stdq.question_key,
				stdq.sequence,
				stdq.std_question_no,
				stdq.std_subquestion_no,
				stdq.std_subquestion_AB,
				stdq.title,
				stdq.question_text,
				stdq.control_type,
				stdq.length,
				stdq.required,
				stdq.pick_list_id,
				NULL as picklist_name,		-- null for bdy/gbdy control
				NULL AS item_value,			-- null for bdy/gbdy control
				NULL AS item_description,	-- null for bdy/gbdy control
				NULL AS sequence,			-- null for bdy/gbdy control
				NULL AS effective_date,		-- null for bdy/gbdy control
				NULL AS ineffective_date,	-- null for bdy/gbdy control
				assess.assess_type_code,
				assess.status,
				NULL as resp_item_value,	-- null for bdy/gbdy control
				resp.response as response,
				score.score,
				score.category as score_category,
				case when assess.strikeout_flag is null then 'N' else assess.strikeout_flag END as strikeout_flag,
				case when assess.strikeout_by IS NULL THEN '' ELSE assess.strikeout_by end as strikeout_by,
				dbo.fn_adjust_time_fac_time_zone(@vFacId, assess.strikeout_date)AS strikeout_date,
				case when assess.strikeout_desc IS NULL THEN '' ELSE assess.strikeout_desc end as strikeout_reason,
				stda.include_signature_section_flag,
				case when assess_sec.complete='Y' and assess_sec.completed_title is not null then assess_sec.completed_by+', '+assess_sec.completed_title 
					when assess_sec.complete='Y' and assess_sec.completed_title is null then assess_sec.completed_by else '' end as signed_by,
				assess_sec.completed_date as signed_date
			, cust_hdr
			, cust_sub_hdr
			, cust_hdr_long
			, cust_sub_hdr_long
			, rownumber.value as rnum
			, NULL as unique_question
			, NULL as was_merge
			, '0' as print_s
			, NULL as ams_key
			, NULL as file_metadata_id
			, stdq.visual
			, NULL as ordr
			--,substring(resp.response,1,6)
			FROM #PRP_Assess_Filter af
			INNER JOIN dbo.as_std_assessment stda WITH (NOLOCK) ON stda.std_assess_id=af.std_assess_id
			INNER JOIN dbo.as_assessment assess WITH (NOLOCK) ON assess.assess_id=af.assess_id
			LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id
			LEFT JOIN dbo.as_assessment_section assess_sec WITH (NOLOCK) ON assess.assess_id=assess_sec.assess_id AND stds.section_code=assess_sec.section_code
			INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON stda.std_assess_id=stdq.std_assess_id AND stds.section_code=stdq.section_code
			left OUTER JOIN dbo.as_response rs WITH (NOLOCK) ON rs.assess_id = af.assess_id
																and rs.question_key = stdq.question_key 

			OUTER APPLY		(SELECT num - 1 FROM pcc_num_sequence WHERE num <= stdq.length) rownumber ([value])

			OUTER APPLY		(SELECT stuff(isnull(response_str,''),1, len(@vSeparator),'') as response     
                              FROM	
                                    (SELECT  @vSeparator + ltrim(rtrim(
												CASE CASE WHEN isnumeric(substring(question_key, 2, 1)) = 1	-- case of column (a,b,c,etc.) in grid
														  THEN left(question_key, 1)
														  ELSE left(question_key, 2)
													  END
												WHEN 'a' THEN CASE WHEN bdy_site.description is null then resp.item_value else bdy_site.description end
												WHEN 'b' THEN CASE WHEN bdy_type.description is null then resp.item_value else bdy_type.description end
												WHEN 'f' THEN CASE WHEN bdy_stage.description is null then resp.item_value else bdy_stage.description end
												WHEN 'aa' then resp.item_value
												WHEN 'bb' then resp.item_value
												ELSE resp.item_value 
												END
																)	)
                                          FROM dbo.as_response resp WITH (NOLOCK)
										LEFT JOIN @prp_body_site bdy_site ON convert(varchar, bdy_site.body_site_id) = resp.item_value
										LEFT JOIN @prp_body_type bdy_type ON convert(varchar, bdy_type.body_type_id) = resp.item_value
										LEFT JOIN @prp_body_stage bdy_stage ON convert(varchar, bdy_stage.body_stage_id) =  resp.item_value 
                                          WHERE		assess.assess_id = resp.assess_id 
												and resp.question_key LIKE '%' + stdq.question_key
												and resp.question_key <> stdq.question_key
												and ((@vshort_version IS NULL or @vshort_version = 0) 
														OR (@vshort_version = 1 and( stdq.control_type = 'bdy' and  (bdy_site.description IS NOT NULL  or resp.item_value is NOT NULL))  OR stdq.control_type = 'gbdy'))
												and ((@vshort_version IS NULL or @vshort_version = 0) 
														OR (@vshort_version = 1 and ( stdq.control_type = 'bdy' and (bdy_type.description IS NOT NULL or resp.item_value is NOT NULL))  OR stdq.control_type = 'gbdy'))
												and ((@vshort_version IS NULL or @vshort_version = 0) 
														OR (@vshort_version = 1 and ( stdq.control_type = 'bdy' and (bdy_stage.description IS NOT NULL or resp.item_value is NOT NULL))  or stdq.control_type = 'gbdy'))

												AND  rownumber.[value] =  CASE WHEN isnumeric(substring(question_key, 2, 1)) = 1
																			   THEN case when isnumeric(substring(question_key, 2, charindex('_', question_key) - 2))= 1 then substring(question_key, 2, charindex('_', question_key) - 2) else 0 end
																			   ELSE case when isnumeric(substring(question_key, 3, charindex('_', question_key) - 3))= 1 then substring(question_key, 3, charindex('_', question_key) - 3) else 0 end
																		  END
	
                                          ORDER BY convert(int, CASE WHEN isnumeric(substring(question_key, 2, 1)) = 1
																			   THEN case when isnumeric(substring(question_key, 2, charindex('_', question_key) - 2))= 1 then substring(question_key, 2, charindex('_', question_key) - 2) else 0 end
																			   ELSE case when isnumeric(substring(question_key, 3, charindex('_', question_key) - 3))= 1 then substring(question_key, 3, charindex('_', question_key) - 3) else 0 end
																		  END )
												 , CASE WHEN isnumeric(substring(question_key, 2, 1)) = 1
													    THEN ' ' + left(question_key, 1)
													    ELSE left(question_key, 2)
												   END
                                          FOR XML PATH ('')
                                    ) ans (response_str)
                              )resp

			LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON stdq.std_assess_id=stdqg.std_assess_id and stdq.section_code=stdqg.section_code and stdq.std_question_no=stdqg.std_question_no
				AND stds.section_code=stdqg.section_code
			LEFT JOIN dbo.as_std_assess_type asstype WITH (NOLOCK) ON assess.std_assess_id = asstype.std_assess_id AND assess.assess_type_code = asstype.assess_type_code 

			LEFT JOIN dbo.as_std_score stdscore  WITH (NOLOCK) ON 
								stda.std_assess_id = stdscore.std_assess_id
							AND stdscore.is_default = 'Y'
							AND stdscore.deleted = 'N'

			LEFT JOIN dbo.as_assessment_score score WITH (NOLOCK) ON 
						score.assess_id = assess.assess_id
							AND score.std_score_id = stdscore.std_score_id
		
			-- hide/show  or parent/child question
			left outer join #prp_ShowHideDisable_rules cr
				on stdq.question_key = cr.question_key_obj

			left OUTER JOIN #PRP_as_response asr_split
				ON af.assess_id = asr_split.assess_id 
				and asr_split.question_key = cr.question_key_sbj

			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
										WHERE		af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
								  ) AS cust_hdr 
						) custom_header
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
												ascr.assess_id = af.assess_id
											AND ascr.std_score_id = stds.std_score_id
										where	af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
									) AS cust_sub_hdr
						) custom_sub_header
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
														ascr.assess_id = af.assess_id
													AND ascr.std_score_id = stds.std_score_id
											WHERE		af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
											where	af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long

			WHERE 
					(	stdq.control_type = 'bdy' 
					OR	stdq.control_type = 'gbdy')
					and ((@vshort_version IS NULL OR @vshort_version = 0) 
							OR @vshort_version = 1 and (resp.response IS NOT null and substring(resp.response,1,6) <> @vSeparator))
				
				and
				-- show hide and disabled question
				1 = ( case when 
									cr.enabled_flag = 'Y' 
									and  @vincl_disabled_qs = 0				-- assessment flag "By Default Include Disabled Questions in Report"
									and isnull(cr.item_id, '') = 4102		-- disabled question
									and  cr.range1 = asr_split.first_val	-- value that triggers rule equal response value
								then 0 

								when cr.enabled_flag = 'Y' and not cr.control_type in ('pulse','we','bp','resp','bs','o2','he', 'temp','pnl', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null or ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.item_value))) then 0
								
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pulse','we','resp','bs','o2','he', 'temp', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)

											) then 0
							-- pain level
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pnl')  
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or ( ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.first_val)))
										
											) then 0

								-- blood pressure
								when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'sys'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)
										
											) then 0
									when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'dias'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.second_val)
														or convert(float,cr.range1) > convert(float,asr_split.second_val)
													)
										
											) then 0

								else 1 end
					)

		set @vStep = 123
		set @vgsStepStartTime=GETDATE()
		if @debug_me='Y' Print 'Step ' + convert(varchar(10),@vStep) + ' ebdy parts insert new body diagram for UK' 
		if @debug_me='Y' SELECT * from #PRP_Results

	-- Add in Body Part controls (originally for layout_style = 'V', 'PV', or 'C1', this is now for all bdy and gbdy)
			INSERT INTO #PRP_Results
			SELECT 
				assess.fac_id,
				stda.std_assess_id,
				assess.client_id,
				assess.assess_id,
				assess.assess_date, 
				asstype.description as assessment_type, 
				stda.description as UDA,
				stds.title as section_title,
				stds.sequence as section_sequence,
				stdqg.std_question_no,
				stdqg.group_title,
				stdqg.group_text,
				stdqg.layout_style,
				stds.section_code,
				stdq.question_key,
				stdq.sequence,
				stdq.std_question_no,
				stdq.std_subquestion_no,
				stdq.std_subquestion_AB,
				stdq.title,
				stdq.question_text,
				stdq.control_type,
				stdq.length,
				stdq.required,
				stdq.pick_list_id,
				NULL as picklist_name,		-- null for bdy/gbdy control
				NULL AS item_value,			-- null for bdy/gbdy control
				NULL AS item_description,	-- null for bdy/gbdy control
				NULL AS sequence,			-- null for bdy/gbdy control
				NULL AS effective_date,		-- null for bdy/gbdy control
				NULL AS ineffective_date,	-- null for bdy/gbdy control
				assess.assess_type_code,
				assess.status,
				NULL as resp_item_value,	-- null for bdy/gbdy control
				resp.response as response,
				score.score,
				score.category as score_category,
				case when assess.strikeout_flag is null then 'N' else assess.strikeout_flag END as strikeout_flag,
				case when assess.strikeout_by IS NULL THEN '' ELSE assess.strikeout_by end as strikeout_by,
				dbo.fn_adjust_time_fac_time_zone(@vFacId, assess.strikeout_date)AS strikeout_date,
				case when assess.strikeout_desc IS NULL THEN '' ELSE assess.strikeout_desc end as strikeout_reason,
				stda.include_signature_section_flag,
				case when assess_sec.complete='Y' and assess_sec.completed_title is not null then assess_sec.completed_by+', '+assess_sec.completed_title 
					when assess_sec.complete='Y' and assess_sec.completed_title is null then assess_sec.completed_by else '' end as signed_by,
				assess_sec.completed_date as signed_date
			, cust_hdr
			, cust_sub_hdr
			, cust_hdr_long
			, cust_sub_hdr_long
			, rownumber.value as rnum
			, NULL as unique_question
			, NULL as was_merge
			, '0' as print_s
			, NULL as ams_key
			, NULL as file_metadata_id
			, stdq.visual
			, NULL as ordr
			--,substring(resp.response,1,6)
			FROM #PRP_Assess_Filter af
			INNER JOIN dbo.as_std_assessment stda WITH (NOLOCK) ON stda.std_assess_id=af.std_assess_id
			INNER JOIN dbo.as_assessment assess WITH (NOLOCK) ON assess.assess_id=af.assess_id
			LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id
			LEFT JOIN dbo.as_assessment_section assess_sec WITH (NOLOCK) ON assess.assess_id=assess_sec.assess_id AND stds.section_code=assess_sec.section_code
			INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON stda.std_assess_id=stdq.std_assess_id AND stds.section_code=stdq.section_code
			left OUTER JOIN dbo.as_response rs WITH (NOLOCK) ON rs.assess_id = af.assess_id
																and rs.question_key = stdq.question_key 

			OUTER APPLY		(SELECT num - 1 FROM pcc_num_sequence WHERE num <= stdq.length) rownumber ([value])

			OUTER APPLY		(SELECT stuff(isnull(response_str,''),1, len(@vSeparator),'') as response     
                              FROM	
                                    (SELECT  @vSeparator + ltrim(rtrim(
												CASE CASE WHEN isnumeric(substring(question_key, 2, 1)) = 1	-- case of column (a,b,c,etc.) in grid
														  THEN left(question_key, 1)
														  ELSE left(question_key, 2)
													  END
												WHEN 'a' THEN CASE WHEN bdy_site.description is null then resp.item_value else bdy_site.description end
												WHEN 'b' THEN CASE WHEN bdy_type.description is null then resp.item_value else bdy_type.description end
												WHEN 'f' THEN CASE WHEN bdy_stage.description is null then resp.item_value else bdy_stage.description end
												WHEN 'aa' then resp.item_value
												WHEN 'bb' then resp.item_value
												ELSE resp.item_value 
												END
																)	)
                                          FROM dbo.as_response resp WITH (NOLOCK)
										LEFT JOIN @prp_body_site bdy_site ON convert(varchar, bdy_site.body_site_id) = resp.item_value
										LEFT JOIN @prp_body_type bdy_type ON convert(varchar, bdy_type.body_type_id) = resp.item_value
										LEFT JOIN @prp_body_stage_egbdy bdy_stage ON convert(varchar, bdy_stage.body_stage_id) =  resp.item_value 
                                          WHERE		assess.assess_id = resp.assess_id 
												and resp.question_key LIKE '%' + stdq.question_key
												and resp.question_key <> stdq.question_key
												and ((@vshort_version IS NULL or @vshort_version = 0) 
														OR (@vshort_version = 1 and( stdq.control_type = 'ebdy' and  (bdy_site.description IS NOT NULL  or resp.item_value is NOT NULL))  ))
												and ((@vshort_version IS NULL or @vshort_version = 0) 
														OR (@vshort_version = 1 and ( stdq.control_type = 'ebdy' and (bdy_type.description IS NOT NULL or resp.item_value is NOT NULL))  ))
												and ((@vshort_version IS NULL or @vshort_version = 0) 
														OR (@vshort_version = 1 and ( stdq.control_type = 'ebdy' and (bdy_stage.description IS NOT NULL or resp.item_value is NOT NULL))  ))

												AND  rownumber.[value] =  CASE WHEN isnumeric(substring(question_key, 2, 1)) = 1
																			   THEN case when isnumeric(substring(question_key, 2, charindex('_', question_key) - 2))= 1 then substring(question_key, 2, charindex('_', question_key) - 2) else 0 end
																			   ELSE case when isnumeric(substring(question_key, 3, charindex('_', question_key) - 3))= 1 then substring(question_key, 3, charindex('_', question_key) - 3) else 0 end
																		  END
	
                                          ORDER BY convert(int, CASE WHEN isnumeric(substring(question_key, 2, 1)) = 1
																			   THEN case when isnumeric(substring(question_key, 2, charindex('_', question_key) - 2))= 1 then substring(question_key, 2, charindex('_', question_key) - 2) else 0 end
																			   ELSE case when isnumeric(substring(question_key, 3, charindex('_', question_key) - 3))= 1 then substring(question_key, 3, charindex('_', question_key) - 3) else 0 end
																		  END )
												 , CASE WHEN isnumeric(substring(question_key, 2, 1)) = 1
													    THEN ' ' + left(question_key, 1)
													    ELSE left(question_key, 2)
												   END
                                          FOR XML PATH ('')
                                    ) ans (response_str)
                              )resp

			LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON stdq.std_assess_id=stdqg.std_assess_id and stdq.section_code=stdqg.section_code and stdq.std_question_no=stdqg.std_question_no
				AND stds.section_code=stdqg.section_code
			LEFT JOIN dbo.as_std_assess_type asstype WITH (NOLOCK) ON assess.std_assess_id = asstype.std_assess_id AND assess.assess_type_code = asstype.assess_type_code 

			LEFT JOIN dbo.as_std_score stdscore  WITH (NOLOCK) ON 
								stda.std_assess_id = stdscore.std_assess_id
							AND stdscore.is_default = 'Y'
							AND stdscore.deleted = 'N'

			LEFT JOIN dbo.as_assessment_score score WITH (NOLOCK) ON 
						score.assess_id = assess.assess_id
							AND score.std_score_id = stdscore.std_score_id
		
			-- hide/show  or parent/child question
					left outer join #prp_ShowHideDisable_rules cr
			on stdq.question_key = cr.question_key_obj

			left OUTER JOIN #PRP_as_response asr_split
				ON af.assess_id = asr_split.assess_id 
				and asr_split.question_key = cr.question_key_sbj

			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
										WHERE		af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
								  ) AS cust_hdr 
						) custom_header
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
												ascr.assess_id = af.assess_id
											AND ascr.std_score_id = stds.std_score_id
										where	af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
									) AS cust_sub_hdr
						) custom_sub_header
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
														ascr.assess_id = af.assess_id
													AND ascr.std_score_id = stds.std_score_id
											WHERE		af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
											where	af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long

			WHERE 
					(	stdq.control_type = 'ebdy' 
					)
					and ((@vshort_version IS NULL OR @vshort_version = 0) 
							OR @vshort_version = 1 and (resp.response IS NOT null and substring(resp.response,1,6) <> @vSeparator))
				
				and
				-- show hide and disabled question
				1 = ( case when 
									cr.enabled_flag = 'Y' 
									and  @vincl_disabled_qs = 0				-- assessment flag "By Default Include Disabled Questions in Report"
									and isnull(cr.item_id, '') = 4102		-- disabled question
									and  cr.range1 = asr_split.first_val	-- value that triggers rule equal response value
								then 0 

								when cr.enabled_flag = 'Y' and not cr.control_type in ('pulse','we','bp','resp','bs','o2','he', 'temp','pnl', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null or ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.item_value))) then 0
								
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pulse','we','resp','bs','o2','he', 'temp', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)

											) then 0
							-- pain level
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pnl')  
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or ( ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.first_val)))
										
											) then 0

								-- blood pressure
								when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'sys'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)
										
											) then 0
									when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'dias'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.second_val)
														or convert(float,cr.range1) > convert(float,asr_split.second_val)
													)
										
											) then 0

								else 1 end
					)

			set @vRowCount = @vRowCount + @@rowcount
			set @vStep = 125
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'Step ' + convert(varchar(10),@vStep) + ' tansfer discharge insert' 

	-- Add in Transfer/Discharge Details controls
			INSERT INTO #PRP_Results
			SELECT 
				assess.fac_id,
				stda.std_assess_id,
				assess.client_id,
				assess.assess_id,
				assess.assess_date, 
				asstype.description as assessment_type, 
				stda.description as UDA,
				stds.title as section_title,
				stds.sequence as section_sequence,
				stdqg.std_question_no,
				stdqg.group_title,
				stdqg.group_text,
				stdqg.layout_style,
				stds.section_code,
				stdq.question_key,
				stdq.sequence,
				stdq.std_question_no,
				stdq.std_subquestion_no,
				stdq.std_subquestion_AB,
				stdq.title,
				stdq.question_text,
				stdq.control_type,
				stdq.length,
				stdq.required,
				stdq.pick_list_id,
				NULL as picklist_name,		-- null for to control
				NULL AS item_value,			-- null for to control
				NULL AS item_description,	-- null for to control
				NULL AS sequence,			-- null for to control
				NULL AS effective_date,		-- null for to control
				NULL AS ineffective_date,	-- null for to control
				assess.assess_type_code,
				assess.status,
				NULL as resp_item_value,	-- null for bdy/gbdy control
				resp.response as response,
				score.score,
				score.category as score_category,
				case when assess.strikeout_flag is null then 'N' else assess.strikeout_flag END as strikeout_flag,
				case when assess.strikeout_by IS NULL THEN '' ELSE assess.strikeout_by end as strikeout_by,
				dbo.fn_adjust_time_fac_time_zone(@vFacId, assess.strikeout_date)AS strikeout_date,
				case when assess.strikeout_desc IS NULL THEN '' ELSE assess.strikeout_desc end as strikeout_reason,
				stda.include_signature_section_flag,
				case when assess_sec.complete='Y' and assess_sec.completed_title is not null then assess_sec.completed_by+', '+assess_sec.completed_title 
					when assess_sec.complete='Y' and assess_sec.completed_title is null then assess_sec.completed_by else '' end as signed_by,
				assess_sec.completed_date as signed_date
			, cust_hdr
			, cust_sub_hdr
			, cust_hdr_long
			, cust_sub_hdr_long
			, NULL as rnum
			, NULL as unique_question
			, NULL as was_merge
			, '0' as print_s
			, NULL as ams_key
			, NULL as file_metadata_id
			, stdq.visual
			, NULL as ordr
			FROM #PRP_Assess_Filter af
			INNER JOIN dbo.as_std_assessment stda WITH (NOLOCK) ON stda.std_assess_id=af.std_assess_id
			INNER JOIN dbo.as_assessment assess WITH (NOLOCK) ON assess.assess_id=af.assess_id
			LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id
			LEFT JOIN dbo.as_assessment_section assess_sec WITH (NOLOCK) ON assess.assess_id=assess_sec.assess_id AND stds.section_code=assess_sec.section_code
			INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON stda.std_assess_id=stdq.std_assess_id AND stds.section_code=stdq.section_code
			OUTER APPLY		(SELECT stuff(isnull(response_str,''),1, len(@vSeparator),'') as response     
                              FROM	
                                    (SELECT  @vSeparator + ltrim(rtrim(
												CASE replace(resp.question_key, stdq.question_key + '_', '')
													-- sent to
													WHEN '1' THEN CASE WHEN isnumeric(resp.item_value) = 1 THEN CASE WHEN convert(int, resp.item_value) > 0 THEN sent_to_int.item_description ELSE sent_to_ext.name END ELSE '' END
													-- unit
													WHEN '4' THEN CASE WHEN unit.unit_desc IS NULL THEN '' ELSE unit.unit_desc END
													-- reason
													WHEN '5' THEN CASE WHEN trf_reason.description IS NULL THEN '' ELSE trf_reason.description END
													-- hour
													WHEN '7' THEN CASE WHEN isnull(resp.item_value ,'') = '' THEN '' ELSE right('00' + resp.item_value, 2) END
													-- minute
													WHEN '8' THEN CASE WHEN isnull(resp.item_value ,'') = '' THEN '' ELSE right('00' + resp.item_value, 2) END
													-- date
													WHEN '2' THEN CASE WHEN isnull(resp.item_value ,'') = '' THEN '' ELSE convert(varchar(10),convert(date,resp.item_value), @vdateFormatStyle)  END

													-- all others ( 3=sent from, 6=sent type) get passed through without modification
													ELSE CASE WHEN resp.item_value IS NULL THEN '' ELSE resp.item_value END
												END
																)	)
                                          FROM dbo.as_response resp WITH (NOLOCK)
											LEFT JOIN dbo.common_code sent_to_int WITH (NOLOCK) ON replace(resp.question_key, stdq.question_key + '_', '') = '1' AND convert(varchar, sent_to_int.item_id) = resp.item_value
											LEFT JOIN dbo.emc_ext_facilities sent_to_ext WITH (NOLOCK) ON replace(resp.question_key, stdq.question_key + '_', '') = '1' AND convert(varchar, 0 - sent_to_ext.ext_fac_id) = resp.item_value
											LEFT JOIN dbo.unit WITH (NOLOCK) ON convert(varchar, unit.unit_id) = resp.item_value
											LEFT JOIN WESREFERENCE.dbo.admin_reason_for_transfer trf_reason WITH (NOLOCK) ON convert(varchar, trf_reason.reason_id) = resp.item_value
                                          WHERE		assess.assess_id = resp.assess_id 
												AND resp.question_key LIKE stdq.question_key + '%'
												and resp.question_key <> stdq.question_key
                                          ORDER BY replace(resp.question_key, stdq.question_key + '_', '')
                                          FOR XML PATH ('')
                                    ) ans (response_str)
                              )resp

			LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON stdq.std_assess_id=stdqg.std_assess_id and stdq.section_code=stdqg.section_code and stdq.std_question_no=stdqg.std_question_no
				AND stds.section_code=stdqg.section_code
			LEFT JOIN dbo.as_std_assess_type asstype WITH (NOLOCK) ON assess.std_assess_id = asstype.std_assess_id AND assess.assess_type_code = asstype.assess_type_code 

			LEFT JOIN dbo.as_std_score stdscore  WITH (NOLOCK) ON 
								stda.std_assess_id = stdscore.std_assess_id
							AND stdscore.is_default = 'Y'
							AND stdscore.deleted = 'N'

			LEFT JOIN dbo.as_assessment_score score WITH (NOLOCK) ON 
						score.assess_id = assess.assess_id
							AND score.std_score_id = stdscore.std_score_id
			-- hide/show  or parent/child question
					left outer join #prp_ShowHideDisable_rules cr
			on stdq.question_key = cr.question_key_obj

			left OUTER JOIN #PRP_as_response asr_split
				ON af.assess_id = asr_split.assess_id 
				and asr_split.question_key = cr.question_key_sbj

			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
										WHERE		af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
								  ) AS cust_hdr 
						) custom_header
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
												ascr.assess_id = af.assess_id
											AND ascr.std_score_id = stds.std_score_id
										where	af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
									) AS cust_sub_hdr
						) custom_sub_header
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
														ascr.assess_id = af.assess_id
													AND ascr.std_score_id = stds.std_score_id
											WHERE		af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
											where	af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long

			WHERE 
					stdq.control_type = 'to'
				
				and
				-- show hide and disabled question
				1 = ( case when 
									cr.enabled_flag = 'Y' 
									and  @vincl_disabled_qs = 0				-- assessment flag "By Default Include Disabled Questions in Report"
									and isnull(cr.item_id, '') = 4102		-- disabled question
									and  cr.range1 = asr_split.first_val	-- value that triggers rule equal response value
								then 0 

								when cr.enabled_flag = 'Y' and not cr.control_type in ('pulse','we','bp','resp','bs','o2','he', 'temp','pnl', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null or ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.item_value))) then 0
								
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pulse','we','resp','bs','o2','he', 'temp', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)

											) then 0
							-- pain level
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pnl')  
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or ( ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.first_val)))
										
											) then 0

								-- blood pressure
								when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'sys'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)
										
											) then 0
									when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'dias'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.second_val)
														or convert(float,cr.range1) > convert(float,asr_split.second_val)
													)
										
											) then 0

								else 1 end
					)

			set @vRowCount = @vRowCount + @@rowcount

		set @vStep = 126
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'Step ' + convert(varchar(10),@vStep) + ' advance directives insert' 

	-- Add in Advance Directive control
			INSERT INTO #PRP_Results
			SELECT 
				assess.fac_id,
				stda.std_assess_id,
				assess.client_id,
				assess.assess_id,
				assess.assess_date, 
				asstype.description as assessment_type, 
				stda.description as UDA,
				stds.title as section_title,
				stds.sequence as section_sequence,
				stdqg.std_question_no,
				stdqg.group_title,
				stdqg.group_text,
				stdqg.layout_style,
				stds.section_code,
				stdq.question_key,
				stdq.sequence,
				stdq.std_question_no,
				stdq.std_subquestion_no,
				stdq.std_subquestion_AB,
				stdq.title,
				stdq.question_text,
				stdq.control_type,
				stdq.length,
				stdq.required,
				stdq.pick_list_id,
				NULL as picklist_name,		-- null for adir control
				NULL AS item_value,			-- null for adir control
				NULL AS item_description,	-- null for adir control
				NULL AS sequence,			-- null for adir control
				NULL AS effective_date,		-- null for adir control
				NULL AS ineffective_date,	-- null for adir control
				assess.assess_type_code,
				assess.status,
				NULL as resp_item_value,	-- null for bdy/gbdy control
				resp.response as response,
				score.score,
				score.category as score_category,
				case when assess.strikeout_flag is null then 'N' else assess.strikeout_flag END as strikeout_flag,
				case when assess.strikeout_by IS NULL THEN '' ELSE assess.strikeout_by end as strikeout_by,
				dbo.fn_adjust_time_fac_time_zone(@vFacId, assess.strikeout_date)AS strikeout_date,
				case when assess.strikeout_desc IS NULL THEN '' ELSE assess.strikeout_desc end as strikeout_reason,
				stda.include_signature_section_flag,
				case when assess_sec.complete='Y' and assess_sec.completed_title is not null then assess_sec.completed_by+', '+assess_sec.completed_title 
					when assess_sec.complete='Y' and assess_sec.completed_title is null then assess_sec.completed_by else '' end as signed_by,
				assess_sec.completed_date as signed_date
			, cust_hdr
			, cust_sub_hdr
			, cust_hdr_long
			, cust_sub_hdr_long
			, NULL as rnum
			, NULL as unique_question
			, NULL as was_merge
			, '0' as print_s
			, NULL as ams_key
			, NULL as file_metadata_id
			, stdq.visual
			, NULL as ordr
			FROM #PRP_Assess_Filter af
			INNER JOIN dbo.as_std_assessment stda WITH (NOLOCK) ON stda.std_assess_id=af.std_assess_id
			INNER JOIN dbo.as_assessment assess WITH (NOLOCK) ON assess.assess_id=af.assess_id
			LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id
			LEFT JOIN dbo.as_assessment_section assess_sec WITH (NOLOCK) ON assess.assess_id=assess_sec.assess_id AND stds.section_code=assess_sec.section_code
			INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON stda.std_assess_id=stdq.std_assess_id AND stds.section_code=stdq.section_code
			OUTER APPLY		(SELECT stuff(isnull(response_str,''),1, len(@vSeparator),'') as response     
                              FROM	(
									 SELECT  @vSeparator + ltrim(rtrim(description + @vSeparator + CASE WHEN items IS NULL THEN '0' ELSE '1' END ))
									 FROM wesreference.dbo.pho_std_advanced_directive adir WITH (NOLOCK)
									 LEFT JOIN dbo.split((SELECT item_value FROM dbo.as_response resp2 WITH (NOLOCK) 
														  WHERE resp2.assess_id = af.assess_id
															AND resp2.question_key = stdq.question_key), '~') picked
										  ON convert(varchar, adir.std_advanced_directive_id) = picked.items
                                          FOR XML PATH ('')
                                    ) ans (response_str)
                             )resp

			LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON stdq.std_assess_id=stdqg.std_assess_id and stdq.section_code=stdqg.section_code and stdq.std_question_no=stdqg.std_question_no
				AND stds.section_code=stdqg.section_code
			LEFT JOIN dbo.as_std_assess_type asstype WITH (NOLOCK) ON assess.std_assess_id = asstype.std_assess_id AND assess.assess_type_code = asstype.assess_type_code 

			LEFT JOIN dbo.as_std_score stdscore  WITH (NOLOCK) ON 
								stda.std_assess_id = stdscore.std_assess_id
							AND stdscore.is_default = 'Y'
							AND stdscore.deleted = 'N'

			LEFT JOIN dbo.as_assessment_score score WITH (NOLOCK) ON 
						score.assess_id = assess.assess_id
							AND score.std_score_id = stdscore.std_score_id
			-- hide/show  or parent/child question
					left outer join #prp_ShowHideDisable_rules cr
			on stdq.question_key = cr.question_key_obj

			left OUTER JOIN #PRP_as_response asr_split
				ON af.assess_id = asr_split.assess_id 
				and asr_split.question_key = cr.question_key_sbj

			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
										WHERE		af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
								  ) AS cust_hdr 
						) custom_header
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
												ascr.assess_id = af.assess_id
											AND ascr.std_score_id = stds.std_score_id
										where	af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
									) AS cust_sub_hdr
						) custom_sub_header
				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
														ascr.assess_id = af.assess_id
													AND ascr.std_score_id = stds.std_score_id
											WHERE		af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
											where	af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long

			WHERE 
					stdq.control_type = 'adir'
				
				and
				-- show hide and disabled question
				1 = ( case when 
									cr.enabled_flag = 'Y' 
									and  @vincl_disabled_qs = 0				-- assessment flag "By Default Include Disabled Questions in Report"
									and isnull(cr.item_id, '') = 4102		-- disabled question
									and  cr.range1 = asr_split.first_val	-- value that triggers rule equal response value
								then 0 

								when cr.enabled_flag = 'Y' and not cr.control_type in ('pulse','we','bp','resp','bs','o2','he', 'temp','pnl', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null or ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.item_value))) then 0
								
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pulse','we','resp','bs','o2','he', 'temp', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)

											) then 0
							-- pain level
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pnl')  
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or ( ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.first_val)))
										
											) then 0

								-- blood pressure
								when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'sys'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)
										
											) then 0
									when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'dias'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.second_val)
														or convert(float,cr.range1) > convert(float,asr_split.second_val)
													)
										
											) then 0

								else 1 end
					)

			set @vRowCount = @vRowCount + @@rowcount

		set @vStep = 130
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'Step ' + convert(varchar(10),@vStep) + ' resident contact insert' 

	-- Add in Resident Contacts control
			INSERT INTO #PRP_Results
			SELECT 
				assess.fac_id,
				stda.std_assess_id,
				assess.client_id,
				assess.assess_id,
				assess.assess_date, 
				asstype.description as assessment_type, 
				stda.description as UDA,
				stds.title as section_title,
				stds.sequence as section_sequence,
				stdqg.std_question_no,
				stdqg.group_title,
				stdqg.group_text,
				stdqg.layout_style,
				stds.section_code,
				stdq.question_key,
				stdq.sequence,
				stdq.std_question_no,
				stdq.std_subquestion_no,
				stdq.std_subquestion_AB,
				stdq.title,
				stdq.question_text,
				stdq.control_type,
				stdq.length,
				stdq.required,
				stdq.pick_list_id,
				NULL as picklist_name,		-- null for cnt control
				NULL AS item_value,			-- null for cnt control
				NULL AS item_description,	-- null for cnt control
				NULL AS sequence,			-- null for cnt control
				NULL AS effective_date,		-- null for cnt control
				NULL AS ineffective_date,	-- null for cnt control
				assess.assess_type_code,
				assess.status,
				NULL as resp_item_value,	-- null for bdy/gbdy control
				resp.response as response,
				score.score,
				score.category as score_category,
				case when assess.strikeout_flag is null then 'N' else assess.strikeout_flag END as strikeout_flag,
				case when assess.strikeout_by IS NULL THEN '' ELSE assess.strikeout_by end as strikeout_by,
				dbo.fn_adjust_time_fac_time_zone(@vFacId, assess.strikeout_date)AS strikeout_date,
				case when assess.strikeout_desc IS NULL THEN '' ELSE assess.strikeout_desc end as strikeout_reason,
				stda.include_signature_section_flag,
				case when assess_sec.complete='Y' and assess_sec.completed_title is not null then assess_sec.completed_by+', '+assess_sec.completed_title 
					when assess_sec.complete='Y' and assess_sec.completed_title is null then assess_sec.completed_by else '' end as signed_by,
				assess_sec.completed_date as signed_date
			, cust_hdr
			, cust_sub_hdr
			, cust_hdr_long
			, cust_sub_hdr_long
			, NULL as rnum
			, NULL as unique_question
			, NULL as was_merge
			, '0' as print_s
			, NULL as ams_key
			, NULL as file_metadata_id
			, stdq.visual
			, NULL as ordr
			FROM #PRP_Assess_Filter af
			INNER JOIN dbo.as_std_assessment stda WITH (NOLOCK) ON stda.std_assess_id=af.std_assess_id
			INNER JOIN dbo.as_assessment assess WITH (NOLOCK) ON assess.assess_id=af.assess_id
			LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id
			LEFT JOIN dbo.as_assessment_section assess_sec WITH (NOLOCK) ON assess.assess_id=assess_sec.assess_id AND stds.section_code=assess_sec.section_code
			INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON stda.std_assess_id=stdq.std_assess_id AND stds.section_code=stdq.section_code
			OUTER APPLY		(SELECT stuff(isnull(response_str,''),1, len(@vSeparator),'') as response     
                              FROM	(
										SELECT ( 
												SELECT @vSeparator + item_value FROM as_response resp WITH (NOLOCK)
												WHERE resp.question_key LIKE stdq.question_key + '_[^ct_]%'
												  AND resp.assess_id = af.assess_id
												FOR XML PATH ('')
												) + (
												SELECT  @vSeparator + ltrim(rtrim(c_type.description + @vSeparator + CASE WHEN ISNULL(resp.item_value, '') = '' THEN '0' ELSE '1' END ))
												FROM wesreference.dbo.common_code_standard_contact_type c_type WITH (NOLOCK)
												LEFT JOIN as_response resp WITH (NOLOCK) ON convert(varchar, c_type.item_id) = replace(resp.question_key, stdq.question_key + '_ct_', '')
												WHERE resp.assess_id = af.assess_id 
												AND   resp.question_key LIKE stdq.question_key + '_ct_%'
												ORDER BY c_type.item_id
												FOR XML PATH ('')
												)
                                    ) ans (response_str)
                             )resp

			LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON stdq.std_assess_id=stdqg.std_assess_id and stdq.section_code=stdqg.section_code and stdq.std_question_no=stdqg.std_question_no
				AND stds.section_code=stdqg.section_code
			LEFT JOIN dbo.as_std_assess_type asstype WITH (NOLOCK) ON assess.std_assess_id = asstype.std_assess_id AND assess.assess_type_code = asstype.assess_type_code 

			LEFT JOIN dbo.as_std_score stdscore  WITH (NOLOCK) ON 
								stda.std_assess_id = stdscore.std_assess_id
							AND stdscore.is_default = 'Y'
							AND stdscore.deleted = 'N'

			LEFT JOIN dbo.as_assessment_score score WITH (NOLOCK) ON 
						score.assess_id = assess.assess_id
							AND score.std_score_id = stdscore.std_score_id
			-- hide/show  or parent/child question
					left outer join #prp_ShowHideDisable_rules cr
			on stdq.question_key = cr.question_key_obj

			left OUTER JOIN #PRP_as_response asr_split
				ON af.assess_id = asr_split.assess_id 
				and asr_split.question_key = cr.question_key_sbj

			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
										WHERE		af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
								  ) AS cust_hdr 
						) custom_header
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
												ascr.assess_id = af.assess_id
											AND ascr.std_score_id = stds.std_score_id
										where	af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
									) AS cust_sub_hdr
						) custom_sub_header
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
														ascr.assess_id = af.assess_id
													AND ascr.std_score_id = stds.std_score_id
											WHERE		af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
											where	af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long

			WHERE 
					stdq.control_type = 'cnt'
				
			and
				-- show hide and disabled question
				1 = ( case when 
									cr.enabled_flag = 'Y' 
									and  @vincl_disabled_qs = 0				-- assessment flag "By Default Include Disabled Questions in Report"
									and isnull(cr.item_id, '') = 4102		-- disabled question
									and  cr.range1 = asr_split.first_val	-- value that triggers rule equal response value
								then 0 

								when cr.enabled_flag = 'Y' and not cr.control_type in ('pulse','we','bp','resp','bs','o2','he', 'temp','pnl', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null or ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.item_value))) then 0
								
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pulse','we','resp','bs','o2','he', 'temp', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)

											) then 0
							-- pain level
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pnl')  
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or ( ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.first_val)))
										
											) then 0

								-- blood pressure
								when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'sys'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)
										
											) then 0
									when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'dias'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.second_val)
														or convert(float,cr.range1) > convert(float,asr_split.second_val)
													)
										
											) then 0

								else 1 end
					)

			set @vRowCount = @vRowCount + @@rowcount


		set @vStep = 135
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'Step ' + convert(varchar(10),@vStep) + ' hck insert' 

	-- Add in hck control
			INSERT INTO #PRP_Results
			SELECT 
				  assess.fac_id
				, stda.std_assess_id
				, assess.client_id
				, assess.assess_id
				, assess.assess_date
				, asstype.description as assessment_type
				, stda.description as UDA
				, stds.title as section_title
				, stds.sequence as section_sequence
				, stdqg.std_question_no
				, stdqg.group_title
				, stdqg.group_text
				, stdqg.layout_style
				, stds.section_code
				, stdq.question_key
				, stdq.sequence
				, stdq.std_question_no
				, stdq.std_subquestion_no
				, stdq.std_subquestion_AB
				, stdq.title
				, stdq.question_text
				, stdq.control_type
				, stdq.length
				, stdq.required
				, stdq.pick_list_id
				, NULL as picklist_name
				, pick_list.[value] AS pick_list_value
				, NULL AS item_description
				, NULL AS sequence
				, NULL AS effective_date
				, NULL AS ineffective_date
				, assess.assess_type_code
				, assess.status
				, CASE WHEN resp.item_value IS NULL THEN '' ELSE resp.item_value END AS resp_item_value
				, CASE WHEN resp.item_value IS NULL THEN '' ELSE resp.item_value END AS response
				, score.score
				, score.category as score_category
				, case when assess.strikeout_flag is null then 'N' else assess.strikeout_flag END as strikeout_flag
				, case when assess.strikeout_by IS NULL THEN '' ELSE assess.strikeout_by end as strikeout_by
				, dbo.fn_adjust_time_fac_time_zone(@vFacId, assess.strikeout_date)AS strikeout_date
				, case when assess.strikeout_desc IS NULL THEN '' ELSE assess.strikeout_desc end as strikeout_reason
				, stda.include_signature_section_flag
				, case when assess_sec.complete='Y' and assess_sec.completed_title is not null then assess_sec.completed_by+', '+assess_sec.completed_title 
					when assess_sec.complete='Y' and assess_sec.completed_title is null then assess_sec.completed_by else '' end as signed_by
				, assess_sec.completed_date as signed_date
				, cust_hdr
				, cust_sub_hdr
				, cust_hdr_long
				, cust_sub_hdr_long
				, NULL as rnum
				, NULL as unique_question
				, NULL as was_merge
				, '0' as print_s
				, NULL as ams_key
				, NULL as file_metadata_id
				, stdq.visual
				, NULL as ordr
			FROM #PRP_Assess_Filter af
			INNER JOIN dbo.as_std_assessment stda WITH (NOLOCK) ON stda.std_assess_id=af.std_assess_id
			INNER JOIN dbo.as_assessment assess WITH (NOLOCK) ON assess.assess_id=af.assess_id
			LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id
			LEFT JOIN dbo.as_assessment_section assess_sec WITH (NOLOCK) ON assess.assess_id=assess_sec.assess_id AND stds.section_code=assess_sec.section_code
			INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON stda.std_assess_id=stdq.std_assess_id AND stds.section_code=stdq.section_code
			LEFT JOIN dbo.as_std_pick_list stdpl WITH (NOLOCK) ON 
									stdq.pick_list_id = stdpl.pick_list_id
								
			LEFT JOIN dbo.as_response resp WITH (NOLOCK) ON assess.assess_id=resp.assess_id and stdq.question_key=resp.question_key

			LEFT JOIN dbo.mirror_as_std_pick_list_item stdpli WITH (NOLOCK) ON 
									stdq.pick_list_id = stdpli.pick_list_id 
									and resp.item_value = stdpli.item_value 
			LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) 
				ON stdq.std_assess_id=stdqg.std_assess_id 
				and stdq.section_code=stdqg.section_code 
				and stdq.std_question_no=stdqg.std_question_no
				AND stds.section_code=stdqg.section_code
			OUTER APPLY		(SELECT stuff(isnull(pick_list_value,''), 1, len(@vSeparator), '') as [value]     
                              FROM	(
										SELECT @vSeparator + stdpli.item_value FROM dbo.as_std_pick_list stdpl WITH (NOLOCK)
										LEFT JOIN dbo.mirror_as_std_pick_list_item stdpli WITH (NOLOCK) ON 
													stdpl.pick_list_id=stdpli.pick_list_id 
												AND stdpli.item_description<>'Blank (skip pattern)'
												AND (resp.revision_date is null or resp.revision_date>=stdpli.effective_date )
												AND (resp.revision_date is null or resp.revision_date<=stdpli.ineffective_date OR stdpli.ineffective_date IS null)
										WHERE stdq.pick_list_id=stdpl.pick_list_id
											ORDER BY stdpli.sequence
										FOR XML PATH ('')
                                    ) plv (pick_list_value)
                             ) pick_list
			LEFT JOIN dbo.as_std_assess_type asstype WITH (NOLOCK) ON assess.std_assess_id = asstype.std_assess_id AND assess.assess_type_code = asstype.assess_type_code 

			LEFT JOIN dbo.as_std_score stdscore  WITH (NOLOCK) ON 
								stda.std_assess_id = stdscore.std_assess_id
							AND stdscore.is_default = 'Y'
							AND stdscore.deleted = 'N'

			LEFT JOIN dbo.as_assessment_score score WITH (NOLOCK) ON 
						score.assess_id = assess.assess_id
							AND score.std_score_id = stdscore.std_score_id

			LEFT JOIN dbo.mirror_as_std_pick_list_item plresp WITH (NOLOCK) ON 
									stdq.pick_list_id = plresp.pick_list_id 
								AND resp.item_value = plresp.item_value

			-- hide/show  or parent/child question
					left outer join #prp_ShowHideDisable_rules cr
			on stdq.question_key = cr.question_key_obj

			left OUTER JOIN #PRP_as_response asr_split
				ON af.assess_id = asr_split.assess_id 
				and asr_split.question_key = cr.question_key_sbj

			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
										WHERE		af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
								  ) AS cust_hdr 
						) custom_header
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
												ascr.assess_id = af.assess_id
											AND ascr.std_score_id = stds.std_score_id
										where	af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
									) AS cust_sub_hdr
						) custom_sub_header
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
														ascr.assess_id = af.assess_id
													AND ascr.std_score_id = stds.std_score_id
											WHERE		af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
											where	af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long

			WHERE stdq.control_type = 'hck'
					and ((@vshort_version = 1 and ((stdpl.pick_list_id is not NULL and stdpli.item_description= plresp.item_description)
					or isnull(resp.item_value,'') = '') OR stdpl.pick_list_id IS NULL )
					or @vshort_version = 0 OR @vshort_version is NULL)  
				
				and
				-- show hide and disabled question
				1 = ( case when 
									cr.enabled_flag = 'Y' 
									and  @vincl_disabled_qs = 0				-- assessment flag "By Default Include Disabled Questions in Report"
									and isnull(cr.item_id, '') = 4102		-- disabled question
									and  cr.range1 = asr_split.first_val	-- value that triggers rule equal response value
								then 0 

								when cr.enabled_flag = 'Y' and not cr.control_type in ('pulse','we','bp','resp','bs','o2','he', 'temp','pnl', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null or ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.item_value))) then 0
								
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pulse','we','resp','bs','o2','he', 'temp', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)

											) then 0
							-- pain level
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pnl')  
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or ( ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.first_val)))
										
											) then 0

								-- blood pressure
								when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'sys'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)
										
											) then 0
									when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'dias'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.second_val)
														or convert(float,cr.range1) > convert(float,asr_split.second_val)
													)
										
											) then 0

								else 1 end
					)

			set @vRowCount = @vRowCount + @@rowcount

		set @vStep = 140
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'Step ' + convert(varchar(10),@vStep) + ' ident insert' 

	-- Add in ident control
			INSERT INTO #PRP_Results
			SELECT 
				assess.fac_id,
				stda.std_assess_id,
				assess.client_id,
				assess.assess_id,
				assess.assess_date, 
				asstype.description as assessment_type, 
				stda.description as UDA,
				stds.title as section_title,
				stds.sequence as section_sequence,
				stdqg.std_question_no,
				stdqg.group_title,
				stdqg.group_text,
				stdqg.layout_style,
				stds.section_code,
				stdq.question_key,
				stdq.sequence,
				stdq.std_question_no,
				stdq.std_subquestion_no,
				stdq.std_subquestion_AB,
				stdq.title,
				stdq.question_text,
				stdq.control_type,
				stdq.length,
				stdq.required,
				stdq.pick_list_id,
				NULL as picklist_name,		-- null for ident control
				NULL AS item_value,			-- null for ident control
				NULL AS item_description,	-- null for ident control
				NULL AS sequence,			-- null for ident control
				NULL AS effective_date,		-- null for ident control
				NULL AS ineffective_date,	-- null for ident control
				assess.assess_type_code,
				assess.status,
				ISNULL(resp.item_value, '') as resp_item_value,
				ISNULL(resp.item_value, '') + @vSeparator + ISNULL(type_id.format, '') as response,
				score.score,
				score.category as score_category,
				case when assess.strikeout_flag is null then 'N' else assess.strikeout_flag END as strikeout_flag,
				case when assess.strikeout_by IS NULL THEN '' ELSE assess.strikeout_by end as strikeout_by,
				dbo.fn_adjust_time_fac_time_zone(@vFacId, assess.strikeout_date)AS strikeout_date,
				case when assess.strikeout_desc IS NULL THEN '' ELSE assess.strikeout_desc end as strikeout_reason,
				stda.include_signature_section_flag,
				case when assess_sec.complete='Y' and assess_sec.completed_title is not null then assess_sec.completed_by+', '+assess_sec.completed_title 
					when assess_sec.complete='Y' and assess_sec.completed_title is null then assess_sec.completed_by else '' end as signed_by,
				assess_sec.completed_date as signed_date
			, cust_hdr
			, cust_sub_hdr
			, cust_hdr_long
			, cust_sub_hdr_long
			, NULL as rnum
			, NULL as unique_question
			, NULL as was_merge
			, '0' as print_s
			, NULL as ams_key
			, NULL as file_metadata_id
			, stdq.visual
			, NULL as ordr
			FROM #PRP_Assess_Filter af
			INNER JOIN dbo.as_std_assessment stda WITH (NOLOCK) ON stda.std_assess_id=af.std_assess_id
			INNER JOIN dbo.as_assessment assess WITH (NOLOCK) ON assess.assess_id=af.assess_id
			LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id
			LEFT JOIN dbo.as_assessment_section assess_sec WITH (NOLOCK) ON assess.assess_id=assess_sec.assess_id AND stds.section_code=assess_sec.section_code
			INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON stda.std_assess_id=stdq.std_assess_id AND stds.section_code=stdq.section_code
			LEFT JOIN dbo.as_std_pick_list stdpl WITH (NOLOCK) ON 
									stdq.pick_list_id = stdpl.pick_list_id
								
			LEFT JOIN dbo.as_response resp WITH (NOLOCK) ON 
								assess.assess_id = resp.assess_id 
							AND stdq.question_key = resp.question_key

			LEFT JOIN dbo.mirror_as_std_pick_list_item stdpli WITH (NOLOCK) ON 
									stdq.pick_list_id = stdpli.pick_list_id 
									and resp.item_value = stdpli.item_value 

			LEFT JOIN dbo.id_type type_id WITH (NOLOCK) ON
								type_id.id_type_id = stdq.pick_list_id
			LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON stdq.std_assess_id=stdqg.std_assess_id and stdq.section_code=stdqg.section_code and stdq.std_question_no=stdqg.std_question_no
				AND stds.section_code=stdqg.section_code
			LEFT JOIN dbo.as_std_assess_type asstype WITH (NOLOCK) ON assess.std_assess_id = asstype.std_assess_id AND assess.assess_type_code = asstype.assess_type_code 

			LEFT JOIN dbo.as_std_score stdscore  WITH (NOLOCK) ON 
								stda.std_assess_id = stdscore.std_assess_id
							AND stdscore.is_default = 'Y'
							AND stdscore.deleted = 'N'

			LEFT JOIN dbo.as_assessment_score score WITH (NOLOCK) ON 
						score.assess_id = assess.assess_id
							AND score.std_score_id = stdscore.std_score_id

			LEFT JOIN dbo.mirror_as_std_pick_list_item plresp WITH (NOLOCK) ON 
									stdq.pick_list_id = plresp.pick_list_id 
								AND resp.item_value = plresp.item_value
			-- hide/show  or parent/child question
					left outer join #prp_ShowHideDisable_rules cr
			on stdq.question_key = cr.question_key_obj

			left OUTER JOIN #PRP_as_response asr_split
				ON af.assess_id = asr_split.assess_id 
				and asr_split.question_key = cr.question_key_sbj

			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
										WHERE		af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
								  ) AS cust_hdr 
						) custom_header
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
												ascr.assess_id = af.assess_id
											AND ascr.std_score_id = stds.std_score_id
										where	af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
									) AS cust_sub_hdr
						) custom_sub_header
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
														ascr.assess_id = af.assess_id
													AND ascr.std_score_id = stds.std_score_id
											WHERE		af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
											where	af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long

			WHERE stdq.control_type = 'ident'
					and ((@vshort_version = 1 and ((stdpl.pick_list_id is not NULL and stdpli.item_description= plresp.item_description)
					or isnull(resp.item_value,'') = '') OR stdpl.pick_list_id IS NULL )
					or @vshort_version = 0 OR @vshort_version is NULL) 
				
				and
				-- show hide and disabled question
				1 = ( case when 
									cr.enabled_flag = 'Y' 
									and  @vincl_disabled_qs = 0				-- assessment flag "By Default Include Disabled Questions in Report"
									and isnull(cr.item_id, '') = 4102		-- disabled question
									and  cr.range1 = asr_split.first_val	-- value that triggers rule equal response value
								then 0 

								when cr.enabled_flag = 'Y' and not cr.control_type in ('pulse','we','bp','resp','bs','o2','he', 'temp','pnl', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null or ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.item_value))) then 0
								
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pulse','we','resp','bs','o2','he', 'temp', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)

											) then 0
							-- pain level
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pnl')  
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or ( ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.first_val)))
										
											) then 0

								-- blood pressure
								when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'sys'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)
										
											) then 0
									when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'dias'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.second_val)
														or convert(float,cr.range1) > convert(float,asr_split.second_val)
													)
										
											) then 0

								else 1 end
					)
			set @vRowCount = @vRowCount + @@rowcount


-- Add in care plan control

			set @vStep = 145
	set @vgsStepStartTime=GETDATE()

	if @debug_me='Y' Print 'Step ' + convert(varchar(10),@vStep) + ' care plan control insert' 


; with cp_data as 
(
SELECT 
 distinct 
--top 100 PERCENT 
				assess.fac_id,
				stda.std_assess_id,
				assess.client_id,
				assess.assess_id,
				assess.assess_date, 
				asstype.description as assessment_type, 
				stda.description as UDA,
				stds.title as section_title,
				stds.sequence as section_sequence,
				stdqg.std_question_no as grp_std_question_no,
				stdqg.group_title,
				stdqg.group_text,
				stdqg.layout_style,
				stds.section_code,
				stdq.question_key,
				stdq.sequence,
				stdq.std_question_no,
				stdq.std_subquestion_no,
				stdq.std_subquestion_AB,

				case WHEN stdi.is_task = 'Y' and isnull(stdq.question_text,'') <> '' 
							and (ncount.focus_text = isnull(@vTermFocus + interv_parent.text1, @vTermFocus + goal_parent.text1) 
								or COALESCE(@vTermFocus + interv_parent.text1, @vTermFocus + goal_parent.text1,'') = ''
								)then '<b>Other '+@vTermTasks +'</b>'  
					WHEN ncount.focus_text = isnull(@vTermFocus + interv_parent.text1, @vTermFocus + goal_parent.text1) THEN NULL 
					

					ELSE isnull('<b>'+ @vTermFocus +'</b>' + case when substring(interv_parent.text1,1,1) = ' '  
									then STUFF(replace(replace(interv_parent.text1, char(10),''),char(13),''),1,1, '') 
									else ltrim(rtrim(replace(replace(interv_parent.text1, char(10),''),char(13),''))) end

								, '<b>' + @vTermFocus +'</b>' + case when substring(goal_parent.text1,1,1) = ' '  
									then STUFF(replace(replace(goal_parent.text1, char(10),''),char(13),''),1,1, '') 
									else ltrim(rtrim(replace(replace(goal_parent.text1, char(10),''),char(13),''))) end)

					
					END  as title /*question title*/,
				
				
				stdq.question_text,
				stdq.control_type,
				stdq.length,
				stdq.required,
				stdq.pick_list_id,
				NULL as picklist_name,			
				coalesce(stdn.std_need_id,stdg.std_need_id,stdi.std_need_id,stdt.std_trigger_id)  AS item_value,		
				NULL    AS item_description,	
				NULL AS pick_list_sequence,			
				NULL AS effective_date,		
				NULL AS ineffective_date,	
				assess.assess_type_code,
				assess.status,
				ISNULL(trig_res.checked, '') as resp_item_value,

				-- this line get the edited text 
				CASE WHEN stdt.trigger_type = 'N' THEN '<b>' +@vTermFocus+'</b>' + isnull(trig_res.custom_description, stdn.text1)
				 WHEN stdt.trigger_type = 'G' THEN '<b>' +@vTermGoal +'</b>' + isnull(trig_res.custom_description,stdg.text1)
				 WHEN stdt.trigger_type = 'I' THEN CASE WHEN stdi.is_task = 'Y' THEN '<b>'+ @vTermTask +' </b>' ELSE '<b>' + @vTermIntervention + ' </b>' END + isnull(trig_res.custom_description,stdi.text1)
				 ELSE ''
				 END as response,
				score.score,
				score.category as score_category,
				case when assess.strikeout_flag is null then 'N' else assess.strikeout_flag END as strikeout_flag,
				case when assess.strikeout_by IS NULL THEN '' ELSE assess.strikeout_by end as strikeout_by,
				dbo.fn_adjust_time_fac_time_zone(@vFacId, assess.strikeout_date)AS strikeout_date,
				case when assess.strikeout_desc IS NULL THEN '' ELSE assess.strikeout_desc end as strikeout_reason,
				stda.include_signature_section_flag,
				case when assess_sec.complete='Y' and assess_sec.completed_title is not null then assess_sec.completed_by+', '+assess_sec.completed_title 
					when assess_sec.complete='Y' and assess_sec.completed_title is null then assess_sec.completed_by else '' end as signed_by,
				assess_sec.completed_date as signed_date
			, cust_hdr
			, cust_sub_hdr
			, cust_hdr_long
			, cust_sub_hdr_long
			,stdi.is_task
			, '0' as print_s
			, ncount.focus_text
			, interv_parent.text1 as intervention_parent
			, goal_parent.text1 as goal_parent			
			, stdq.visual
			, CASE WHEN stdt.trigger_type = 'G' THEN stdg.ordr
				 WHEN stdt.trigger_type = 'I' THEN stdi.ordr
				 ELSE NULL
				 END as ordr

			FROM #PRP_Assess_Filter af
			INNER JOIN dbo.as_std_assessment stda WITH (NOLOCK) ON stda.std_assess_id=af.std_assess_id
			INNER JOIN dbo.as_assessment assess WITH (NOLOCK) ON assess.assess_id=af.assess_id
			LEFT JOIN dbo.as_std_section stds WITH (NOLOCK) ON stda.std_assess_id=stds.std_assess_id
			LEFT JOIN dbo.as_assessment_section assess_sec WITH (NOLOCK) ON assess.assess_id=assess_sec.assess_id AND stds.section_code=assess_sec.section_code
			INNER JOIN dbo.mirror_as_std_question stdq WITH (NOLOCK) ON stda.std_assess_id=stdq.std_assess_id AND stds.section_code=stdq.section_code
			
			left outer JOIN dbo.as_std_trigger stdt WITH (NOLOCK) ON stdt.std_assess_id = af.std_assess_id AND stdt.deleted = 'N'
																and stdq.question_key = stdt.question_key 
			 LEFT JOIN dbo.cp_std_need stdn WITH (NOLOCK) ON stdt.trigger_type = 'N' AND stdn.std_need_id = stdt.triggered_item_id
			 LEFT JOIN dbo.cp_std_goal stdg WITH (NOLOCK) ON stdt.trigger_type = 'G' AND stdg.std_goal_id = stdt.triggered_item_id
			 LEFT JOIN dbo.cp_std_intervention stdi WITH (NOLOCK)ON stdt.trigger_type = 'I' AND stdi.std_intervention_id = stdt.triggered_item_id
			 left OUTER JOIN dbo.cp_std_need interv_parent WITH (NOLOCK) ON stdi.std_need_id = interv_parent.std_need_id 
			 left OUTER JOIN dbo.cp_std_need goal_parent WITH (NOLOCK) ON stdg.std_need_id = goal_parent.std_need_id 

			left join (SELECT asr.assess_response_id , asr.assess_id , asr.question_key , b.items as item_value 
				FROM dbo.as_response asr WITH (NOLOCK)
				Outer APPLY (SELECT items from dbo.Split(asr.item_value,',')) b
				
				) resp
				ON resp.assess_id = assess.assess_id 
				and stdq.question_key = resp.question_key 
				and convert(varchar(100),stdt.std_trigger_id) = resp.item_value
				

					-- added to handle short version of assessment where nothing was selected				
				left outer join dbo.as_response cp_resp with (nolock)
				on cp_resp.assess_id = assess.assess_id
				and cp_resp.question_key = stdq.question_key

			left JOIN dbo.as_response_trigger_item trig_res WITH (NOLOCK)
							ON resp.item_value = convert(varchar(50),trig_res.std_trigger_id )
							and resp.assess_response_id = trig_res.assess_response_id 

			LEFT JOIN dbo.as_std_question_group stdqg WITH (NOLOCK) ON stdq.std_assess_id=stdqg.std_assess_id 
				and stdq.section_code=stdqg.section_code 
				and stdq.std_question_no=stdqg.std_question_no
				AND stds.section_code=stdqg.section_code
			LEFT JOIN dbo.as_std_assess_type asstype WITH (NOLOCK) ON assess.std_assess_id = asstype.std_assess_id 
				AND assess.assess_type_code = asstype.assess_type_code 

			LEFT JOIN dbo.as_std_score stdscore  WITH (NOLOCK) ON 
								stda.std_assess_id = stdscore.std_assess_id
							AND stdscore.is_default = 'Y'
							AND stdscore.deleted = 'N'

			LEFT JOIN dbo.as_assessment_score score WITH (NOLOCK) ON 
						score.assess_id = assess.assess_id
							AND score.std_score_id = stdscore.std_score_id
				
			left outer join #prp_ShowHideDisable_rules cr
			on stdq.question_key = cr.question_key_obj

				-- show hide rules
			left OUTER JOIN #PRP_as_response asr_split
				ON af.assess_id = asr_split.assess_id 
				and asr_split.question_key = cr.question_key_sbj 


			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_on_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
										WHERE		af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
								  ) AS cust_hdr 
						) custom_header

			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Score' + @vSeparator + isnull(convert(varchar, ascr.score), '') + @vSeparator2 ELSE '' END
											 + CASE WHEN stds.cat_subsequent_header = 'Y' THEN isnull(stds.description, '') + ' Category' + @vSeparator + isnull(ascr.category, '') + @vSeparator2 ELSE '' END
										FROM dbo.as_std_score stds WITH (NOLOCK)
										LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
												ascr.assess_id = af.assess_id
											AND ascr.std_score_id = stds.std_score_id
										where	af.std_assess_id = stds.std_assess_id
												AND stds.deleted = 'N'
												and len(stds.description) < 25
										ORDER BY stds.std_score_id
										FOR XML PATH ('')
									) AS cust_sub_hdr
						) custom_sub_header
			OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
														ascr.assess_id = af.assess_id
													AND ascr.std_score_id = stds.std_score_id
											WHERE		af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
									  ) AS cust_hdr_long 
							) custom_header_long

				OUTER APPLY (	SELECT (	SELECT CASE WHEN stds.on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Score: </b>' + isnull(convert(varchar, ascr.score), '') + '<br>'  ELSE '' END
												 + CASE WHEN stds.cat_on_header = 'Y' THEN '<b>' + isnull(stds.description, '') + ' Category: </b>' + isnull(ascr.category, '') + '<br>' ELSE '' END
											FROM dbo.as_std_score stds WITH (NOLOCK)
											LEFT JOIN dbo.as_assessment_score ascr WITH (NOLOCK) ON
													ascr.assess_id = af.assess_id
												AND ascr.std_score_id = stds.std_score_id
											where	af.std_assess_id = stds.std_assess_id
													AND stds.deleted = 'N'
													and len(stds.description) >= 25
											ORDER BY stds.std_score_id
											FOR XML PATH ('')
										) AS cust_sub_hdr_long
							) custom_sub_header_long

			outer apply ( SELECT @vTermFocus + stdn.text1 as focus_text, stdn.std_need_id from dbo.as_std_trigger stt WITH (nolock)
							INNER JOIN dbo.cp_std_need stdna WITH (NOLOCK) ON stt.trigger_type = 'N' 
								
							where stt.std_assess_id = af.std_assess_id
							AND stdna.std_need_id = stt.triggered_item_id
							AND stdna.std_need_id = stdn.std_need_id
							and stt.question_key = stdq.question_key
							and stdt.std_trigger_id = stt.std_trigger_id
							
							and stt.deleted = 'N'
						) ncount	
			WHERE 
					stdq.control_type = 'cp'
					
					and (  (len(resp.item_value) >  1   and @vshort_version = 1)  -- short version with selected, return only selected
							or (@vshort_version = 0 )  -- long version return all
							or (isnull(cp_resp.item_value,'') = '' and @vshort_version = 1) -- short version but nothing was selected , return all
							)

				-- show hide and disabled question
				
				
				and 1 = ( case when 
									cr.enabled_flag = 'Y' 
									and  @vincl_disabled_qs = 0				-- assessment flag "By Default Include Disabled Questions in Report"
									and isnull(cr.item_id, '') = 4102		-- disabled question
									and  cr.range1 = asr_split.first_val	-- value that triggers rule equal response value
								then 0 

								when cr.enabled_flag = 'Y' and not cr.control_type in ('pulse','we','bp','resp','bs','o2','he', 'temp','pnl', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null or ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.item_value))) then 0
								
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pulse','we','resp','bs','o2','he', 'temp', 'numde') 
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)

											) then 0
							-- pain level
								when cr.enabled_flag = 'Y' and  cr.control_type in ('pnl')  
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or ( ltrim(rtrim(cr.range1)) <> ltrim(rtrim(asr_split.first_val)))
										
											) then 0

								-- blood pressure
								when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'sys'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.first_val)
														or convert(float,cr.range1) > convert(float,asr_split.first_val)
													)
										
											) then 0
									when cr.enabled_flag = 'Y' and  cr.control_type in ('bp')  and cr.question_key_info = 'dias'
										and isnull(cr.item_id,'') = 4110
										and (asr_split.item_value is null 
													or (  convert(float,cr.range2) < convert(float,asr_split.second_val)
														or convert(float,cr.range1) > convert(float,asr_split.second_val)
													)
										
											) then 0

								else 1 end
								
					)

	) -- cp_data



	INSERT INTO #PRP_Results


	select 
				fac_id,
				std_assess_id,
				client_id,
				assess_id,
				assess_date, 
				assessment_type, 
				UDA,
				section_title,
				section_sequence,
				grp_std_question_no,
				group_title,
				group_text,
				layout_style,
				section_code,
				question_key,
				sequence,
				std_question_no,
				std_subquestion_no,
				std_subquestion_AB,
				CASE WHEN (row_number()  OVER ( partition BY cp_data.std_assess_id, cp_data.assess_id, cp_data.question_key , title
								ORDER BY cp_data.std_assess_id, cp_data.assess_id, cp_data.question_key, title, ordr, response ) ) = 1 -- Organize by ordr then response for UDA print to match UDA view
							THEN isnull(title,'') ELSE '' end as title,
				question_text,
				control_type,
				[length],
				[required],
				pick_list_id,
				picklist_name,		-- null for ident control
				item_value,			-- null for ident control
				item_description,	-- null for ident control
				pick_list_sequence, -- null for ident control
				effective_date,		-- null for ident control
				ineffective_date,	-- null for ident control
				assess_type_code,
				status,
				resp_item_value,
				response,
				score,
				score_category,
				strikeout_flag,
				strikeout_by,
				strikeout_date,
				strikeout_reason,
				include_signature_section_flag,
				signed_by,
				signed_date,
				cust_hdr,
				cust_sub_hdr,
				cust_hdr_long,
				cust_sub_hdr_long
				, null as rnum

			, row_number()  OVER ( partition BY cp_data.std_assess_id, cp_data.assess_id, cp_data.question_key 
								
						ORDER BY cp_data.std_assess_id, cp_data.assess_id, cp_data.question_key, title, ordr, response)  unique_question
				,null
				,print_s
				,null
				,null
				,visual
				,ordr
	 from cp_data 
	 where visual <> 'N'


			set @vRowCount = @@rowcount			
			if @debug_me = 'Y' SELECT 'after_cp_insert', * from #PRP_Results

			DELETE from #PRP_Results
			where visual = 'N'
			
-- update question title to support c2 layout
			if @vRowCount > 0 
			begin

					-- update response flag to support c2 layout
					update rp
					SET rp.resp_item_value = question_tit.resp_item_value_title
					from #PRP_Results rp
					outer apply  ( SELECT  (	SELECT 
													
													re.resp_item_value + ','
												FROM #PRP_Results re WITH (NOLOCK)
												
												where	re.assess_id = rp.assess_id
													and re.question_key = rp.question_key
													and re.control_type = 'cp'
													and re.group_layout_Style = 'C2'
													order by re.unique_question
												
												FOR XML PATH ('')
											) resp_item_value_title
							)question_tit
					where rp.control_type = 'cp'
						 and rp.group_layout_Style = 'C2';
					-- update response to support c2 layout


					update rp
					SET rp.response = question_title.response_title
						
					from #PRP_Results rp
					outer apply  ( SELECT ( SELECT re.response + @vseparator FROM #PRP_Results re WITH (NOLOCK)
												
												where	re.assess_id = rp.assess_id
													and re.question_key = rp.question_key
													and re.control_type = 'cp'
													and re.group_layout_Style = 'C2'
													order by re.unique_question
												
												FOR XML PATH ('')
											) response_title
							)question_title
					where rp.control_type = 'cp'
						 and rp.group_layout_Style = 'C2';

					update rp
					SET rp.question_title = question_t.q_title
						
					from #PRP_Results rp
					outer apply  ( SELECT ( SELECT case when re.question_title = '' then ' ' else re.question_title END  + @vseparator
													
												FROM #PRP_Results re WITH (NOLOCK)
												
												where	re.assess_id = rp.assess_id
													and re.question_key = rp.question_key
													and re.control_type = 'cp'
													and re.group_layout_Style = 'C2'
													order by re.unique_question

												FOR XML PATH ('')
											) q_title
								)question_t
					where rp.control_type = 'cp'
						 and rp.group_layout_Style = 'C2';


					if @debug_me = 'Y' SELECT 'first update', * from #PRP_Results

			END

		DELETE from #PRP_Results
		where control_type = 'CP'
			and group_layout_Style = 'C2'
			and unique_question > 1

		end -- end of populated data



	update assess SET assess.response=isnull(lang.item_description,'')
	from #PRP_Results assess
	INNER JOIN dbo.common_code lang WITH (NOLOCK) ON assess.resp_item_value=lang.item_id and assess.control_type='lang'

	UPDATE #PRP_Results SET std_subquestion_no='ZZXXYY' where std_subquestion_no='' 
			

	if @debug_me = 'Y' select 'before 2 column merge', * from #PRP_Results
	order by    client_id
		  , assess_id
		  , section_sequence
		  , sequence
		  , case when isnumeric(pick_list_sequence)=1 then cast (pick_list_sequence as int) end 


	UPDATE #PRP_Results
	set group_layout_style = 'V'
	where group_layout_style = 'C2'
	and control_type in ( 'pain', 'gbdy', 'bdy', 'ebdy')
	--and control_type = 'pain'

	set @vRowCount = @@rowcount
	if @vRowCount > 0
	begin
	; with updated_pain
	  as ( select client_id
		  , assess_id
		  , sequence
		  from #PRP_Results
		  WHERE group_layout_style = 'V'
		  and control_type = 'pain'
	  
		)


		UPDATE a
		set a.group_layout_style = 'V'
		from #PRP_Results a inner join 
		updated_pain upd
		on a.client_id = upd.client_id
		and a.assess_id = upd.assess_id
		and a.sequence = upd.sequence + 1 
		and a.group_layout_style = 'C2'

	end
/***************************************************************************
						HANDLE 2 COLUMN SECTIONS C2
***************************************************************************/

if @debug_me = 'Y' select 'before 2 column merge after update for C2', * from #PRP_Results
	order by    client_id
		  , assess_id
		  , section_sequence
		  , sequence
		  , case when isnumeric(pick_list_sequence)=1 then cast (pick_list_sequence as int) end 



	UPDATE #PRP_Results
	SET control_type = ISNULL(A_control_type, '') + @vSeparator3 +  ISNULL(B_control_type, '')
		--control_type = ISNULL(A_control_type, '') + @vSeparator3 + ISNULL(B_control_type, '')
	  , std_subquestion_no = ISNULL(A_std_subquestion_no, '') + @vSeparator3 + ISNULL(B_std_subquestion_no, '')
	  , question_text = ISNULL(A_text, '') + @vSeparator3 + ISNULL(B_text, '')
	  , question_title = ISNULL(A_question_title, '') + @vSeparator3 + ISNULL(B_question_title, '')
	  , pick_list_id = 0
	  , pick_list_name = ISNULL(A_pick_list_name, '') + @vSeparator3 + ISNULL(B_pick_list_name, '')
	  , pick_list_value = ISNULL(A_pick_list_value, '') + @vSeparator3 + ISNULL(B_pick_list_value, '')
	  , pick_list_description = ISNULL(A_pick_list_description, '') + @vSeparator3 + ISNULL(B_pick_list_description, '')
	  , resp_item_value = ISNULL(A_resp_item_value, '') + @vSeparator3 + ISNULL(B_resp_item_value, '')
	  , response = ISNULL(A_response, '') + @vSeparator3 + ISNULL(B_response, '')
	  , print_s = ISNULL(A_print_s, '') + @vSeparator3 + ISNULL(B_print_s, '')
	  , was_merge = 1
	  , ams_key = ISNULL(A_ams_key, '') + @vSeparator3 + ISNULL(B_ams_key, '')
	  , pick_list_sequence = ISNULL(A_pick_list_sequence, '') + @vSeparator3 + ISNULL(B_pick_list_sequence, '')
	FROM
	

(


		SELECT CASE WHEN Col_1.new_seq IS NULL THEN Col_2.new_seq ELSE Col_1.new_seq END as new_seq -- remove on next revision if clears QAT
			 , Col_1.A_control_type
			 , Col_2.B_control_type
			 , Col_1.A_std_subquestion_no
			 , Col_2.B_std_subquestion_no
			 , Col_1.A_text
			 , Col_2.B_text
			 , Col_1.A_question_title
			 , Col_2.B_question_title
			 , Col_1.A_pick_list_name
			 , Col_2.B_pick_list_name
			 , Col_1.A_pick_list_value
			 , Col_2.B_pick_list_value
			 , Col_1.A_pick_list_description
			 , Col_2.B_pick_list_description
			 , Col_1.A_resp_item_value
			 , Col_2.B_resp_item_value
			 , Col_1.A_response
			 , Col_2.B_response
			 , Col_1.A_print_s
			 , Col_2.B_print_s
			 , CASE WHEN Col_1.section_sequence IS NULL THEN Col_2.section_sequence ELSE Col_1.section_sequence END AS sec_seq
			 , CASE WHEN Col_1.group_no IS NULL THEN Col_2.group_no ELSE Col_1.group_no END AS grp_no
			 , CASE WHEN Col_1.A_seq IS NULL THEN Col_2.B_seq ELSE Col_1.A_seq END AS seq
			 , CASE WHEN col_1.assess_id IS NULL THEN col_2.assess_id ELSE col_1.assess_id END AS ass_id
			 , Col_1.A_ams_key
			 , Col_2.B_ams_key
			 , Col_1.A_pick_list_sequence
			 , Col_2.B_pick_list_sequence
		FROM
				(SELECT
					  ROW_NUMBER() OVER ( PARTITION BY assess_id
							 , section_sequence
							 , group_no
					  ORDER BY assess_id
							 , section_sequence
							 , group_no
							 , sequence
						) AS new_seq

					, assess_id
					, section_sequence
					, group_no
					, sequence AS A_seq
					, std_subquestion_no AS A_std_subquestion_no
					, control_type AS A_control_type
					, question_text AS A_text
					, question_title AS A_question_title
					, pick_list_name AS A_pick_list_name
					, pick_list_value AS A_pick_list_value
					, pick_list_description AS A_pick_list_description
					, resp_item_value AS A_resp_item_value
					, response AS A_response
					, print_s as A_print_s
					, ams_key AS A_ams_key
					, pick_list_sequence as A_pick_list_sequence
				FROM #PRP_Results Col_A 
				WHERE Col_A.group_layout_style = 'C2'
				  AND Col_A.control_type <> 'bdy'
				  AND Col_A.control_type <> 'gbdy'
				  --AND col_A.control_type <> 'cp'
				  AND Col_A.sequence <	CASE WHEN
										(
											SELECT TOP 1 col_2_start.sequence FROM #PRP_Results col_2_start 
											WHERE	col_2_start.assess_id = Col_A.assess_id
												AND col_2_start.section_sequence = Col_A.section_sequence
												AND col_2_start.group_no = Col_A.group_no
												AND col_2_start.std_subquestion_AB = 'B'
												AND col_2_start.control_type <> 'bdy'
												AND col_2_start.control_type <> 'gbdy'
										) IS NULL THEN
										(
											SELECT MAX(col_2_start.sequence) + 1 FROM #PRP_Results col_2_start 
											WHERE	col_2_start.assess_id = Col_A.assess_id
												AND col_2_start.section_sequence = Col_A.section_sequence
												AND col_2_start.group_no = Col_A.group_no
												AND col_2_start.control_type <> 'bdy'
												AND col_2_start.control_type <> 'gbdy'
												--AND col_2_start.control_type <> 'cp'
										) ELSE
										(
											SELECT TOP 1 col_2_start.sequence FROM #PRP_Results col_2_start 
											WHERE	col_2_start.assess_id = Col_A.assess_id
												AND col_2_start.section_sequence = Col_A.section_sequence
												AND col_2_start.group_no = Col_A.group_no
												AND col_2_start.std_subquestion_AB = 'B'
												AND col_2_start.control_type <> 'bdy'
												AND col_2_start.control_type <> 'gbdy'
												--AND col_2_start.control_type <> 'cp'
										) END
				) Col_1
		FULL OUTER JOIN
				(SELECT
					  ROW_NUMBER() OVER ( PARTITION BY assess_id
							 , section_sequence
							 , group_no
					  ORDER BY assess_id
							 , section_sequence
							 , group_no
							 , sequence
						) AS new_seq

					, assess_id
					, section_sequence
					, group_no
					, sequence AS B_seq
					, std_subquestion_no AS B_std_subquestion_no
					, control_type AS B_control_type
					, question_text AS B_text
					, question_title AS B_question_title
					, pick_list_name AS B_pick_list_name
					, pick_list_value AS B_pick_list_value
					, pick_list_description AS B_pick_list_description
					, resp_item_value AS B_resp_item_value
					, response AS B_response
					, print_s as B_print_s
					, ams_key AS B_ams_key
					, pick_list_sequence as B_pick_list_sequence
				FROM #PRP_Results Col_A 
				WHERE Col_A.group_layout_style = 'C2'
				  AND Col_A.control_type <> 'bdy'
				  AND Col_A.control_type <> 'gbdy'
				 -- AND col_A.control_type <> 'cp'
				  AND Col_A.sequence >= 
										(
											SELECT TOP 1 col_2_start.sequence FROM #PRP_Results col_2_start 
											WHERE	col_2_start.assess_id = Col_A.assess_id
												AND col_2_start.section_sequence = Col_A.section_sequence
												AND col_2_start.group_no = Col_A.group_no
												AND col_2_start.std_subquestion_AB = 'B'
												AND col_2_start.control_type <> 'bdy'
												AND col_2_start.control_type <> 'gbdy'
												--AND col_2_start.control_type <> 'cp'
										)
				) Col_2 ON
							Col_1.assess_id = Col_2.assess_id
						AND	Col_1.section_sequence = Col_2.section_sequence
						AND	Col_1.group_no = Col_2.group_no
						AND	Col_1.new_seq = Col_2.new_seq
	) my_view


	WHERE	assess_id = my_view.ass_id
		AND	section_sequence = my_view.sec_seq
		AND	group_no = my_view.grp_no
		AND	sequence = my_view.seq
		and my_view.A_std_subquestion_no = std_subquestion_no
		AND control_type <> 'bdy'
		AND control_type <> 'gbdy'
		--AND control_type <> 'cp'


-- the following code was added to handle the scenario where lay out was set to two columns but there's no question(s) on the first column

if @debug_me = 'Y' print 'handling c2 where column 1 is empty'
	update prpres

	set prpres.was_merge = 1
	from #prp_results prpres
	inner JOIN
		(select  
				fac_id
				, client_id
				, std_assess_id
				, assess_id
				, std_question_no

				, substring(std_subquestion_no
					, charindex(@vSeparator3,std_subquestion_no) + len(@vSeparator3)
					, len(std_subquestion_no) - (charindex(@vSeparator3,std_subquestion_no) + len(@vSeparator3)) + 1) std_subquestion_no

				,  substring(question_title
					, charindex(@vSeparator3,question_title) + len(@vSeparator3)
					, len(question_title) - (charindex(@vSeparator3,question_title) + len(@vSeparator3)) + 1) question_title
				,  substring(question_text
					, charindex(@vSeparator3,question_text) + len(@vSeparator3)
					, len(question_text) - (charindex(@vSeparator3,question_text) + len(@vSeparator3)) + 1) question_text

				,  substring(control_type
					, charindex(@vSeparator3,control_type) + len(@vSeparator3)
					, len(control_type) - (charindex(@vSeparator3,control_type) + len(@vSeparator3)) + 1) control_type

				,  substring(pick_list_name
					, charindex(@vSeparator3,pick_list_name) + len(@vSeparator3)
					, len(pick_list_name) - (charindex(@vSeparator3,pick_list_name) + len(@vSeparator3)) + 1) pick_list_name
		
				,  substring(resp_item_value
					, charindex(@vSeparator3,resp_item_value) + len(@vSeparator3)
					, len(resp_item_value) - (charindex(@vSeparator3,resp_item_value) + len(@vSeparator3)) + 1) resp_item_value

				,  substring(response
					, charindex(@vSeparator3,response) + len(@vSeparator3)
					, len(response) - (charindex(@vSeparator3,response) + len(@vSeparator3)) + 1) response

				,  substring(pick_list_value
					, charindex(@vSeparator3,pick_list_value) + len(@vSeparator3)
					, len(pick_list_value) - (charindex(@vSeparator3,pick_list_value) + len(@vSeparator3)) + 1) pick_list_value

				,  substring(pick_list_description
					, charindex(@vSeparator3,pick_list_description) + len(@vSeparator3)
					, len(pick_list_description) - (charindex(@vSeparator3,pick_list_description) + len(@vSeparator3)) + 1) pick_list_description
				
				,  substring(print_s
					, charindex(@vSeparator3,print_s) + len(@vSeparator3)
					, len(print_s) - (charindex(@vSeparator3,print_s) + len(@vSeparator3)) + 1) print_s


		 from #prp_results where was_merge = 1) wm
		 on prpres.fac_id = wm.fac_id
		 and prpres.client_id = wm.client_id
		 and prpres.std_assess_id = wm.std_assess_id
		 and prpres.assess_id = wm.assess_id
		 and prpres.std_question_no = wm.std_question_no
		 and ISNULL(prpres.std_subquestion_no,'') = wm.std_subquestion_no
		 and ISNULL(prpres.question_title,'') = wm.question_title
		 and ISNULL(prpres.question_text,'') = wm.question_text
		 and ISNULL(prpres.control_type,'') = wm.control_type

		 and ISNULL(prpres.pick_list_name,'') = wm.pick_list_name
		 and ISNULL(prpres.resp_item_value,'') = wm.resp_item_value
		 and ISNULL(prpres.response,'') = wm.response
		 and ISNULL(prpres.pick_list_value,'') = wm.pick_list_value
		 and ISNULL(prpres.pick_list_description,'') = wm.pick_list_description
		 and ISNULL(prpres.print_s,'') = wm.print_s
		 and prpres.group_layout_style = 'C2'



	UPDATE #prp_results
	set std_subquestion_no = @vSeparator3 + isnull(std_subquestion_no ,'')
		,question_title = @vSeparator3 + isnull(question_title ,'')
		,question_text = @vSeparator3 + isnull(question_text ,'')
		,control_type = ' '+ @vSeparator3 + isnull(control_type ,'')
		,pick_list_name = @vSeparator3 + isnull(pick_list_name ,'')
		,resp_item_value = @vSeparator3 + isnull(resp_item_value ,'')
		,response = ' '+  @vSeparator3 + isnull(response ,'')
		,pick_list_value = @vSeparator3 + isnull(pick_list_value ,'')
		,pick_list_description = @vSeparator3 + isnull(pick_list_description ,'')
		,print_s = @vSeparator3 + isnull(print_s ,'')
		,ams_key =  ' '+  @vSeparator3 + isnull(ams_key ,'')
	WHERE group_layout_style = 'C2'
		 and was_merge is NULL




--	Since all the required info is now merged into combined rows, delete the rows that were not part of the merge
if @debug_me = 'Y' 
select 'before delete', *
from #PRP_Results
order by    client_id
		  , assess_id
		  , section_sequence
		  , sequence
		  , case when isnumeric(pick_list_sequence)=1 then cast (pick_list_sequence as int) end 


	DELETE FROM #PRP_Results
	--FROM  #PRP_Results  
	WHERE	group_layout_style = 'C2'
			AND control_type <> 'gbdy'
			AND control_type <> 'bdy'
			AND control_type not LIKE '%' + @vSeparator3 + '%' 
			

if @debug_me='Y' select '#PRP_Results After delete', * from #PRP_Results
order by    client_id
		  , assess_id
		  , section_sequence
		  , sequence
		  , case when isnumeric(pick_list_sequence)=1 then cast (pick_list_sequence as int) end 

/***************************************************************************
					END OF HANDLE 2 COLUMN SECTIONS
***************************************************************************/

	Set @vgs_fill_end_time  = getdate() ; -- fill end time

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(@vRowCount)))+ ' rows in '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep = 150
	set @vgsStepStartTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' returning final result ' + convert(varchar(26),getdate(),109)
	--*********************************************************************************************************

	select @cnt_result = count(*) from #PRP_Results

	select @min_clientid = min(client_id) from #clients


	;with tbBase
	as
	(
	select  DISTINCT
		 res.fac_id
		, cl.mrn_number
		, cl.sex
		, cl.date_of_birth
		, cl.admission_date
		, cl.initial_admission_date
		, cl.client_name
		, cl.client_language
		, cl.client_title
		, cl.client_id_number
		, res.client_id
		, convert(varchar,res.fac_id)		as fac_id_str --- required for building group id 	
		, convert(varchar,res.client_id)		as client_id_str --- required for building group id 	
		, convert(varchar,res.std_assess_id)		as std_assess_id_str --- required for building group id 	
		, convert(varchar,res.assess_id)		as assess_id_str --- required for building group id 
		, ltrim(rtrim(cl.client_physician)) as physician
		, cl.location
		, cl.allergy
		, cl.ids
		, cl.subids
		, res.std_assess_id
		, res.assess_id
		, res.assess_date
		, res.assessment_type
		,	dbo.fn_scape_characters( res.uda , '<') as uda
		, case when res.section_code='Cust' THEN '' WHEN res.section_code LIKE 'Cust_%' THEN RIGHT(res.section_code,(LEN(res.section_code)-5)) ELSE res.section_code end as section_no
		, res.section_title
		, res.section_sequence
		, res.group_no
		, res.group_title
		, res.group_text
		, res.group_layout_style
		, res.sequence
		, res.std_question_no
		, res.std_subquestion_no
		, res.std_subquestion_AB
		, res.question_title
		, res.question_text
		, res.control_type
		, res.control_length
		, res.response_required
		, res.pick_list_id
		, res.pick_list_name
		, res.pick_list_value
		, res.pick_list_description	
		, res.pick_list_sequence		
		, res.pick_list_value_effective_date
		, res.pick_list_value_ineffective_date
		, res.assess_type_code
		, res.assess_status
		, res.resp_item_value
		, res.response
		, res.score 
		, res.score_category
		, res.strikeout_flag
		, res.strikeout_by
		, CASE WHEN res.strikeout_date is not null 
			   THEN CONVERT(varchar(10), res.strikeout_date, @vdateFormatStyle) + ' '
				  + CONVERT(varchar(5), res.strikeout_date, 114) 
			   ELSE '' 
		  END as strikeout_date
		, res.strikeout_reason
		, res.include_signature_section_flag
		, res.signed_by
		, case when res.signed_date is not null then convert(varchar(10), dbo.fn_adjust_time_fac_time_zone(res.fac_id, res.signed_date), 101) /*convert(char(10),res.signed_date,101)*/  ELSE '' END as signed_date
		, cust_hdr
		, cust_sub_hdr
		, cust_hdr_long
		, cust_sub_hdr_long
		, rnum
		, unique_question
		, print_s
		, ams_key
		, file_metadata_id
		, res.ordr
     from #clients cl
	left JOIN #PRP_Results res ON res.client_id=cl.client_id
	where (@client_id <> -1 or res.client_id is not null
					or (@cnt_result = 0 and cl.client_id = @min_clientid )
		  )
	)
, tbWithGroupSet
	as
	(
		Select *
		,isnull(fac_id_str,'')+'_' +isnull(client_id_str,'')+'_' +isnull(std_assess_id_str,'')+'_' +isnull(assess_id_str,'') as P_set_id
		,std_assess_id as G_set_id
		,uda as G1
		from tbBase
	)
	, tbWithSort
	as
	(
	Select 
		client_name
		, client_id
		, client_id_number
		, location
		, admission_date
		, initial_admission_date
		, mrn_number
		, client_language
		, client_title
		, sex
		, date_of_birth
		, physician
		, allergy
		, ids
		, subids
		, std_assess_id
		, assess_id
		, assess_date
		, assessment_type
		, uda
		, section_no
		, section_title
		, section_sequence
		, group_no
		, group_title
		, group_text
		, group_layout_style
		, sequence
		, std_question_no
		, replace(std_subquestion_no, 'ZZXXYY', '') AS std_subquestion_no
		, std_subquestion_AB
		, question_title
		, question_text
		, control_type
		, control_length
		, response_required
		, pick_list_id
		, pick_list_name
		, pick_list_value
		, pick_list_description	
		, pick_list_sequence		
		, pick_list_value_effective_date
		, pick_list_value_ineffective_date
		, assess_type_code
		, assess_status
		, resp_item_value
		, response
		, score 
		, score_category
		, strikeout_flag
		, strikeout_by
		, strikeout_date
		, strikeout_reason
		, include_signature_section_flag
		, isnull(signed_by,'') as signed_by
		, isnull(signed_date,'') as signed_date
		, cust_hdr
		, cust_sub_hdr
		, cust_hdr_long
		, cust_sub_hdr_long
		, P_set_id
		, print_s
		, ams_key
		, file_metadata_id
		, Case  
			  when @vP1 = 'client_name'				then client_name
			  when @vP1 = 'client_number'			then client_id_number
			  when @vP1 = 'client_location'			then location
			  when @vP1 = 'assess_date'				then isnull(convert(varchar(10), assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vP1 = 'admission_date'			then admission_date
			  when @vP1 = 'date_of_birth' 			then date_of_birth 
			  when @vP1 = 'sex' 					then sex
			  when @vP1 = 'client_language' 		then client_language 
			  when @vP1 = 'physician' 				then physician 
			  when @vP1 = 'allergy'					then allergy
			  when @vP1 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP1 = 'uda'						then isnull(uda,@uda_title)
			  when @vP1 = 'assessment_type' 		then assessment_type
			  when @vP1 = 'facility_name'			then @vFacName
			  when @vP1 = 'facility_address'		then @vFacAddress
			  when @vP1 = 'initial_admission_date'	then initial_admission_date
			  when @vP1 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP1 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP1 = 'ids'						then ids
		  else NULL end as P1
		, Case  
			  when @vP2 = 'client_name'				then client_name
			  when @vP2 = 'client_number'			then client_id_number
			  when @vP2 = 'client_location'			then location
			  when @vP2 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vP2 = 'admission_date'			then admission_date
			  when @vP2 = 'date_of_birth' 			then date_of_birth 
			  when @vP2 = 'sex' 					then sex
			  when @vP2 = 'client_language' 		then client_language 
			  when @vP2 = 'physician' 				then physician 
			  when @vP2 = 'allergy'					then allergy
			  when @vP2 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP2 = 'uda'						then isnull(uda,@uda_title)
			  when @vP2 = 'assessment_type' 		then assessment_type
			  when @vP2 = 'facility_name'			then @vFacName
			  when @vP2 = 'facility_address'		then @vFacAddress
			  when @vP2 = 'initial_admission_date'	then initial_admission_date
			  when @vP2 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP2 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP2 = 'ids'						then ids
		  else NULL end as P2
		, Case  
			  when @vP3 = 'client_name'				then client_name
			  when @vP3 = 'client_number'			then client_id_number
			  when @vP3 = 'client_location'			then location
			  when @vP3 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vP3 = 'admission_date'			then admission_date
			  when @vP3 = 'date_of_birth' 			then date_of_birth 
			  when @vP3 = 'sex' 					then sex
			  when @vP3 = 'client_language' 		then client_language 
			  when @vP3 = 'physician' 				then physician 
			  when @vP3 = 'allergy'					then allergy
			  when @vP3 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP3 = 'uda'						then isnull(uda,@uda_title)
			  when @vP3 = 'assessment_type' 		then assessment_type
			  when @vP3 = 'facility_name'			then @vFacName
			  when @vP3 = 'facility_address'		then @vFacAddress
			  when @vP3 = 'initial_admission_date'	then initial_admission_date
			  when @vP3 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP3 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP3 = 'ids'						then ids
		  else NULL end as P3
		, Case  
			  when @vP4 = 'client_name'				then client_name
			  when @vP4 = 'client_number'			then client_id_number
			  when @vP4 = 'client_location'			then location
			  when @vP4 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vP4 = 'admission_date'			then admission_date
			  when @vP4 = 'date_of_birth' 			then date_of_birth 
			  when @vP4 = 'sex' 					then sex
			  when @vP4 = 'client_language' 		then client_language 
			  when @vP4 = 'physician' 				then physician 
			  when @vP4 = 'allergy'					then allergy
			  when @vP4 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP4 = 'uda'						then isnull(uda,@uda_title)
			  when @vP4 = 'assessment_type' 		then assessment_type
			  when @vP4 = 'facility_name'			then @vFacName
			  when @vP4 = 'facility_address'		then @vFacAddress
			  when @vP4 = 'initial_admission_date'	then initial_admission_date
			  when @vP4 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP4 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP4 = 'ids'						then ids
		  else NULL end as P4
		, Case  
			  when @vP5 = 'client_name'				then client_name
			  when @vP5 = 'client_number'			then client_id_number
			  when @vP5 = 'client_location'			then location
			  when @vP5 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vP5 = 'admission_date'			then admission_date
			  when @vP5 = 'date_of_birth' 			then date_of_birth 
			  when @vP5 = 'sex' 					then sex
			  when @vP5 = 'client_language' 		then client_language 
			  when @vP5 = 'physician' 				then physician 
			  when @vP5 = 'allergy'					then allergy 
			  when @vP5 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP5 = 'uda'						then isnull(uda,@uda_title)
			  when @vP5 = 'assessment_type' 		then assessment_type
			  when @vP5 = 'facility_name'			then @vFacName
			  when @vP5 = 'facility_address'		then @vFacAddress
			  when @vP5 = 'initial_admission_date'	then initial_admission_date
			  when @vP5 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP5 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP5 = 'ids'						then ids
		  else NULL end as P5
		, Case  
			  when @vP6 = 'client_name'				then client_name
			  when @vP6 = 'client_number'			then client_id_number
			  when @vP6 = 'client_location'			then location
			  when @vP6 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vP6 = 'admission_date'			then admission_date
			  when @vP6 = 'date_of_birth' 			then date_of_birth 
			  when @vP6 = 'sex' 					then sex
			  when @vP6 = 'client_language' 		then client_language 
			  when @vP6 = 'physician' 				then physician 
			  when @vP6 = 'allergy'					then allergy 
			  when @vP6 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP6 = 'uda'						then isnull(uda,@uda_title)
			  when @vP6 = 'assessment_type' 		then assessment_type
			  when @vP6 = 'facility_name'			then @vFacName
			  when @vP6 = 'facility_address'		then @vFacAddress
			  when @vP6 = 'initial_admission_date'	then initial_admission_date
			  when @vP6 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP6 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP6 = 'ids'						then ids
		  else NULL end as P6
		, Case  
			  when @vP7 = 'client_name'				then client_name
			  when @vP7 = 'client_number'			then client_id_number
			  when @vP7 = 'client_location'			then location
			  when @vP7 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vP7 = 'admission_date'			then admission_date
			  when @vP7 = 'date_of_birth' 			then date_of_birth 
			  when @vP7 = 'sex' 					then sex
			  when @vP7 = 'client_language' 		then client_language 
			  when @vP7 = 'physician' 				then physician 
			  when @vP7 = 'allergy'					then allergy 
			  when @vP7 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP7 = 'uda'						then isnull(uda,@uda_title)
			  when @vP7 = 'assessment_type' 		then assessment_type
			  when @vP7 = 'facility_name'			then @vFacName
			  when @vP7 = 'facility_address'		then @vFacAddress
			  when @vP7 = 'initial_admission_date'	then initial_admission_date
			  when @vP7 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP7 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP7 = 'ids'						then ids
		  else NULL end as P7
		, Case  
			  when @vP8 = 'client_name'				then client_name
			  when @vP8 = 'client_number'			then client_id_number
			  when @vP8 = 'client_location'			then location
			  when @vP8 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vP8 = 'admission_date'			then admission_date
			  when @vP8 = 'date_of_birth' 			then date_of_birth 
			  when @vP8 = 'sex' 					then sex
			  when @vP8 = 'client_language' 		then client_language 
			  when @vP8 = 'physician' 				then physician 
			  when @vP8 = 'allergy'					then allergy 
			  when @vP8 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP8 = 'uda'						then isnull(uda,@uda_title)
			  when @vP8 = 'assessment_type' 		then assessment_type
			  when @vP8 = 'facility_name'			then @vFacName
			  when @vP8 = 'facility_address'		then @vFacAddress
			  when @vP8 = 'initial_admission_date'	then initial_admission_date
			  when @vP8 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP8 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP8 = 'ids'						then ids
		  else NULL end as P8
		, Case  
			  when @vP9 = 'client_name'				then client_name
			  when @vP9 = 'client_number'			then client_id_number
			  when @vP9 = 'client_location'			then location
			  when @vP9 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vP9 = 'admission_date'			then admission_date
			  when @vP9 = 'date_of_birth' 			then date_of_birth 
			  when @vP9 = 'sex' 					then sex
			  when @vP9 = 'client_language' 		then client_language 
			  when @vP9 = 'physician' 				then physician 
			  when @vP9 = 'allergy'					then allergy 
			  when @vP9 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP9 = 'uda'						then isnull(uda,@uda_title)
			  when @vP9 = 'assessment_type' 		then assessment_type
			  when @vP9 = 'facility_name'			then @vFacName
			  when @vP9 = 'facility_address'		then @vFacAddress
			  when @vP9 = 'initial_admission_date'	then initial_admission_date
			  when @vP9 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP9 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP9 = 'ids'						then ids
		  else NULL end as P9
		, Case  
			  when @vP10 = 'client_name'			then client_name
			  when @vP10 = 'client_number'			then client_id_number
			  when @vP10 = 'client_location'		then location
			  when @vP10 = 'assess_date'			then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'')
			  when @vP10 = 'admission_date'			then admission_date
			  when @vP10 = 'date_of_birth' 			then date_of_birth 
			  when @vP10 = 'sex' 					then sex
			  when @vP10 = 'client_language' 		then client_language 
			  when @vP10 = 'physician' 				then physician 
			  when @vP10 = 'allergy'				then allergy
			  when @vP10 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP10 = 'uda'					then isnull(uda,@uda_title)
			  when @vP10 = 'assessment_type' 		then assessment_type
			  when @vP10 = 'facility_name'			then @vFacName
			  when @vP10 = 'facility_address'		then @vFacAddress
			  when @vP10 = 'initial_admission_date'	then initial_admission_date
			  when @vP10 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP10 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP10 = 'ids'					then ids
		  else NULL end as P10
		, Case  
			  when @vP11 = 'client_name'			then client_name
			  when @vP11 = 'client_number'			then client_id_number
			  when @vP11 = 'client_location'		then location
			  when @vP11 = 'assess_date'			then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'')
			  when @vP11 = 'admission_date'			then admission_date
			  when @vP11 = 'date_of_birth' 			then date_of_birth 
			  when @vP11 = 'sex' 					then sex
			  when @vP11 = 'client_language' 		then client_language 
			  when @vP11 = 'physician' 				then physician 
			  when @vP11 = 'allergy'				then allergy 
			  when @vP11 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP11 = 'uda'					then isnull(uda,@uda_title)
			  when @vP11 = 'assessment_type' 		then assessment_type
			  when @vP11 = 'facility_name'			then @vFacName
			  when @vP11 = 'facility_address'		then @vFacAddress
			  when @vP11 = 'initial_admission_date'	then initial_admission_date
			  when @vP11 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP11 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP11 = 'ids'					then ids
		  else NULL end as P11
		, Case  
			  when @vP12 = 'client_name'			then client_name
			  when @vP12 = 'client_number'			then client_id_number
			  when @vP12 = 'client_location'		then location
			  when @vP12 = 'assess_date'			then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'')
			  when @vP12 = 'admission_date'			then admission_date
			  when @vP12 = 'date_of_birth' 			then date_of_birth 
			  when @vP12 = 'sex' 					then sex
			  when @vP12 = 'client_language' 		then client_language 
			  when @vP12 = 'physician' 				then physician 
			  when @vP12 = 'allergy'				then allergy 
			  when @vP12 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP12 = 'uda'					then isnull(uda,@uda_title)
			  when @vP12 = 'assessment_type' 		then assessment_type
			  when @vP12 = 'facility_name'			then @vFacName
			  when @vP12 = 'facility_address'		then @vFacAddress
			  when @vP12 = 'initial_admission_date'	then initial_admission_date
			  when @vP12 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP12 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP12 = 'ids'					then ids
		  else NULL end as P12
		, Case  
			  when @vP13 = 'client_name'			then client_name
			  when @vP13 = 'client_number'			then client_id_number
			  when @vP13 = 'client_location'		then location
			  when @vP13 = 'assess_date'			then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'')
			  when @vP13 = 'admission_date'			then admission_date
			  when @vP13 = 'date_of_birth' 			then date_of_birth 
			  when @vP13 = 'sex' 					then sex
			  when @vP13 = 'client_language' 		then client_language 
			  when @vP13 = 'physician' 				then physician 
			  when @vP13 = 'allergy'				then allergy 
			  when @vP13 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP13 = 'uda'					then isnull(uda,@uda_title)
			  when @vP13 = 'assessment_type' 		then assessment_type
			  when @vP13 = 'facility_name'			then @vFacName
			  when @vP13 = 'facility_address'		then @vFacAddress
			  when @vP13 = 'initial_admission_date'	then initial_admission_date
			  when @vP13 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP13 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP13 = 'ids'					then ids
		  else NULL end as P13
		, Case  
			  when @vP14 = 'client_name'			then client_name
			  when @vP14 = 'client_number'			then client_id_number
			  when @vP14 = 'client_location'		then location
			  when @vP14 = 'assess_date'			then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'')
			  when @vP14 = 'admission_date'			then admission_date
			  when @vP14 = 'date_of_birth' 			then date_of_birth 
			  when @vP14 = 'sex' 					then sex
			  when @vP14 = 'client_language' 		then client_language 
			  when @vP14 = 'physician' 				then physician 
			  when @vP14 = 'allergy'				then allergy 
			  when @vP14 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP14 = 'uda'					then isnull(uda,@uda_title)
			  when @vP14 = 'assessment_type' 		then assessment_type
			  when @vP14 = 'facility_name'			then @vFacName
			  when @vP14 = 'facility_address'		then @vFacAddress
			  when @vP14 = 'initial_admission_date'	then initial_admission_date
			  when @vP14 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP14 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP14 = 'ids'					then ids
		  else NULL end as P14
		, Case  
			  when @vP15 = 'client_name'			then client_name
			  when @vP15 = 'client_number'			then client_id_number
			  when @vP15 = 'client_location'		then location
			  when @vP15 = 'assess_date'			then isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'')
			  when @vP15 = 'admission_date'			then admission_date
			  when @vP15 = 'date_of_birth' 			then date_of_birth 
			  when @vP15 = 'sex' 					then sex
			  when @vP15 = 'client_language' 		then client_language 
			  when @vP15 = 'physician' 				then physician 
			  when @vP15 = 'allergy'				then allergy
			  when @vP15 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP15 = 'uda'					then isnull(uda,@uda_title)
			  when @vP15 = 'assessment_type' 		then assessment_type
			  when @vP15 = 'facility_name'			then @vFacName
			  when @vP15 = 'facility_address'		then @vFacAddress
			  when @vP15 = 'initial_admission_date'	then initial_admission_date
			  when @vP15 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP15 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP15 = 'ids'					then ids
		  else NULL end as P15
		, Case  
			  when @vP16 = 'client_name'			then client_name
			  when @vP16 = 'client_number'			then client_id_number
			  when @vP16 = 'client_location'		then location
			  when @vP16 = 'assess_date'			then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'')
			  when @vP16 = 'admission_date'			then admission_date
			  when @vP16 = 'date_of_birth' 			then date_of_birth 
			  when @vP16 = 'sex' 					then sex
			  when @vP16 = 'client_language' 		then client_language 
			  when @vP16 = 'physician' 				then physician 
			  when @vP16 = 'allergy'				then allergy
			  when @vP16 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP16 = 'uda'					then isnull(uda,@uda_title)
			  when @vP16 = 'assessment_type' 		then assessment_type
			  when @vP16 = 'facility_name'			then @vFacName
			  when @vP16 = 'facility_address'		then @vFacAddress
			  when @vP16 = 'initial_admission_date'	then initial_admission_date
			  when @vP16 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP16 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP16 = 'ids'					then ids
		  else NULL end as P16
		, Case  
			  when @vP17 = 'client_name'			then client_name
			  when @vP17 = 'client_number'			then client_id_number
			  when @vP17 = 'client_location'		then location
			  when @vP17 = 'assess_date'			then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'')
			  when @vP17 = 'admission_date'			then admission_date
			  when @vP17 = 'date_of_birth' 			then date_of_birth 
			  when @vP17 = 'sex' 					then sex
			  when @vP17 = 'client_language' 		then client_language 
			  when @vP17 = 'physician' 				then physician 
			  when @vP17 = 'allergy'				then allergy
			  when @vP17 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP17 = 'uda'					then isnull(uda,@uda_title)
			  when @vP17 = 'assessment_type' 		then assessment_type
			  when @vP17 = 'facility_name'			then @vFacName
			  when @vP17 = 'facility_address'		then @vFacAddress
			  when @vP17 = 'initial_admission_date'	then initial_admission_date
			  when @vP17 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP17 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP17 = 'ids'					then ids
		  else NULL end as P17
		, Case  
			  when @vP18 = 'client_name'			then client_name
			  when @vP18 = 'client_number'			then client_id_number
			  when @vP18 = 'client_location'		then location
			  when @vP18 = 'assess_date'			then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'')
			  when @vP18 = 'admission_date'			then admission_date
			  when @vP18 = 'date_of_birth' 			then date_of_birth 
			  when @vP18 = 'sex' 					then sex
			  when @vP18 = 'client_language' 		then client_language 
			  when @vP18 = 'physician' 				then physician 
			  when @vP18 = 'allergy'				then allergy 
			  when @vP18 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP18 = 'uda'					then isnull(uda,@uda_title)
			  when @vP18 = 'assessment_type' 		then assessment_type
			  when @vP18 = 'facility_name'			then @vFacName
			  when @vP18 = 'facility_address'		then @vFacAddress
			  when @vP18 = 'initial_admission_date'	then initial_admission_date
			  when @vP18 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP18 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP18 = 'ids'					then ids
		  else NULL end as P18
		, Case  
			  when @vP19 = 'client_name'			then client_name
			  when @vP19 = 'client_number'			then client_id_number
			  when @vP19 = 'client_location'		then location
			  when @vP19 = 'assess_date'			then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'')
			  when @vP19 = 'admission_date'			then admission_date
			  when @vP19 = 'date_of_birth' 			then date_of_birth 
			  when @vP19 = 'sex' 					then sex
			  when @vP19 = 'client_language' 		then client_language 
			  when @vP19 = 'physician' 				then physician 
			  when @vP19 = 'allergy'				then allergy
			  when @vP19 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP19 = 'uda'					then isnull(uda,@uda_title)
			  when @vP19 = 'assessment_type' 		then assessment_type
			  when @vP19 = 'facility_name'			then @vFacName
			  when @vP19 = 'facility_address'		then @vFacAddress
			  when @vP19 = 'initial_admission_date'	then initial_admission_date
			  when @vP19 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP19 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP19 = 'ids'					then ids
		  else NULL end as P19
		, Case  
			  when @vP20 = 'client_name'			then client_name
			  when @vP20 = 'client_number'			then client_id_number
			  when @vP20 = 'client_location'		then location
			  when @vP20 = 'assess_date'			then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'')
			  when @vP20 = 'admission_date'			then admission_date
			  when @vP20 = 'date_of_birth' 			then date_of_birth 
			  when @vP20 = 'sex' 					then sex
			  when @vP20 = 'client_language' 		then client_language 
			  when @vP20 = 'physician' 				then physician 
			  when @vP20 = 'allergy'				then allergy 
			  when @vP20 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vP20 = 'uda'					then isnull(uda,@uda_title)
			  when @vP20 = 'assessment_type' 		then assessment_type
			  when @vP20 = 'facility_name'			then @vFacName
			  when @vP20 = 'facility_address'		then @vFacAddress
			  when @vP20 = 'initial_admission_date'	then initial_admission_date
			  when @vP20 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vP20 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vP20 = 'ids'					then ids
		  else NULL end as P20
		, Case  
			  when @vSubP1 = 'client_name'				then client_name
			  when @vSubP1 = 'client_number'			then client_id_number
			  when @vSubP1 = 'client_location'			then location
			  when @vSubP1 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP1 = 'admission_date'			then admission_date
			  when @vSubP1 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP1 = 'sex' 						then sex
			  when @vSubP1 = 'client_language' 			then client_language 
			  when @vSubP1 = 'physician' 				then physician 
			  when @vSubP1 = 'allergy'					then allergy
			  when @vSubP1 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP1 = 'uda'						then uda
			  when @vSubP1 = 'assessment_type' 			then assessment_type
			  when @vSubP1 = 'facility_name'			then @vFacName
			  when @vSubP1 = 'facility_address'			then @vFacAddress
			  when @vSubP1 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP1 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP1 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP1 = 'subids'					then subids
		  else NULL end as SubP1
		, Case  
			  when @vSubP2 = 'client_name'				then client_name
			  when @vSubP2 = 'client_number'			then client_id_number
			  when @vSubP2 = 'client_location'			then location
			  when @vSubP2 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP2 = 'admission_date'			then admission_date
			  when @vSubP2 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP2 = 'sex' 						then sex
			  when @vSubP2 = 'client_language' 			then client_language 
			  when @vSubP2 = 'physician' 				then physician 
			  when @vSubP2 = 'allergy'					then allergy 
			  when @vSubP2 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP2 = 'uda'						then uda
			  when @vSubP2 = 'assessment_type' 			then assessment_type
			  when @vSubP2 = 'facility_name'			then @vFacName
			  when @vSubP2 = 'facility_address'			then @vFacAddress
			  when @vSubP2 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP2 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP2 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP2 = 'subids'					then subids
		  else NULL end as SubP2
		, Case  
			  when @vSubP3 = 'client_name'				then client_name
			  when @vSubP3 = 'client_number'			then client_id_number
			  when @vSubP3 = 'client_location'			then location
			  when @vSubP3 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP3 = 'admission_date'			then admission_date
			  when @vSubP3 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP3 = 'sex' 						then sex
			  when @vSubP3 = 'client_language' 			then client_language 
			  when @vSubP3 = 'physician' 				then physician 
			  when @vSubP3 = 'allergy'					then allergy 
			  when @vSubP3 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP3 = 'uda'						then uda
			  when @vSubP3 = 'assessment_type' 			then assessment_type
			  when @vSubP3 = 'facility_name'			then @vFacName
			  when @vSubP3 = 'facility_address'			then @vFacAddress
			  when @vSubP3 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP3 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP3 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP3 = 'subids'					then subids
		  else NULL end as SubP3
		, Case  
			  when @vSubP4 = 'client_name'				then client_name
			  when @vSubP4 = 'client_number'			then client_id_number
			  when @vSubP4 = 'client_location'			then location
			  when @vSubP4 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP4 = 'admission_date'			then admission_date
			  when @vSubP4 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP4 = 'sex' 						then sex
			  when @vSubP4 = 'client_language' 			then client_language 
			  when @vSubP4 = 'physician' 				then physician 
			  when @vSubP4 = 'allergy'					then allergy 
			  when @vSubP4 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP4 = 'uda'						then uda
			  when @vSubP4 = 'assessment_type' 			then assessment_type
			  when @vSubP4 = 'facility_name'			then @vFacName
			  when @vSubP4 = 'facility_address'			then @vFacAddress
			  when @vSubP4 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP4 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP4 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP4 = 'subids'					then subids
		  else NULL end as SubP4
		, Case  
			  when @vSubP5 = 'client_name'				then client_name
			  when @vSubP5 = 'client_number'			then client_id_number
			  when @vSubP5 = 'client_location'			then location
			  when @vSubP5 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'')  + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP5 = 'admission_date'			then admission_date
			  when @vSubP5 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP5 = 'sex' 						then sex
			  when @vSubP5 = 'client_language' 			then client_language 
			  when @vSubP5 = 'physician' 				then physician 
			  when @vSubP5 = 'allergy'					then allergy 
			  when @vSubP5 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP5 = 'uda'						then uda
			  when @vSubP5 = 'assessment_type' 			then assessment_type
			  when @vSubP5 = 'facility_name'			then @vFacName
			  when @vSubP5 = 'facility_address'			then @vFacAddress
			  when @vSubP5 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP5 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP5 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP5 = 'subids'					then subids
		  else NULL end as SubP5
		, Case  
			  when @vSubP6 = 'client_name'				then client_name
			  when @vSubP6 = 'client_number'			then client_id_number
			  when @vSubP6 = 'client_location'			then location
			  when @vSubP6 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP6 = 'admission_date'			then admission_date
			  when @vSubP6 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP6 = 'sex' 						then sex
			  when @vSubP6 = 'client_language' 			then client_language 
			  when @vSubP6 = 'physician' 				then physician 
			  when @vSubP6 = 'allergy'					then allergy 
			  when @vSubP6 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP6 = 'uda'						then uda
			  when @vSubP6 = 'assessment_type' 			then assessment_type
			  when @vSubP6 = 'facility_name'			then @vFacName
			  when @vSubP6 = 'facility_address'			then @vFacAddress
			  when @vSubP6 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP6 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP6 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP6 = 'subids'					then subids
		  else NULL end as SubP6
		, Case  
			  when @vSubP7 = 'client_name'				then client_name
			  when @vSubP7 = 'client_number'			then client_id_number
			  when @vSubP7 = 'client_location'			then location
			  when @vSubP7 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP7 = 'admission_date'			then admission_date
			  when @vSubP7 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP7 = 'sex' 						then sex
			  when @vSubP7 = 'client_language' 			then client_language 
			  when @vSubP7 = 'physician' 				then physician 
			  when @vSubP7 = 'allergy'					then allergy 
			  when @vSubP7 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP7 = 'uda'						then uda
			  when @vSubP7 = 'assessment_type' 			then assessment_type
			  when @vSubP7 = 'facility_name'			then @vFacName
			  when @vSubP7 = 'facility_address'			then @vFacAddress
			  when @vSubP7 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP7 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP7 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP7 = 'subids'					then subids
		  else NULL end as SubP7
		, Case  
			  when @vSubP8 = 'client_name'				then client_name
			  when @vSubP8 = 'client_number'			then client_id_number
			  when @vSubP8 = 'client_location'			then location
			  when @vSubP8 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP8 = 'admission_date'			then admission_date
			  when @vSubP8 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP8 = 'sex' 						then sex
			  when @vSubP8 = 'client_language' 			then client_language 
			  when @vSubP8 = 'physician' 				then physician 
			  when @vSubP8 = 'allergy'					then allergy 
			  when @vSubP8 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP8 = 'uda'						then uda
			  when @vSubP8 = 'assessment_type' 			then assessment_type
			  when @vSubP8 = 'facility_name'			then @vFacName
			  when @vSubP8 = 'facility_address'			then @vFacAddress
			  when @vSubP8 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP8 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP8 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP8 = 'subids'					then subids
		  else NULL end as SubP8
		, Case  
			  when @vSubP9 = 'client_name'				then client_name
			  when @vSubP9 = 'client_number'			then client_id_number
			  when @vSubP9 = 'client_location'			then location
			  when @vSubP9 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP9 = 'admission_date'			then admission_date
			  when @vSubP9 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP9 = 'sex' 						then sex
			  when @vSubP9 = 'client_language' 			then client_language 
			  when @vSubP9 = 'physician' 				then physician 
			  when @vSubP9 = 'allergy'					then allergy 
			  when @vSubP9 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP9 = 'uda'						then uda
			  when @vSubP9 = 'assessment_type' 			then assessment_type
			  when @vSubP9 = 'facility_name'			then @vFacName
			  when @vSubP9 = 'facility_address'			then @vFacAddress
			  when @vSubP9 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP9 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP9 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP9 = 'subids'					then subids
		  else NULL end as SubP9
		, Case  
			  when @vSubP10 = 'client_name'				then client_name
			  when @vSubP10 = 'client_number'			then client_id_number
			  when @vSubP10 = 'client_location'			then location
			  when @vSubP10 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP10 = 'admission_date'			then admission_date
			  when @vSubP10 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP10 = 'sex' 					then sex
			  when @vSubP10 = 'client_language' 		then client_language 
			  when @vSubP10 = 'physician' 				then physician 
			  when @vSubP10 = 'allergy'					then allergy 
			  when @vSubP10 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP10 = 'uda'						then uda
			  when @vSubP10 = 'assessment_type' 		then assessment_type
			  when @vSubP10 = 'facility_name'			then @vFacName
			  when @vSubP10 = 'facility_address'		then @vFacAddress
			  when @vSubP10 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP10 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP10 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP10 = 'subids'					then subids
		  else NULL end as SubP10
		, Case  
			  when @vSubP11 = 'client_name'				then client_name
			  when @vSubP11 = 'client_number'			then client_id_number
			  when @vSubP11 = 'client_location'			then location
			  when @vSubP11 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP11 = 'admission_date'			then admission_date
			  when @vSubP11 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP11 = 'sex' 					then sex
			  when @vSubP11 = 'client_language' 		then client_language 
			  when @vSubP11 = 'physician' 				then physician 
			  when @vSubP11 = 'allergy'					then allergy 
			  when @vSubP11 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP11 = 'uda'						then uda
			  when @vSubP11 = 'assessment_type' 		then assessment_type
			  when @vSubP11 = 'facility_name'			then @vFacName
			  when @vSubP11 = 'facility_address'		then @vFacAddress
			  when @vSubP11 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP11 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP11 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP11 = 'subids'					then subids
		  else NULL end as SubP11
		, Case  
			  when @vSubP12 = 'client_name'				then client_name
			  when @vSubP12 = 'client_number'			then client_id_number
			  when @vSubP12 = 'client_location'			then location
			  when @vSubP12 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP12 = 'admission_date'			then admission_date
			  when @vSubP12 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP12 = 'sex' 					then sex
			  when @vSubP12 = 'client_language' 		then client_language 
			  when @vSubP12 = 'physician' 				then physician 
			  when @vSubP12 = 'allergy'					then allergy 
			  when @vSubP12 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP12 = 'uda'						then uda
			  when @vSubP12 = 'assessment_type' 		then assessment_type
			  when @vSubP12 = 'facility_name'			then @vFacName
			  when @vSubP12 = 'facility_address'		then @vFacAddress
			  when @vSubP12 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP12 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP12 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP12 = 'subids'					then subids
		  else NULL end as SubP12
		, Case  
			  when @vSubP13 = 'client_name'				then client_name
			  when @vSubP13 = 'client_number'			then client_id_number
			  when @vSubP13 = 'client_location'			then location
			  when @vSubP13 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP13 = 'admission_date'			then admission_date
			  when @vSubP13 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP13 = 'sex' 					then sex
			  when @vSubP13 = 'client_language' 		then client_language 
			  when @vSubP13 = 'physician' 				then physician 
			  when @vSubP13 = 'allergy'					then allergy 
			  when @vSubP13 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP13 = 'uda'						then uda
			  when @vSubP13 = 'assessment_type' 		then assessment_type
			  when @vSubP13 = 'facility_name'			then @vFacName
			  when @vSubP13 = 'facility_address'		then @vFacAddress
			  when @vSubP13 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP13 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP13 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP13 = 'subids'					then subids
		  else NULL end as SubP13
		, Case  
			  when @vSubP14 = 'client_name'				then client_name
			  when @vSubP14 = 'client_number'			then client_id_number
			  when @vSubP14 = 'client_location'			then location
			  when @vSubP14 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP14 = 'admission_date'			then admission_date
			  when @vSubP14 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP14 = 'sex' 					then sex
			  when @vSubP14 = 'client_language' 		then client_language 
			  when @vSubP14 = 'physician' 				then physician 
			  when @vSubP14 = 'allergy'					then allergy 
			  when @vSubP14 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP14 = 'uda'						then uda
			  when @vSubP14 = 'assessment_type' 		then assessment_type
			  when @vSubP14 = 'facility_name'			then @vFacName
			  when @vSubP14 = 'facility_address'		then @vFacAddress
			  when @vSubP14 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP14 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP14 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP14 = 'subids'					then subids
		  else NULL end as SubP14
		, Case  
			  when @vSubP15 = 'client_name'				then client_name
			  when @vSubP15 = 'client_number'			then client_id_number
			  when @vSubP15 = 'client_location'			then location
			  when @vSubP15 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP15 = 'admission_date'			then admission_date
			  when @vSubP15 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP15 = 'sex' 					then sex
			  when @vSubP15 = 'client_language' 		then client_language 
			  when @vSubP15 = 'physician' 				then physician 
			  when @vSubP15 = 'allergy'					then allergy 
			  when @vSubP15 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP15 = 'uda'						then uda
			  when @vSubP15 = 'assessment_type' 		then assessment_type
			  when @vSubP15 = 'facility_name'			then @vFacName
			  when @vSubP15 = 'facility_address'		then @vFacAddress
			  when @vSubP15 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP15 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP15 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP15 = 'subids'					then subids
		  else NULL end as SubP15
		, Case  
			  when @vSubP16 = 'client_name'				then client_name
			  when @vSubP16 = 'client_number'			then client_id_number
			  when @vSubP16 = 'client_location'			then location
			  when @vSubP16 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP16 = 'admission_date'			then admission_date
			  when @vSubP16 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP16 = 'sex' 					then sex
			  when @vSubP16 = 'client_language' 		then client_language 
			  when @vSubP16 = 'physician' 				then physician 
			  when @vSubP16 = 'allergy'					then allergy 
			  when @vSubP16 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP16 = 'uda'						then uda
			  when @vSubP16 = 'assessment_type' 		then assessment_type
			  when @vSubP16 = 'facility_name'			then @vFacName
			  when @vSubP16 = 'facility_address'		then @vFacAddress
			  when @vSubP16 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP16 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP16 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP16 = 'subids'					then subids
		  else NULL end as SubP16
		, Case  
			  when @vSubP17 = 'client_name'				then client_name
			  when @vSubP17 = 'client_number'			then client_id_number
			  when @vSubP17 = 'client_location'			then location
			  when @vSubP17 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP17 = 'admission_date'			then admission_date
			  when @vSubP17 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP17 = 'sex' 					then sex
			  when @vSubP17 = 'client_language' 		then client_language 
			  when @vSubP17 = 'physician' 				then physician 
			  when @vSubP17 = 'allergy'					then allergy 
			  when @vSubP17 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP17 = 'uda'						then uda
			  when @vSubP17 = 'assessment_type' 		then assessment_type
			  when @vSubP17 = 'facility_name'			then @vFacName
			  when @vSubP17 = 'facility_address'		then @vFacAddress
			  when @vSubP17 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP17 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP17 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP17 = 'subids'					then subids
		  else NULL end as SubP17
		, Case  
			  when @vSubP18 = 'client_name'				then client_name
			  when @vSubP18 = 'client_number'			then client_id_number
			  when @vSubP18 = 'client_location'			then location
			  when @vSubP18 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP18 = 'admission_date'			then admission_date
			  when @vSubP18 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP18 = 'sex' 					then sex
			  when @vSubP18 = 'client_language' 		then client_language 
			  when @vSubP18 = 'physician' 				then physician 
			  when @vSubP18 = 'allergy'					then allergy 
			  when @vSubP18 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP18 = 'uda'						then uda
			  when @vSubP18 = 'assessment_type' 		then assessment_type
			  when @vSubP18 = 'facility_name'			then @vFacName
			  when @vSubP18 = 'facility_address'		then @vFacAddress
			  when @vSubP18 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP18 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP18 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP18 = 'subids'					then subids
		  else NULL end as SubP18
		, Case  
			  when @vSubP19 = 'client_name'				then client_name
			  when @vSubP19 = 'client_number'			then client_id_number
			  when @vSubP19 = 'client_location'			then location
			  when @vSubP19 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP19 = 'admission_date'			then admission_date
			  when @vSubP19 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP19 = 'sex' 					then sex
			  when @vSubP19 = 'client_language' 		then client_language 
			  when @vSubP19 = 'physician' 				then physician 
			  when @vSubP19 = 'allergy'					then allergy 
			  when @vSubP19 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP19 = 'uda'						then uda
			  when @vSubP19 = 'assessment_type' 		then assessment_type
			  when @vSubP19 = 'facility_name'			then @vFacName
			  when @vSubP19 = 'facility_address'		then @vFacAddress
			  when @vSubP19 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP19 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP19 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP19 = 'subids'					then subids
		  else NULL end as SubP19
		, Case  
			  when @vSubP20 = 'client_name'				then client_name
			  when @vSubP20 = 'client_number'			then client_id_number
			  when @vSubP20 = 'client_location'			then location
			  when @vSubP20 = 'assess_date'				then  isnull(convert(varchar(10),assess_date, @vdateFormatStyle),'') + ' ' + isnull(substring(convert(varchar(20),assess_date, 120), 12, 5),'')
			  when @vSubP20 = 'admission_date'			then admission_date
			  when @vSubP20 = 'date_of_birth' 			then date_of_birth 
			  when @vSubP20 = 'sex' 					then sex
			  when @vSubP20 = 'client_language' 		then client_language 
			  when @vSubP20 = 'physician' 				then physician 
			  when @vSubP20 = 'allergy'					then allergy 
			  when @vSubP20 = 'Diagnoses'				then CASE WHEN @vis_blank = 1 THEN '' ELSE case when isnull(dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId), '') = '' then 'No Medical Diagnosis Found' else dbo.fn_prp_get_diagnosis(client_id,assess_date,@vFacId) end END
			  when @vSubP20 = 'uda'						then uda
			  when @vSubP20 = 'assessment_type' 		then assessment_type
			  when @vSubP20 = 'facility_name'			then @vFacName
			  when @vSubP20 = 'facility_address'		then @vFacAddress
			  when @vSubP20 = 'initial_admission_date'	then initial_admission_date
			  when @vSubP20 = 'score'					then CASE WHEN ISNULL(score, '') = '' THEN 'NA' ELSE convert(varchar,score) END
			  when @vSubP20 = 'score_category'			then CASE WHEN ISNULL(score_category, '') = '' THEN 'NA' ELSE score_category END
			  when @vSubP20 = 'subids'					then subids
		  else NULL end as SubP20
		, G_set_id
		, G1
		-- Organizes UDA print to match UDA view
		,Dense_rank() over ( ORDER BY CASE WHEN @vSort1='client_name' then client_name
										   WHEN @vSort1='client_number' then client_id_number
										   WHEN @vSort1='client_location' then location
										   ELSE ''
									  END
								  , assess_date DESC
								  , assess_id DESC
								  , section_sequence
								  , sequence
								  , group_no
								  , std_subquestion_no
								  , case when isnumeric(pick_list_sequence)=1 then cast(pick_list_sequence as int) end
								  , pick_list_value
								  , tbWithGroupSet.ordr
								  , response
								  , unique_question
								  , right('00000000'+ pick_list_value,10)
		) as row_num
		, ROW_NUMBER() OVER ( PARTITION BY client_id, assess_date, assess_id
							  ORDER BY Case when @vSort1='client_name' then client_name
									WHEN @vSort1='client_number' then client_id_number
									WHEN @vSort1='client_location' then location
									ELSE '' end
								  , assess_date DESC
								  , assess_id DESC
								  , section_sequence
								  , sequence
								  , group_no
								  , std_subquestion_no
								  , unique_question
								  , case when isnumeric(pick_list_sequence)=1 then cast(pick_list_sequence as int) end 
								  , right('00000000'+ pick_list_value,10)
		) as header_row
		, @vTermFocus + replace(
																replace(
																replace(
																	focus.text1
																	,char(10),'')
																	,char(13),'')
																	,' ' ,'') as cp_focus_sort
		from tbWithGroupSet

		left outer join dbo.cp_std_need focus WITH (NOLOCK)
			on convert(varchar(20),focus.std_need_id) = tbWithGroupSet.pick_list_value
			and tbWithGroupSet.control_type = 'cp'

	)
	, tb
	as
	(

	Select TOP 100 PERCENT 
	@vFacId as fac_id
	, client_id
	, client_name
	, client_id_number
	, location
	, admission_date
	, initial_admission_date
	, mrn_number
	, sex
	, date_of_birth
	, physician
	, allergy
	, ids
	, std_assess_id
	, assess_id
	, assess_date as effective_date
	, assessment_type
	, uda
	, section_no
	, replace(replace(section_title ,'&lt;', '<') ,'&gt;', '>') as section_title
	, section_sequence
	, group_no
	,  replace(replace(group_title ,'&lt;', '<') ,'&gt;', '>') as group_title
	, replace(replace( group_text ,'&lt;', '<') ,'&gt;', '>') as group_text
	, group_layout_style
	, sequence
	, std_question_no
	, std_subquestion_no
	, std_subquestion_AB
	, replace(replace(question_title,'&lt;', '<') ,'&gt;', '>') as question_title
	, replace(replace(question_text,'&lt;', '<') ,'&gt;', '>') as question_text
	, control_type
	, control_length
	, response_required
	, pick_list_id
	, pick_list_name
	, replace(replace(pick_list_value,'&lt;', '<') ,'&gt;', '>') as pick_list_value
	, replace(	replace(replace(pick_list_description,'&lt;', '<') ,'&gt;', '>') ,'&amp;', '&') as pick_list_description
	, pick_list_sequence		
	, pick_list_value_effective_date
	, pick_list_value_ineffective_date
	, assess_type_code
	, assess_status
	, replace(replace(resp_item_value,'&lt;', '<') ,'&gt;', '>') as resp_item_value
	, replace(replace(response,'&lt;', '<') ,'&gt;', '>') as response
	, score 
	, score_category
	, strikeout_flag
	, strikeout_by
	, strikeout_date
	, strikeout_reason
	, include_signature_section_flag
	, signed_by
	, signed_date
	, cust_hdr
	, cust_sub_hdr
	, cust_hdr_long
	, cust_sub_hdr_long
	, @vHeaderColumnCount as header_column_count
 	, P_set_id 
	, cp_focus_sort
	, case when header_row= 1 then 
		replace (	(	  CASE WHEN @vP1_disp_name IS NULL AND P1 IS NULL THEN ' ' ELSE -- NOTE: single space is required here
						  CASE WHEN @vP1_disp_name  = 'Identifiers' then '' + isnull(P1,'')  + @vSeparator2 ELSE isnull( @vP1_disp_name,'')   + @vSeparator + isnull(P1,'') + @vSeparator2 end
						+ CASE WHEN @vP2_disp_name  = 'Identifiers' then '' + isnull(P2,'')  + @vSeparator2 ELSE isnull( @vP2_disp_name,'' )  + @vSeparator + isnull(P2,'') + @vSeparator2 END 
						+ CASE WHEN @vP3_disp_name  = 'Identifiers' then '' + isnull(P3,'')  + @vSeparator2 ELSE isnull( @vP3_disp_name,'' )  + @vSeparator + isnull(P3,'') + @vSeparator2 END 
						+ CASE WHEN @vP4_disp_name  = 'Identifiers' then '' + isnull(P4,'')  + @vSeparator2 ELSE isnull( @vP4_disp_name,'' )  + @vSeparator + isnull(P4,'') + @vSeparator2 END 
						+ CASE WHEN @vP5_disp_name  = 'Identifiers' then '' + isnull(P5,'')  + @vSeparator2 ELSE isnull( @vP5_disp_name,'' )  + @vSeparator + isnull(P5,'') + @vSeparator2 END 
						+ CASE WHEN @vP6_disp_name  = 'Identifiers' then '' + isnull(P6,'')  + @vSeparator2 ELSE isnull( @vP6_disp_name,'' )  + @vSeparator + isnull(P6,'') + @vSeparator2 END 
						+ CASE WHEN @vP7_disp_name  = 'Identifiers' then '' + isnull(P7,'')  + @vSeparator2 ELSE isnull( @vP7_disp_name,'' )  + @vSeparator + isnull(P7,'') + @vSeparator2 END 
						+ CASE WHEN @vP8_disp_name  = 'Identifiers' then '' + isnull(P8,'')  + @vSeparator2 ELSE isnull( @vP8_disp_name,'' )  + @vSeparator + isnull(P8,'') + @vSeparator2 END 
						+ CASE WHEN @vP9_disp_name  = 'Identifiers' then '' + isnull(P9,'')  + @vSeparator2 ELSE isnull( @vP9_disp_name,'' )  + @vSeparator + isnull(P9,'') + @vSeparator2 END 
						+ CASE WHEN @vP10_disp_name = 'Identifiers' then '' + isnull(P10,'') + @vSeparator2 ELSE isnull( @vP10_disp_name,'' ) + @vSeparator + isnull(P10,'')+ @vSeparator2 END 
						+ CASE WHEN @vP11_disp_name = 'Identifiers' then '' + isnull(P11,'') + @vSeparator2 ELSE isnull( @vP11_disp_name,'' ) + @vSeparator + isnull(P11,'')+ @vSeparator2 END 
						+ CASE WHEN @vP12_disp_name = 'Identifiers' then '' + isnull(P12,'') + @vSeparator2 ELSE isnull( @vP12_disp_name,'' ) + @vSeparator + isnull(P12,'')+ @vSeparator2 END 
						+ CASE WHEN @vP13_disp_name = 'Identifiers' then '' + isnull(P13,'') + @vSeparator2 ELSE isnull( @vP13_disp_name,'' ) + @vSeparator + isnull(P13,'')+ @vSeparator2 END 
						+ CASE WHEN @vP14_disp_name = 'Identifiers' then '' + isnull(P14,'') + @vSeparator2 ELSE isnull( @vP14_disp_name,'' ) + @vSeparator + isnull(P14,'')+ @vSeparator2 END 
						+ CASE WHEN @vP15_disp_name = 'Identifiers' then '' + isnull(P15,'') + @vSeparator2 ELSE isnull( @vP15_disp_name,'' ) + @vSeparator + isnull(P15,'')+ @vSeparator2 END 
						+ CASE WHEN @vP16_disp_name = 'Identifiers' then '' + isnull(P16,'') + @vSeparator2 ELSE isnull( @vP16_disp_name,'' ) + @vSeparator + isnull(P16,'')+ @vSeparator2 END 
						+ CASE WHEN @vP17_disp_name = 'Identifiers' then '' + isnull(P17,'') + @vSeparator2 ELSE isnull( @vP17_disp_name,'' ) + @vSeparator + isnull(P17,'')+ @vSeparator2 END 
						+ CASE WHEN @vP18_disp_name = 'Identifiers' then '' + isnull(P18,'') + @vSeparator2 ELSE isnull( @vP18_disp_name,'' ) + @vSeparator + isnull(P18,'')+ @vSeparator2 END 
						+ CASE WHEN @vP19_disp_name = 'Identifiers' then '' + isnull(P19,'') + @vSeparator2 ELSE isnull( @vP19_disp_name,'' ) + @vSeparator + isnull(P19,'')+ @vSeparator2 END 
						+ CASE WHEN @vP20_disp_name = 'Identifiers' then '' + isnull(P20,'') + @vSeparator2 ELSE isnull( @vP20_disp_name,'' ) + @vSeparator + isnull(P20,'')+ @vSeparator2 END 
					END),'UVWXYZZYXWVU','')
			ELSE '' end
		as P1
	, case when header_row= 1 then 
		replace ((	CASE WHEN @vSubP1_disp_name IS NULL AND SubP1 IS NULL THEN ' ' ELSE -- NOTE: single space is required here
						  CASE WHEN @vSubP1_disp_name = 'Identifiers' then '' + isnull(SubP1,'')+ @vSeparator2 ELSE isnull( @vSubP1_disp_name,'' ) + @vSeparator + isnull(SubP1,'') + @vSeparator2 end
						+ CASE WHEN @vSubP2_disp_name = 'Identifiers' then '' + isnull(SubP2,'')+ @vSeparator2 ELSE isnull( @vSubP2_disp_name,'' ) + @vSeparator + isnull(SubP2,'') + @vSeparator2 END 
						+ CASE WHEN @vSubP3_disp_name = 'Identifiers' then '' + isnull(SubP3,'')+ @vSeparator2 ELSE isnull( @vSubP3_disp_name,'' ) + @vSeparator + isnull(SubP3,'') + @vSeparator2 END 
						+ CASE WHEN @vSubP4_disp_name = 'Identifiers' then '' + isnull(SubP4,'')+ @vSeparator2 ELSE isnull( @vSubP4_disp_name,'' ) + @vSeparator + isnull(SubP4,'') + @vSeparator2 END 
						+ CASE WHEN @vSubP5_disp_name = 'Identifiers' then '' + isnull(SubP5,'')+ @vSeparator2 ELSE isnull( @vSubP5_disp_name,'' ) + @vSeparator + isnull(SubP5,'') + @vSeparator2 END 
						+ CASE WHEN @vSubP6_disp_name = 'Identifiers' then '' + isnull(SubP6,'')+ @vSeparator2 ELSE isnull( @vSubP6_disp_name,'' ) + @vSeparator + isnull(SubP6,'') + @vSeparator2 END 
						+ CASE WHEN @vSubP7_disp_name = 'Identifiers' then '' + isnull(SubP7,'')+ @vSeparator2 ELSE isnull( @vSubP7_disp_name,'' ) + @vSeparator + isnull(SubP7,'') + @vSeparator2 END 
						+ CASE WHEN @vSubP8_disp_name = 'Identifiers' then '' + isnull(SubP8,'')+ @vSeparator2 ELSE isnull( @vSubP8_disp_name,'' ) + @vSeparator + isnull(SubP8,'') + @vSeparator2 END 
						+ CASE WHEN @vSubP9_disp_name = 'Identifiers' then '' + isnull(SubP9,'')+ @vSeparator2 ELSE isnull( @vSubP9_disp_name,'' ) + @vSeparator + isnull(SubP9,'') + @vSeparator2 END 
						+ CASE WHEN @vSubP10_disp_name = 'Identifiers' then '' + isnull(SubP10,'')+ @vSeparator2 ELSE isnull( @vSubP10_disp_name,'' ) + @vSeparator + isnull(SubP10,'')+ @vSeparator2 END 
						+ CASE WHEN @vSubP11_disp_name = 'Identifiers' then '' + isnull(SubP11,'')+ @vSeparator2 ELSE isnull( @vSubP11_disp_name,'' ) + @vSeparator + isnull(SubP11,'')+ @vSeparator2 END 
						+ CASE WHEN @vSubP12_disp_name = 'Identifiers' then '' + isnull(SubP12,'')+ @vSeparator2 ELSE isnull( @vSubP12_disp_name,'' ) + @vSeparator + isnull(SubP12,'')+ @vSeparator2 END 
						+ CASE WHEN @vSubP13_disp_name = 'Identifiers' then '' + isnull(SubP13,'')+ @vSeparator2 ELSE isnull( @vSubP13_disp_name,'' ) + @vSeparator + isnull(SubP13,'')+ @vSeparator2 END 
						+ CASE WHEN @vSubP14_disp_name = 'Identifiers' then '' + isnull(SubP14,'')+ @vSeparator2 ELSE isnull( @vSubP14_disp_name,'' ) + @vSeparator + isnull(SubP14,'')+ @vSeparator2 END 
						+ CASE WHEN @vSubP15_disp_name = 'Identifiers' then '' + isnull(SubP15,'')+ @vSeparator2 ELSE isnull( @vSubP15_disp_name,'' ) + @vSeparator + isnull(SubP15,'')+ @vSeparator2 END 
						+ CASE WHEN @vSubP16_disp_name = 'Identifiers' then '' + isnull(SubP16,'')+ @vSeparator2 ELSE isnull( @vSubP16_disp_name,'' ) + @vSeparator + isnull(SubP16,'')+ @vSeparator2 END 
						+ CASE WHEN @vSubP17_disp_name = 'Identifiers' then '' + isnull(SubP17,'')+ @vSeparator2 ELSE isnull( @vSubP17_disp_name,'' ) + @vSeparator + isnull(SubP17,'')+ @vSeparator2 END 
						+ CASE WHEN @vSubP18_disp_name = 'Identifiers' then '' + isnull(SubP18,'')+ @vSeparator2 ELSE isnull( @vSubP18_disp_name,'' ) + @vSeparator + isnull(SubP18,'')+ @vSeparator2 END 
						+ CASE WHEN @vSubP19_disp_name = 'Identifiers' then '' + isnull(SubP19,'')+ @vSeparator2 ELSE isnull( @vSubP19_disp_name,'' ) + @vSeparator + isnull(SubP19,'')+ @vSeparator2 END 
						+ CASE WHEN @vSubP20_disp_name = 'Identifiers' then '' + isnull(SubP20,'')+ @vSeparator2 ELSE isnull( @vSubP20_disp_name,'' ) + @vSeparator + isnull(SubP20,'')+ @vSeparator2 END 
				END),'UVWXYZZYXWVU','') 
			ELSE '' end
		as SubP1
	, NULL 	as P2
	, NULL 	as P3
	, G_set_id  ---0/1
	, G1
	, Null as G2
	, Null as G3
	,Case when @vFooter = 'footer_2' then 
			'Signature'		   + @vSeparator + '' + @vSeparator
	      + 'Date'			   + @vSeparator + '' + @vSeparator	
--		  + (Select Replace(chart_codes, '[$]', @vSeparator) from @PRP_ChartCodes )
--		 when isnull(@vfooter,'footer_1') = 'footer_1' then
--			client_name
--			else NULL end
		 when @vFooter = 'footer_1' then
			client_name
		else  
			signed_by			+ @vSeparator + '' + @vSeparator
	      + signed_date			+ @vSeparator + '' + @vSeparator	
		end  
		as page_footer
	, row_num
	, @status_code as status_code
	, @status_text as status_text
	, header_row
	, print_s
	, replace(replace(replace(replace(
				ams_key
				,'&lt;', '<') 
				,'&gt;', '>') ,'&amp;', '&'), '"','&#34;')
				as ams_key
	, file_metadata_id
   	from tbWithSort
	)

	Select 
		  case when tb.std_assess_id is null then null else tb.fac_id end fac_id
		,  tb.std_assess_id
		,  tb.assess_id
		,  tb.effective_date
		,  tb.assessment_type
		,  tb.uda
		,  case when tb.std_assess_id is null then '' else tb.section_no end section_no
		,  case when tb.std_assess_id is null then '' else dbo.fn_scape_characters(rtrim(tb.section_title), '<')	 end section_title
		,  tb.section_sequence
		,  tb.group_no
		, dbo.fn_scape_characters(rtrim(tb.group_title), '<') as group_title
		, dbo.fn_scape_characters(rtrim(tb.group_text) , '<') as group_text
		,  tb.group_layout_style
		,  tb.sequence
		,  tb.std_question_no
		,  tb.std_subquestion_no
		,  tb.std_subquestion_AB
		, dbo.fn_scape_characters( rtrim(tb.question_title), '<') as question_title
		, dbo.fn_scape_characters(	rtrim(tb.question_text), '<') as question_text
		,  tb.control_type
		,  tb.control_length
		,  tb.response_required
		,  tb.pick_list_id
		,  tb.pick_list_name
		,  dbo.fn_scape_characters(	rtrim(tb.pick_list_value), '<')	as pick_list_value
		, dbo.fn_scape_characters( rtrim(tb.pick_list_description), '<') as pick_list_description
		,  tb.pick_list_sequence		
		,  tb.pick_list_value_effective_date
		,  tb.pick_list_value_ineffective_date
		,  tb.assess_type_code
		,  tb.assess_status
		, dbo.fn_scape_characters(	rtrim(tb.resp_item_value), '<') as resp_item_value 
		,  tb.response
		,  tb.score 
		,  tb.score_category
		,  tb.strikeout_flag
		,  tb.strikeout_by
		,  tb.strikeout_date
		,  tb.strikeout_reason
		,  tb.include_signature_section_flag
		,  tb.signed_by
		,  tb.signed_date
		,  tb.header_column_count
		,  tb.P_set_id   ---0/1
		, CASE WHEN  tb.header_row = 1 THEN LEFT(P1,
				   CASE 
						WHEN charindex('Title' + @vSeparator, P1) <> 0 then charindex('Title' + @vSeparator, P1)
						WHEN charindex('Allergies' + @vSeparator, P1) <> 0 then charindex('Allergies' + @vSeparator, P1)
						WHEN charindex('Diagnoses' + @vSeparator, P1) <> 0 then charindex('Diagnoses' + @vSeparator, P1)
						ELSE len(P1) + 1 END - 1
					) -- left part
					+ isnull(cust_hdr, '') -- middle part
					+ SUBSTRING(P1,
					CASE 
						WHEN charindex('Title' + @vSeparator, P1) <> 0 then charindex('Title' + @vSeparator, P1)
						WHEN charindex('Allergies' + @vSeparator, P1) <> 0 then charindex('Allergies' + @vSeparator, P1)
						WHEN charindex('Diagnoses' + @vSeparator, P1) <> 0 then charindex('Diagnoses' + @vSeparator, P1)
						ELSE len(P1) + 1 END
					, 8000) -- right part
				ELSE ''
		  END AS P1
		, CASE WHEN  tb.header_row = 1 THEN LEFT(SubP1,
				   CASE 
						WHEN charindex('Title' + @vSeparator, SubP1) <> 0 then charindex('Title' + @vSeparator, SubP1)
						WHEN charindex('Allergies' + @vSeparator, SubP1) <> 0 then charindex('Allergies' + @vSeparator, SubP1)
						WHEN charindex('Diagnoses' + @vSeparator, SubP1) <> 0 then charindex('Diagnoses' + @vSeparator, SubP1)
						ELSE len(SubP1) + 1 END - 1
					) -- left part
					+ isnull(cust_sub_hdr, '') -- middle part
					+ SUBSTRING(SubP1,
					CASE 
						WHEN charindex('Title' + @vSeparator, SubP1) <> 0 then charindex('Title' + @vSeparator, SubP1)
						WHEN charindex('Allergies' + @vSeparator, SubP1) <> 0 then charindex('Allergies' + @vSeparator, SubP1)
						WHEN charindex('Diagnoses' + @vSeparator, SubP1) <> 0 then charindex('Diagnoses' + @vSeparator, SubP1)
						ELSE len(SubP1) + 1 END
					, 8000) -- right part
				ELSE ''
		  END AS SubP1

		, CASE WHEN  tb.header_row = 1 then reverse(stuff(reverse(cust_hdr_long),1,10,'')) else '' end P1_long
		, CASE WHEN  tb.header_row = 1 then reverse(stuff(reverse(cust_sub_hdr_long),1,10,'')) else '' end SubP1_long
		, P2
		, P3
		, G_set_id  ---0/1
		, G1
		, G2
		, G3
		, page_footer
		--, col_width
		, (case when row_num = 1 then status_code else null end )status_code 
		, (case when row_num = 1 then isnull(status_text,'')  + isnull(' Error from term:  '  + @vtermErrorMsg,'') else null end )status_text	
		,row_num
		,cp_focus_sort
		, print_s
		--, null [file_name]
		--, null pixel_height
		--, null pixel_width
		--, convert(image,null) image_data

		, pix.[file_name]
		,pix.pixel_height
		,pix.pixel_width
		, case when row_num = 1 then  pix.image_data else null end as image_data
		,dbo.fn_scape_characters(	rtrim(tb.ams_key), '<') as ams_key 
		,file_metadata as file_metadata_id
	from tb
		left outer join 
			(select cfg_pix.[file_name]
				,cfg_pix.pixel_height
				,cfg_pix.pixel_width
				,cfg_pix.image_data
				, pix_map.std_assess_id
				,cfg_pix.fac_id
		 from dbo.cfg_image cfg_pix with (nolock)
			inner join dbo.as_std_assessment_cfg_image_mapping pix_map WITH (NOLOCK)
			on cfg_pix.image_id = pix_map.image_id
			) pix
			on pix.std_assess_id = tb.std_assess_id
		OUTER APPLY (	SELECT	 STUFF(ids, 1, LEN(@vSeparator), '')
						FROM	(	SELECT @vSeparator + cast(file_metadata_id as varchar(20))
									FROM dbo.as_assessment_file_mapping m with (nolock)
									WHERE m.assess_id = tb.assess_id
									FOR XML PATH ('')
								) AS f (ids)
					) fm (file_metadata)				
			 
		
		where (@vrecnum = 0 OR header_row <= @vrecnum)  -- this condition was added to help jrxml debug the template because of too many control types and lay outs 

	Order by  row_num

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'



END TRY 

BEGIN CATCH 
	if @status_code = 0 Set @Status_Code = 1 else set @status_code = 2  --- convert 3 to 2
	if @status_code = 1
	BEGIN
		select @Status_Text = Rtrim(Left('Stored Procedure Failed with error Code : ' +   Cast(error_number() as Varchar(10)) +  ' Line Number : ' +  Cast(ERROR_LINE() as Varchar(5)) + ' ' +  ERROR_MESSAGE(),3000))

		if @debug_me='Y' Print 'Stored procedure failure in step:'+ convert(varchar(3),@vstep) + '	' + convert(varchar(26),getdate())
		if @debug_me='Y' Print 'Error code: '+convert(varchar(3),@vStep) + '; Error description:	' + @Status_Text + 'Error from term:  ' + isnull(@vtermErrorMsg,'')
	END 


	Select 
		  NULL as fac_id
		, NULL as std_assess_id
		, NULL as assess_id
		, NULL as effective_date
		, NULL as assessment_type
		, NULL as uda
		, NULL as section_no
		, NULL as section_title
		, NULL as section_sequence
		, NULL as group_no
		, NULL as group_title
		, NULL as group_text
		, NULL as group_layout_style
		, NULL as sequence
		, NULL as std_question_no
		, NULL as std_subquestion_no
		, NULL as std_subquestion_AB
		, NULL as question_title
		, NULL as question_text
		, NULL as control_type
		, NULL as control_length
		, NULL as response_required
		, NULL as pick_list_id
		, NULL as pick_list_name
		, NULL as pick_list_value
		, NULL as pick_list_description	
		, NULL as pick_list_sequence		
		, NULL as pick_list_value_effective_date
		, NULL as pick_list_value_ineffective_date
		, NULL as assess_type_code
		, NULL as assess_status
		, NULL as resp_item_value
		, NULL as response
		, NULL as score 
		, NULL as score_category
		, NULL as strikeout_flag
		, NULL as strikeout_by
		, NULL as strikeout_date
		, NULL as include_signature_section_flag
		, NULL as strikeout_reason
		, NULL as signed_by
		, NULL as signed_date
		, NULL as header_column_count
		, NULL as P_set_id   ---0/1
		, NULL as P1
		, NULL as SubP1
		, NULL as P1_long
		, NULL as SubP1_long
		, NULL as P2
		, NULL as P3
		, null as print_s
		, NULL as G_set_id  ---0/1
		, NULL as G1
		, NULL as G2
		, NULL as G3
		, NULL as page_footer
		, null as cp_focus_sort
		, @status_code as status_code
		, @status_text + isnull(' Error from term:  '  + @vtermErrorMsg,'')  as status_text	
		, NULL as assess_id
		, NULL as row_num
		, null [file_name]
		, null pixel_height
		, null pixel_width
		, convert(image,null) as image_data
		, null as ams_key 
		, null as file_metadata_id
		
END CATCH 

RETURN 

END
GO
GRANT EXECUTE ON  dbo.sproc_prp_rl_ocpc_uda_report  to PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_prp_rl_ocpc_uda_report.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_ocpc_uda_report.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_poc_documentation_survey_hybrid.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- PCC-80308       :   script to sproc_prp_rl_poc_documentation_survey_hybrid Procedure  
--						-- 
-- Written By:          H Ehghaghi
-- Reviewed By:         
-- 
-- Script Type:         DDL 
-- Target DB Type:      Client
-- Target ENVIRONMENT:  BOTH (US/CA) 
-- 
-- 
-- Re-Runable:          YES 
-- 
-- Description of Script : Create sproc_prp_rl_poc_documentation_survey_hybrid Procedure for Document Survey Report
-- 
-- Special Instruction: 

-- 
-- =================================================================================

/***********************************************************************************
Revision History:
-- DATE			NAME				JIRA           VERSION		DESCRIPTION
-- 2015-10-07	 	H. Ehghaghi		PCC-80980 	3.7.8.1		Fixed various bug
-- 2015-10-07	 	H. Ehghaghi		PCC-80980 	3.7.8.1		Fixed Duration Schedule bug
-- 2015-10-15	 	H. Ehghaghi		PCC-80980 	3.7.8.1		Join two result set in one
-- 2015-10-15	 	H. Ehghaghi		PCC-80980 	3.7.8.1		Improve Performance
-- 2015-10-15	 	H. Ehghaghi		PCC-80980 	3.7.8.1		Add is_chart parameter for supporting clinical chart date range
-- 2015-10-15	 	H. Ehghaghi		PCC-80980 	3.7.8.1		fixed Struck Out information and BA request
-- 2015-10-15	 	H. Ehghaghi		PCC-80980 	3.7.8.1		add client_id to struck out information
-- 2015-11-03	 	H. Ehghaghi		PCC-80980 	3.7.8.1		Fixed time zone issue and legend part
-- 2015-11-05	 	H. Ehghaghi		PCC-80980 	3.7.8.1		Fixed various bug
-- 2015-11-05	 	H. Ehghaghi		PCC-80980 	3.7.8.1		Fixed Unschedule task bug   
-- 2015-11-05	 	H. Ehghaghi		PCC-84854 	3.7.8.1		Fixed schedule and Prn issue  
-- 2015-11-05	 	H. Ehghaghi		PCC-84854 	3.7.8.1		Fixed field to display
-- 2015-11-10	 	H. Ehghaghi		PCC-84856 	3.7.8.1		Fixed  Unscheduled documentation not shown  
-- 2015-11-11	 	H. Ehghaghi		PCC-85189 	3.7.9		Fixed  Data Issue for Prn and Qshift  
-- 2015-11-11	 	H. Ehghaghi		PCC-85189 	3.7.9		Fixed  Data Issue  schedule date
-- 2015-11-15	 	H. Ehghaghi		PCC-85189 	3.7.9		Fixed  Multi document PRN and Qshift 
-- 2015-11-20	 	H. Ehghaghi		PCC-85186 	3.7.9		Fixed  Legend and historical picklist 
-- 2015-11-20	 	H. Ehghaghi		PCC-85186 	3.7.9		Fixed  struck out Pick List Issue 
-- 2015-12-15	 	H. Ehghaghi		PCC-86848 	3.7.9		Performance Improvement 
-- 2015-12-17	 	H. Ehghaghi		PCC-86848 	3.7.9		Apply DM Comment
-- 2016-01-05	 	H. Ehghaghi		PCC-86848 	3.7.9		Fixed the date issue
-- 2016-01-08	 	H. Ehghaghi		PCC-87851 	3.7.9		Fixed resolve date issue
-- 2016-02-22		R. Sanchez		PCC-85292	3.7.9.1		Added more struck out information
-- 2016-03-10	 	H. Ehghaghi		PCC-91537 	3.7.9.0.2.5	Fixed effective date of 12/31/1969
-- 2016-07-04	 	L. Mendzeleu	PCC-92983 	3.7.10.2	Fixed reading short codes from POC General Configuration
-- 2016-07-06		R. Sanchez		PCC-97103	3.7.11		Display data base from documented date instead of schedule date
-- 2016-07-06		L. Mendzeleu	PCC-97103	3.7.11		Fixed bug with monthly MD schedule which was introduced earlier by implementation of PCC-97103
-- 2016-07-25		L. Mendzeleu	PCC-97103	3.7.11		Addressing issue of usage prev day schedule for after midnight documentation on night shift. Part of implementation of PCC-97103
-- 2016-08-16		L. Mendzeleu	PCC-93739	3.7.11 		POC: Documentation Survey report V2- documentation not appearing correctly
-- 2016-08-18 		L. Mendzeleu 	PCC-99843 	3.7.11		POC: Documentation Survey report V2-Schedules not appearing in report for some org/facilities
-- 2016-08-30		R. Sanchez		PCC-99875	3.7.11		blank report is displayed when adding another night shift to the facility
-- 2016-09-07		R. Sanchez		PCC-96344	3.7.11		POC: Documentation Survey Report V2 displays with No data found when running the report within POC go live date
-- 2016-09-27		K. Niakhai		PCC-100840	3.7.11.1	POC: Documentation Survey report V2- responses are being repeated in the report output for a schedule with specific time and with overlapping shifts
-- 2016-10-19		R. Sanchez		PCC-96952	3.7.11.1	Support UK terminology and date format
-- 2016-11-09		K. Niakhai		PCC-95083	3.7.11.1	Reports: Documentation Survey Report V2 missing follow up question responses in legend
-- 2016-11-11		K. Niakhai		PCC-104829	3.7.11.1	UK terms- doc survey report v2- dates not formatted in the poc legend in the report
-- 2016-11-21		R. Sanchez		PCC-105011		3.7.11.0.12/3.7.11.1.1	Swap short code with item value when applicable
-- 2016-11-23	Rolly Sanchez		PCC-105564		3.7.12	Update framework related to UK local terminology
-- 2016-11-29		K. Niakhai		PCC-105825		3.7.11.2	Apply date formating for fixed effective date of 12/31/1969
-- 2016-12-02	Rolly Sanchez		PCC-103375		3.7.11.1.4	Return all sched even if the shift is not on POC Assignment setup
-- 2017-01-13 Rolly Sanchez		PCC-107258		3.7.12		Change logic for localization based on user's default facility
-- 2017-02-08		K. Niakhai		PCC-106350 3.7.12.1	Clinical Reports: Documentation Survey Report V2 not displaying intervention that has documentation completed
-- 2017-02-13		R. Sanchez		PCC-107045 3.7.12.1	legend and short code is missing when the picklist item got deleted
-- 2017-02-27		R. Sanchez		PCC-106920 3.7.12.1	include schedule time on the final sort
-- 2017-03-28		R. Sanchez		PCC-111846	 3.7.12.1	Change logic on how to retrieve data from historical
-- 2017-04-11		R. Sanchez		PCC-113577 3.7.12.2	Include 2nd signature
-- 2017-04-21		R.Sanchez		PCC-114737	 3.7.12.2	Exclude struck out secondary signature on legend
-- 2017-04-25		R.Sanchez		PCC-113569	 3.7.12.2	Exclude Daily Notes
-- 2017-05-01		R.Sanchez		PCC-115262 3.7.12.2	Exclude Daily Notes on Struck out information
-- 2017-05-11		K. Niakhai		PCC-104767 3.7.13 Documentation Survey Report v2: Some unscheduled tasks data not shown	
-- 2017-05-12		K. Niakhai		PCC-104767 3.7.13 Documentation Survey Report v2: Some unscheduled tasks data not shown due to intervention marked as resolved.
-- 2017-05-12		R. Sanchez		PCC-97856 3.7.13 POC: Documentation Survey Report V2 User Legend enhancement
-- 2017-05-19		R.Sanchez		PCC-116434 3.7.13	Display legend if its configure to create pass/back dated schedule
-- 2017-06-23		R.Sanchez		PCC-117810		3.7.14	Add blood sugar control type to the report	
-- 2017-09-19		R.Sanchez		PCC-119766 3.7.14.1	Reports: POC Documentation Survey Report V2 is showing "no data found" when there is POC documentation for the resident 
-- 2017-10-06		R.Sanchez		CORE-2713  3.7.13.2.7			Showing incorrect documented response according to what was recorded - it showing item value instead of short code
-- 2017-10-27		R. Sanchez		CORE-5343	3.7.15	POC Documentation survey V2 schedule that fall during DST time change is not adjusted on UK facility
-- 2018-01-22		R. Sanchez		CORE-9946	3.7.15	Report generate no data found incorrectly
-- 2018-01-29		R. Sanchez		CORE-10293	3.7.15.1	Technical jira: log error to execution_statistics table
-- 2018-02-06		R. Sanchez		CORE-9205	3.7.15.2	Follow up question show out of sequence after revision
-- 2018-09-24		R. Sanchez		CORE-13175	3.7.17.1	Enhance to support GHC performance issue
-- 2019-04-24       Mustafa Behrainwala	CORE-38896	Multi-Select: Reporting - Investigate SPROC Change For Documentation Survey Report v2
-- 2019-07-09 		R. Kim			CORE-36082	3.7.20		Documentation Survey Report V2: displays a blank box where there is recorded documentation on first of month
-- 2019-07-24 		R. Kim			CORE-46146	3.7.20		POC: Documentation Survey Report V2 displays "An unexpected error has occurred."
-- 2020-05-22 		R. Kim			CORE-65537	4.2.0		Documentation Survey Report: Support Narrative Text Control Type.
*********************************************************************************************************/


IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_prp_rl_poc_documentation_survey_hybrid' and ROUTINE_TYPE = 'PROCEDURE' )
BEGIN
	DROP PROCEDURE dbo.sproc_prp_rl_poc_documentation_survey_hybrid
END
GO



Create Procedure dbo.sproc_prp_rl_poc_documentation_survey_hybrid
 @report_id int
, @fac_id int
, @is_emc  bit = '0'
, @field_list varchar(max)
, @filter_list varchar(max)
, @is_chart varchar(200)='0'
, @execution_user_login varchar(60)	--- login username of person running the report
, @rows_returned int out
, @debug_me char(1)
, @status_code int out
, @status_text varchar(3000)	out
/********************************************************************************

Declare  @rows_ret int		,@statuscode int		,@statustext varchar(3000)
exec dbo.sproc_prp_rl_poc_documentation_survey_hybrid
 @report_id = -1026,
 @fac_id = 2,
 @field_list = 'photo,1;initial,1;doc_time,1;user_legend,1;struck_out,1',
 @filter_list = 'client_id=2174;ds_schedule_mth_yr=10,2015;ds_type=-1',
 --@is_chart='2015-10-15,2015-10-31',
 @execution_user_login = 'sanchr',
 @rows_returned = null,
 @debug_me = 'n',
 @status_code = null,
 @status_text = null

**********************************************************************************/
as
Begin

SET NOCOUNT ON;
----Local Variables
DECLARE     @vReportId int
		, @vFacId int
		, @vIsEMC bit
		, @vFieldList varchar(max)
		, @vFilterList varchar(max)
		, @vSortList varchar(max)
		, @vEnv varchar(5)
		, @vIs_chart varchar(max);

----Parameter Sniffing - use local variables when they are used in a where clause
SET @vReportId    = @report_id;
SET @vFacID	   = @fac_id;
SET @vFieldList   = @field_list;
SET @vFilterList  = @filter_list;
SET @vIsEMC	   = @is_emc;
SET @vIs_chart	   = @is_chart;

----MRN Variables for header
DECLARE	  @vMRNId int
		, @vMRNDesc varchar(100);

------TERMINOLOGY VARIABLES and COMMON VARIABLES FOR A FAC
DECLARE @vTermClient       VARCHAR(50),
        @vTermAdmission    VARCHAR(50),
        @vTerm_Client      VARCHAR(50),
        @vTermClients      VARCHAR(50),
        @vTermFacility     VARCHAR(50),
        @vTermFacilities   VARCHAR(50),
        @vTerm_Admission   VARCHAR(50),
        @vTermAdmissions   VARCHAR(50),
        @vTermDischarge    VARCHAR(50),
        @vTermDischarges   VARCHAR(50),
        @vTermRoom         VARCHAR(50),
        @vTermRooms        VARCHAR(50),
		@vTermTask		varchar(1000),
		@vTermIntervention		varchar(1000),
        @vTermAdvDirective VARCHAR(50);

--Standard local variables required for any stored proc
DECLARE @vStep              INT,
        @vStepName          VARCHAR(100),
        @step_start_time    DATETIME,
        @vErr               VARCHAR(MAX),
        @vDelim             CHAR(1),
        @vDelim_s           CHAR(1),
        @vCharNewLine       CHAR(2),
        @vNewLine           CHAR(1),
        @vTab               CHAR(1),
        @vPlaceHolder		CHAR(5),
        @vSeparator         CHAR(6),
        @vReportDate        DATETIME		,	--- usually same as getdate() unless report has some specific requirements
        @vRowCount          INT,
        @vResponseSeparator VARCHAR(17)		,	-- s/b 2 x len(@vTempCharNewLine) + 1
        @vTempCharNewLine   VARCHAR(8);


--Facility Related variables, also used in capturing execution Statistics
DECLARE @vFacIDs VARCHAR(MAX);
DECLARE @vFacWarningMsg VARCHAR(MAX);

-----Governor and Statistics Variables
DECLARE @vgs_program_name   VARCHAR(200),
        @vgs_execution_user VARCHAR(60),
	   @vgs_start_time     DATETIME;

-----Variables for each column and sort in the report
 DECLARE 	 @header        VARCHAR(50)

---max of 3 group levels are supported
DECLARE @vfil_ds_task_choice INT,	-- result of incl (only) task dialog
        @vfil_client_id      BIT,
        @vfil_ds_type        BIT;

 -- Field to Display
DECLARE @vIncludePhoto          BIT,
        @vIncludeDocumentRespon BIT,
        @vIncludeInitial        BIT,
        @vIncludeDocumentTime   BIT,
        @vIncludeStruckOut      BIT,
        @vIncludeUserLegend     BIT;

DECLARE

	   @vfil_ds_schedule_mth_yr      VARCHAR(7),
	   @vfil_ds_schedule_mth         SMALLINT,
	   @vfil_ds_schedule_yr          SMALLINT,
	   @vfil_ds_schedule_date        DATETIME,
	   @vfil_ds_schedule_date2       DATETIME,
	   @vfil_ds_last_day_of_month    DATETIME,
	   @vfil_ds_schedule_date_tzadj  DATETIME	,
	   @vfil_ds_schedule_date2_tzadj DATETIME	,
	   @vfil_ds_schedule_date2_tzadj_plus1 DATETIME	,
	   @vdaylightStart               DATETIME,
	   @vdaylightEnd                 DATETIME,
	   @vyear                        SMALLINT,
	   @vStartOfMarch                DATETIME,
	   @vStartOfNovember             DATETIME,
	   @vPocGoLiveDate			   DATETIME,
	   @vCountryId					INT,
	   @vAdjtoDST				char(1),
	   @vCountryName varchar(260),
	   @vCountryCode char(2),
	   @vdateFormatStyle smallint,
	   @vgoal_flag							tinyint = 1;
----Client access variables
DECLARE @client_id VARCHAR(MAX);

DECLARE @vClientIDs VARCHAR(MAX);

DECLARE @vClientWarningMsg VARCHAR(MAX);--- to know whether it the returned list is restricted

DECLARE @vCurrentDate             DATETIME,
        @vOldestDate              DATETIME,
        @today                    DATETIME,
        @vMaxHist                 DATETIME;

DECLARE @vfil_fuq_options           BIT,
        @vfil_fuq_options_for_mds_g BIT,
        @vfil_poc_advanced          BIT,
        @vseq                       BIGINT,
		@vAllowPastSched char(1),
	   @vShowHistorical            BIT,
	   @SystemPicklist             varchar(max);

CREATE TABLE #PRP_Report_Metadata_FieldstoDisplay(filter_name  VARCHAR(100),
                                                  filter_value TINYINT);

CREATE TABLE #PRP_ClientList(client_id           INT,
                             client_name         VARCHAR(200),
                             admission_date      datetime,
                             discharge_date      VARCHAR(10),
                             deceased_date       VARCHAR(10),
                             gender              CHAR(1),
                             allergy             VARCHAR(1000),
                             location            VARCHAR(500),
                             date_of_birth       VARCHAR(10),
                             client_physician_id VARCHAR(15)		, --- required for building grouping id
                             client_physician    VARCHAR(200),
                             client_pharmacy     VARCHAR(75),
                             mrn_number          VARCHAR(50),
                             client_id_number    VARCHAR(35),
                             photo               VARCHAR(50),
					    photo_date          VARCHAR(11),
					    current_care_plan_id  int );

CREATE CLUSTERED INDEX _tmp_idx_prp_clients ON #PRP_ClientList(client_id);

CREATE TABLE #PRP_ds_interventions(client_id           INT,
                                   gen_intervention_id INT,
                                   intervention_id     INT,
                                   std_intervention_id INT,
                                   resolved_date       DATETIME,
                                   flowsheet           CHAR(1),
                                   current_row         CHAR(1),
                                   fac_id              INT,
                                   text1               VARCHAR(MAX),
                                   date_initiated      DATETIME);

CREATE NonCLUSTERED INDEX _tmp_idx_prp_interventions on #PRP_ds_interventions(fac_id,client_id)
INCLUDE (gen_intervention_id,intervention_id,std_intervention_id);



CREATE TABLE #PRP_Filters(filter_name  VARCHAR(50),
                          filter_value VARCHAR(50));

CREATE TABLE #stdQuestionIdTable(genInterventionId           INT,
                                 interventionId              INT,
                                 stdInterventionId           INT,
                                 stdQuestionId               INT,
                                 stdQuestionText             VARCHAR(max),
                                 stdQuestionContorlType      VARCHAR(5),
                                 stdQuestionEffective_Date   DATETIME,
                                 stdQuestionIneffective_Date DATETIME,
                                 stdPickListId               INT,
                                 sequence                    INT,
                                 system_control_flag         CHAR(1),
                                 mds_question_key_old        varchar(max),
                                 less_picklist               BIT,
                                 rowNumber                   INT,
								 stdQuestionRank			 TINYINT,
								 fac_id						 INT );

CREATE CLUSTERED INDEX IDX_stdInterventionId_stdQuestionId_UIDX ON #stdQuestionIdTable(stdQuestionId, fac_id)
CREATE NOnCLUSTERED INDEX IDX_stdInterventionId_stdQuestionIdUIDX ON #stdQuestionIdTable(genInterventionId,interventionId,stdInterventionId)
 INCLUDE (less_picklist, system_control_flag, mds_question_key_old, sequence,stdQuestionIneffective_Date,stdQuestionEffective_Date);

CREATE TABLE #stdPickListTable(genInterventionId     INT,
                               interventionId        INT,
                               stdInterventionId     INT,
                               stdQuestionId         INT,
                               std_pick_list_item_id INT,
                               std_pick_list_id      INT,
                               item_value            VARCHAR(2000),
                               description           VARCHAR(200),
                               sequence              INT,
                               short_code            varchar(max),
                               effective_date        DATETIME,
                               ineffective_date      DATETIME);

CREATE NONCLUSTERED INDEX IDX_InterventionId_stdPickListIdUIDX ON #stdPickListTable(std_pick_list_id);
CREATE NONCLUSTERED INDEX IDX_InterventionId_stdPickListId_UIDX ON #stdPickListTable(genInterventionId,interventionId,stdInterventionId)
INCLUDE (effective_date,ineffective_date,stdQuestionId,std_pick_list_item_id);



DECLARE @pocGeneralConfig TABLE(id_key           INT IDENTITY(1, 1),
                                name             VARCHAR(100),
                                [value]          VARCHAR(100),
                                effective_date   DATETIME,
                                ineffective_date DATETIME);

DECLARE @pocShortCodesConfig TABLE([id]			  INT IDENTITY(1, 1),
						  [default_value_id]  VARCHAR(100),
                                [name]			  VARCHAR(100),
                                [value]			  VARCHAR(max),
                                [effective_date]	  DATETIME,
                                [ineffective_date]  DATETIME);

CREATE TABLE #cp_documentation_responses(schedule_detail_id     VARCHAR(1000),
                                         client_id              INT,
                                         gen_intervention_id    INT,
                                         intervention_id        INT,
                                         std_intervention_id    INT,
                                         text1                  VARCHAR(MAX),
                                         stdQuestionId          INT,
                                         stdQuestionContorlType VARCHAR(5),
                                         stdQuestionText        VARCHAR(max),
                                         sequence               INT,
                                         stdPickListId          INT,
                                         fac_id                 INT,
                                         schedule_id            INT,
                                         std_shift_id           INT,
                                         description            VARCHAR(max),
                                         start_time             VARCHAR(4),
                                         end_time               VARCHAR(4),
                                         shift_date             DATETIME,
                                         schedule_start_date    DATETIME,
                                         schedule_end_date      DATETIME,
                                         schedule_date          DATETIME,
                                         documentation_id       VARCHAR(max),
                                         completed_date         DATETIME,
                                         entered_date           DATETIME,
                                         task_time              SMALLINT,
                                         std_question_id        INT,
                                         item_value_id          VARCHAR(max),
                                         item_value             VARCHAR(max),
                                         retired_date           DATETIME,
                                         resolved_date          DATETIME,
                                         created_by_longname    VARCHAR(60),
                                         created_by_position    VARCHAR(60),
                                         initials               VARCHAR(40),
                                         strikeout_flag         VARCHAR(1),
                                         strikeout_id           INT,
                                         strikeout_description  VARCHAR(max),
                                         strikeout_by           VARCHAR(60),
                                         strikeout_date         DATETIME,
                                         schedule_type          INT,
                                         schedule_time          INT,
										 short_code varchar(max));

CREATE TABLE #prp_shifts(shift_id    INT,
                         shift_name  VARCHAR(50),
                         start_time  INT,
                         end_time    INT,
                         group_name  VARCHAR(15),
                         position_id INT,
                         flg         INT);

CREATE TABLE #prp_shift_link(shift_id    INT,
                             shift_name  VARCHAR(50),
                             start_time  INT,
                             end_time    INT,
                             group_name  VARCHAR(15),
                             position_id INT);

DECLARE @Dateadjust AS TABLE(day_date     DATETIME,
                             std_shift_id INT,
                             shift_name   VARCHAR(MAX),
                             fac_id       INT,
                             s_date       DATETIME,
                             dd           DATETIME,
                             tm           INT);

Create Table #pocData (
                          schedule_detail_id     VARCHAR(max),
                          client_id              INT ,
                          gen_intervention_id    INT ,
                          intervention_id        INT,
                          std_intervention_id    INT,
                          text1                  VARCHAR(MAX),
                          stdQuestionId          INT,
                          stdQuestionContorlType VARCHAR(5),
                          stdQuestionText        VARCHAR(max),
                          sequence               INT,
                          stdPickListId          INT,
                          fac_id                 INT,
                          schedule_id            INT,
                          std_shift_id           varchar(max),
                          description            VARCHAR(max),
                          start_time             VARCHAR(4),
                          end_time               VARCHAR(4),
                          shift_date             DATETIME,
                          schedule_start_date    DATETIME,
                          schedule_end_date      DATETIME,
                          schedule_date          DATETIME,
                          documentation_id       VARCHAR(max),
                          completed_date         DATETIME,
                          entered_date           DATETIME,
                          task_time              SMALLINT,
                          std_question_id        INT,
                          item_value_id          VARCHAR(max),
                          item_value             VARCHAR(max),
                          retired_date           DATETIME,
                          resolved_date          DATETIME,
                          created_by_longname    VARCHAR(60),
                          created_by_position    VARCHAR(60),
                          initials               VARCHAR(40),
                          strikeout_flag         VARCHAR(1),
                          strikeout_id           INT,
                          strikeout_description  VARCHAR(max),
                          strikeout_by           VARCHAR(60),
                          strikeout_date         DATETIME,
                          schedule_type          INT,
                          flag                   VARCHAR(20),
                          schedule_time          INT,
                          day_of_month           TINYINT,
						  short_code varchar(max)
						  );
create clustered index _pocData_idx on #pocData (client_id,fac_id);
create nonclustered index _pocData_2_idx on #pocData (gen_intervention_id,intervention_id,std_intervention_id)
INCLUDE (strikeout_flag,flag,day_of_month,schedule_date,schedule_detail_id) ;


Create Table #poc(
				  seq                 varchar(max),
                      fac_id              INT,
                      client_id           INT,
				  admission_date	  datetime,
                      documentation_id    VARCHAR(max),
                      detail_id           INT,
                      gen_intervention_id INT,
                      intervention_id     INT,
                      std_intervention_id INT,
                      text1               VARCHAR(MAX),
                      schedule_id         INT,
                      shift_name          VARCHAR(100),
                      schedule_date       DATETIME,
                      schedule_start_date DATETIME,
                      schedule_end_date   DATETIME,
                      day_of_month        INT,
                      strikeout_flag      CHAR(1),
                      completed_date      DATETIME,
                      task_time           INT,
                      schedule_time       INT,
                      flag                VARCHAR(500),
                      doc                 VARCHAR(max));

create clustered index _poc_idx on #poc (client_id,fac_id);
create nonclustered index _poc_2_idx on #poc (gen_intervention_id,intervention_id,std_intervention_id)
INCLUDE (admission_date,flag,day_of_month,schedule_start_date,schedule_end_date,shift_name,documentation_id) ;

 Create table #intervention_audit (
                               genInterventionId     INT,
                               interventionId        INT,
                               stdInterventionId     INT,
                               stdQuestionEffective_Date datetime,
                               stdQuestionIneffective_Date datetime,
                               questionText varchar(max),
							   std_question_id int)
create nonclustered index _intervention_audit on #intervention_audit (genInterventionId,interventionId,stdInterventionId)
include (stdQuestionEffective_Date,stdQuestionIneffective_Date);

Create table #event_date (
                               genInterventionId     INT,
                               interventionId        INT,
                               stdInterventionId     INT,
						 stdQuestionId		   INT,
						 questiontext		   varchar(max),
                               effective_date datetime,
                               ineffective_date datetime,
                              )
create nonclustered index _intervention_audit on #event_date (genInterventionId,interventionId,stdInterventionId)
include (effective_date,ineffective_date);


DECLARE @dayTable AS TABLE(day_of_month        INT,
                           seq                 varchar(max),
                           fac_id              INT,
                           client_id           INT,
                           gen_intervention_id INT,
                           intervention_id     INT,
                           std_intervention_id INT,
                           shift_name          VARCHAR(max),
                           day_n               VARCHAR(max),
                           row_id              INT);

--DECLARE @Numbers AS TABLE(number INT);

DECLARE @PRP_ds_interv_schedule AS TABLE(id_key              INT IDENTITY(1, 1) PRIMARY KEY,
                                         row_type            INT,
                                         row_id              INT,
                                         seq                 VARCHAR(5),
                                         seq_name            VARCHAR(50),
                                         fac_id              INT,
                                         client_id           INT,
                                         client_name         VARCHAR(250),
                                         admint_date         datetime,
                                         date_of_birth       VARCHAR(10),
                                         location            VARCHAR(100),
                                         photo               VARCHAR(55),
                                         photo_date          VARCHAR(11),
                                         mrn_number          VARCHAR(50),
                                         user_legend         VARCHAR(MAX),
                                         report_header       VARCHAR(MAX),
								 gen_intervention_id int,
								 intervention_id     int,
                                         std_intervention_id INT,
								 intervention_desc   varchar(max),
                                         text1               VARCHAR(MAX),
                                         schedule_id         INT,
                                         shift_id            INT,
                                         shift_name          VARCHAR(100),
                                         schedule_date       DATETIME,
                                         schedule_time       varchar(10),
                                         day_1               VARCHAR(MAX),
                                         day_2               VARCHAR(MAX),
                                         day_3               VARCHAR(MAX),
                                         day_4               VARCHAR(MAX),
                                         day_5               VARCHAR(MAX),
                                         day_6               VARCHAR(MAX),
                                         day_7               VARCHAR(MAX),
                                         day_8               VARCHAR(MAX),
                                         day_9               VARCHAR(MAX),
                                         day_10              VARCHAR(MAX),
                                         day_11              VARCHAR(MAX),
                                         day_12              VARCHAR(MAX),
                                         day_13              VARCHAR(MAX),
                                         day_14              VARCHAR(MAX),
                                         day_15              VARCHAR(MAX),
                                         day_16              VARCHAR(MAX),
                                         day_17              VARCHAR(MAX),
                                         day_18              VARCHAR(MAX),
                                         day_19              VARCHAR(MAX),
                                         day_20              VARCHAR(MAX),
                                         day_21              VARCHAR(MAX),
                                         day_22              VARCHAR(MAX),
                                         day_23              VARCHAR(MAX),
                                         day_24              VARCHAR(MAX),
                                         day_25              VARCHAR(MAX),
                                         day_26              VARCHAR(MAX),
                                         day_27              VARCHAR(MAX),
                                         day_28              VARCHAR(MAX),
                                         day_29              VARCHAR(MAX),
                                         day_30              VARCHAR(MAX),
                                         day_31              VARCHAR(MAX),
                                         UNIQUE NONCLUSTERED(row_id,row_type),
								  Unique (client_id,gen_intervention_id,intervention_id,std_intervention_id, id_key));

CREATE Table #PRP_ds_interv_schedule_cte (

								 row_type            INT,
                                         row_id              INT,
                                         seq                 VARCHAR(5),
                                         seq_name            VARCHAR(50),
                                         fac_id              INT,
                                         client_id           INT,
                                         client_name         VARCHAR(250),
                                         admint_date         datetime,
                                         date_of_birth       VARCHAR(10),
                                         location            VARCHAR(100),
                                         photo               VARCHAR(55),
                                         photo_date          VARCHAR(11),
                                         mrn_number          VARCHAR(50),
                                         user_legend         VARCHAR(MAX),
                                         report_header       VARCHAR(MAX),
								 gen_intervention_id int,
								 intervention_id     int,
                                         std_intervention_id INT,
								 intervention_desc   varchar(max),
                                         text1               VARCHAR(MAX),
                                         schedule_id         INT,
                                         shift_id            INT,
                                         shift_name          VARCHAR(100),
                                         schedule_date       DATETIME,
                                         schedule_time       varchar(10),
                                         day_1               VARCHAR(MAX),
                                         day_2               VARCHAR(MAX),
                                         day_3               VARCHAR(MAX),
                                         day_4               VARCHAR(MAX),
                                         day_5               VARCHAR(MAX),
                                         day_6               VARCHAR(MAX),
                                         day_7               VARCHAR(MAX),
                                         day_8               VARCHAR(MAX),
                                         day_9               VARCHAR(MAX),
                                         day_10              VARCHAR(MAX),
                                         day_11              VARCHAR(MAX),
                                         day_12              VARCHAR(MAX),
                                         day_13              VARCHAR(MAX),
                                         day_14              VARCHAR(MAX),
                                         day_15              VARCHAR(MAX),
                                         day_16              VARCHAR(MAX),
                                         day_17              VARCHAR(MAX),
                                         day_18              VARCHAR(MAX),
                                         day_19              VARCHAR(MAX),
                                         day_20              VARCHAR(MAX),
                                         day_21              VARCHAR(MAX),
                                         day_22              VARCHAR(MAX),
                                         day_23              VARCHAR(MAX),
                                         day_24              VARCHAR(MAX),
                                         day_25              VARCHAR(MAX),
                                         day_26              VARCHAR(MAX),
                                         day_27              VARCHAR(MAX),
                                         day_28              VARCHAR(MAX),
                                         day_29              VARCHAR(MAX),
                                         day_30              VARCHAR(MAX),
                                         day_31              VARCHAR(MAX),
								 document_id         varchar(500)
                                        );

CREATE TABLE #FollowUpQuestionandPicklistItem(
                                       id_key                 INT IDENTITY(1, 1) PRIMARY KEY,
                                       seq              INT ,
                                       geninterventionid INT,
                                       interventionid     INT,
                                       stdinterventionid INT,
                                       period_start_date        DATETIME,
                                       period_end_date      DATETIME,
							    stdquestionid int,
							    question_text varchar(max),
							    picklist_text varchar(max),
							    sequence int
							    ,std_pick_list_id int,
							    Unique (geninterventionid,interventionid,stdinterventionid, id_key));



----Staff Legend
	CREATE TABLE #PRP_tbUserLegend
	(
            client_id int
		, document_by varchar(60)
		, initials varchar(40)
	);
     CREATE nonCLUSTERED INDEX _tempTbUserLegend ON #PRP_tbUserLegend( client_id );
-- New Code

Create table #PRP_question_periods (seq               INT,
                                       genInterventionId INT,
                                       interventionId    INT,
                                       stdInterventionId INT,
                                       period_start_date DATETIME,
                                       period_end_date   DATETIME,
                                       questiontext      VARCHAR(2000),
                                       std_question_id   INT)

create nonclustered index _PRP_question_periods on #PRP_question_periods (genInterventionId,interventionId,stdInterventionId)
include (period_start_date,period_end_date,std_question_id);
;


DECLARE @vprpFinalPickList AS TABLE(seq               INT,
                                    genInterventionId INT,
                                    interventionId    INT,
                                    stdInterventionId INT,
                                    stdQuestionId     INT,
                                    questiontext      VARCHAR(2000),
                                    std_pick_list_id  INT,
                                    picktext          VARCHAR(MAX),
                                    period_start_date DATETIME,
                                    period_end_date   DATETIME);

Create table #vprpPickList (
                               genInterventionId     INT,
                               interventionId        INT,
                               stdInterventionId     INT,
                               stdQuestionId         INT,
                               std_pick_list_item_id INT,
                               std_pick_list_id      INT,
                               item_value            VARCHAR(2000),
                               description           VARCHAR(200),
                               sequence              INT,
                               short_code            varchar(max),
                               effective_date        DATETIME,
                               ineffective_date      DATETIME)

create nonclustered index _vprpPickList_idx on #vprpPickList (genInterventionId,interventionId,stdInterventionId)
include (std_pick_list_item_id,stdQuestionId,effective_date,ineffective_date);

DECLARE @QuestionXML TABLE(genInterventionId    INT,
                            interventionId       INT,
                            stdInterventionId    INT,
                            text1   varchar(max)
                        );

CREATE TABLE #PRP_localterm
	(
            fac_id int
		, name varchar(100)
		, value varchar(1000)
		, status_code int
		, status_text varchar(max)

	);

CREATE TABLE #PRP_cntrlValues
	(
        description varchar(100)
		, item_value int
		, cntrl_type char(3)
		, sequence int
	);

INSERT INTO #PRP_cntrlValues
-- as per CPStdPickListBuilder, getMealTakenAmountOptions()
select '0% Eaten' as description, 0 as item_value, 'mta' as cntrl_type, 1 as sequence
union all
select '25% Eaten', 2, 'mta', 2
union all
select '50% Eaten', 4, 'mta', 3
union all
select '75% Eaten', 6, 'mta', 4
union all
select '100% Eaten', 8, 'mta', 5
union all
-- as per CPStdPickListBuilder, getPainFaceOptions()
select 'No Hurt', 0, 'pfs', 1
union all
select 'Hurts a Little Bit', 2, 'pfs', 2
union all
select 'Hurts a Little More', 4, 'pfs', 3
union all
select 'Hurts Even More', 6, 'pfs', 4
union all
select 'Hurts a Whole Lot', 8, 'pfs', 5
union all
select 'Hurts Worst', 10, 'pfs', 6;



BEGIN Try

     Set @status_code = 0   ---- Status Code 0 = Success, 1 = Exception
	set @status_text = null;
	set @rows_returned = 0;
	Set @vgs_program_name = Object_name(@@ProcID);  ---Current Store Proc Name
	Set @vgs_start_time = getdate();
	Set @vgs_execution_user = @execution_user_login ;

	---Insert Debug at every step
	select @vStep = 0 , @step_start_time = getdate()
	if @debug_me='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Executing store proc :  ' + @vgs_program_name + ' ' + convert(varchar(26),getdate(),109)

	--set Standard variables
	set @vDelim = ','
	set @vDelim_s =';'
	set @vCharNewLine  = Char(13) + char(10);
	set @vSeparator = 'ZYXWVU';
	SET @vTab = Char(9);
	SET @vNewLine = char(10);
	SET @vPlaceHolder = '|||||';


	select @vAllowPastSched  = value from configuration_parameter
	where fac_id = @fac_id and name = 'generate_past_sd'


	/***************************************************************************
							GET MRN INFO
     ***************************************************************************/
    select @vStep = 1 , @step_start_time = getdate()
	if @debug_me='Y' Print 'STEP ' + convert(varchar(20), @vStep) + 'GET MRN INFO :  '  + convert(varchar(26),getdate(),109)

	select   @vMRNId = cfg.hc_no_id
		   , @vMRNDesc = case when cfg.hc_no_id=-2 then 'Client Id Number' else hid.description end
            from   dbo.ar_configuration cfg WITH (NOLOCK)
            left join dbo.facility fac WITH (NOLOCK) on fac.fac_id = cfg.fac_id
            left join dbo.id_type hid WITH (NOLOCK) on cfg.hc_no_id = hid.id_type_id
                  and ( ( hid.fac_id = @vFacId
                              and hid.state_code is null
                              and ( hid.reg_id is null
                                       or hid.reg_id = -1 ) )
                           or hid.fac_id = -1
                           or ( hid.reg_id = fac.regional_id
                                    and hid.state_code is null )
                           or ( hid.state_code = fac.prov
                                    and ( hid.reg_id = fac.regional_id
                                             or hid.reg_id is null
                                             or hid.reg_id = -1 ) )
                                and hid.deleted = 'N' )
            left join dbo.id_type sid WITH (NOLOCK) on cfg.ssn_id = sid.id_type_id
                  and ( ( sid.fac_id = @vFacId
                              and sid.state_code is null
                              and ( sid.reg_id is null or sid.reg_id = -1 )
               )
              or sid.fac_id = -1
              or ( sid.reg_id = fac.regional_id
                  and sid.state_code is null )
              or ( sid.state_code = fac.prov
                                    and ( sid.reg_id = fac.regional_id
                                             or sid.reg_id is null
                                             or sid.reg_id = -1 ) )
                                and sid.deleted = 'N' )
            where  cfg.fac_id = @vFacId and cfg.deleted = 'N' ;
	if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'
	if @debug_me='Y' Select   @vMRNId [MRN Ifo]

	/* -------------------------------- */
	/* GET FACILITY ACCESS RESTRICTIONS */
	/* -------------------------------- */

	Select @vStep = 2, @step_start_time = getdate();
	if @debug_me='Y' Print 'BEGIN STEP '+convert(varchar(20), @vStep)  + ' Getting Facility access fac list ' + convert(varchar(26),getdate(),109);

	EXEC [dbo].[sproc_prp_get_facility_access_list_delim]
	  @fac_id  = @fac_id
	 ,@execution_user_login = @vgs_execution_user
	 ,@fac_id_out =  @vFacIds OUT
	 ,@msg_out    =  @vFacWarningMsg OUT;

    if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'

	--facilities warnings
	IF @vFacWarningMsg is NOT NULL --- NOT NULL stands for restricted facilities access warning message
	Begin
		Set @status_code = 2 ; ----Set it warning
		Set @status_text = isnull(@status_text,'') + @vFacWarningMsg ;
	End

	--fill facids into @vFacList
	SELECT @vFacId = Cast(items AS INT) FROM dbo.Split(@vFacIds,@vdelim);  ----Only one FacId is expected at a time
	if @@ROWCOUNT = 0  ---- only if there is any FacCount proceed with getting Client list
	BEGIN
		IF @status_code = 0
		Set @status_code = 3;
		RaisError( @status_text,11,1);
	END

	if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'
	/*-------------------------------*/
	/* MULTI VALUE FILTER temp table */
	/*-------------------------------*/

	select @vStep = 3, @step_start_time = getdate()
	if @debug_me='Y' Print 'BEGIN STEP ' +  convert(varchar(20), @vStep)  + 'Filters... ' + convert(varchar(26),getdate(),109)

	---shred column filters value for all integers value
	INSERT INTO #PRP_Filters (filter_name, filter_value)
	select left(items,charindex('=',items)-1) ,substring(items,charindex('=',items)+1,len(items))from dbo.Split (@vFilterList,@vDelim_s);

	if @debug_me='Y' select '#PRP_Filters'
	if @debug_me='Y' select '#PRP_Filters' PRP_Filters, * from #PRP_Filters
	if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'
   	/* -------------------------------- */
	/* GET client ACCESS RESTRICTIONS */
	/* -------------------------------- */

	SELECT @vStep = 4, @step_start_time = getdate();
	IF @debug_me='Y'
	    Print 'BEGIN STEP ' + convert(varchar(20), @vStep) + ' Getting user access client list ' + convert(varchar(26),getdate(),109);
	    Select @vClientIDs = (select filter_value from #PRP_Filters where filter_name='client_id')
			      ,@vClientWarningMsg = msg
	    From  dbo.fn_prp_get_client_access_list_delim(@Client_id,@fac_id,@vgs_execution_user) ---filter the Client list with user access

	IF @vClientWarningMsg is NOT NULL --- NOT NULL stands for restricted Client access warning message
	Begin
		Set @status_code = 2 ; ----Set it warning
		Set @status_text = Isnull(@status_text,'') + @vClientWarningMsg ;
	End

	if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'



	-- Facility Type
	select @vEnv=facility_type
			, @vCountryId = country_id
			, @vAdjtoDST = adjust_for_dst
				 from dbo.facility fac
				where fac.fac_id=@vFacId;


	select @vCountryCode = cntry_code.ISO_Country_Alpha_2_Code
		from dbo.facility fac with (nolock)
	inner join dbo.sec_user sec with (nolock)
		on fac.fac_id = sec.fac_id
	left JOIN dbo.common_code cntry with (nolock) ON fac.country_id = cntry.item_id
	left outer join wesreference.dbo.country cntry_code with (nolock)
	on cntry.item_description = cntry_code.ISO_Country_Name
	where sec.loginname = @vgs_execution_user


set  @vdateFormatStyle = dbo.fn_localized_dateformat_style(@vCountryCode, 1)

	/*------------------------------------*/
	/* DETERMINING WHICH FILTERS ARE USED */
	/*------------------------------------*/

	select @vStep = 5, @step_start_time = getdate()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Determining which filters are used... ' + convert(varchar(26),getdate(),109)

	if Exists( select 1 from #PRP_Filters where filter_name = 'ds_type'  and filter_value<>'-1') SET @vfil_ds_type = '1';

	SELECT @vfil_ds_task_choice = filter_value from #PRP_Filters where filter_name = 'ds_task_choice' AND filter_value NOT IN ('-1', 'ALL', '');

	SELECT @vgoal_flag = filter_value from #PRP_Filters where filter_name = 'goal_local_term'

   --** GET DATE FILTER value variables
	SELECT @vfil_ds_schedule_mth_yr = filter_value
	FROM #PRP_Filters
	WHERE filter_name = 'ds_schedule_mth_yr';

	if len(@vfil_ds_schedule_mth_yr) = 6
	begin
	set @vfil_ds_schedule_mth_yr = '0'+ @vfil_ds_schedule_mth_yr
	end

	SET @vfil_ds_schedule_mth   = CONVERT(SMALLINT, left(@vfil_ds_schedule_mth_yr, CHARINDEX(@vDelim, @vfil_ds_schedule_mth_yr) - 1));
	SET @vfil_ds_schedule_yr    = CONVERT(SMALLINT, right(@vfil_ds_schedule_mth_yr, LEN(@vfil_ds_schedule_mth_yr) - CHARINDEX(@vDelim, @vfil_ds_schedule_mth_yr)));

	IF len(@vIs_chart)=1
	BEGIN
	    SET @vfil_ds_schedule_date  = CONVERT(DATETIME, CONVERT(VARCHAR(4), @vfil_ds_schedule_yr) + '-' + CONVERT(VARCHAR(2), @vfil_ds_schedule_mth) + '-01');

	    IF @vfil_ds_schedule_mth    = 12
		    SET @vfil_ds_schedule_date2 = convert(datetime, convert(varchar(4), @vfil_ds_schedule_yr + 1) + '-01-01');
	    ELSE
		    SET @vfil_ds_schedule_date2 = convert(datetime, convert(varchar(4), @vfil_ds_schedule_yr) + '-' + convert(varchar(2), @vfil_ds_schedule_mth + 1) + '-01');
	END

	IF len(@vIs_chart)>1--len(@vIs_chart)>1
	BEGIN

		select
			@vfil_ds_schedule_date=cast(substring(@vIs_chart,1,charindex( @vDelim,@vIs_chart)-1) as datetime),
               @vfil_ds_schedule_date2=cast(substring(@vIs_chart,charindex( @vDelim,@vIs_chart)+1,len(@vIs_chart)) as datetime)+1;

			set @vfil_ds_last_day_of_month = DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0)+1


	  END
	  if @debug_me = 'Y' select @vfil_ds_last_day_of_month as ds_last_day_of_month, @vfil_ds_schedule_date2 as fil_ds_schedule_date2

	SET @today = getdate()

	-- can be replaced by doc.effective_date >= @vfil_ds_schedule_date_tzadj
	select @vfil_ds_schedule_date_tzadj  = dateadd(hh, datediff(hh, dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, @today), @today), @vfil_ds_schedule_date)
	select @vfil_ds_schedule_date2_tzadj = dateadd(hh, datediff(hh, dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, @today), @today), @vfil_ds_schedule_date2)

	set @vfil_ds_schedule_date2_tzadj_plus1 = DATEADD(dd,1,@vfil_ds_schedule_date2_tzadj)

	-- extending it for 2 days - 1 second to cater for night shift or hourly schedule that fell on the last day of the month
	-- and documented on the following month
	SET @vCurrentDate= DATEADD(s,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,1))
	SET @vOldestDate = convert(datetime, '1969-12-31');

	  ---- POC GO LIVE DATE
	  SELECT  @vPocGoLiveDate=dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID,Cast(value as datetime))
	  from configuration_parameter where name ='poc_go_live_date'and fac_id=@vFacId;

	  --if the POC go live date happened in the middle of the month
	  --the report will still need to run
	  if dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, @vfil_ds_schedule_date2) < 	@vPocGoLiveDate
	  BEGIN
	     Set @status_code = 2 ; ----Set it warning
		 set @status_text = 'POC was not live on the selected date range'
		Raiserror( @status_text, 11, 1 );
	  END
	if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'


	select @vStep = 6, @step_start_time = getdate()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' daylight saving... ' + convert(varchar(26),getdate(),109)

	--- daylight saving
	SET @vyear = @vfil_ds_schedule_yr;
	SET @vStartOfMarch     = DATEADD(MONTH, 2, DATEADD(YEAR, @vyear - 1900, 0)) ;
	 SET @vStartOfNovember  = DATEADD(MONTH, 10, DATEADD(YEAR, @vyear - 1900, 0));

	 if @vCountryId <> 5172
	 begin
			-- start of DST is the 2nd Sunday of March
			-- End of DST is the first Sunday of November

		 SET @vdaylightStart    = DATEADD(HOUR, 2, DATEADD(day, ( ( 15 - DATEPART(dw, @vStartOfMarch) ) % 7 )  + 7, @vStartOfMarch))
		 SET @vdaylightEnd      = DATEADD(HOUR, 2, DATEADD(day,   ( ( 8 - DATEPART(dw, @vStartOfNovember) ) % 7 ),  @vStartOfNovember))
	 end

	 else -- UK DST
			-- start of DST is the last Sunday of March
			-- End of DST is the last Sunday of October
	 begin
		 SET @vStartOfNovember  = DATEADD(MONTH, 9, DATEADD(YEAR, @vyear - 1900, 0));
		 SET @vdaylightStart    = DATEADD(HOUR, 1, DATEADD(day,DATEDIFF(day,'19000107',DATEADD(month,DATEDIFF(MONTH,0, @vStartOfMarch),30))/7*7,'19000107'))
		 SET @vdaylightEnd      = DATEADD(HOUR, 2, DATEADD(day,DATEDIFF(day,'19000107',DATEADD(month,DATEDIFF(MONTH,0, @vStartOfNovember),30))/7*7,'19000107'))

	end
   if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'

  ---- Field To Display
     select @vStep = 7, @step_start_time = getdate()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Field To Display... ' + convert(varchar(26),getdate(),109)


	 INSERT INTO #PRP_Report_Metadata_FieldstoDisplay
	 select substring(items,1,charindex(@vDelim,items)-1) ,right(items,1)
	       from dbo.Split(@vFieldList,@vDelim_s) ;

	if Exists( select 1 from #PRP_Report_Metadata_FieldstoDisplay where filter_name = 'photo') SET @vIncludePhoto = '1' ELSE SET @vIncludePhoto='0';
	--if Exists( select 1 from #PRP_Report_Metadata_FieldstoDisplay where filter_name = 'doc_respon') SET @vIncludeDocumentRespon = '1' ELSE SET @vIncludeDocumentRespon='0';
	SET @vIncludeDocumentRespon='1'; -- we always showing documentation respone
	if Exists( select 1 from #PRP_Report_Metadata_FieldstoDisplay where filter_name = 'initial'  and filter_value<>'0') SET @vIncludeInitial = '1' ELSE SET @vIncludeInitial='0';
	if Exists( select 1 from #PRP_Report_Metadata_FieldstoDisplay where filter_name = 'doc_time' and filter_value<>'0') SET @vIncludeDocumentTime = '1' ELSE SET @vIncludeDocumentTime='0';
	if Exists( select 1 from #PRP_Report_Metadata_FieldstoDisplay where filter_name = 'struck_out' and filter_value<>'0') SET @vIncludeStruckOut = '1' ELSE SET @vIncludeStruckOut='0';
	if Exists( select 1 from #PRP_Report_Metadata_FieldstoDisplay where filter_name = 'user_legend' and filter_value<>'0') SET @vIncludeUserLegend = '1' ELSE SET @vIncludeUserLegend='0';


    if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'

      select @vStep = 8, @step_start_time = getdate()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Terminology... ' + convert(varchar(26),getdate(),109)

  ---- Terminology
  Select
		@vTermClient = term_client
		, @vterm_client = term_client
		, @vTermClients = term_clients
		, @vTermFacility = term_facility
		, @vTermFacilities = term_facilities
		, @vTermAdmission = term_admission
		, @vterm_admission  = term_admission
		, @vTermAdmissions = term_admissions
		, @vTermDischarge = term_discharge
		, @vTermDischarges = term_discharges
		, @vTermRoom = term_room
		, @vTermRooms = term_rooms
		, @vTermAdvDirective = term_adv_directive
	from [dbo].fn_prp_get_terminology(@vFacID,@is_emc) where fac_id = @vFacId;


	insert into #PRP_localterm
	exec dbo.sproc_prp_local_terminology 	@vFacId , @vgoal_flag;

	select @vTermTask = value from #prp_localterm where name = 'term_tsk'
	select @vTermIntervention = value from #prp_localterm where name = 'term_intrvntn'

	select @vTermTask = dbo.fn_format_local_term('term_tsk', @vTermTask, 1,1,0)
	 ,@vTermIntervention = dbo.fn_format_local_term('term_intrvntn', @vTermIntervention, 1,1,0)


	if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'


	 select @vStep = 9, @step_start_time = getdate()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Shift Table... ' + convert(varchar(26),getdate(),109)

	--It's using for QSHIFT
      INSERT INTO #prp_shift_link(shift_id,
                            shift_name,
                            start_time,
                            end_time,
                            group_name,
                            position_id)
       SELECT DISTINCT shift.std_shift_id,
                       shift.description+' ('+start_time+'-'+end_time+')' shift_name,
                       shift.start_time,
                             CASE
                                 WHEN CAST(shift.end_time AS INT)-1=-1
                                 THEN 1159
                                 ELSE CAST(shift.end_time AS INT)
                             END AS end_time1,
                       '',
                       0
       FROM dbo.pho_assignment_group_assoc grpass WITH (NOLOCK)
       LEFT JOIN
       cr_shift_group config WITH (NOLOCK)
       ON config.primary_assoc_id=grpass.pho_assignment_group_assoc_id
       INNER JOIN
       dbo.pho_assignment_group grp WITH (NOLOCK)
       ON grpass.pho_assignment_group_id=grp.pho_assignment_group_id
       INNER JOIN
       dbo.cp_std_shift shift WITH (NOLOCK)
       ON grpass.std_shift_id=shift.std_shift_id
      AND shift.deleted='N'
       WHERE shift.deleted='N'
         AND grpass.fac_id=@vFacId
         AND grp.fac_id=grpass.fac_id
         AND grp.deleted='N'
         AND grpass.position_id IS NOT NULL
         AND (grpass.expired_date IS NULL
           OR grpass.expired_date> case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
         AND config.primary_assoc_id IS NOT NULL;


	 INSERT INTO #prp_shift_link(shift_id,
                            shift_name,
                            start_time,
                            end_time,
                            group_name,
                            position_id)
       SELECT DISTINCT sh.std_shift_id,
                       sh.description+' ('+sh.start_time+'-'+sh.end_time+')' shift_name,
                       sh.start_time,
                             CASE
                                 WHEN CAST(sh.end_time AS INT)-1=-1
                                 THEN 1159
                                 ELSE CAST(sh.end_time AS INT)
                             END AS end_time1,
                       '' as group_name,
                       0 as position_id

					    from cp_std_shift sh with (nolock)
			where sh.fac_id in (-1, @vFacId)
			and sh.deleted = 'N'
			and not exists(select 1 from #prp_shift_link b where b.shift_id = sh.std_shift_id )

	if @debug_me='Y' select '#prp_shift_link' prp_shift_link ,* from #prp_shift_link order BY shift_name

	---select * from #prp_shift_link

	--It's using for Non-QSHIFT
	INSERT INTO #prp_shifts(shift_id,
                        shift_name,
                        start_time,
                        end_time,
                        group_name,
                        position_id,
                        flg)
       SELECT DISTINCT shift.std_shift_id,
                       shift.description+' ('+start_time+'-'+end_time+')' shift_name,
                       shift.start_time,
                       shift.end_time-1,
                       '',
                       NULL,
                       0
       FROM dbo.pho_assignment_group_assoc grpass WITH (NOLOCK)
       LEFT JOIN
       cr_shift_group config WITH (NOLOCK)
       ON config.primary_assoc_id=grpass.pho_assignment_group_assoc_id
       INNER JOIN
       dbo.pho_assignment_group grp WITH (NOLOCK)
       ON grpass.pho_assignment_group_id=grp.pho_assignment_group_id
       INNER JOIN
       dbo.cp_std_shift shift WITH (NOLOCK)
       ON grpass.std_shift_id=shift.std_shift_id
      AND shift.deleted='N'
       WHERE shift.deleted='N'
         AND grpass.fac_id=@vFacId
         AND grp.fac_id=grpass.fac_id
         AND grp.deleted='N'
         AND grpass.position_id IS NOT NULL
         AND (grpass.expired_date IS NULL
           OR grpass.expired_date> case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
         AND config.primary_assoc_id IS NOT NULL
         AND CONVERT(INT, shift.end_time)-CONVERT(INT, shift.start_time)>0;

     INSERT INTO #prp_shifts(shift_id,
                        shift_name,
                        start_time,
                        end_time,
                        group_name,
                        position_id,
                        flg)
       SELECT DISTINCT shift.std_shift_id,
                       shift.description+' ('+start_time+'-'+end_time+')' shift_name,
                       shift.start_time,
                       2400-1,
                       '',
                       NULL,
                       0
       FROM dbo.pho_assignment_group_assoc grpass WITH (NOLOCK)
       LEFT JOIN
       cr_shift_group config WITH (NOLOCK)
       ON config.primary_assoc_id=grpass.pho_assignment_group_assoc_id
       INNER JOIN
       dbo.pho_assignment_group grp WITH (NOLOCK)
       ON grpass.pho_assignment_group_id=grp.pho_assignment_group_id
       INNER JOIN
       dbo.cp_std_shift shift WITH (NOLOCK)
       ON grpass.std_shift_id=shift.std_shift_id
      AND shift.deleted='N'
       WHERE shift.deleted='N'
         AND grpass.fac_id=@vFacId
         AND grp.fac_id=grpass.fac_id
         AND grp.deleted='N'
         AND grpass.position_id IS NOT NULL
         AND (grpass.expired_date IS NULL
           OR grpass.expired_date> case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
         AND config.primary_assoc_id IS NOT NULL
         AND CONVERT(INT, shift.end_time)-CONVERT(INT, shift.start_time)<0;

     INSERT INTO #prp_shifts(shift_id,
                        shift_name,
                        start_time,
                        end_time,
                        group_name,
                        position_id,
                        flg)
     SELECT DISTINCT shift.std_shift_id,
                       shift.description+' ('+start_time+'-'+end_time+')' shift_name,
                       '0',
                       shift.end_time-1,
                       '',
                       NULL,
                       1
       FROM dbo.pho_assignment_group_assoc grpass WITH (NOLOCK)
       LEFT JOIN
       cr_shift_group config WITH (NOLOCK)
       ON config.primary_assoc_id=grpass.pho_assignment_group_assoc_id
       INNER JOIN
       dbo.pho_assignment_group grp WITH (NOLOCK)
       ON grpass.pho_assignment_group_id=grp.pho_assignment_group_id
       INNER JOIN
       dbo.cp_std_shift shift WITH (NOLOCK)
       ON grpass.std_shift_id=shift.std_shift_id
      AND shift.deleted='N'
       WHERE shift.deleted='N'
         AND grpass.fac_id=@vFacId
         AND grp.fac_id=grpass.fac_id
         AND grp.deleted='N'
         AND grpass.position_id IS NOT NULL
         AND (grpass.expired_date IS NULL
           OR grpass.expired_date> case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
         AND config.primary_assoc_id IS NOT NULL
         AND CONVERT(INT, shift.end_time)-CONVERT(INT, shift.start_time)<0;


	if @debug_me='Y' select '#prp_shifts' prp_shifts, * from #prp_shifts

	--select * from #prp_shifts

	IF (SELECT adjust_for_dst FROM facility WHERE fac_id= @vFacId)='Y'
	 BEGIN
		   INSERT INTO @Dateadjust (day_date,std_shift_id,shift_name ,fac_id,s_date, dd ,tm )
		    SELECT
			a.day_date,a.std_shift_id,ss.shift_name,a.fac_id,a.s_date,CAST(CONVERT(VARCHAR(10),a.s_date,120) AS DATETIME) dd,
		     CAST(REPLACE(CONVERT(VARCHAR(5),a.s_date,108),':','') as int)tm
		   FROM view_cp_shift_dates a
		    INNER JOIN #prp_shifts ss ON a.std_shift_id=ss.shift_id
		   WHERE a.fac_id=@vFacId
		    AND flg=1
			and a.day_date >= @vfil_ds_schedule_date_tzadj
			and a.day_date <= @vfil_ds_schedule_date2_tzadj_plus1

		   DELETE FROM @Dateadjust WHERE day_date<DATEADD(dd,-1,@vfil_ds_schedule_date) OR day_date> case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end ;
		   --if @debug_me='Y' select '@Dateadjust' Dateadjust, * from @Dateadjust  order BY 1
	 END

	if @debug_me='Y' select '@Dateadjust' Dateadjust, * from @Dateadjust
	if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'

	/* GET LIST OF Client */

	select @vStep = 10 , @step_start_time = getdate()
	if @debug_me='Y' Print 'BEGIN STEP ' +  convert(varchar(20), @vStep)  + ' Getting list of clients... ' + convert(varchar(26),getdate(),109)

	-- Client Information
		Insert into #PRP_ClientList
		(
			  client_id
			, client_name
			, admission_date
			, discharge_date
			, deceased_date
			, gender
			, allergy
			, location
			, date_of_birth
			, client_physician_id
			, client_physician
			, client_pharmacy
			, mrn_number
			, client_id_number
			, photo
			, photo_date
			, current_care_plan_id
		)
		select  c.client_id
			, rtrim( ltrim(rtrim(isnull(m.last_name,''))) + ', ' + ltrim(rtrim(isnull(m.first_name,''))) + ' ' + ltrim(rtrim(isnull(m.middle_name,''))) ) + ' (' + ltrim(rtrim(isnull(c.client_id_number,'')))+ ')' as client_name
			--, admission_date--isnull(convert(char(10),admission_date, 101),'')	as admission_date
			,  admission_date--isnull(convert(char(10),admission_date, 101),'')	as admission_date

			--, isnull(convert(varchar(10),admission_date, 101),'')	as admission_date

			, isnull(convert(char(10),discharge_date, 101),'')	as discharge_date
			, isnull(convert(char(10),m.deceased_date, 101),'')  as deceased_date
			, isnull(m.sex,'') as gender
			, Case when @header = 'header_1' /* in (@header,@vPHDR2, @vPHDR3)*/ then isnull(c.allergy,'') else NULL end as allergy
			, rtrim(ltrim(isnull(unit_desc,''))) + ' ' +
					rtrim(ltrim(isnull(room_desc,'')))  + ' ' + rtrim(ltrim(isnull(bed_desc,''))) as location
			, isnull(convert(char(10),m.date_of_birth, 101),'')  as date_of_birth
			, convert(varchar,c.primary_physician_id) as client_physician_id
			, isnull(last_name + ', ' ,'') + isnull( first_name,'')  + ' ' + isnull(middle_name,'')  as client_physician
			, isnull(pharmacy.name,'') as client_pharmacy

			, Case when @vMRNId = -2 then c.client_id_number
				else NULL
				end as mrn_number
			, c.client_id_number
			, c.photo_small
			, c.photo_date
			, c.current_care_plan_id

		from ( Select  cl.client_id, cl.client_id_number , cl.mpi_id, cl.pharmacy_id, cl.primary_physician_id
					, cl.admission_date

					,cl.photo_date, cl.photo ,cl.photo_small, ca.allergy ,cl.discharge_date ,cl.current_care_plan_id
				from dbo.clients cl  with (nolock)
					inner join ( Select Cast(items as int) as client_id from dbo.split(@vClientIds, @vDelim)) filteredClients
						on filteredClients.client_id = cl.client_id
						and  cl.fac_id = @vFacId and  cl.deleted = 'N'
					INNER  JOIN dbo.clients_attribute ca WITH (NOLOCK)
						on cl.client_id = ca.client_id
			 ) c

		inner join dbo.mpi m with (nolock)	   on m.mpi_id = c.mpi_id
		left join dbo.emc_ext_facilities pharmacy WITH (NOLOCK) ON  ext_fac_id = c.pharmacy_id
  		inner join ( Select row,bed_id,payer_type,client_id from
						(
						 SELECT  ROW_NUMBER()  OVER (partition by client_id ORDER BY census_id desc) AS Row,
					            c.bed_id,
					         	payer_type,
					            c.client_id

						 FROM dbo.census_item c With (nolock)
						 left join dbo.AR_LIB_PAYERS libpayer with (nolock)
							ON c.primary_payer_id = libpayer.payer_id AND (libpayer.deleted = 'N')
						 WHERE c.fac_id = @vFacId and c.deleted = 'N'
							AND c.status_code_id not in (-1,17)
							AND (record_type = 'C' OR record_type IS NULL)
					  ) a
					  where Row = 1
					) loc on c.client_id = loc.client_id and ( loc.payer_type IS NULL OR loc.payer_type  <>  'OutPatient')
		left join dbo.bed b with (nolock) on loc.bed_id=b.bed_id
		left join dbo.room r with (nolock) on b.room_id=r.room_id
		left join dbo.unit u with (nolock) on  u.unit_id=r.unit_id;


	if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'


	/*-------------------------------------------------------------------------------------*/
	/* update MRN number for clients if @vMRNID <> -2 and one of the headers is header_1   */
	/*-------------------------------------------------------------------------------------*/

	if @vMRNId <> -2
	BEGIN
		select @vStep = 11 , @step_start_time = getdate()
		if @debug_me='Y' Print 'STEP' +  convert(varchar(20), @vStep)  + ' Updating MRN number from vwClientIDS for  header_1 ' + convert(varchar(26),getdate(),109)

		Update #PRP_ClientList SET mrn_number = ltrim(rtrim(vwClientIds.description))
			  From #PRP_ClientList c
			  inner join dbo.view_client_ids vwClientIds with (nolock) on vwClientIds.client_id  = c.client_id and id_type_id = @vMRNId
		if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'
	END
	if @debug_me='Y' select '#PRP_ClientList' PRP_ClientList, * from #PRP_ClientList

    ------------------------------------------------------------------------------------------
    ---    POC General Cofiguration PickList
	------------------------------------------------------------------------------------------
	select @vStep = 13 , @step_start_time = getdate()
	if @debug_me='Y' Print 'BEGIN STEP ' +  convert(varchar(20), @vStep)  + ' build variable table of POC General Cofiguration PickList' + convert(varchar(26),getdate(),109)

		 Set @vShowHistorical=0;

		 ;WITH config_audit AS (

						 SELECT 	  fac_id
									, 'fuq_options' as [name]
									, [value]
									, CASE WHEN effective_date IS NULL THEN @vOldestDate ELSE  dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, effective_date) END AS effective_date
									, CASE WHEN ineffective_date IS NULL THEN @vCurrentDate ELSE dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, ineffective_date)  END AS ineffective_date
							FROM dbo.configuration_parameter_audit WITH (NOLOCK)
							WHERE
								 [name] = 'fuq_options'
							AND (FAC_ID = @vFacId  OR FAC_ID = -1)

						 UNION ALL
						  SELECT 	  fac_id
									, 'fuq_options_for_mds_g' as [name]
									, [value]
									, CASE WHEN effective_date IS NULL THEN @vOldestDate ELSE  dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, effective_date) END AS effective_date
									, CASE WHEN ineffective_date IS NULL THEN @vCurrentDate ELSE dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, ineffective_date)  END AS ineffective_date
							FROM dbo.configuration_parameter_audit WITH (NOLOCK)
							WHERE
								 [name] = 'fuq_options_for_mds_g'
							AND (FAC_ID = @vFacId  OR FAC_ID = -1)

						 UNION ALL

						  SELECT 	fac_id, 'poc_advanced_reporting' as [name]
									, [value]
									, CASE WHEN effective_date IS NULL THEN @vOldestDate ELSE  dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, effective_date) END AS effective_date
									, CASE WHEN ineffective_date IS NULL THEN @vCurrentDate ELSE dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, ineffective_date)  END AS ineffective_date
							FROM dbo.configuration_parameter_audit WITH (NOLOCK)
							WHERE
								 [name] = 'poc_advanced_reporting'
							AND (FAC_ID = @vFacId  OR FAC_ID = -1)

						UNION ALL
						 SELECT 	fac_id, 'short_code_resident_not_available' as [name]
									, [value]
									, CASE WHEN effective_date IS NULL THEN @vOldestDate ELSE  dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, effective_date) END AS effective_date
									, CASE WHEN ineffective_date IS NULL THEN @vCurrentDate ELSE dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, ineffective_date)  END AS ineffective_date
							FROM dbo.configuration_parameter_audit WITH (NOLOCK)
							WHERE
								 [name] = 'short_code_resident_not_available'
							AND (FAC_ID = @vFacId  OR configuration_parameter_audit.FAC_ID = -1)
						UNION ALL
						 SELECT 	 fac_id,'short_code_resident_refused' as [name]
									, [value]
									, CASE WHEN effective_date IS NULL THEN @vOldestDate ELSE  dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, effective_date) END AS effective_date
									, CASE WHEN ineffective_date IS NULL THEN @vCurrentDate ELSE dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, ineffective_date)  END AS ineffective_date
							FROM dbo.configuration_parameter_audit WITH (NOLOCK)
							WHERE
								 [name] = 'short_code_resident_refused'
							AND (FAC_ID = @vFacId  OR FAC_ID = -1)
						UNION ALL
						 SELECT 	 fac_id,'short_code_not_applicable' as [name]
									, [value]
									, CASE WHEN effective_date IS NULL THEN @vOldestDate ELSE  dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, effective_date) END AS effective_date
									, CASE WHEN ineffective_date IS NULL THEN @vCurrentDate ELSE dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, ineffective_date)  END AS ineffective_date
							FROM dbo.configuration_parameter_audit WITH (NOLOCK)
							WHERE
								 [name] = 'short_code_not_applicable'
							AND (FAC_ID = @vFacId  OR FAC_ID = -1)
						UNION ALL
						 SELECT 	 fac_id,'poc_adv_report_tube_short_code' as [name]
									, [value]
									, CASE WHEN effective_date IS NULL THEN @vOldestDate ELSE  dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, effective_date) END AS effective_date
									, CASE WHEN ineffective_date IS NULL THEN @vCurrentDate ELSE dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, ineffective_date)  END AS ineffective_date
							FROM dbo.configuration_parameter_audit WITH (NOLOCK)
							WHERE
								 [name] = 'poc_adv_report_tube_short_code'
							AND (FAC_ID = @vFacId  OR FAC_ID = -1)
						UNION ALL
						 SELECT 	 fac_id,'poc_adv_report_npo_short_code' as [name]
									, [value]
									, CASE WHEN effective_date IS NULL THEN @vOldestDate ELSE  dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, effective_date) END AS effective_date
									, CASE WHEN ineffective_date IS NULL THEN @vCurrentDate ELSE dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, ineffective_date)  END AS ineffective_date
							FROM dbo.configuration_parameter_audit WITH (NOLOCK)
							WHERE
								 [name] = 'poc_adv_report_npo_short_code'
							AND (FAC_ID = @vFacId  OR FAC_ID = -1)
		)
		,
		config_current AS (
							SELECT 	 config.fac_id,config.name,config.value,
									 CASE WHEN MaxHist IS NULL THEN @vOldestDate ELSE MaxHist END AS effective_date,
									 @vCurrentDate AS ineffective_date
							FROM dbo.configuration_parameter config WITH (NOLOCK)
							LEFT JOIN (select fac_id, name, MAX(ineffective_date) MaxHist
							            from config_audit
										group by fac_id,name) config_maxDate
									                         ON config_maxDate.name=config.name and
															    config_maxDate.fac_id=config.fac_id
							WHERE	(config.FAC_ID =  @vFacId  OR config.FAC_ID = -1)
								AND	( config.[name] IN ('fuq_options','poc_advanced_reporting','short_code_resident_not_available','short_code_resident_refused',
			                        'short_code_not_applicable', 'poc_adv_report_tube_short_code','poc_adv_report_npo_short_code','fuq_options_for_mds_g'))
		                  )
						, allConfig AS (
							 SELECT name,value,effective_date,ineffective_date
									 FROM config_audit
											UNION all
							 SELECT name,value,effective_date,ineffective_date
									 FROM config_current
							)
						--	, behave_of_application as (
						--	SELECT 	 config.fac_id,config.name,config.value,
						--			  @vOldestDate effective_date,
						--			  @vCurrentDate AS ineffective_date
						--	FROM dbo.configuration_parameter config WITH (NOLOCK)

						--	WHERE	(config.FAC_ID =  @vFacId  OR config.FAC_ID = -1)
						--		AND	( config.[name] IN ('fuq_options','poc_advanced_reporting','short_code_resident_not_available','short_code_resident_refused',
			   --                     'short_code_not_applicable', 'poc_adv_report_tube_short_code','poc_adv_report_npo_short_code','fuq_options_for_mds_g'))
	--						)


	--				--select * FROM config_current

	-------	handeling audit date in a mounth
		INSERT INTO @pocGeneralConfig ( name,value,effective_date,ineffective_date)
		SELECT pConfig.name,pConfig.value,childConfig.effective_date,childConfig.ineffective_date
		FROM allConfig pConfig
		 INNER JOIN (
					SELECT name,max(effective_date) effective_date,max(ineffective_date)	ineffective_date
					 FROM allConfig
					WHERE  --allConfig.name='fuq_options'	  and
					 1=  CASE
							 WHEN (allConfig.effective_date  >=  @vfil_ds_schedule_date  AND allConfig.effective_date  <  @vfil_ds_schedule_date2) THEN 1
							 WHEN (allConfig.ineffective_date IS NULL OR allConfig.ineffective_date>= @vfil_ds_schedule_date2) AND allConfig.effective_date < @vfil_ds_schedule_date2 THEN 1
							 WHEN (allConfig.ineffective_date IS NOT NULL AND  allConfig.ineffective_date< @vfil_ds_schedule_date2  AND allConfig.ineffective_date>= @vfil_ds_schedule_date)
								AND allConfig.effective_date  <  @vfil_ds_schedule_date2 THEN 1
						 ELSE 0 end
					and name not in ('short_code_resident_not_available','short_code_resident_refused','short_code_not_applicable', 'poc_adv_report_tube_short_code','poc_adv_report_npo_short_code')
					GROUP BY name )	childConfig
		    ON pConfig.name= childConfig.name	 AND pConfig.effective_date= childConfig.effective_date AND	pConfig.ineffective_date= childConfig.ineffective_date
			UNION ALL
		   SELECT name,value, effective_date,	ineffective_date
					 FROM allConfig
					WHERE  --allConfig.name='fuq_options'	  and
					 1=  CASE
							 WHEN (allConfig.effective_date  >=  @vfil_ds_schedule_date  AND allConfig.effective_date  <  @vfil_ds_schedule_date2) THEN 1
							 WHEN (allConfig.ineffective_date IS NULL OR allConfig.ineffective_date>= @vfil_ds_schedule_date2) AND allConfig.effective_date < @vfil_ds_schedule_date2 THEN 1
							 WHEN (allConfig.ineffective_date IS NOT NULL AND  allConfig.ineffective_date< @vfil_ds_schedule_date2  AND allConfig.ineffective_date>= @vfil_ds_schedule_date)
								AND allConfig.effective_date  <  @vfil_ds_schedule_date2 THEN 1
						 ELSE 0 end
					and name  in ('short_code_resident_not_available','short_code_resident_refused','short_code_not_applicable', 'poc_adv_report_tube_short_code','poc_adv_report_npo_short_code')
		;

	if @debug_me = 'y' 	 SELECT '@pocGeneralConfig' pocGeneralConfig,* from @pocGeneralConfig

	if (select count(1) from  @pocGeneralConfig
		   where name in ('short_code_not_applicable','short_code_resident_not_available','short_code_resident_refused'))>3
		  set @vShowHistorical=1;

	     if  @vShowHistorical=1
			BEGIN
		         ;with systemPick  as (
			select  distinct top 1000 effective_date,ineffective_date,
			'Effective Date: ('+
					case when convert(varchar(20), b.effective_date,@vdateFormatStyle) like '%1969%' or  convert(varchar(20),b.effective_date,@vdateFormatStyle) is null then CONVERT(varchar(10), CONVERT(date, '12/31/1969' , 101), @vdateFormatStyle)
						else +convert(varchar(20),b.effective_date ,@vdateFormatStyle)+' '+convert(varchar(5),b.effective_date ,108) end +' - '+
					 case when b.ineffective_date=@vcurrentdate or ineffective_date>@vcurrentdate then 'Current' else convert(varchar(20),b.ineffective_date,@vdateFormatStyle)+' '+convert(varchar(5),b.ineffective_date,108) end + ') '  +
		    (
			 select     case when name='short_code_not_applicable' then value +'- Not Applicable'
					 when name='short_code_resident_not_available' then value +'- Resident Not Available'
					 when name='short_code_resident_refused' then value +'- Resident Refused'	 end + ', '  as [text()]
			  from @pocGeneralConfig a

			   where name in ('short_code_not_applicable','short_code_resident_not_available','short_code_resident_refused')
			    and  a.effective_date=b.effective_date and a.ineffective_date=b.ineffective_date
			    order by effective_date,ineffective_date,value
			   FOR XML PATH('')
			   )  as  systempicklist
			   from  @pocGeneralConfig  b
			   where name in ('short_code_not_applicable','short_code_resident_not_available','short_code_resident_refused')

			  order by effective_date,ineffective_date
				)



					select  @SystemPicklist=@vNewLine+left(txt ,len(txt)-1)
					from( select substring(
					 (Select  left(systempicklist,len(systempicklist)-1)+@vNewLine AS [text()]
							 From systemPick
							 For XML PATH ('')
					  ),1,8000) txt	   ) test
			    ;
		     END
	      ELSE
		    BEGIN

		    select @SystemPicklist=systempicklist
		from (	  --' System Response available for all questions: '+
		select  ' '+systemPicklist
		from (
		select top 10  case when name='short_code_not_applicable' then value +'- Not Applicable'
				  when name='short_code_resident_not_available' then value +'- Resident Not Available'
				  when name='short_code_resident_refused' then value +'- Resident Refused'	 end  systemPicklist
		from  @pocGeneralConfig  where name in ('short_code_not_applicable','short_code_resident_not_available','short_code_resident_refused')
		and 1=case when @vIs_chart<>'0' and (ineffective_date>=@vfil_ds_schedule_date2  or ineffective_date is null) 	 then 1
				  when @vIs_chart='0' and (ineffective_date>=@vcurrentdate  or ineffective_date is null) then 1 else 0 end
		 order by value desc
	    ) a1
		FOR XML PATH('')) a(systempicklist)

		    END


	if @debug_me='Y' select @SystemPicklist [SystemPicklist], @vShowHistorical [vShowHistorical]

	IF EXISTS( SELECT 1 FROM @pocGeneralConfig WHERE name = 'fuq_options' and value='Y')
	BEGIN
	 SET @vfil_fuq_options = '1';
	 IF EXISTS( SELECT 1 FROM @pocGeneralConfig WHERE name = 'fuq_options_for_mds_g'  and value='Y')
	   SET @vfil_fuq_options_for_mds_g='1';

	END

	IF EXISTS( SELECT 1 FROM @pocGeneralConfig WHERE name = 'poc_advanced_reporting' and value='Y')
	 SET @vfil_poc_advanced='1';

   if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'

   if @debug_me = 'Y' select @vfil_poc_advanced [vfil_poc_advanced], @vfil_fuq_options_for_mds_g [vfil_fuq_options_for_mds_g],@vfil_fuq_options [vfil_fuq_options]
	--select 888,* FROM @pocGeneralConfig

	--LIST OF INTERVENTIONS/TASKS
	select @vStep = 14 , @step_start_time = getdate()
	if @debug_me='Y' Print 'BEGIN STEP ' +  convert(varchar(20), @vStep)  +  ' build temp table of interventions' + convert(varchar(26),getdate(),109)

	INSERT INTO #PRP_ds_interventions (client_id,gen_intervention_id, intervention_id, std_intervention_id,resolved_date ,
                                        flowsheet, current_row ,fac_id ,text1, date_initiated)
	SELECT  distinct
		  c.client_id
		, intervention.gen_intervention_id
		, intervention.intervention_id
		, intervention.std_intervention_id
		, intervention.resolved_date
		, intervention.flowsheet
		, intervention.current_row
		, intervention.fac_id
		, intervention.text1
		, intervention.date_initiated

		FROM
			dbo.CP_REV_INTERVENTION intervention WITH (NOLOCK)
			INNER JOIN #PRP_ClientList c WITH (NOLOCK) ON
					c.client_id = intervention.clientID

			INNER JOIN dbo.CP_SCHEDULE  schedule WITH (NOLOCK) ON
                          schedule.fac_Id = intervention.fac_id
                       AND schedule.intervention_id = intervention.gen_intervention_id

			LEFT JOIN dbo.CP_REV_NEED need WITH (NOLOCK) ON
				intervention.fac_id = need.fac_id
				and intervention.need_id = need.need_id
				AND need.care_plan_id = c.current_care_plan_id
				AND need.current_row = 'Y'

			LEFT JOIN dbo.cp_fst_type_std_intervention fst WITH (NOLOCK) ON
					fst.std_intervention_id = intervention.std_intervention_id

			LEFT JOIN #PRP_Filters f_ds_type WITH (NOLOCK) ON
			    f_ds_type.filter_name = 'ds_type'
			AND f_ds_type.filter_value = convert(varchar(10),fst.fst_type_id)

		WHERE
		   schedule.fac_id         = @vFacId
		and intervention.fac_id     = @vFacId
		and isnull(schedule.retired_date, @vfil_ds_schedule_date) >= @vfil_ds_schedule_date
		and intervention.flowsheet    = 'Y'
		and (schedule.schedule_type=40 or isnull(intervention.resolved_date,@vfil_ds_schedule_date2)>@vfil_ds_schedule_date )
		 AND 1 = CASE WHEN @vfil_ds_task_choice IS NULL THEN 1
						 WHEN @vfil_ds_task_choice = 1 THEN CASE WHEN intervention.is_task = 'N' OR intervention.is_task IS NULL THEN 1 ELSE 0 END
						 WHEN @vfil_ds_task_choice = 2 THEN CASE WHEN intervention.is_task = 'Y' THEN 1 ELSE 0 END
						 WHEN @vfil_ds_task_choice = 3 THEN 1
					 END
		AND (@vfil_ds_type is null or (@vfil_ds_type = '1' and f_ds_type.filter_value is not null))
		    AND intervention.flowsheet='Y'
			AND intervention.current_row='Y'




	if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'
	if @debug_me = 'Y' select 'PRP_ds_interventions' as PRP_ds_interventions, * from #PRP_ds_interventions


	------------------------------------------------------------------------------------------
     ---    Question
	------------------------------------------------------------------------------------------
	select @vStep = 15 , @step_start_time = getdate()
	if @debug_me='Y' Print 'BEGIN STEP ' +  convert(varchar(20), @vStep)  +  ' build temp table of Question IDs' + convert(varchar(26),getdate(),109)



	 ;with maxdate_intervention as (  -- All Task except custom ones
							SELECT b.gen_intervention_id gen_intervention_id,b.intervention_id ,a.std_intervention_id,
								case when @vfil_ds_schedule_date2 < MAX(a.ineffective_date)  then @vfil_ds_schedule_date2 else MAX(a.ineffective_date) end
								effective_date
								FROM dbo.cp_std_intervention_question_audit a WITH (NOLOCK)
								 INNER JOIN #PRP_ds_interventions b	 ON b.std_intervention_id=a.std_intervention_id
							 WHERE
								 ((((a.effective_date >= @vfil_ds_schedule_date
								    AND a.effective_date <  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
								    OR (a.ineffective_date >= @vfil_ds_schedule_date
								    AND a.ineffective_date <  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
								    OR (a.effective_date < @vfil_ds_schedule_date
								    AND a.ineffective_date >  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end ))
								    ))
								GROUP BY a.std_intervention_id,b.gen_intervention_id	,b.intervention_id

								UNION ALL

							  -- For custom task
    							     SELECT a.gen_intervention_id,a.intervention_id, b.std_intervention_id,
									 case when @vfil_ds_schedule_date2 < MAX(a.ineffective_date)  then @vfil_ds_schedule_date2 else MAX(a.ineffective_date) end effective_date
							     FROM dbo.cp_rev_intervention_question_audit a WITH (NOLOCK)
							       INNER JOIN  #PRP_ds_interventions b  ON b.gen_intervention_id=a.gen_intervention_id  and  b.intervention_id=a.intervention_id
								WHERE
								 ((((a.effective_date >= @vfil_ds_schedule_date
								    AND a.effective_date <  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
								    OR (a.ineffective_date >= @vfil_ds_schedule_date
								    AND a.ineffective_date <  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
								    OR (a.effective_date < @vfil_ds_schedule_date
								    AND a.ineffective_date >  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end ))
								    ))
							     GROUP BY a.gen_intervention_id,a.intervention_id, b.std_intervention_id


							)
	   , auditQuesion as (
					    SELECT c.gen_intervention_id,c.intervention_id,a.std_intervention_id, a.std_question_id, a.sequence,
					    case
					      when convert(varchar(20),a.effective_date ,101) like '%1969%' then cast(convert(varchar(20),a.effective_date ,101) as datetime)
					      else
					     cast(convert(varchar(20),a.effective_date ,101)+  +' '+convert(varchar(5),a.effective_date ,108) as datetime) end  effective_date,
						cast(convert(varchar(20),a.ineffective_date ,101)+  +' '+convert(varchar(5),a.ineffective_date ,108) as datetime) 	ineffective_date
					    FROM dbo.cp_std_intervention_question_audit a WITH (NOLOCK)
					    INNER JOIN #PRP_ds_interventions c
						    ON c.std_intervention_id = a.std_intervention_id
					     WHERE
						   ((((a.effective_date >= @vfil_ds_schedule_date
							 AND a.effective_date <  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
							 OR (a.ineffective_date >= @vfil_ds_schedule_date
							 AND a.ineffective_date <  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
							 OR (a.effective_date < @vfil_ds_schedule_date
							 AND a.ineffective_date >  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end ))
							 ))
					  UNION ALL
					   --custom task
					   SELECT a.gen_intervention_id,a.intervention_id,c.std_intervention_id, a.std_question_id, a.sequence,
					    case
					      when convert(varchar(20),a.effective_date ,101) like '%1969%' then cast(convert(varchar(20),a.effective_date ,101) as datetime)
					      else
					     cast(convert(varchar(20),a.effective_date ,101)+  +' '+convert(varchar(5),a.effective_date ,108) as datetime) end  effective_date,
						cast(convert(varchar(20),a.ineffective_date ,101)+  +' '+convert(varchar(5),a.ineffective_date ,108) as datetime) 	ineffective_date
					    FROM dbo.cp_rev_intervention_question_audit a WITH (NOLOCK)
					    INNER JOIN #PRP_ds_interventions c
						    ON c.gen_intervention_id = a.gen_intervention_id and c.intervention_id=a.intervention_id
					     WHERE
						   ((((a.effective_date >= @vfil_ds_schedule_date
							 AND a.effective_date <  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
							 OR (a.ineffective_date >= @vfil_ds_schedule_date
							 AND a.ineffective_date <  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
							 OR (a.effective_date < @vfil_ds_schedule_date
							 AND a.ineffective_date >  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end ))
							 ))

	   )
	   , all_question	 as (
						    SELECT	c.gen_intervention_id,
						          c.intervention_id,
							   a.std_intervention_id,
							   a.std_question_id,
							   a.sequence,
							   cast(convert(varchar(20),tt.effective_date ,101)+  +' '+convert(varchar(5),tt.effective_date ,108) as datetime) effective_date,
							   CAST(NULL AS datetime) ineffective_date
						   FROM dbo.cp_std_intervention_question a WITH (NOLOCK)
						    INNER JOIN #PRP_ds_interventions c  ON c.std_intervention_id = a.std_intervention_id
						    outer apply( select * from maxdate_intervention b  where a.std_intervention_id = b.std_intervention_id) tt

						  UNION ALL
						    SELECT c.gen_intervention_id,
								   c.intervention_id,
							     -1 std_intervention_id,
							      a.std_question_id,
							      a.sequence,
							      cast(convert(varchar(20),tt.effective_date ,101)+  +' '+convert(varchar(5),tt.effective_date ,108) as datetime) effective_date,
							      CAST(NULL AS datetime) ineffective_date
						   FROM dbo.cp_rev_intervention_question a WITH (NOLOCK)
						   INNER JOIN #PRP_ds_interventions c on c.gen_intervention_id=a.intervention_id and c.std_intervention_id=-1
						    outer apply( select * from maxdate_intervention b  where c.intervention_id = b.intervention_id) tt

       )



	 INSERT INTO #stdQuestionIdTable (genInterventionId,interventionId,stdInterventionId,stdQuestionId,stdQuestionText,stdQuestionContorlType,stdQuestionEffective_Date,stdQuestionIneffective_Date,
	                                  stdPickListId,sequence,system_control_flag,mds_question_key_old,less_picklist,rowNumber, stdQuestionRank, fac_id)


	  SELECT distinct rev.gen_intervention_id,rev.intervention_id,rev.std_intervention_id, quest.std_question_id, stdQues.question_text, stdQues.control_type
			    , isnull(quest.effective_date,cast('1969-12-31' as datetime))
			    , isnull (quest.ineffective_date,@vCurrentDate)
				, stdQues.std_pick_list_id, quest.sequence ,stdQues.system_control_flag,	stdQues.mds_question_key_old
				, CASE
					  WHEN  @vEnv='CDN' THEN 1
					  WHEN mdsPickList.std_question_id IS NULL AND  @vEnv='USAR' THEN 0 ELSE 1 END
				, dense_rank() over ( order by rev.std_intervention_id
				, case when convert(varchar,quest.effective_date,101)='12/31/1969'  then cast('12/31/1969' as datetime) else  quest.effective_date end,sequence) row_number
				, ROW_NUMBER() over( partition by rev.gen_intervention_id,rev.intervention_id,rev.std_intervention_id, quest.std_question_id order by rev.gen_intervention_id,rev.intervention_id,rev.std_intervention_id, quest.std_question_id,   isnull(quest.effective_date,cast('1969-12-31' as datetime)) )
				, rev.fac_id

	   from  #PRP_ds_interventions  rev
	    LEFT JOIN (
					   select  a.gen_intervention_id,a.intervention_id,a.std_intervention_id ,a.std_question_id,a.sequence,a.effective_date ,a.ineffective_date
					   from auditQuesion a
								where not exists( select 1 from all_question aq where aq.intervention_id =  a.intervention_id
																								and aq.std_intervention_id = a.std_intervention_id
																								and  aq.std_question_id = a.std_question_id )
					   union ALL

					   select  a.gen_intervention_id,a.intervention_id,a.std_intervention_id ,a.std_question_id,a.sequence,a.effective_date ,a.ineffective_date
						 from  all_question a
					   where
						 exists (select 1 from  maxdate_intervention d where
														d.std_intervention_id=a.std_intervention_id
														and d.gen_intervention_id=a.gen_intervention_id
														and d.intervention_id =a.intervention_id
																		 and  (ISNULL(@vAllowPastSched,'N') = 'Y' or -- skip if they allow to create schedule in the past
																		 d.effective_date<=    case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end 	)
																		 )
						or
								(ineffective_date is null
							   and not exists (select 1 from  maxdate_intervention d where
															  d.std_intervention_id=a.std_intervention_id
														  and d.gen_intervention_id=a.gen_intervention_id
														  and d.intervention_id =a.intervention_id))
			   ) AS quest
			ON  quest.std_intervention_id = rev.std_intervention_id
				  and rev.gen_intervention_id= quest.gen_intervention_id
				  and rev.intervention_id=quest.intervention_id
		INNER JOIN dbo.cp_std_fuq_fac fuq  WITH (NOLOCK)
			ON fuq.fac_id=@vFacId AND fuq.question_id=quest.std_question_id

		LEFT JOIN dbo.cp_std_question stdQues WITH (NOLOCK)
			ON stdQues.std_question_id = quest.std_question_id

		LEFT JOIN  ( SELECT  DISTINCT  mds.std_question_id
						FROM cp_std_question_mds mds
						WHERE mds.mds_question_key LIKE 'G0110%' or mds.mds_question_key LIKE 'G0120%'
					) mdsPickList
		ON mdsPickList.std_question_id =stdQues.std_question_id;



   if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'
   if @debug_me = 'y' 	 SELECT '#stdQuestionIdTable' as stdQuestionIdTable,* from #stdQuestionIdTable

   ------------------------------------------------------------------------------------------
     ---    Raw Pick List
   ------------------------------------------------------------------------------------------

	select @vStep = 16 , @step_start_time = getdate()
	if @debug_me='Y' Print 'BEGIN STEP ' +  convert(varchar(20), @vStep)  + ' build temp table of PickList ' + convert(varchar, @step_start_time)

       ;WITH lessPicklist AS (
						  SELECT question.stdInterventionId,
						 question.stdQuestionId,
						 question.less_picklist,
						 MAX(CASE
							    WHEN @vfil_fuq_options_for_mds_g=1
							    THEN pk_list.sequence
							    ELSE 0
							END) sequence
							 FROM dbo.cp_std_pick_list_item pk_list WITH (NOLOCK)
							 INNER JOIN  #stdQuestionIdTable question
							       ON question.stdPickListId=pk_list.std_pick_list_id
							 WHERE pk_list.deleted='N'
							   AND question.less_picklist<>0
							 GROUP BY question.stdInterventionId,
									question.stdQuestionId,
									question.less_picklist )
	   ,maxeffectiveDate as(
				   SELECT b.genInterventionId,
						 b.interventionId,
						 b.stdInterventionId,
						 b.stdQuestionId, std_pick_list_id,
						 MAX(a.ineffective_date)  effective_date  ,MAX(a.effective_date)   effective_date_befor
				    FROM dbo.cp_std_pick_list_item_audit a  WITH (NOLOCK)
				    INNER JOIN	 #stdQuestionIdTable b   ON b.stdPickListId=a.std_pick_list_id
				    --where stdInterventionId=8663 and a.std_pick_list_id =81
				    GROUP BY b.genInterventionId,
						   b.interventionId,
						   b.stdInterventionId,
						   b.stdQuestionId ,std_pick_list_id
	  )
	 ,picklist_audit as (

        select  distinct  question.genInterventionId,question.interventionId,question.stdInterventionId,question.stdQuestionId,
             a.std_pick_list_item_id,a.std_pick_list_id,a.item_value
	         ,a.description,a.sequence,a.short_code,
	 	   case
					      when convert(varchar(20),a.effective_date ,101) like '%1969%' then cast(convert(varchar(20),a.effective_date ,101) as datetime)
					      else
					     cast(convert(varchar(20),a.effective_date ,101)+  +' '+convert(varchar(5),a.effective_date ,108) as datetime) end  effective_date,
						cast(convert(varchar(20),a.ineffective_date ,101)+  +' '+convert(varchar(5),a.ineffective_date ,108) as datetime) 	ineffective_date
    FROM dbo.cp_std_pick_list_item_audit a  WITH (NOLOCK)
		inner join #stdQuestionIdTable question on question.stdPickListId=a.std_pick_list_id

		WHERE
				--a.deleted='N' AND
		 --and stdInterventionId=8663 and a.std_pick_list_id =81
		  NOT EXISTS (select 1 FROM lessPicklist lpk where lpk.stdInterventionId=question.stdInterventionId and lpk.stdQuestionId=question.stdQuestionId  and
			 				 lpk.sequence=a.sequence)
		and
								 (  ISNULL(@vAllowPastSched,'N') = 'Y' or
									 (((a.effective_date >= @vfil_ds_schedule_date
										AND a.effective_date <  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
										OR (a.ineffective_date >= @vfil_ds_schedule_date
										AND a.ineffective_date <  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
										OR (a.effective_date < @vfil_ds_schedule_date
										AND a.ineffective_date >  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end ))
										))

	 	 )
	 , all_picklist as (

  	select distinct
	 question.genInterventionId,question.interventionId,question.stdInterventionId,question.stdQuestionId,
             a.std_pick_list_item_id,a.std_pick_list_id,a.item_value
	         ,a.description,a.sequence,a.short_code,
 	 	  cast(convert(varchar(20),tt.effective_date ,101)+  +' '+convert(varchar(5),tt.effective_date ,108) as datetime) effective_date,
							   CAST(NULL AS datetime) ineffective_date
	FROM dbo.cp_std_pick_list_item a  WITH (NOLOCK)
		inner join #stdQuestionIdTable question on question.stdPickListId=a.std_pick_list_id
		 outer apply( select * from maxeffectiveDate b  where question.stdInterventionId = b.stdInterventionId
		 										    and question.InterventionId = b.InterventionId
												    and question.genInterventionId = b.genInterventionId
												    and a.std_pick_list_id = b.std_pick_list_id

		) tt
	 where  (a.deleted='N' or ( a.deleted_date>= @vfil_ds_schedule_date))
	--and question.stdInterventionId=8663 and a.std_pick_list_id =81
	)

	 INSERT INTO #stdPickListTable (genInterventionId,interventionId,stdInterventionId,stdQuestionId ,std_pick_list_item_id,std_pick_list_id,item_value,description,
	                           sequence,short_code,effective_date,ineffective_date )
	  select distinct genInterventionId,interventionId,stdInterventionId,stdQuestionId ,std_pick_list_item_id,std_pick_list_id,item_value,description,
	         sequence,short_code,effective_date, ineffective_date
		    from (
	  select genInterventionId,interventionId,stdInterventionId,stdQuestionId ,std_pick_list_item_id,std_pick_list_id,item_value,description,
	         sequence,short_code,effective_date, ineffective_date
		from picklist_audit
		union all
	    select distinct genInterventionId,interventionId,stdInterventionId,stdQuestionId ,std_pick_list_item_id,std_pick_list_id,item_value,description,
	                               sequence,short_code,effective_date,
							 isnull( ineffective_date,@vCurrentDate)
		from all_picklist a
		 where  (exists (select 1 from  maxeffectiveDate d where
										d.stdInterventionId=a.stdInterventionId
										and d.geninterventionid=a.geninterventionid
										and d.interventionid =a.interventionId
										and d.std_pick_list_id = a.std_pick_list_id
	                                             and  (ISNULL(@vAllowPastSched,'N') = 'Y' or  effective_date<=    case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end 	) )
	    or
	            (ineffective_date is null
			   and not exists (select 1 from  maxeffectiveDate d where
										d.stdInterventionId=a.stdInterventionId
										and d.geninterventionid=a.geninterventionid
										and d.interventionid =a.interventionId
										and d.std_pick_list_id = a.std_pick_list_id)))

			  ) tt


	  INSERT INTO #stdPickListTable (genInterventionId,interventionId,stdInterventionId,stdQuestionId ,std_pick_list_item_id,std_pick_list_id,item_value,description,sequence,short_code,
								effective_date,ineffective_date )
		    SELECT distinct  question.genInterventionId,question.interventionId,question.stdInterventionId,question.stdQuestionId,
						 NULL std_pick_list_item_id, NuLL std_pick_list_id, cntrl.item_value, cntrl.description, isnull(cntrl.sequence, question.sequence),NULL short_code,
						 NULL effective_date ,@vCurrentDate ineffective_date
				    FROM #stdQuestionIdTable question
					LEFT JOIN #PRP_cntrlValues cntrl
					on question.stdQuestionContorlType = cntrl.cntrl_type
		    WHERE question.stdPickListId is null
			AND NOT EXISTS (select 1 FROM #stdPickListTable lpk where lpk.stdInterventionId=question.stdInterventionId and
														   lpk.stdQuestionId=question.stdQuestionId  and
														   lpk.genInterventionId=question.genInterventionId
			 					) ;

	 UPDATE  #stdPickListTable
		    SET effective_date=@vOldestDate
		 WHERE effective_date IS NULL;

	if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'
	if @debug_me = 'Y' select '#stdPickListTable' as stdPickListTable, * from #stdPickListTable



     select @vStep = 17, @step_start_time = getdate()
	if @debug_me='Y' Print 'BEGIN STEP ' +  convert(varchar(20), @vStep)  + ' Insert Final PickList by correct date range  ' + convert(varchar, @step_start_time)

	insert into #vprpPickList(genInterventionId,interventionId,stdInterventionId,stdQuestionId ,std_pick_list_item_id,std_pick_list_id,item_value,description,
	  sequence,short_code,effective_date,ineffective_date)

	    	select genInterventionId,interventionId,stdInterventionId,stdQuestionId ,std_pick_list_item_id,std_pick_list_id,item_value,description,
	  sequence,short_code,effective_date,ineffective_date
	from #stdPickListTable a where
						   (  ISNULL(@vAllowPastSched,'N') = 'Y' or
						   (((a.effective_date >= @vfil_ds_schedule_date
							 AND a.effective_date <  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
							 OR (a.ineffective_date >= @vfil_ds_schedule_date
							 AND a.ineffective_date <  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
							 OR (a.effective_date < @vfil_ds_schedule_date
							 AND a.ineffective_date >  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end ))
							 ));

 if @debug_me='Y' select  '#vprpPickList' as vprpPickList , * from #vprpPickList

 insert into #intervention_audit (genInterventionId,interventionId,stdInterventionId,stdQuestionEffective_Date,stdQuestionIneffective_Date,questionText, std_question_id)
	    select distinct  a.genInterventionId,a.interventionId,a.stdInterventionId,a.stdQuestionEffective_Date,a.stdQuestionIneffective_Date,
	 (
	 select cast(stdQuestionId as varchar)+',' as [text()]
	  from #stdQuestionIdTable b
	  where b.genInterventionId=a.genInterventionId
	  and b.interventionId=a.interventionId
	  and b.stdInterventionId=a.stdInterventionId
	  and b.stdQuestionEffective_Date=a.stdQuestionEffective_Date
	  order by b.stdQuestionEffective_Date, b.stdQuestionIneffective_Date	,
	  b.genInterventionId,b.interventionId,b.stdInterventionId,b.rowNumber
	  FOR XML PATH('')
	 )  questionText
	 , a.stdQuestionId
	 from #stdQuestionIdTable a;

 if @debug_me='Y' select  '#intervention_audit' as intervention_audit , * from #intervention_audit



 insert into #event_date (effective_date,ineffective_date,genInterventionId,interventionId,stdInterventionId,stdQuestionId,questiontext)
		 select distinct

		 --b.stdQuestioneffective_Date,b.stdQuestionineffective_Date,
		 a.effective_date,a.ineffective_date,
		 --case
			--    when  (a.ineffective_date> b.stdQuestioneffective_Date  and a.ineffective_date<stdQuestionIneffective_Date   and effective_date<	stdQuestioneffective_Date) then 1
			--	when (a.effective_date>= b.stdQuestioneffective_Date  and a.effective_date<=stdQuestionIneffective_Date   and ineffective_date>=	stdQuestionIneffective_Date) then 1
			--	when a.effective_date=b.stdQuestioneffective_Date and a.ineffective_date<stdQuestionIneffective_Date then 1
			--  else 0 end tt ,

			  a.genInterventionId,a.interventionId,a.stdInterventionId,a.stdQuestionId,b.questiontext

			  from #vprpPickList a --picklist_audit a
			  inner join #intervention_audit b
			  on  a.stdInterventionId=b.stdInterventionId
			    and a.genInterventionId=b.genInterventionId
			    and a.interventionId  =b.interventionId
			 where
			 --a.stdInterventionId=8660
			 -- and

			 1 = case
			    when  (a.ineffective_date> b.stdQuestioneffective_Date  and a.ineffective_date<stdQuestionIneffective_Date   and effective_date<	stdQuestioneffective_Date) then 1
				when (a.effective_date>= b.stdQuestioneffective_Date  and a.effective_date<=stdQuestionIneffective_Date   and ineffective_date>=	stdQuestionIneffective_Date) then 1
				when a.effective_date=b.stdQuestioneffective_Date and a.ineffective_date<stdQuestionIneffective_Date then 1
			  else 0 end



;with	    event_all_question as
	    (
		 select 	genInterventionId,interventionId,stdInterventionId ,effective_date,ineffective_date,left(questiontext ,len(questiontext)-1) questiontext
			 ,DENSE_RANK() OVER (ORDER BY genInterventionId,interventionId,stdInterventionId ,questiontext,effective_date,	ineffective_date) seq
			 , std_question_id
		  from (
			   select   distinct
			   --stdQuestioneffective_Date,stdQuestionineffective_Date,effective_date,	ineffective_date ,
			   --case
						-- when effective_date >= stdQuestioneffective_Date and effective_date<=stdQuestionineffective_Date and (case when ineffective_date>@vcurrentdate then @vCurrentDate else ineffective_date end=@vCurrentDate) then 1
						-- when	effective_date <=stdQuestioneffective_Date and (case when ineffective_date>@vcurrentdate then @vCurrentDate else ineffective_date end) <stdQuestionineffective_Date then 2
						-- when b.ineffective_date is null and b.effective_date is null then 3
						-- when stdQuestioneffective_Date=stdQuestionineffective_Date  then 4
					 --  else 0 end	,
			   a.genInterventionId,a.interventionId,a.stdInterventionId,
				   case when b.effective_date is null then a.stdQuestioneffective_Date else b.effective_date end effective_date ,
				   case when b.ineffective_date is null then a.stdQuestionIneffective_Date else
				     case when b.ineffective_date>@vcurrentdate then @vcurrentdate else b.ineffective_date end end  ineffective_date,
				   case when b.questiontext is null then a.questiontext else b.questiontext end questiontext ,
				   a.std_question_id
				   from #intervention_audit a
				   left join #event_date b
				   on  a.stdInterventionId=b.stdInterventionId
				   and a.genInterventionId=b.genInterventionId
				   and a.interventionId  =b.interventionId
				   and a.questiontext=b.questiontext
				   where
				   1=case
						 	 when effective_date >= stdQuestioneffective_Date and effective_date<=stdQuestionineffective_Date and (case when ineffective_date>@vcurrentdate then @vCurrentDate else ineffective_date end=@vCurrentDate) then 1
						 when	effective_date <=stdQuestioneffective_Date and (case when ineffective_date>@vcurrentdate then @vCurrentDate else ineffective_date end) <stdQuestionineffective_Date then 1
						 when b.ineffective_date is null and b.effective_date is null then 1
					   else 0 end
			    )A

)
,fixed_allquestion_date as (

select distinct

a.genInterventionId,a.interventionId,a.stdInterventionId ,
case   when a.effective_date<=b.effective_date  and b.effective_date<a.ineffective_date then a.effective_date
  else  a.effective_date END effective_date,

	case
	when a.effective_date<=b.effective_date  and b.ineffective_date=@vcurrentdate and  b.ineffective_date=a.ineffective_date then b.effective_date
	when b.effective_date<=a.effective_date  and b.ineffective_date=@vcurrentdate and  b.ineffective_date=a.ineffective_date then a.effective_date
     when a.effective_date=b.effective_date  and b.ineffective_date=@vcurrentdate and a.ineffective_date<b.ineffective_date then a.ineffective_date
     else a.ineffective_date
	END ineffective_date	,

a.questiontext,a.seq
, a.std_question_id
FROM event_all_question  a
left join event_all_question b ON
a.stdInterventionId=b.stdInterventionId
and a.genInterventionId=b.genInterventionId
and a.interventionId  =b.interventionId
and a.questiontext=b.questiontext
and a.seq+1=b.seq
--where a.stdInterventionId=8660
)

insert into #PRP_question_periods ( seq,genInterventionId,interventionId,stdInterventionId,period_start_date,period_end_date,questiontext,std_question_id)
Select
    seq,genInterventionId,interventionId,stdInterventionId,effective_date,ineffective_date,questiontext , std_question_id
    From fixed_allquestion_date



  if @debug_me = 'Y'  select '#PRP_question_periods' PRP_question_periods,* from #PRP_question_periods


 ; with picklist as (

select seq,genInterventionId,interventionId ,stdInterventionId,period_start_date,period_end_date,questiontext	,std_question_id,std_pick_list_id,std_pick_list_item_id
	,sequence,pick_desc, rnum
from (
  select distinct a.seq,a.genInterventionId,a.interventionId,a.stdInterventionId,
  --a.period_start_date,a.period_end_date
  b.effective_date period_start_date, b.ineffective_date period_end_date
  ,a.questiontext
  ,b.std_pick_list_id,b.std_pick_list_item_id,b.sequence,b.short_code	, a.std_question_id
   , dense_rank () over ( order by a.genInterventionId,a.interventionId,a.stdInterventionId,
   case when year(b.effective_date) = 1969 and (b.ineffective_date = @vcurrentdate
    or (ISNULL(@vAllowPastSched,'N') = 'Y' and
					 year(b.effective_date) = 1969 and b.ineffective_date >= @vcurrentdate))
	then 0 else 1 end,
   b.effective_date,
case when 	ISNULL(@vAllowPastSched,'N') = 'Y' and
					 year(b.effective_date) = 1969 and b.ineffective_date >= @vcurrentdate then @vcurrentdate else
	b.ineffective_date end
	) rnum

   , isnull( ISNULL(b.short_code, b.item_value) +'- '+ b.description,'-')	as pick_desc
      FROM  #stdPickListTable b
		left join #PRP_question_periods a


--   FROM
--   #PRP_question_periods a
--left join #stdPickListTable b

 on  a.stdInterventionId=b.stdInterventionId
	  and a.genInterventionId=b.genInterventionId
	  and a.interventionId  =b.interventionId
	  and a.std_question_id=b.stdQuestionId
	  and (ISNULL(@vAllowPastSched,'N') = 'Y' or
				(((b.effective_date >= @vfil_ds_schedule_date
							 AND b.effective_date <  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
							 OR (b.ineffective_date >= @vfil_ds_schedule_date
							 AND b.ineffective_date <  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end )
							 OR (b.effective_date < @vfil_ds_schedule_date
							 AND b.ineffective_date >  case when @vIs_chart<>'0' then @vfil_ds_last_day_of_month else @vfil_ds_schedule_date2 end ))
							 ))


	) Allquestion
   )

   insert into @vprpFinalPickList (seq,genInterventionId,interventionId ,stdInterventionId,period_start_date,period_end_date,questiontext
       ,stdQuestionId,std_pick_list_id,picktext)

   select distinct  rnum,genInterventionId,interventionId ,stdInterventionId,period_start_date,
   case when period_end_date >@vcurrentdate then @vcurrentdate else period_end_date end,questiontext
       ,std_question_id,std_pick_list_id,
	(
	  select pick_desc+' ' as [text()]
	  from picklist b
	  where a.seq=b.seq
	  and a.genInterventionId=b.genInterventionId
	  and a.interventionId=b.interventionId
	  and a.stdInterventionId=b.stdInterventionId
	  and a.period_start_date=b.period_start_date
	  and a.period_end_date=b.period_end_date
	  and a.questiontext=b.questiontext
	  and a.std_question_id=b.std_question_id
		and a.rnum = b.rnum
	  and isnull(a.std_pick_list_id,0)=isnull(b.std_pick_list_id,0)

	order by seq,genInterventionId,interventionId,stdInterventionId,rnum, period_start_date,period_end_date,std_question_id,std_pick_list_id,sequence
	 FOR XML PATH('')	) pickText
   from picklist a	;

     if @debug_me = 'Y'  select '@vprpFinalPickList' vprpFinalPickList,* from @vprpFinalPickList

 ; with question as (
   select distinct b.sequence,a.genInterventionId,a.interventionId,a.stdInterventionId,a.period_start_date,a.period_end_date,a.stdQuestionId,seq,
   a.std_pick_list_id,b.stdQuestionText ,a.picktext
   --into #temp14
   from @vprpFinalPickList a
   inner join #stdQuestionIdTable b
    ON a.genInterventionId=b.genInterventionId
	  and a.interventionId=b.interventionId
	  and a.stdInterventionId=b.stdInterventionId
	  and a.stdQuestionId=b.stdQuestionId

	  where ( isnull(a.period_start_date, @vCurrentDate) <= @vCurrentDate and a.period_end_date >=@vfil_ds_schedule_date
					)

	   )



	   insert into #FollowUpQuestionandPicklistItem(seq,genInterventionId,interventionId,stdInterventionId,period_start_date,period_end_date,
	                           stdquestionid,question_text,picklist_text,sequence,std_pick_list_id)
	     select max(seq)  ,genInterventionId,interventionId,stdInterventionId,period_start_date,period_end_date,stdQuestionId,stdQuestionText,picktext,sequence,std_pick_list_id
	    from question a
	     group by genInterventionId,interventionId,stdInterventionId,period_start_date,period_end_date,stdQuestionId,stdQuestionText,picktext,sequence,std_pick_list_id ;



	if @debug_me = 'Y'  select '#FollowUpQuestionandPicklistItem' FollowUpQuestionandPicklistItem,* from #FollowUpQuestionandPicklistItem;

	;with   QuestionXML
		as (

				select  distinct seq,b.genInterventionId,b.interventionId,b.stdInterventionId
				,b.period_start_date,b.period_end_date , b.sequence
				,
				replace(replace(replace(replace(
				 '(Effective Date: '+														 +
				 case
					 when convert(varchar(20), b.period_start_date,@vdateFormatStyle) like '%1969%' or  convert(varchar(20), b.period_start_date,@vdateFormatStyle) is null then 'Created Date'
					else +convert(varchar(20),b.period_start_date ,@vdateFormatStyle)+' '+convert(varchar(5),b.period_start_date ,108) end +' - '+
				   case when b.period_end_date=@vcurrentdate then 'Current' else  convert(varchar(20),b.period_end_date,@vdateFormatStyle)+' '+convert(varchar(5),b.period_end_date,108) end + ') '+
				(
				 select
                    '<b>'+cast(sequence as varchar)+'- '+a.question_text+'</b> ' + isnull(picklist_text,'-')+@vtab+'' +
                    case
                        -- Add a static label to the legend if control_type = 'ntv'
                        when q.control_type = 'ntv' then '0 - Narrative Text (see Follow Up Question Report for full response)'
                        else ''
                    end as [text()]

				   FROM #FollowUpQuestionandPicklistItem a
				   left join cp_std_question q on a.stdquestionid = q.std_question_id
				   where a.seq=b.seq
					and a.genInterventionId=b.genInterventionId
				  and a.interventionId=b.interventionId
				  and a.stdInterventionId=b.stdInterventionId
				  and a.sequence = b.sequence
				 order by a.genInterventionId,a.interventionId,a.stdInterventionId,a.period_start_date,a.period_end_date,a.sequence,a.seq ,a.stdQuestionId,a.std_pick_list_id
				 FOR XML PATH('')),'&lt;','<'),'&gt;','>'),'&amp;lt;','<'),'&amp;gt;','>') question_text

				 --into #temp15
				FROM #FollowUpQuestionandPicklistItem b
		)

	INSERT INTO @QuestionXML	(genInterventionId,interventionId,stdInterventionId,text1)

	select distinct genInterventionId,interventionId,stdInterventionId
	 , replace(replace(replace(replace(
		(
			select a.question_text+' <br />' as [text()]
				from  QuestionXML	a
				where a.genInterventionId=b.genInterventionId
				and a.interventionId=b.interventionId
				and a.stdInterventionId=b.stdInterventionId

				order by a.genInterventionId,a.interventionId,a.stdInterventionId, a.sequence,a.period_start_date,a.period_end_date
				FOR XML PATH('')
		) ,'&lt;','<'),'&gt;','>'),'&amp;lt;','<'),'&amp;gt;','>')  question_all
 	from  QuestionXML b	 ;

	if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'
	if @debug_me = 'Y' select '@QuestionXML' as QuestionXML, * from @QuestionXML


	------------------------------------------------------------------------------------------
	----	Get All responses from the current tables and put them into the temp table
	------------------------------------------------------------------------------------------

	IF ( @vfil_ds_schedule_date2 >=(select dbo.fn_cp_poc_getDataAgeDate())) -- Current  Data
	BEGIN
	  SELECT @vStep = 18, @step_start_time = getdate()
		IF @debug_me='Y' PRINT 'BEGIN STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' Geting the current document responses at ' + CONVERT(VARCHAR, @step_start_time)

			--PRN Calculation
			      INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id ,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)
				SELECT  distinct
				'-1_P_A' as schedule_detail_id,
				intervention.client_id,
				intervention.gen_intervention_id,
				intervention.intervention_id,
				intervention.std_intervention_id,
				intervention.text1,
				stdQId.stdQuestionId,
				stdQId.stdQuestionContorlType,
				stdQId.stdQuestionText,
				stdQId.sequence,
				stdQId.stdPickListId,
				schedule.fac_id,
				shift.schedule_id AS schedule_id,
				shift.std_shift_id AS std_shift_id,
				stdshift.description,stdshift.start_time,stdshift.end_time,
				CONVERT(DATETIME,NULL) AS shift_date,
				intervention.date_initiated AS schedule_start_date,
				convert(datetime,NULL) AS schedule_end_date,
				doc.effective_date as schedule_date,
				CASE WHEN doc.cp_prn_documentation_id IS NULL THEN NULL
				     when strike.cp_prn_documentation_id is not null then null
					 ELSE CONVERT(VARCHAR,doc.cp_prn_documentation_id)+'_P'	END	AS documentation_id	,
				 case when strike.cp_prn_documentation_id is not null then null else doc.effective_date end  as completed_date,
				 case when strike.cp_prn_documentation_id is not null then null else doc.entered_date end,
				 case when strike.cp_prn_documentation_id is not null then null else doc.task_time end,
				 case when strike.cp_prn_documentation_id is not null then null else resp.item_value_id end,
				 case when strike.cp_prn_documentation_id is not null then null else resp.item_value end,
				 schedule.retired_date,
				 intervention.resolved_date,
				 case when strike.cp_prn_documentation_id is not null then null else audit.long_username end AS created_by_longname,
				 case when strike.cp_prn_documentation_id is not null then null else audit.position_description end AS created_by_position ,
				 case when strike.cp_prn_documentation_id is not null then null else audit.initials end,
				 'N'	as strikeout_flag,
				 NULL AS strikeout_id,
				 NULL AS strikeout_description,
				 NULL AS strikeout_by,
				 NULL strikeout_date ,
				schedule.schedule_type AS schedule_type

				 FROM   dbo.cp_schedule schedule WITH (NOLOCK)
				  INNER JOIN  #PRP_ds_interventions intervention
					 ON  schedule.intervention_id = intervention.gen_intervention_id
					 and schedule.fac_id= intervention.fac_id

				   INNER JOIN dbo.cp_schedule_shift shift WITH (NOLOCK)
					 ON	 shift.schedule_id = schedule.schedule_id

				  INNER JOIN dbo.cp_std_shift stdshift WITH (NOLOCK)
					 ON shift.std_shift_id = stdshift.std_shift_id

				  LEFT JOIN dbo.cp_prn_documentation doc WITH (NOLOCK)
					 ON	doc.schedule_id = shift.schedule_id
					  AND doc.std_shift_id = shift.std_shift_id
				       AND  doc.effective_date>= @vfil_ds_schedule_date
				       AND  doc.effective_date <= @vfil_ds_schedule_date2_tzadj

				  LEFT JOIN dbo.cp_prn_documentation_strikeout strike  WITH (NOLOCK)
					ON  doc.cp_prn_documentation_id = strike.cp_prn_documentation_id

				  LEFT JOIN dbo.cp_prn_response resp  WITH (NOLOCK)
					 ON	resp.cp_prn_documentation_id = doc.cp_prn_documentation_id

				  left JOIN #stdQuestionIdTable stdQId
				        on  intervention.std_intervention_id = stdqid.stdinterventionid
					     and intervention.gen_intervention_id = stdqid.genInterventionId
						 and intervention.intervention_id = stdqid.interventionId
						 and resp.std_question_id=stdQId.stdQuestionId
						 and stdQId.stdQuestionRank = 1

				 LEFT JOIN dbo.cp_sec_user_audit audit  WITH (NOLOCK)
					 ON	doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id

				WHERE
					  schedule.schedule_type = 8
				  AND schedule.deleted = 'N'
				  AND schedule.fac_id=@vFacId
				  AND schedule.fac_id = intervention.fac_id
				  AND intervention.flowsheet  = 'Y'
				  AND intervention.current_row  = 'Y'
				  AND (schedule.retired_date IS NULL  OR schedule.retired_date >= @vfil_ds_schedule_date_tzadj)
				  AND (intervention.resolved_date IS NULL OR intervention.resolved_date >= @vfil_ds_schedule_date_tzadj)
				  and stdQId.stdQuestionId is not null
				  and strike.cp_prn_documentation_id is  null
					;

				 INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id ,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)
				select schedule_detail_id ,client_id ,gen_intervention_id,intervention_id ,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type
				 from (
				 	SELECT
				'-1_P_A' as schedule_detail_id,
				intervention.client_id,
				intervention.gen_intervention_id,
				intervention.intervention_id ,
				intervention.std_intervention_id,
				intervention.text1,
				stdQId.stdQuestionId,
				stdQId.stdQuestionContorlType,
				stdQId.stdQuestionText,
				stdQId.sequence,
				stdQId.stdPickListId,
				schedule.fac_id,
				shift.schedule_id AS schedule_id,
				shift.std_shift_id AS std_shift_id,
				stdshift.description,stdshift.start_time,stdshift.end_time,
				CONVERT(DATETIME,NULL) AS shift_date,
				intervention.date_initiated AS schedule_start_date,
				convert(datetime,NULL) AS schedule_end_date,
				convert(datetime,NULL) as schedule_date,
				Null	AS documentation_id	,
				NULL as completed_date,
				NULL as entered_date,
				NULL task_time,
				NULL item_value_id,
				NULL item_value,
				schedule.retired_date,
				 intervention.resolved_date,
			     NULL created_by_longname,
				NULL created_by_position ,
				NULL initials,
				'N'	as strikeout_flag,
				NULL strikeout_id,
				NULL strikeout_description,
				NULL strikeout_by,
				NULL strikeout_date ,
				schedule.schedule_type AS schedule_type

				 FROM   dbo.cp_schedule schedule WITH (NOLOCK)
				   INNER JOIN  #PRP_ds_interventions intervention
					 ON  schedule.intervention_id = intervention.gen_intervention_id
					 and schedule.fac_id= intervention.fac_id

				   INNER JOIN  #PRP_ClientList c on c.client_id=intervention.client_id
				    and  1= case
				              when c.admission_date< intervention.date_initiated and  year(intervention.date_initiated)= year(@vfil_ds_schedule_date)
						     and month(intervention.date_initiated)<= month(@vfil_ds_schedule_date)  then 1
							when c.admission_date< intervention.date_initiated and  year(intervention.date_initiated)< year(@vfil_ds_schedule_date)
						     and month(intervention.date_initiated)>= month(@vfil_ds_schedule_date)  then 1
						    when  c.admission_date> intervention.date_initiated and  month( c.admission_date)<= month(@vfil_ds_schedule_date) then 1 else 0 end					
				   INNER JOIN dbo.cp_schedule_shift shift WITH (NOLOCK)
					 ON	 shift.schedule_id = schedule.schedule_id					 

				  INNER JOIN dbo.cp_std_shift stdshift WITH (NOLOCK)
					 ON shift.std_shift_id = stdshift.std_shift_id

				  left JOIN #stdQuestionIdTable stdQId
				      ON
					 --stdQId.stdquestionid = resp.std_question_id
				       intervention.std_intervention_id = stdqid.stdinterventionid
					     and intervention.gen_intervention_id = stdqid.genInterventionId
						 and intervention.intervention_id = stdqid.interventionId
						 and stdQId.stdQuestionRank = 1

				WHERE
					  schedule.schedule_type = 8
				  AND schedule.deleted = 'N'
				  AND schedule.fac_id=@vFacId
				  AND intervention.flowsheet  = 'Y'
				  AND intervention.current_row  = 'Y'
				  --and intervention.std_intervention_id=3926
				  AND (schedule.retired_date IS NULL  OR schedule.retired_date >= @vfil_ds_schedule_date_tzadj)
				  AND (intervention.resolved_date IS NULL OR intervention.resolved_date >= @vfil_ds_schedule_date_tzadj)  )tt
				where not exists (select 1 from #cp_documentation_responses b where
				    b.schedule_detail_id=tt.schedule_detail_id and
				    b.client_id= tt.client_id and
				    b.gen_intervention_id = tt.gen_intervention_id and
				    b.intervention_id =tt.intervention_id and
				   b.std_intervention_id	  =tt.std_intervention_id  and
				   b.schedule_id=tt.schedule_id AND
				   b.std_shift_id=tt.std_shift_id AND
				   b.stdQuestionId=	tt.stdQuestionId   )  ;

			 -- StruckOut Info.
			     INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id ,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)
				SELECT
				'-1_P_A' as schedule_detail_id,
				intervention.client_id,
				intervention.gen_intervention_id,
				intervention.intervention_id,
				intervention.std_intervention_id,
				intervention.text1,
				stdQId.stdQuestionId,
				stdQId.stdQuestionContorlType,
				stdQId.stdQuestionText,
				stdQId.sequence,
				stdQId.stdPickListId,
				schedule.fac_id,
				shift.schedule_id AS schedule_id,
				shift.std_shift_id AS std_shift_id,
				stdshift.description,stdshift.start_time,stdshift.end_time,
				CONVERT(DATETIME,NULL) AS shift_date,
				intervention.date_initiated AS schedule_start_date,
				convert(datetime,NULL) AS schedule_end_date,
				doc.effective_date as schedule_date,
				CASE WHEN doc.cp_prn_documentation_id IS NULL THEN NULL
					 ELSE CONVERT(VARCHAR,doc.cp_prn_documentation_id)+'_P'	END	AS documentation_id	,
				 doc.effective_date  as completed_date,
				 doc.entered_date,
				 doc.task_time,
				 resp.item_value_id,
				 resp.item_value,
				 schedule.retired_date,
				 intervention.resolved_date,
				 audit.long_username AS created_by_longname,
				 audit.position_description AS created_by_position ,
				 audit.initials,
				 'Y' as strikeout_flag,
				strikeaudit.item_id AS strikeout_id,
				strikeaudit.description AS strikeout_description,
				strike_audit.long_username AS strikeout_by,
				strike.entered_date AS strikeout_date ,
				schedule.schedule_type AS schedule_type

				 FROM   dbo.cp_schedule schedule WITH (NOLOCK)
				  INNER JOIN  #PRP_ds_interventions intervention
					 ON  schedule.intervention_id = intervention.gen_intervention_id
					 and schedule.fac_id= intervention.fac_id

				   INNER JOIN dbo.cp_schedule_shift shift WITH (NOLOCK)
					 ON	 shift.schedule_id = schedule.schedule_id					 

				  INNER JOIN dbo.cp_std_shift stdshift WITH (NOLOCK)
					 ON shift.std_shift_id = stdshift.std_shift_id

				  LEFT JOIN dbo.cp_prn_documentation doc WITH (NOLOCK)
					 ON	doc.schedule_id = shift.schedule_id
					  AND doc.std_shift_id = shift.std_shift_id
					  AND ISNULL( doc.effective_date,@vfil_ds_schedule_date) >= @vfil_ds_schedule_date
				       AND ISNULL( doc.effective_date,@vfil_ds_schedule_date) <= @vfil_ds_schedule_date2_tzadj

				  INNER JOIN dbo.cp_prn_documentation_strikeout strike   WITH (NOLOCK)
					 ON doc.cp_prn_documentation_id = strike.cp_prn_documentation_id

				  INNER JOIN dbo.cp_strikeout_reason_audit strikeaudit WITH (NOLOCK)
					 ON strikeaudit.cp_strikeout_reason_audit_id = strike.cp_strikeout_reason_audit_id

				  LEFT JOIN dbo.cp_prn_response resp  WITH (NOLOCK)
					 ON	resp.cp_prn_documentation_id = doc.cp_prn_documentation_id

				  left JOIN #stdQuestionIdTable stdQId
				      --ON	stdQId.stdquestionid = resp.std_question_id
				        on  intervention.std_intervention_id = stdqid.stdinterventionid
					     and intervention.gen_intervention_id = stdqid.genInterventionId
						 and intervention.intervention_id = stdqid.interventionId
					     and resp.std_question_id=stdQId.stdQuestionId
						 and stdQId.stdQuestionRank = 1


				  INNER JOIN dbo.cp_sec_user_audit strike_audit WITH (NOLOCK)
					 ON strike.cp_sec_user_audit_id = strike_audit.cp_sec_user_audit_id

				  LEFT JOIN dbo.cp_sec_user_audit audit  WITH (NOLOCK)
					 ON	doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id

				WHERE
					  schedule.schedule_type = 8
				  AND schedule.deleted = 'N'
				  AND schedule.fac_id=@vFacId
				  AND intervention.flowsheet  = 'Y'
				  AND intervention.current_row  = 'Y'
				  AND (schedule.retired_date IS NULL  OR schedule.retired_date >= @vfil_ds_schedule_date_tzadj)
				  AND (intervention.resolved_date IS NULL OR intervention.resolved_date >= @vfil_ds_schedule_date_tzadj)
				  and stdQId.stdQuestionId is not null

			 --QShift details
			      INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)

				SELECT
				    CONVERT(VARCHAR,detail.cp_qshift_detail_id)+'_Q_A' AS schedule_detail_id,
				    rev.client_id,
				    rev.gen_intervention_id,
				    rev.intervention_id,
				    rev.std_intervention_id,
				    rev.text1,
				    case when strike.cp_qshift_documentation_id is not null then null else stdQId.stdQuestionId end,
				    case when strike.cp_qshift_documentation_id is not null then null else stdQId.stdQuestionContorlType end,
				    case when strike.cp_qshift_documentation_id is not null then null else stdQId.stdQuestionText end,
				    case when strike.cp_qshift_documentation_id is not null then null else stdQId.sequence end,
				    case when strike.cp_qshift_documentation_id is not null then null else stdQId.stdPickListId end,
				    detail.fac_id,
				    detail.schedule_id AS schedule_id,
				    detail.std_shift_id as std_shift_id,
				    stdshift.description,stdshift.start_time,stdshift.end_time,
				    detail.shift_date as shift_date,
				    rev.date_initiated AS schedule_start_date,
				    convert(datetime,NULL) AS schedule_end_date,
				    dates.s_date as schedule_date,
				    case when doc.cp_qshift_documentation_id is null THEN  null
				         when strike.cp_qshift_documentation_id is not null then null
					    else convert(varchar,doc.cp_qshift_documentation_id)+'_Q' end	as documentation_id	,
				    case when strike.cp_qshift_documentation_id is not null then null else doc.effective_date end  as completed_date,
				    case when strike.cp_qshift_documentation_id is not null then null else doc.entered_date end,
				    case when strike.cp_qshift_documentation_id is not null then null else doc.task_time end,
				    case when strike.cp_qshift_documentation_id is not null then null else resp.item_value_id end item_value_id,
				    case when strike.cp_qshift_documentation_id is not null then null else resp.item_value end item_value,
				    sched.retired_date,
				    rev.resolved_date,
				    case when strike.cp_qshift_documentation_id is not null then null else audit.long_username end as created_by_longname,
				    case when strike.cp_qshift_documentation_id is not null then null else audit.position_description end AS created_by_position ,
				    case when strike.cp_qshift_documentation_id is not null then null else audit.initials end,
				    'N' as strikeout_flag,
				    Null AS strikeout_id,
				    Null AS strikeout_description,
				    Null AS strikeout_by,
				    Null AS strikeout_date ,
				    sched.schedule_type AS schedule_type
			    from  dbo.cp_schedule sched  WITH (NOLOCK)

				    INNER JOIN #PRP_ds_interventions rev
					ON  sched.intervention_id  = rev.gen_intervention_id
						and sched.fac_id = rev.fac_id
						and sched.fac_id = @vFacID

				    INNER JOIN dbo.cp_qshift_detail detail	 WITH (NOLOCK)
						ON sched.schedule_id = detail.schedule_id
						and rev.fac_id = detail.fac_id

				    INNER JOIN dbo.cp_std_shift stdshift WITH (NOLOCK)
						ON stdshift.std_shift_id = detail.std_shift_id

					INNER JOIN view_cp_shift_dates dates WITH (NOLOCK)
					ON	dates.day_date = detail.shift_date
					    AND detail.std_shift_id = dates.std_shift_id
					    AND dates.fac_id = detail.fac_id

					LEFT OUTER JOIN #stdQuestionIdTable stdQId
					 on  rev.std_intervention_id = stdqid.stdinterventionid
						    and rev.gen_intervention_id = stdqid.genInterventionId
							and rev.intervention_id = stdqid.interventionId
							and rev.fac_id = stdQid.fac_id
							and stdQId.stdQuestionRank = 1

				    LEFT JOIN dbo.cp_qshift_documentation doc WITH (NOLOCK)
					ON doc.cp_qshift_detail_id = detail.cp_qshift_detail_id
						AND ISNULL(doc.effective_date,@vfil_ds_schedule_date) >= @vfil_ds_schedule_date
						AND ISNULL(doc.effective_date,@vfil_ds_schedule_date2) <= @vfil_ds_schedule_date2_tzadj

				    LEFT JOIN dbo.cp_qshift_documentation_strikeout strike  WITH (NOLOCK)
					ON  doc.cp_qshift_documentation_id = strike.cp_qshift_documentation_id

				    LEFT JOIN dbo.cp_qshift_response resp WITH (NOLOCK)
					ON	resp.cp_qshift_documentation_id = doc.cp_qshift_documentation_id
					and resp.std_question_id=stdQId.stdQuestionId

				    LEFT JOIN dbo.cp_sec_user_audit audit WITH (NOLOCK)
					ON	 doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id

				 WHERE
				     sched.deleted  = 'N'
				    AND (sched.retired_date IS NULL  OR sched.retired_date >= @vfil_ds_schedule_date_tzadj )
				    AND (rev.resolved_date IS NULL OR rev.resolved_date >= @vfil_ds_schedule_date_tzadj )
					AND (ISNULL(doc.effective_date, detail.shift_date) >= @vfil_ds_schedule_date and ISNULL(doc.effective_date, detail.shift_date) < @vfil_ds_schedule_date2_tzadj_plus1)
					;



			    -- StruckOut Info.
				 INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)
				SELECT
				    CONVERT(VARCHAR,detail.cp_qshift_detail_id)+'_Q_A' AS schedule_detail_id,
				    rev.client_id,
				    rev.gen_intervention_id,
				    rev.intervention_id,
				    rev.std_intervention_id,
				    rev.text1,
				    stdQId.stdQuestionId,
				    stdQId.stdQuestionContorlType,
				    stdQId.stdQuestionText,
				    stdQId.sequence,
				    stdQId.stdPickListId,
				    detail.fac_id,
				    detail.schedule_id AS schedule_id,
				    detail.std_shift_id as std_shift_id,
				    stdshift.description,stdshift.start_time,stdshift.end_time,
				    detail.shift_date as shift_date,
				    rev.date_initiated AS schedule_start_date,
				    convert(datetime,NULL) AS schedule_end_date,
				    dates.s_date as schedule_date,
				    case when doc.cp_qshift_documentation_id is null THEN  null
					    else convert(varchar,doc.cp_qshift_documentation_id)+'_Q' end	as documentation_id	,
				    doc.effective_date as completed_date,
				    doc.entered_date,
				    doc.task_time,
				    resp.item_value_id,
				    resp.item_value,
				    sched.retired_date,
				    rev.resolved_date,
				    audit.long_username as created_by_longname,
				    audit.position_description AS created_by_position ,
				    audit.initials,
				    'Y'as strikeout_flag,
				    strikeaudit.item_id AS strikeout_id,
				    strikeaudit.description AS strikeout_description,
				    strike_audit.long_username AS strikeout_by,
				    strike.entered_date AS strikeout_date ,
				    sched.schedule_type AS schedule_type
			    from  dbo.cp_schedule sched  WITH (NOLOCK)
				    INNER JOIN #PRP_ds_interventions rev
					ON rev.gen_intervention_id = sched.intervention_id
					and sched.fac_id = rev.fac_id
						and sched.fac_id = @vFacID

				   INNER JOIN dbo.cp_qshift_detail detail	 WITH (NOLOCK)
						ON sched.schedule_id = detail.schedule_id
						and rev.fac_id = detail.fac_id

				    INNER JOIN dbo.cp_std_shift stdshift WITH (NOLOCK)
						ON stdshift.std_shift_id = detail.std_shift_id

				    LEFT JOIN dbo.cp_qshift_documentation doc WITH (NOLOCK)
					ON doc.cp_qshift_detail_id = detail.cp_qshift_detail_id
						AND ISNULL( doc.effective_date,@vfil_ds_schedule_date) >= @vfil_ds_schedule_date
						AND	ISNULL( doc.effective_date,@vfil_ds_schedule_date2) <= @vfil_ds_schedule_date2_tzadj

				    inner JOIN dbo.cp_qshift_documentation_strikeout strike WITH (NOLOCK)
					ON  doc.cp_qshift_documentation_id = strike.cp_qshift_documentation_id

				    inner JOIN dbo.cp_strikeout_reason_audit strikeaudit WITH (NOLOCK)
					ON strikeaudit.cp_strikeout_reason_audit_id = strike.cp_strikeout_reason_audit_id

				    inner JOIN dbo.cp_sec_user_audit strike_audit WITH (NOLOCK)
					ON strike.cp_sec_user_audit_id = strike_audit.cp_sec_user_audit_id

				    LEFT JOIN dbo.cp_qshift_response resp WITH (NOLOCK)
					ON	resp.cp_qshift_documentation_id = doc.cp_qshift_documentation_id

				    LEFT JOIN #stdQuestionIdTable stdQId
					 on  rev.std_intervention_id = stdqid.stdinterventionid
						    and rev.gen_intervention_id = stdqid.genInterventionId
							and rev.intervention_id = stdqid.interventionId
							and resp.std_question_id=stdQId.stdQuestionId
							and stdQId.stdQuestionRank = 1

				    INNER JOIN view_cp_shift_dates dates WITH (NOLOCK)
					ON	dates.day_date = detail.shift_date
					    AND detail.std_shift_id=dates.std_shift_id
					    AND dates.fac_id=detail.fac_id


				    LEFT JOIN dbo.cp_sec_user_audit audit WITH (NOLOCK)
					ON	 doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id

				 WHERE sched.deleted  = 'N'
				    AND (sched.retired_date IS NULL  OR sched.retired_date >= @vfil_ds_schedule_date_tzadj)
				    AND (rev.resolved_date IS NULL OR rev.resolved_date >= @vfil_ds_schedule_date_tzadj)
					AND (ISNULL(doc.effective_date, detail.shift_date) >= @vfil_ds_schedule_date and ISNULL(doc.effective_date, detail.shift_date) < @vfil_ds_schedule_date2_tzadj_plus1)
					;

			 ----Scheduled details
			      INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)

			 SELECT
			   CONVERT(VARCHAR,detail.cp_scheduled_detail_id)+'_S_A' AS schedule_detail_id,
				rev.client_id,
				rev.gen_intervention_id,
				rev.intervention_id,
				rev.std_intervention_id,
				rev.text1,
				stdQId.stdQuestionId,
				stdQId.stdQuestionContorlType,
				stdQId.stdQuestionText,
				stdQId.sequence,
			     stdQId.stdPickListId,
				detail.fac_id,
				detail.schedule_id AS schedule_id,
				NULL AS std_shift_id,
				NULL description,
				NULL start_time,
				NULL end_time,
				CONVERT(DATETIME,NULL) AS shift_date,
				rev.date_initiated AS schedule_start_date,
				CONVERT(DATETIME,NULL) AS schedule_end_date,
				detail.schedule_date as schedule_date,
				CASE WHEN doc.cp_scheduled_documentation_id IS NULL THEN NULL
				 when strike.cp_scheduled_documentation_id is not null then null
					 ELSE convert(varchar,doc.cp_scheduled_documentation_id)+'_S'
				 END AS documentation_id,
				case when strike.cp_scheduled_documentation_id is not null then null else doc.effective_date end as completed_date,
				case when strike.cp_scheduled_documentation_id is not null then null else doc.entered_date end,
				case when strike.cp_scheduled_documentation_id is not null then null else doc.task_time end,
				case when strike.cp_scheduled_documentation_id is not null then null else resp.item_value_id end,
				case when strike.cp_scheduled_documentation_id is not null then null else resp.item_value end,
				sched.retired_date,
				rev.resolved_date,
				case when strike.cp_scheduled_documentation_id is not null then null else audit.long_username  end as created_by_longname,
				case when strike.cp_scheduled_documentation_id is not null then null else audit.position_description end AS created_by_position ,
				case when strike.cp_scheduled_documentation_id is not null then null else audit.initials end,
				'N' as strikeout_flag,
				Null AS strikeout_id,
				Null AS strikeout_description,
				Null AS strikeout_by,
				Null AS strikeout_date ,
				sched.schedule_type AS schedule_type

			 FROM dbo.cp_schedule sched  WITH (NOLOCK)
				INNER JOIN #PRP_ds_interventions rev
				 ON rev.gen_intervention_id = sched.intervention_id
				 and sched.fac_id = rev.fac_id
				 and sched.fac_id = @vFacID

				INNER JOIN dbo.cp_scheduled_detail detail	 WITH (NOLOCK)
				 ON sched.schedule_id = detail.schedule_id
					and sched.fac_id = detail.fac_id

				LEFT JOIN dbo.cp_scheduled_documentation doc WITH (NOLOCK)
				 ON doc.cp_scheduled_detail_id = detail.cp_scheduled_detail_id
				  AND  ISNULL( doc.effective_date,@vfil_ds_schedule_date) >= @vfil_ds_schedule_date AND
				  1 = case
				          when
						 ISNULL( doc.effective_date,@vfil_ds_schedule_date2) < @vfil_ds_schedule_date2_tzadj_plus1 and
				           cast(replace(convert (varchar(5),ISNULL(dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, doc.effective_date),@vfil_ds_schedule_date2),108),':','') as int) >=(select top 1 cast(start_time as int)  from #prp_shifts where flg=1)
				       and cast(replace(convert (varchar(5),ISNULL(dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacID, doc.effective_date),@vfil_ds_schedule_date2),108),':','') as int)<=(select top 1  end_time  from #prp_shifts where flg=1)
				          then 1
				          when  ISNULL(doc.effective_date,@vfil_ds_schedule_date2) <= @vfil_ds_schedule_date2_tzadj then 1
				       else 0 end

				LEFT JOIN dbo.cp_scheduled_documentation_strikeout strike  WITH (NOLOCK)
				  ON  doc.cp_scheduled_documentation_id = strike.cp_scheduled_documentation_id

				LEFT JOIN dbo.cp_scheduled_response resp WITH (NOLOCK)
				 ON	 resp.cp_scheduled_documentation_id = doc.cp_scheduled_documentation_id

				left JOIN #stdQuestionIdTable stdQId WITH (NOLOCK)
				  on  rev.std_intervention_id = stdqid.stdinterventionid
					     and rev.gen_intervention_id = stdqid.genInterventionId
						 and rev.intervention_id = stdqid.interventionId
						and  resp.std_question_id=stdQId.stdQuestionId
						and stdQId.stdQuestionRank = 1

				LEFT JOIN dbo.cp_sec_user_audit audit WITH (NOLOCK)
				 ON	 doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id
				where sched.deleted  = 'N'
					AND (sched.retired_date IS NULL  OR sched.retired_date >= @vfil_ds_schedule_date_tzadj)
					AND (rev.resolved_date IS NULL OR rev.resolved_date >= @vfil_ds_schedule_date_tzadj)
					and (detail.schedule_date >= @vfil_ds_schedule_date and detail.schedule_date <= @vfil_ds_schedule_date2_tzadj_plus1)

					;
			      -- Scheduled details StruckOut Info.
				 INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)

			 SELECT
			   CONVERT(VARCHAR,detail.cp_scheduled_detail_id)+'_S_A' AS schedule_detail_id,
				rev.client_id,
				rev.gen_intervention_id,
				rev.intervention_id,
				rev.std_intervention_id,
				rev.text1,
				stdQId.stdQuestionId,
				stdQId.stdQuestionContorlType,
				stdQId.stdQuestionText,
				stdQId.sequence,
			     stdQId.stdPickListId,
				detail.fac_id,
				detail.schedule_id AS schedule_id,
				NULL AS std_shift_id,
				NULL description,
				NULL start_time,
				NULL end_time,
				CONVERT(DATETIME,NULL) AS shift_date,
				rev.date_initiated AS schedule_start_date,
				CONVERT(DATETIME,NULL) AS schedule_end_date,
				detail.schedule_date as schedule_date,
				CASE WHEN doc.cp_scheduled_documentation_id IS NULL THEN NULL
					 ELSE convert(varchar,doc.cp_scheduled_documentation_id)+'_S'
				 END AS documentation_id,
				doc.effective_date as completed_date,
				doc.entered_date,
				doc.task_time,
				resp.item_value_id,
				resp.item_value,
				sched.retired_date,
				rev.resolved_date,
				audit.long_username as created_by_longname,
				audit.position_description AS created_by_position ,
					audit.initials,
				'Y'  strikeout_flag,
				strikeaudit.item_id AS strikeout_id,
				strikeaudit.description AS strikeout_description,
				strike_audit.long_username AS strikeout_by,
				strike.entered_date AS strikeout_date ,
				sched.schedule_type AS schedule_type

			 FROM dbo.cp_schedule sched  WITH (NOLOCK)
				INNER JOIN #PRP_ds_interventions rev
				 ON rev.gen_intervention_id = sched.intervention_id
					and sched.fac_id = rev.fac_id
					and sched.fac_id = @vFacID

				INNER JOIN dbo.cp_scheduled_detail detail	 WITH (NOLOCK)
				 ON sched.schedule_id = detail.schedule_id
					and sched.fac_id = detail.fac_id

				INNER JOIN dbo.cp_scheduled_documentation doc WITH (NOLOCK)
				 ON doc.cp_scheduled_detail_id = detail.cp_scheduled_detail_id
				  AND  ISNULL( doc.effective_date,@vfil_ds_schedule_date) >= @vfil_ds_schedule_date AND
					  ISNULL( doc.effective_date,@vfil_ds_schedule_date2) <= @vfil_ds_schedule_date2_tzadj

				INNER JOIN dbo.cp_scheduled_documentation_strikeout strike WITH (NOLOCK)
				 ON doc.cp_scheduled_documentation_id = strike.cp_scheduled_documentation_id

				INNER JOIN dbo.cp_strikeout_reason_audit strikeaudit WITH (NOLOCK)
				 ON strikeaudit.cp_strikeout_reason_audit_id = strike.cp_strikeout_reason_audit_id

				INNER JOIN dbo.cp_sec_user_audit strike_audit WITH (NOLOCK)
				 ON strike.cp_sec_user_audit_id = strike_audit.cp_sec_user_audit_id

				LEFT JOIN dbo.cp_scheduled_response resp WITH (NOLOCK)
				 ON	 resp.cp_scheduled_documentation_id = doc.cp_scheduled_documentation_id

				left JOIN #stdQuestionIdTable stdQId WITH (NOLOCK)
				  on  rev.std_intervention_id = stdqid.stdinterventionid
					     and rev.gen_intervention_id = stdqid.genInterventionId
						 and rev.intervention_id = stdqid.interventionId
						 and  resp.std_question_id=stdQId.stdQuestionId
						 and stdQId.stdQuestionRank = 1

				LEFT JOIN dbo.cp_sec_user_audit audit WITH (NOLOCK)
				 ON	 doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id
				where  sched.deleted = 'N'
					AND (sched.retired_date IS NULL  OR sched.retired_date >= @vfil_ds_schedule_date_tzadj)
					AND (rev.resolved_date IS NULL OR rev.resolved_date >= @vfil_ds_schedule_date_tzadj)
					and (detail.schedule_date >= @vfil_ds_schedule_date and detail.schedule_date <= @vfil_ds_schedule_date2_tzadj_plus1);

			--Schedule Duration
			-- No overlapping month

			      INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)
			 SELECT
			   CONVERT(VARCHAR,detail.cp_duration_detail_id)+'_D_A' AS schedule_detail_id,
				rev.client_id,
				rev.gen_intervention_id,
				rev.intervention_id,
				rev.std_intervention_id,
				rev.text1,
				stdQId.stdQuestionId,
				stdQId.stdQuestionContorlType,
				stdQId.stdQuestionText,
				stdQId.sequence,
				stdQId.stdPickListId,
				detail.fac_id,
				detail.schedule_id as schedule_id,
				NULL AS std_shift_id,
				NULL description,NULL start_time,NULL end_time,
				CONVERT(DATETIME,NULL) AS shift_date,
				rev.date_initiated AS schedule_start_date,
				detail.schedule_end_date AS schedule_end_date,
				detail.schedule_start_date AS schedule_date,
				 CASE WHEN doc.cp_duration_documentation_id IS NULL THEN NULL
				  when strike.cp_duration_documentation_id is not null then null
					ELSE convert(varchar,doc.cp_duration_documentation_id)+'_D'
				 END AS documentation_id,
				case when strike.cp_duration_documentation_id is not null then null else doc.effective_date end AS completed_date,
				case when strike.cp_duration_documentation_id is not null then null else doc.entered_date end,
				case when strike.cp_duration_documentation_id is not null then null else doc.task_time end,
				case when strike.cp_duration_documentation_id is not null then null else resp.item_value_id end,
				case when strike.cp_duration_documentation_id is not null then null else resp.item_value end,
				sched.retired_date,
				rev.resolved_date,
				case when strike.cp_duration_documentation_id is not null then null else audit.long_username end AS created_by_longname,
				case when strike.cp_duration_documentation_id is not null then null else audit.position_description end AS created_by_position ,
				case when strike.cp_duration_documentation_id is not null then null else audit.initials end,
				'N'	AS strikeout_flag,
				NULL AS strikeout_id,
				NULL AS strikeout_description,
				NULL AS strikeout_by,
				NULL AS strikeout_date ,
				sched.schedule_type AS schedule_type
			 FROM dbo.cp_schedule sched  WITH (NOLOCK)
				INNER JOIN #PRP_ds_interventions rev
				 ON rev.gen_intervention_id = sched.intervention_id
					and sched.fac_id = rev.fac_id
					and sched.fac_id = @vFacID

				INNER JOIN dbo.cp_duration_detail detail	 WITH (NOLOCK)
				 ON sched.schedule_id = detail.schedule_id
					and sched.fac_id = detail.fac_id

				LEFT JOIN dbo.cp_duration_documentation doc WITH (NOLOCK)
				 ON doc.cp_duration_detail_id = detail.cp_duration_detail_id
				  AND ISNULL( doc.effective_date,@vfil_ds_schedule_date) >= @vfil_ds_schedule_date AND
					 ISNULL( doc.effective_date,@vfil_ds_schedule_date2) <= @vfil_ds_schedule_date2_tzadj

				LEFT JOIN dbo.cp_duration_documentation_strikeout strike WITH (NOLOCK)
				 on doc.cp_duration_documentation_id = strike.cp_duration_documentation_id

				LEFT JOIN dbo.cp_duration_response resp WITH (NOLOCK)
				 ON	 resp.cp_duration_documentation_id = doc.cp_duration_documentation_id

				LEFT JOIN #stdQuestionIdTable stdQId WITH (NOLOCK)
				 on  rev.std_intervention_id = stdqid.stdinterventionid
					     and rev.gen_intervention_id = stdqid.genInterventionId
						 and rev.intervention_id = stdqid.interventionId
						 and  resp.std_question_id=stdQId.stdQuestionId
						 and stdQId.stdQuestionRank = 1

				LEFT JOIN dbo.cp_sec_user_audit audit WITH (NOLOCK)
					on doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id
				where sched.deleted = 'N'
					AND (sched.retired_date IS NULL  OR sched.retired_date >= @vfil_ds_schedule_date_tzadj)
					AND (rev.resolved_date IS NULL OR rev.resolved_date >= @vfil_ds_schedule_date_tzadj)

					and not EXISTS(select 1 from dbo.cp_duration_documentation_strikeout strike WITH (NOLOCK)
									where doc.cp_duration_documentation_id = strike.cp_duration_documentation_id);
				  ;
			--StruckOut Info.
			      INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)
			 SELECT
			   CONVERT(VARCHAR,detail.cp_duration_detail_id)+'_D_A' AS schedule_detail_id,
				rev.client_id,
				rev.gen_intervention_id,
				rev.intervention_id,
				rev.std_intervention_id,
				rev.text1,
				stdQId.stdQuestionId,
				stdQId.stdQuestionContorlType,
				stdQId.stdQuestionText,
				stdQId.sequence,
				stdQId.stdPickListId,
				detail.fac_id,
				detail.schedule_id as schedule_id,
				NULL AS std_shift_id,
				NULL description,NULL start_time,NULL end_time,
				CONVERT(DATETIME,NULL) AS shift_date,
				rev.date_initiated AS schedule_start_date,
				detail.schedule_end_date AS schedule_end_date,
				detail.schedule_start_date AS schedule_date,
				 CASE WHEN doc.cp_duration_documentation_id IS NULL THEN NULL
					ELSE convert(varchar,doc.cp_duration_documentation_id)+'_D'
				 END AS documentation_id,
				doc.effective_date AS completed_date,
				doc.entered_date,
				doc.task_time,
				resp.item_value_id,
				resp.item_value,
				sched.retired_date,
				rev.resolved_date,
				audit.long_username AS created_by_longname,
				audit.position_description AS created_by_position ,
				audit.initials,
				'Y' strikeout_flag,
				strikeaudit.item_id AS strikeout_id,
				strikeaudit.description AS strikeout_description,
				strike_audit.long_username AS strikeout_by,
				strike.entered_date AS strikeout_date ,
				sched.schedule_type AS schedule_type
			 FROM dbo.cp_schedule sched  WITH (NOLOCK)
				INNER JOIN #PRP_ds_interventions rev
				 ON rev.gen_intervention_id = sched.intervention_id
					and sched.fac_id = rev.fac_id
					and sched.fac_id = @vFacID

				INNER JOIN dbo.cp_duration_detail detail	 WITH (NOLOCK)
				 ON sched.schedule_id = detail.schedule_id

				INNER JOIN dbo.cp_duration_documentation doc WITH (NOLOCK)
				 ON doc.cp_duration_detail_id = detail.cp_duration_detail_id
				  AND ISNULL( doc.effective_date,@vfil_ds_schedule_date) >= @vfil_ds_schedule_date AND
					 ISNULL(doc.effective_date,@vfil_ds_schedule_date2) <= @vfil_ds_schedule_date2_tzadj

				INNER JOIN dbo.cp_duration_documentation_strikeout strike WITH (NOLOCK)
				 ON doc.cp_duration_documentation_id = strike.cp_duration_documentation_id

				INNER JOIN dbo.cp_strikeout_reason_audit strikeaudit WITH (NOLOCK)
				 ON strikeaudit.cp_strikeout_reason_audit_id = strike.cp_strikeout_reason_audit_id

				INNER JOIN dbo.cp_sec_user_audit strike_audit WITH (NOLOCK)
				 ON strike.cp_sec_user_audit_id = strike_audit.cp_sec_user_audit_id

				LEFT JOIN dbo.cp_duration_response resp WITH (NOLOCK)
				 ON	 resp.cp_duration_documentation_id = doc.cp_duration_documentation_id

				LEFT JOIN #stdQuestionIdTable stdQId WITH (NOLOCK)
				 on  rev.std_intervention_id = stdqid.stdinterventionid
					     and rev.gen_intervention_id = stdqid.genInterventionId
						 and rev.intervention_id = stdqid.interventionId
						 and  resp.std_question_id=stdQId.stdQuestionId
						 and stdQId.stdQuestionRank = 1

				LEFT JOIN dbo.cp_sec_user_audit audit WITH (NOLOCK)
					on doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id
				where sched.deleted  = 'N'
					  AND (sched.retired_date IS NULL  OR sched.retired_date >= @vfil_ds_schedule_date_tzadj)
					  AND (rev.resolved_date IS NULL OR rev.resolved_date >= @vfil_ds_schedule_date_tzadj)
					  AND (detail.schedule_start_date >= @vfil_ds_schedule_date2_tzadj_plus1 );

			--Unscheduled Calculation
			IF (SELECT value FROM configuration_parameter WHERE name='enable_unscheduled_tasks'  and fac_id=@vFacId)='Y'
			BEGIN

			 INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)
			 SELECT	distinct
			   '-1_U_A' AS schedule_detail_id,
				rev.client_id,
				rev.gen_intervention_id,
				rev.intervention_id,
				rev.std_intervention_id,
				rev.text1,
				stdQId.stdQuestionId,
				stdQId.stdQuestionContorlType,
				stdQId.stdQuestionText,
				stdQId.sequence,
				stdQId.stdPickListId,
				sched.fac_id,
				sched.schedule_id AS schedule_id,
				NULL as std_shift_id,
				NULL description,NULL start_time,NULL end_time,
				CONVERT(DATETIME,NULL) AS shift_date,
				rev.date_initiated AS schedule_start_date,
				CONVERT(DATETIME,NULL) AS schedule_end_date,
				doc.effective_date as schedule_date,
				 CASE WHEN doc.cp_unscheduled_documentation_id IS NULL THEN NULL
					  ELSE convert(varchar,doc.cp_unscheduled_documentation_id)+'_U'
				 END AS documentation_id,
				doc.effective_date as completed_date,
				doc.entered_date,
				doc.task_time,
				resp.item_value_id,
				resp.item_value,
				sched.retired_date,
				rev.resolved_date,
				audit.long_username AS created_by_longname,
				audit.position_description AS created_by_position ,
				audit.initials,
				CASE
					WHEN (strike.cp_strikeout_reason_audit_id IS NOT NULL) THEN
						'Y'
					ELSE
						'N'
				END	as strikeout_flag,
				strikeaudit.item_id AS strikeout_id,
				strikeaudit.description AS strikeout_description,
				strike_audit.long_username AS strikeout_by,
				strike.entered_date AS strikeout_date ,
				sched.schedule_type AS schedule_type
			 FROM dbo.cp_schedule sched  WITH (NOLOCK)
				INNER JOIN #PRP_ds_interventions rev
				 ON rev.gen_intervention_id = sched.intervention_id
					and sched.fac_id = rev.fac_id
					and sched.fac_id = @vFacID

				LEFT JOIN dbo.cp_unscheduled_documentation doc WITH (NOLOCK)
				 ON doc.schedule_id = sched.schedule_id
				  AND doc.effective_date >= @vfil_ds_schedule_date
				  AND doc.effective_date <= @vfil_ds_schedule_date2_tzadj

				LEFT JOIN dbo.cp_unscheduled_documentation_strikeout strike WITH (NOLOCK)
				 ON doc.cp_unscheduled_documentation_id = strike.cp_unscheduled_documentation_id

				LEFT JOIN dbo.cp_strikeout_reason_audit strikeaudit WITH (NOLOCK)
				 ON strikeaudit.cp_strikeout_reason_audit_id = strike.cp_strikeout_reason_audit_id

				LEFT JOIN dbo.cp_sec_user_audit strike_audit WITH (NOLOCK)
				 ON strike.cp_sec_user_audit_id = strike_audit.cp_sec_user_audit_id

				LEFT JOIN dbo.cp_unscheduled_response resp WITH (NOLOCK)
				 ON	 resp.cp_unscheduled_documentation_id = doc.cp_unscheduled_documentation_id

				left JOIN #stdQuestionIdTable stdQId WITH (NOLOCK)
				  on  rev.std_intervention_id = stdqid.stdinterventionid
					     and rev.gen_intervention_id = stdqid.genInterventionId
						 and rev.intervention_id = stdqid.interventionId
						 and  resp.std_question_id=stdQId.stdQuestionId
						 and stdQId.stdQuestionRank = 1

				LEFT JOIN dbo.cp_sec_user_audit audit WITH (NOLOCK)
					on doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id

				where sched.schedule_Type = 40
					  AND (sched.retired_date IS NULL  OR sched.retired_date >= @vfil_ds_schedule_date_tzadj);

			END
	if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'
	if @debug_me = 'Y'
	  select '#cp_documentation_responses_current' as cp_documentation_responses_current, * from #cp_documentation_responses a  order by 1

	END



     -- HISTORICAL  Data
	-- PRN Historical Data
    IF (@vfil_ds_schedule_date < (SELECT current_history_end_date
									FROM dbo.process_configuration
									WHERE process_name = 'poc_prn_history_load' ))
	BEGIN

	  SELECT @vStep = 19, @step_start_time = getdate()
		IF @debug_me='Y' PRINT 'BEGIN STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' Geting the Historical document responses  at ' + CONVERT(VARCHAR, @step_start_time)
			--PRN Calculation

			--PRN Calculation
			      INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id ,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)
				SELECT  distinct
				'-1_P_H' as schedule_detail_id,
				intervention.client_id,
				intervention.gen_intervention_id,
				intervention.intervention_id,
				intervention.std_intervention_id,
				intervention.text1,
				stdQId.stdQuestionId,
				stdQId.stdQuestionContorlType,
				stdQId.stdQuestionText,
				stdQId.sequence,
				stdQId.stdPickListId,
				schedule.fac_id,
				shift.schedule_id AS schedule_id,
				shift.std_shift_id AS std_shift_id,
				stdshift.description,stdshift.start_time,stdshift.end_time,
				CONVERT(DATETIME,NULL) AS shift_date,
				intervention.date_initiated AS schedule_start_date,
				convert(datetime,NULL) AS schedule_end_date,
				doc.effective_date as schedule_date,
				CASE WHEN doc.cp_prn_documentation_history_id IS NULL THEN NULL
				     when strike.cp_prn_documentation_history_id is not null then null
					 ELSE CONVERT(VARCHAR,doc.cp_prn_documentation_history_id)+'_P'	END	AS documentation_id	,
				 case when strike.cp_prn_documentation_history_id is not null then null else doc.effective_date end  as completed_date,
				 case when strike.cp_prn_documentation_history_id is not null then null else doc.entered_date end,
				 case when strike.cp_prn_documentation_history_id is not null then null else doc.task_time end,
				 case when strike.cp_prn_documentation_history_id is not null then null else resp.item_value_id end,
				 case when strike.cp_prn_documentation_history_id is not null then null else resp.item_value end,
				 schedule.retired_date,
				 intervention.resolved_date,
				 case when strike.cp_prn_documentation_history_id is not null then null else audit.long_username end AS created_by_longname,
				 case when strike.cp_prn_documentation_history_id is not null then null else audit.position_description end AS created_by_position ,
				 case when strike.cp_prn_documentation_history_id is not null then null else audit.initials end,
				 'N'	as strikeout_flag,
				 NULL AS strikeout_id,
				 NULL AS strikeout_description,
				 NULL AS strikeout_by,
				 NULL strikeout_date ,
				schedule.schedule_type AS schedule_type

				 FROM   dbo.cp_schedule schedule WITH (NOLOCK)
				  INNER JOIN  #PRP_ds_interventions intervention
					 ON  schedule.intervention_id = intervention.gen_intervention_id
					 and schedule.fac_id= intervention.fac_id
					 and schedule.fac_id=@vFacId

				   INNER JOIN dbo.cp_schedule_shift shift WITH (NOLOCK)
						ON	 shift.schedule_id = schedule.schedule_id

				  INNER JOIN dbo.cp_std_shift stdshift WITH (NOLOCK)
						ON shift.std_shift_id = stdshift.std_shift_id

				  LEFT JOIN dbo.cp_prn_documentation_history doc WITH (NOLOCK)
						ON	doc.schedule_id = shift.schedule_id
						AND doc.std_shift_id = shift.std_shift_id
						AND ISNULL( doc.effective_date,@vfil_ds_schedule_date) >= @vfil_ds_schedule_date
						AND ISNULL( doc.effective_date,@vfil_ds_schedule_date) <= @vfil_ds_schedule_date2_tzadj

				  LEFT JOIN dbo.cp_prn_documentation_strikeout_history strike  WITH (NOLOCK)
					ON  doc.cp_prn_documentation_history_id = strike.cp_prn_documentation_history_id

				  LEFT JOIN dbo.cp_prn_response_history resp  WITH (NOLOCK)
					 ON	resp.cp_prn_documentation_history_id = doc.cp_prn_documentation_history_id

				  left JOIN #stdQuestionIdTable stdQId
				        on  intervention.std_intervention_id = stdqid.stdinterventionid
					     and intervention.gen_intervention_id = stdqid.genInterventionId
						 and intervention.intervention_id = stdqid.interventionId
					     and resp.std_question_id=stdQId.stdQuestionId
						 and stdQId.stdQuestionRank = 1

				 LEFT JOIN dbo.cp_sec_user_audit audit  WITH (NOLOCK)
					 ON	doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id

				WHERE
					  schedule.schedule_type = 8
				  AND schedule.deleted  = 'N'
				  AND intervention.flowsheet  = 'Y'
				  AND intervention.current_row  = 'Y'
				  AND (schedule.retired_date IS NULL  OR schedule.retired_date >= @vfil_ds_schedule_date_tzadj)
				  AND (intervention.resolved_date IS NULL OR intervention.resolved_date >= @vfil_ds_schedule_date_tzadj)
				  and stdQId.stdQuestionId is not null
				  and strike.cp_prn_documentation_history_id is  null
					;

				 INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id ,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)
				select schedule_detail_id ,client_id ,gen_intervention_id,intervention_id ,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type
				 from (
				 	SELECT
				'-1_P_H' as schedule_detail_id,
				intervention.client_id,
				intervention.gen_intervention_id,
				intervention.intervention_id ,
				intervention.std_intervention_id,
				intervention.text1,
				stdQId.stdQuestionId,
				stdQId.stdQuestionContorlType,
				stdQId.stdQuestionText,
				stdQId.sequence,
				stdQId.stdPickListId,
				schedule.fac_id,
				shift.schedule_id AS schedule_id,
				shift.std_shift_id AS std_shift_id,
				stdshift.description,stdshift.start_time,stdshift.end_time,
				CONVERT(DATETIME,NULL) AS shift_date,
				intervention.date_initiated AS schedule_start_date,
				convert(datetime,NULL) AS schedule_end_date,
				convert(datetime,NULL) as schedule_date,
				Null	AS documentation_id	,
				NULL as completed_date,
				NULL as entered_date,
				NULL task_time,
				NULL item_value_id,
				NULL item_value,
				schedule.retired_date,
				 intervention.resolved_date,
			     NULL created_by_longname,
				NULL created_by_position ,
				NULL initials,
				'N'	as strikeout_flag,
				NULL strikeout_id,
				NULL strikeout_description,
				NULL strikeout_by,
				NULL strikeout_date ,
				schedule.schedule_type AS schedule_type

				 FROM   dbo.cp_schedule schedule WITH (NOLOCK)
				   INNER JOIN  #PRP_ds_interventions intervention
					 ON  schedule.intervention_id = intervention.gen_intervention_id
					 and schedule.fac_id= intervention.fac_id

				   INNER JOIN  #PRP_ClientList c on c.client_id=intervention.client_id
				    and  1= case
				              when c.admission_date< intervention.date_initiated and  year(intervention.date_initiated)= year(@vfil_ds_schedule_date)
						     and month(intervention.date_initiated)<= month(@vfil_ds_schedule_date)  then 1
							when c.admission_date< intervention.date_initiated and  year(intervention.date_initiated)< year(@vfil_ds_schedule_date)
						     and month(intervention.date_initiated)>= month(@vfil_ds_schedule_date)  then 1
						    when  c.admission_date> intervention.date_initiated and  month( c.admission_date)<= month(@vfil_ds_schedule_date) then 1 else 0 end
				   INNER JOIN dbo.cp_schedule_shift shift WITH (NOLOCK)
					 ON	 shift.schedule_id = schedule.schedule_id

				  INNER JOIN dbo.cp_std_shift stdshift WITH (NOLOCK)
					 ON shift.std_shift_id = stdshift.std_shift_id

				  left JOIN #stdQuestionIdTable stdQId
				      ON
					 --stdQId.stdquestionid = resp.std_question_id
				       intervention.std_intervention_id = stdqid.stdinterventionid
					     and intervention.gen_intervention_id = stdqid.genInterventionId
						 and intervention.intervention_id = stdqid.interventionId
						 and stdQId.stdQuestionRank = 1

				WHERE
					  schedule.schedule_type = 8
				  AND schedule.deleted  = 'N'
				  AND schedule.fac_id=@vFacId
				  AND schedule.fac_id = intervention.fac_id
				  AND intervention.flowsheet  = 'Y'
				  AND intervention.current_row  = 'Y'
				  AND (schedule.retired_date IS NULL  OR schedule.retired_date >= @vfil_ds_schedule_date_tzadj)
				  AND (intervention.resolved_date IS NULL OR intervention.resolved_date >= @vfil_ds_schedule_date_tzadj)  )tt
				where not exists (select 1 from #cp_documentation_responses b where
				    b.schedule_detail_id=tt.schedule_detail_id and
				    b.client_id= tt.client_id and
				    b.gen_intervention_id = tt.gen_intervention_id and
				    b.intervention_id =tt.intervention_id and
				   b.std_intervention_id	  =tt.std_intervention_id  and
				   b.schedule_id=tt.schedule_id AND
				   b.std_shift_id=tt.std_shift_id AND
				   b.stdQuestionId=	tt.stdQuestionId   )  ;

			 -- StruckOut Info.
			     INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id ,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)
				SELECT
				'-1_P_H' as schedule_detail_id,
				intervention.client_id,
				intervention.gen_intervention_id,
				intervention.intervention_id,
				intervention.std_intervention_id,
				intervention.text1,
				stdQId.stdQuestionId,
				stdQId.stdQuestionContorlType,
				stdQId.stdQuestionText,
				stdQId.sequence,
				stdQId.stdPickListId,
				schedule.fac_id,
				shift.schedule_id AS schedule_id,
				shift.std_shift_id AS std_shift_id,
				stdshift.description,stdshift.start_time,stdshift.end_time,
				CONVERT(DATETIME,NULL) AS shift_date,
				intervention.date_initiated AS schedule_start_date,
				convert(datetime,NULL) AS schedule_end_date,
				doc.effective_date as schedule_date,
				CASE WHEN doc.cp_prn_documentation_history_id IS NULL THEN NULL
					 ELSE CONVERT(VARCHAR,doc.cp_prn_documentation_history_id)+'_P'	END	AS documentation_id	,
				 doc.effective_date  as completed_date,
				 doc.entered_date,
				 doc.task_time,
				 resp.item_value_id,
				 resp.item_value,
				 schedule.retired_date,
				 intervention.resolved_date,
				 audit.long_username AS created_by_longname,
				 audit.position_description AS created_by_position ,
				 audit.initials,
				 'Y' as strikeout_flag,
				strikeaudit.item_id AS strikeout_id,
				strikeaudit.description AS strikeout_description,
				strike_audit.long_username AS strikeout_by,
				strike.entered_date AS strikeout_date ,
				schedule.schedule_type AS schedule_type

				 FROM   dbo.cp_schedule schedule WITH (NOLOCK)
				  INNER JOIN  #PRP_ds_interventions intervention
					 ON  schedule.intervention_id = intervention.gen_intervention_id
					 and schedule.fac_id= intervention.fac_id
					 AND schedule.fac_id=@vFacId

				   INNER JOIN dbo.cp_schedule_shift shift WITH (NOLOCK)
					 ON	 shift.schedule_id = schedule.schedule_id

				  INNER JOIN dbo.cp_std_shift stdshift WITH (NOLOCK)
					 ON shift.std_shift_id = stdshift.std_shift_id

				  INNER JOIN dbo.cp_prn_documentation_history doc WITH (NOLOCK)
					ON	doc.schedule_id = shift.schedule_id
					AND doc.std_shift_id = shift.std_shift_id
					AND ISNULL( doc.effective_date,@vfil_ds_schedule_date) >= @vfil_ds_schedule_date
					AND ISNULL( doc.effective_date,@vfil_ds_schedule_date) <= @vfil_ds_schedule_date2_tzadj

				  INNER JOIN dbo.cp_prn_documentation_strikeout_history strike   WITH (NOLOCK)
					 ON doc.cp_prn_documentation_history_id = strike.cp_prn_documentation_history_id

				  INNER JOIN dbo.cp_strikeout_reason_audit strikeaudit WITH (NOLOCK)
					 ON strikeaudit.cp_strikeout_reason_audit_id = strike.cp_strikeout_reason_audit_id

				  INNER JOIN dbo.cp_prn_response_history resp  WITH (NOLOCK)
					 ON	resp.cp_prn_documentation_history_id = doc.cp_prn_documentation_history_id

				  INNER JOIN #stdQuestionIdTable stdQId
				        on  intervention.std_intervention_id = stdqid.stdinterventionid
					     and intervention.gen_intervention_id = stdqid.genInterventionId
						 and intervention.intervention_id = stdqid.interventionId
					     and resp.std_question_id=stdQId.stdQuestionId
						 and stdQId.stdQuestionRank = 1

				  INNER JOIN dbo.cp_sec_user_audit strike_audit WITH (NOLOCK)
					 ON strike.cp_sec_user_audit_id = strike_audit.cp_sec_user_audit_id

				  INNER JOIN dbo.cp_sec_user_audit audit  WITH (NOLOCK)
					 ON	doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id

				WHERE
					  schedule.schedule_type = 8
				  AND schedule.deleted  = 'N'
				  AND intervention.flowsheet  = 'Y'
				  AND intervention.current_row  = 'Y'
				  AND (schedule.retired_date IS NULL  OR schedule.retired_date >= @vfil_ds_schedule_date_tzadj)
				  AND (intervention.resolved_date IS NULL OR intervention.resolved_date >= @vfil_ds_schedule_date_tzadj)
				  and stdQId.stdQuestionId is not null
				   	;
		END

		IF (@vfil_ds_schedule_date < (SELECT current_history_end_date
									FROM dbo.process_configuration
									WHERE process_name = 'poc_qshift_history_load' ) )
		BEGIN
			IF @debug_me='Y' PRINT 'BEGIN STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' Geting the QShift Historical document responses  at ' + CONVERT(VARCHAR, @step_start_time)

			 --QShift details
			      INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)
				SELECT
				    CONVERT(VARCHAR,detail.cp_qshift_detail_history_id)+'_Q_H' AS schedule_detail_id,
				    rev.client_id,
				    rev.gen_intervention_id,
				    rev.intervention_id,
				    rev.std_intervention_id,
				    rev.text1,
				    case when strike.cp_qshift_documentation_history_id is not null then null else stdQId.stdQuestionId end,
				    case when strike.cp_qshift_documentation_history_id is not null then null else stdQId.stdQuestionContorlType end,
				    case when strike.cp_qshift_documentation_history_id is not null then null else stdQId.stdQuestionText end,
				    case when strike.cp_qshift_documentation_history_id is not null then null else stdQId.sequence end,
				    case when strike.cp_qshift_documentation_history_id is not null then null else stdQId.stdPickListId end,
				    detail.fac_id,
				    detail.schedule_id AS schedule_id,
				    detail.std_shift_id as std_shift_id,
				    stdshift.description,stdshift.start_time,stdshift.end_time,
				    detail.shift_date as shift_date,
				    rev.date_initiated AS schedule_start_date,
				    convert(datetime,NULL) AS schedule_end_date,
				    dates.s_date as schedule_date,
				    case when doc.cp_qshift_documentation_history_id is null THEN  null
				         when strike.cp_qshift_documentation_history_id is not null then null
					    else convert(varchar,doc.cp_qshift_documentation_history_id)+'_Q' end	as documentation_id	,
				    case when strike.cp_qshift_documentation_history_id is not null then null else doc.effective_date end  as completed_date,
				    case when strike.cp_qshift_documentation_history_id is not null then null else doc.entered_date end,
				    case when strike.cp_qshift_documentation_history_id is not null then null else doc.task_time end,
				    case when strike.cp_qshift_documentation_history_id is not null then null else resp.item_value_id end,
				    case when strike.cp_qshift_documentation_history_id is not null then null else resp.item_value end,
				    sched.retired_date,
				    rev.resolved_date,
				    case when strike.cp_qshift_documentation_history_id is not null then null else audit.long_username end as created_by_longname,
				    case when strike.cp_qshift_documentation_history_id is not null then null else audit.position_description end AS created_by_position ,
				    case when strike.cp_qshift_documentation_history_id is not null then null else audit.initials end,
				    'N' as strikeout_flag,
				    Null AS strikeout_id,
				    Null AS strikeout_description,
				    Null AS strikeout_by,
				    Null AS strikeout_date ,
				    sched.schedule_type AS schedule_type
			    from  #PRP_ds_interventions rev
				    INNER JOIN dbo.cp_schedule sched  WITH (NOLOCK)
					ON rev.gen_intervention_id = sched.intervention_id
					and sched.fac_id = rev.fac_id
					and sched.fac_id = @vFacID

					INNER JOIN dbo.cp_qshift_detail_history detail	 WITH (NOLOCK)
					ON sched.schedule_id = detail.schedule_id
						AND sched.fac_id = detail.fac_id						

					INNER JOIN dbo.cp_std_shift stdshift WITH (NOLOCK)
					ON stdshift.std_shift_id = detail.std_shift_id

					 INNER JOIN dbo.view_cp_shift_dates dates WITH (NOLOCK)
					ON	dates.day_date = detail.shift_date
					    AND detail.std_shift_id=dates.std_shift_id
					    AND dates.fac_id=detail.fac_id

					LEFT JOIN #stdQuestionIdTable stdQId
					 on  rev.std_intervention_id = stdqid.stdinterventionid
						    and rev.gen_intervention_id = stdqid.genInterventionId
							and rev.intervention_id = stdqid.interventionId
							and stdQId.stdQuestionRank = 1

				    LEFT JOIN dbo.cp_qshift_documentation_history doc WITH (NOLOCK)
					ON doc.cp_qshift_detail_history_id = detail.cp_qshift_detail_history_id
						AND  doc.effective_date >= @vfil_ds_schedule_date
						AND	 doc.effective_date <= @vfil_ds_schedule_date2_tzadj

				    LEFT JOIN dbo.cp_qshift_documentation_strikeout_history strike  WITH (NOLOCK)
					ON  doc.cp_qshift_documentation_history_id = strike.cp_qshift_documentation_history_id

				    LEFT JOIN dbo.cp_qshift_response_history resp WITH (NOLOCK)
					ON	resp.cp_qshift_documentation_history_id = doc.cp_qshift_documentation_history_id
						and resp.std_question_id=stdQId.stdQuestionId

				    LEFT JOIN dbo.cp_sec_user_audit audit WITH (NOLOCK)
					ON	 doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id

				 WHERE sched.deleted  = 'N'
				    AND (sched.retired_date IS NULL  OR sched.retired_date >= @vfil_ds_schedule_date_tzadj)
				    AND (rev.resolved_date IS NULL OR rev.resolved_date >= @vfil_ds_schedule_date_tzadj)
					AND (ISNULL(doc.effective_date, detail.shift_date) >= @vfil_ds_schedule_date and ISNULL(doc.effective_date, detail.shift_date) < @vfil_ds_schedule_date2_tzadj_plus1)
					;
			    -- StruckOut Info.
				 INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)
				SELECT
				    CONVERT(VARCHAR,detail.cp_qshift_detail_history_id)+'_Q_H' AS schedule_detail_id,
				    rev.client_id,
				    rev.gen_intervention_id,
				    rev.intervention_id,
				    rev.std_intervention_id,
				    rev.text1,
				    stdQId.stdQuestionId,
				    stdQId.stdQuestionContorlType,
				    stdQId.stdQuestionText,
				    stdQId.sequence,
				    stdQId.stdPickListId,
				    detail.fac_id,
				    detail.schedule_id AS schedule_id,
				    detail.std_shift_id as std_shift_id,
				    stdshift.description,stdshift.start_time,stdshift.end_time,
				    detail.shift_date as shift_date,
				    rev.date_initiated AS schedule_start_date,
				    convert(datetime,NULL) AS schedule_end_date,
				    dates.s_date as schedule_date,
				    case when doc.cp_qshift_documentation_history_id is null THEN  null
					    else convert(varchar,doc.cp_qshift_documentation_history_id)+'_Q' end	as documentation_id	,
				    doc.effective_date as completed_date,
				    doc.entered_date,
				    doc.task_time,
				    resp.item_value_id,
				    resp.item_value,
				    sched.retired_date,
				    rev.resolved_date,
				    audit.long_username as created_by_longname,
				    audit.position_description AS created_by_position ,
				    audit.initials,
				    'Y'as strikeout_flag,
				    strikeaudit.item_id AS strikeout_id,
				    strikeaudit.description AS strikeout_description,
				    strike_audit.long_username AS strikeout_by,
				    strike.entered_date AS strikeout_date ,
				    sched.schedule_type AS schedule_type
			    from  dbo.cp_schedule sched  WITH (NOLOCK)
				    INNER JOIN #PRP_ds_interventions rev
					ON rev.gen_intervention_id = sched.intervention_id
					and sched.fac_id = rev.fac_id
					and rev.fac_id = @vFacID

					INNER JOIN dbo.cp_qshift_detail_history detail	 WITH (NOLOCK)
							ON sched.schedule_id = detail.schedule_id
								and sched.fac_id = detail.fac_id								

					INNER JOIN dbo.cp_std_shift stdshift WITH (NOLOCK)
					ON stdshift.std_shift_id = detail.std_shift_id

				    INNER JOIN dbo.cp_qshift_documentation_history doc WITH (NOLOCK)
					ON doc.cp_qshift_detail_history_id = detail.cp_qshift_detail_history_id
						and  (doc.effective_date >= @vfil_ds_schedule_date and @vfil_ds_schedule_date_tzadj <= @vfil_ds_schedule_date2_tzadj)

				    inner JOIN dbo.cp_qshift_documentation_strikeout_history strike WITH (NOLOCK)
					ON  doc.cp_qshift_documentation_history_id = strike.cp_qshift_documentation_history_id

				    inner JOIN dbo.cp_strikeout_reason_audit strikeaudit WITH (NOLOCK)
					ON strikeaudit.cp_strikeout_reason_audit_id = strike.cp_strikeout_reason_audit_id

				    inner JOIN dbo.cp_sec_user_audit strike_audit WITH (NOLOCK)
					ON strike.cp_sec_user_audit_id = strike_audit.cp_sec_user_audit_id

				    INNER JOIN dbo.cp_qshift_response_history resp WITH (NOLOCK)
					ON	resp.cp_qshift_documentation_history_id = doc.cp_qshift_documentation_history_id

					INNER JOIN dbo.view_cp_shift_dates dates WITH (NOLOCK)
										ON	dates.day_date = detail.shift_date
											AND detail.std_shift_id=dates.std_shift_id
											AND dates.fac_id=detail.fac_id

					INNER JOIN dbo.cp_sec_user_audit audit WITH (NOLOCK)
					ON	 doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id

				    LEFT JOIN #stdQuestionIdTable stdQId
					 on  rev.std_intervention_id = stdqid.stdinterventionid
						    and rev.gen_intervention_id = stdqid.genInterventionId
							and rev.intervention_id = stdqid.interventionId
							and resp.std_question_id=stdQId.stdQuestionId
							and stdQId.stdQuestionRank = 1


				 WHERE sched.deleted  = 'N'
				    AND (sched.retired_date IS NULL  OR sched.retired_date >= @vfil_ds_schedule_date_tzadj)
				    AND (rev.resolved_date IS NULL OR rev.resolved_date >= @vfil_ds_schedule_date_tzadj)
					AND (ISNULL(doc.effective_date, detail.shift_date) >= @vfil_ds_schedule_date and ISNULL(doc.effective_date, detail.shift_date) < @vfil_ds_schedule_date2_tzadj_plus1)
					;
		END

		IF (@vfil_ds_schedule_date < (SELECT current_history_end_date
									FROM dbo.process_configuration
									WHERE process_name = 'poc_scheduled_history_load' ) )
		BEGIN
			IF @debug_me='Y' PRINT 'BEGIN STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' Geting the Scheduled Historical document responses  at ' + CONVERT(VARCHAR, @step_start_time)

			  -- Scheduled details
			      INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)

			 SELECT
			   CONVERT(VARCHAR,detail.cp_scheduled_detail_history_id)+'_S_H' AS schedule_detail_id,
				rev.client_id,
				rev.gen_intervention_id,
				rev.intervention_id,
				rev.std_intervention_id,
				rev.text1,
				stdQId.stdQuestionId,
				stdQId.stdQuestionContorlType,
				stdQId.stdQuestionText,
				stdQId.sequence,
			     stdQId.stdPickListId,
				detail.fac_id,
				detail.schedule_id AS schedule_id,
				NULL AS std_shift_id,
				NULL description,
				NULL start_time,
				NULL end_time,
				CONVERT(DATETIME,NULL) AS shift_date,
				rev.date_initiated AS schedule_start_date,
				CONVERT(DATETIME,NULL) AS schedule_end_date,
				detail.schedule_date as schedule_date,
				CASE WHEN doc.cp_scheduled_documentation_history_id IS NULL THEN NULL
				 when strike.cp_scheduled_documentation_history_id is not null then null
					 ELSE convert(varchar,doc.cp_scheduled_documentation_history_id)+'_S'
				 END AS documentation_id,
				case when strike.cp_scheduled_documentation_history_id is not null then null else doc.effective_date end as completed_date,
				case when strike.cp_scheduled_documentation_history_id is not null then null else doc.entered_date end,
				case when strike.cp_scheduled_documentation_history_id is not null then null else doc.task_time end,
				case when strike.cp_scheduled_documentation_history_id is not null then null else resp.item_value_id end,
				case when strike.cp_scheduled_documentation_history_id is not null then null else resp.item_value end,
				sched.retired_date,
				rev.resolved_date,
				case when strike.cp_scheduled_documentation_history_id is not null then null else audit.long_username  end as created_by_longname,
				case when strike.cp_scheduled_documentation_history_id is not null then null else audit.position_description end AS created_by_position ,
				case when strike.cp_scheduled_documentation_history_id is not null then null else audit.initials end,
				'N' as strikeout_flag,
				Null AS strikeout_id,
				Null AS strikeout_description,
				Null AS strikeout_by,
				Null AS strikeout_date ,
				sched.schedule_type AS schedule_type

			 FROM dbo.cp_schedule sched  WITH (NOLOCK)
				INNER JOIN #PRP_ds_interventions rev
				 ON rev.gen_intervention_id = sched.intervention_id
				 and sched.fac_id = rev.fac_id

				LEFT JOIN dbo.cp_scheduled_detail_history detail	 WITH (NOLOCK)
				 ON sched.schedule_id = detail.schedule_id
					and sched.fac_id = detail.fac_id

				LEFT JOIN dbo.cp_scheduled_documentation_history doc WITH (NOLOCK)
				 ON doc.cp_scheduled_detail_history_id = detail.cp_scheduled_detail_history_id
				  AND  ISNULL( doc.effective_date,@vfil_ds_schedule_date) >= @vfil_ds_schedule_date AND
					  ISNULL( doc.effective_date,@vfil_ds_schedule_date2) <= @vfil_ds_schedule_date2_tzadj

				LEFT JOIN dbo.cp_scheduled_documentation_strikeout_history strike  WITH (NOLOCK)
				  ON  doc.cp_scheduled_documentation_history_id = strike.cp_scheduled_documentation_history_id

				LEFT JOIN dbo.cp_scheduled_response_history resp WITH (NOLOCK)
				 ON	 resp.cp_scheduled_documentation_history_id = doc.cp_scheduled_documentation_history_id

				left JOIN #stdQuestionIdTable stdQId WITH (NOLOCK)
				  on  rev.std_intervention_id = stdqid.stdinterventionid
					     and rev.gen_intervention_id = stdqid.genInterventionId
						 and rev.intervention_id = stdqid.interventionId
						 and  resp.std_question_id=stdQId.stdQuestionId
						 and stdQId.stdQuestionRank = 1

				LEFT JOIN dbo.cp_sec_user_audit audit WITH (NOLOCK)
				 ON	 doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id
				where
				sched.fac_id=@vFacId
				AND sched.deleted = 'N'
					  AND (sched.retired_date IS NULL  OR sched.retired_date >= @vfil_ds_schedule_date_tzadj)
					  AND (rev.resolved_date IS NULL OR rev.resolved_date >= @vfil_ds_schedule_date_tzadj)
					  AND (detail.schedule_date >= @vfil_ds_schedule_date and detail.schedule_date <= @vfil_ds_schedule_date2_tzadj_plus1)

					;
			  -- StruckOut Info.
				 INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)

			 SELECT
			   CONVERT(VARCHAR,detail.cp_scheduled_detail_history_id)+'_S_H' AS schedule_detail_id,
				rev.client_id,
				rev.gen_intervention_id,
				rev.intervention_id,
				rev.std_intervention_id,
				rev.text1,
				stdQId.stdQuestionId,
				stdQId.stdQuestionContorlType,
				stdQId.stdQuestionText,
				stdQId.sequence,
			     stdQId.stdPickListId,
				detail.fac_id,
				detail.schedule_id AS schedule_id,
				NULL AS std_shift_id,
				NULL description,
				NULL start_time,
				NULL end_time,
				CONVERT(DATETIME,NULL) AS shift_date,
				rev.date_initiated AS schedule_start_date,
				CONVERT(DATETIME,NULL) AS schedule_end_date,
				detail.schedule_date as schedule_date,
				CASE WHEN doc.cp_scheduled_documentation_history_id IS NULL THEN NULL
					 ELSE convert(varchar,doc.cp_scheduled_documentation_history_id)+'_S'
				 END AS documentation_id,
				doc.effective_date as completed_date,
				doc.entered_date,
				doc.task_time,
				resp.item_value_id,
				resp.item_value,
				sched.retired_date,
				rev.resolved_date,
				audit.long_username as created_by_longname,
				audit.position_description AS created_by_position ,
					audit.initials,
				'Y'  strikeout_flag,
				strikeaudit.item_id AS strikeout_id,
				strikeaudit.description AS strikeout_description,
				strike_audit.long_username AS strikeout_by,
				strike.entered_date AS strikeout_date ,
				sched.schedule_type AS schedule_type

			 FROM dbo.cp_schedule sched  WITH (NOLOCK)
				INNER JOIN #PRP_ds_interventions rev
				 ON rev.gen_intervention_id = sched.intervention_id
				 and sched.fac_id = rev.fac_id

				INNER JOIN dbo.cp_scheduled_detail_history detail	 WITH (NOLOCK)
				 ON sched.schedule_id = detail.schedule_id
				 and sched.fac_id = rev.fac_id

				INNER JOIN dbo.cp_scheduled_documentation_history doc WITH (NOLOCK)
				 ON doc.cp_scheduled_detail_history_id = detail.cp_scheduled_detail_history_id
				  AND  ISNULL(doc.effective_date,@vfil_ds_schedule_date) >= @vfil_ds_schedule_date AND
					  ISNULL( doc.effective_date,@vfil_ds_schedule_date2) <= @vfil_ds_schedule_date2_tzadj

				INNER JOIN dbo.cp_scheduled_documentation_strikeout_history strike WITH (NOLOCK)
				 ON doc.cp_scheduled_documentation_history_id = strike.cp_scheduled_documentation_history_id

				INNER JOIN dbo.cp_strikeout_reason_audit strikeaudit WITH (NOLOCK)
				 ON strikeaudit.cp_strikeout_reason_audit_id = strike.cp_strikeout_reason_audit_id

				INNER JOIN dbo.cp_sec_user_audit strike_audit WITH (NOLOCK)
				 ON strike.cp_sec_user_audit_id = strike_audit.cp_sec_user_audit_id

				INNER JOIN dbo.cp_scheduled_response_history resp WITH (NOLOCK)
				 ON	 resp.cp_scheduled_documentation_history_id = doc.cp_scheduled_documentation_history_id

				INNER JOIN #stdQuestionIdTable stdQId WITH (NOLOCK)
				  on  rev.std_intervention_id = stdqid.stdinterventionid
					     and rev.gen_intervention_id = stdqid.genInterventionId
						 and rev.intervention_id = stdqid.interventionId
						 and  resp.std_question_id=stdQId.stdQuestionId
						 and stdQId.stdQuestionRank = 1

				LEFT JOIN dbo.cp_sec_user_audit audit WITH (NOLOCK)
				 ON	 doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id
				where
				detail.fac_id=@vFacId
				AND sched.deleted   = 'N'
					  AND (sched.retired_date IS NULL  OR sched.retired_date >= @vfil_ds_schedule_date_tzadj)
					  AND (rev.resolved_date IS NULL OR rev.resolved_date >= @vfil_ds_schedule_date_tzadj)
					  AND (detail.schedule_date >= @vfil_ds_schedule_date and detail.schedule_date <= @vfil_ds_schedule_date2_tzadj_plus1) ;
		END

		IF (@vfil_ds_schedule_date < (SELECT current_history_end_date
									FROM dbo.process_configuration
									WHERE process_name = 'poc_duration_history_load' ) )
		BEGIN
			IF @debug_me='Y' PRINT 'BEGIN STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' Geting the Duration Historical document responses  at ' + CONVERT(VARCHAR, @step_start_time)


		--Schedule Duration
			      INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)
			 SELECT
			   CONVERT(VARCHAR,detail.cp_duration_detail_history_id)+'_D_H' AS schedule_detail_id,
				rev.client_id,
				rev.gen_intervention_id,
				rev.intervention_id,
				rev.std_intervention_id,
				rev.text1,
				stdQId.stdQuestionId,
				stdQId.stdQuestionContorlType,
				stdQId.stdQuestionText,
				stdQId.sequence,
				stdQId.stdPickListId,
				detail.fac_id,
				detail.schedule_id as schedule_id,
				NULL AS std_shift_id,
				NULL description,NULL start_time,NULL end_time,
				CONVERT(DATETIME,NULL) AS shift_date,
				rev.date_initiated AS schedule_start_date,
				detail.schedule_end_date AS schedule_end_date,
				detail.schedule_start_date AS schedule_date,
				 CASE WHEN doc.cp_duration_detail_history_id IS NULL THEN NULL
				  when strike.cp_duration_documentation_history_id is not null then null
					ELSE convert(varchar,doc.cp_duration_detail_history_id)+'_D'
				 END AS documentation_id,
				case when strike.cp_duration_documentation_history_id is not null then null else doc.effective_date end AS completed_date,
				case when strike.cp_duration_documentation_history_id is not null then null else doc.entered_date end,
				case when strike.cp_duration_documentation_history_id is not null then null else doc.task_time end,
				case when strike.cp_duration_documentation_history_id is not null then null else resp.item_value_id end,
				case when strike.cp_duration_documentation_history_id is not null then null else resp.item_value end,
				sched.retired_date,
				rev.resolved_date,
				case when strike.cp_duration_documentation_history_id is not null then null else audit.long_username end AS created_by_longname,
				case when strike.cp_duration_documentation_history_id is not null then null else audit.position_description end AS created_by_position ,
				case when strike.cp_duration_documentation_history_id is not null then null else audit.initials end,
				'N'	AS strikeout_flag,
				NULL AS strikeout_id,
				NULL AS strikeout_description,
				NULL AS strikeout_by,
				NULL AS strikeout_date ,
				sched.schedule_type AS schedule_type
			 FROM dbo.cp_schedule sched  WITH (NOLOCK)
				INNER JOIN #PRP_ds_interventions rev
				 ON rev.gen_intervention_id = sched.intervention_id
					and sched.fac_id = rev.fac_id

				LEFT JOIN dbo.cp_duration_detail_history detail	 WITH (NOLOCK)
				 ON sched.schedule_id = detail.schedule_id
				 and sched.fac_id = detail.fac_id

				LEFT JOIN dbo.cp_duration_documentation_history doc WITH (NOLOCK)
				 ON doc.cp_duration_detail_history_id = detail.cp_duration_detail_history_id
				  AND ISNULL( doc.effective_date,@vfil_ds_schedule_date) >= @vfil_ds_schedule_date AND
					 ISNULL( doc.effective_date,@vfil_ds_schedule_date2) <= @vfil_ds_schedule_date2_tzadj

				LEFT JOIN dbo.cp_duration_documentation_strikeout_history strike WITH (NOLOCK)
				 on doc.cp_duration_documentation_history_id = strike.cp_duration_documentation_history_id

				LEFT JOIN dbo.cp_duration_response_history resp WITH (NOLOCK)
				 ON	 resp.cp_duration_documentation_history_id = doc.cp_duration_documentation_history_id

				LEFT JOIN #stdQuestionIdTable stdQId WITH (NOLOCK)
				 on  rev.std_intervention_id = stdqid.stdinterventionid
					     and rev.gen_intervention_id = stdqid.genInterventionId
						 and rev.intervention_id = stdqid.interventionId
				         and  resp.std_question_id=stdQId.stdQuestionId
						 and stdQId.stdQuestionRank = 1

				LEFT JOIN dbo.cp_sec_user_audit audit WITH (NOLOCK)
					on doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id
				where
				detail.fac_id=@vFacId
					 AND sched.deleted  = 'N'
					  AND (sched.retired_date IS NULL  OR sched.retired_date >= @vfil_ds_schedule_date_tzadj)
					  AND (rev.resolved_date IS NULL OR rev.resolved_date >= @vfil_ds_schedule_date_tzadj)
					   and not EXISTS(select 1 from dbo.cp_duration_documentation_strikeout_history strike WITH (NOLOCK)
				 where doc.cp_duration_documentation_history_id = strike.cp_duration_documentation_history_id);
				  ;
			--StruckOut Info.
			      INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)
			 SELECT
			   CONVERT(VARCHAR,detail.cp_duration_detail_history_id)+'_DH' AS schedule_detail_id,
				rev.client_id,
				rev.gen_intervention_id,
				rev.intervention_id,
				rev.std_intervention_id,
				rev.text1,
				stdQId.stdQuestionId,
				stdQId.stdQuestionContorlType,
				stdQId.stdQuestionText,
				stdQId.sequence,
				stdQId.stdPickListId,
				detail.fac_id,
				detail.schedule_id as schedule_id,
				NULL AS std_shift_id,
				NULL description,NULL start_time,NULL end_time,
				CONVERT(DATETIME,NULL) AS shift_date,
				rev.date_initiated AS schedule_start_date,
				detail.schedule_end_date AS schedule_end_date,
				detail.schedule_start_date AS schedule_date,
				 CASE WHEN doc.cp_duration_documentation_history_id IS NULL THEN NULL
					ELSE convert(varchar,doc.cp_duration_documentation_history_id)+'_D'
				 END AS documentation_id,
				doc.effective_date AS completed_date,
				doc.entered_date,
				doc.task_time,
				resp.item_value_id,
				resp.item_value,
				sched.retired_date,
				rev.resolved_date,
				audit.long_username AS created_by_longname,
				audit.position_description AS created_by_position ,
				audit.initials,
				'Y' strikeout_flag,
				strikeaudit.item_id AS strikeout_id,
				strikeaudit.description AS strikeout_description,
				strike_audit.long_username AS strikeout_by,
				strike.entered_date AS strikeout_date ,
				sched.schedule_type AS schedule_type
			 FROM dbo.cp_schedule sched  WITH (NOLOCK)
				INNER JOIN #PRP_ds_interventions rev
				 ON rev.gen_intervention_id = sched.intervention_id
					and sched.fac_id = rev.fac_id

				LEFT JOIN dbo.cp_duration_detail_history detail	 WITH (NOLOCK)
				 ON sched.schedule_id = detail.schedule_id
					and sched.fac_id = detail.fac_id

				LEFT JOIN dbo.cp_duration_documentation_history doc WITH (NOLOCK)
				 ON doc.cp_duration_detail_history_id = detail.cp_duration_detail_history_id
				  AND ISNULL( doc.effective_date,@vfil_ds_schedule_date) >= @vfil_ds_schedule_date AND
					 ISNULL( doc.effective_date,@vfil_ds_schedule_date2) <= @vfil_ds_schedule_date2_tzadj

				INNER JOIN dbo.cp_duration_documentation_strikeout_history strike WITH (NOLOCK)
				 ON doc.cp_duration_documentation_history_id = strike.cp_duration_documentation_history_id

				INNER JOIN dbo.cp_strikeout_reason_audit strikeaudit WITH (NOLOCK)
				 ON strikeaudit.cp_strikeout_reason_audit_id = strike.cp_strikeout_reason_audit_id

				INNER JOIN dbo.cp_sec_user_audit strike_audit WITH (NOLOCK)
				 ON strike.cp_sec_user_audit_id = strike_audit.cp_sec_user_audit_id

				LEFT JOIN dbo.cp_duration_response_history resp WITH (NOLOCK)
				 ON	 resp.cp_duration_documentation_history_id = doc.cp_duration_documentation_history_id

				LEFT JOIN #stdQuestionIdTable stdQId WITH (NOLOCK)
				 on  rev.std_intervention_id = stdqid.stdinterventionid
					     and rev.gen_intervention_id = stdqid.genInterventionId
						 and rev.intervention_id = stdqid.interventionId
				         and  resp.std_question_id=stdQId.stdQuestionId
						 and stdQId.stdQuestionRank = 1

				LEFT JOIN dbo.cp_sec_user_audit audit WITH (NOLOCK)
					on doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id
				where
				detail.fac_id=@vFacId
					 AND sched.deleted  = 'N'
					  AND (sched.retired_date IS NULL  OR sched.retired_date >= @vfil_ds_schedule_date_tzadj)
					  AND (rev.resolved_date IS NULL OR rev.resolved_date >= @vfil_ds_schedule_date_tzadj) ;
			--Unscheduled Calculation
			IF (SELECT value FROM configuration_parameter WHERE name='enable_unscheduled_tasks'  and fac_id=@vFacId)='Y'
			BEGIN
			 INSERT INTO #cp_documentation_responses(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type)
			 SELECT	distinct
			   '-1_U_H' AS schedule_detail_id,
				rev.client_id,
				rev.gen_intervention_id,
				rev.intervention_id,
				rev.std_intervention_id,
				rev.text1,
				stdQId.stdQuestionId,
				stdQId.stdQuestionContorlType,
				stdQId.stdQuestionText,
				stdQId.sequence,
				stdQId.stdPickListId,
				sched.fac_id,
				sched.schedule_id AS schedule_id,
				NULL as std_shift_id,
				NULL description,NULL start_time,NULL end_time,
				CONVERT(DATETIME,NULL) AS shift_date,
				rev.date_initiated AS schedule_start_date ,
				CONVERT(DATETIME,NULL) AS schedule_end_date,
				doc.effective_date as schedule_date,
				 CASE WHEN doc.cp_unscheduled_documentation_history_id IS NULL THEN NULL
					  ELSE convert(varchar,doc.cp_unscheduled_documentation_history_id)+'_U'
				 END AS documentation_id,
				doc.effective_date as completed_date,
				doc.entered_date,
				doc.task_time,
				resp.item_value_id,
				resp.item_value,
				sched.retired_date,
				rev.resolved_date,
				audit.long_username AS created_by_longname,
				audit.position_description AS created_by_position ,
				audit.initials,
				CASE
					WHEN (strike.cp_strikeout_reason_audit_id IS NOT NULL) THEN
						'Y'
					ELSE
						'N'
				END	as strikeout_flag,
				strikeaudit.item_id AS strikeout_id,
				strikeaudit.description AS strikeout_description,
				strike_audit.long_username AS strikeout_by,
				strike.entered_date AS strikeout_date  ,
				sched.schedule_type
			 FROM dbo.cp_schedule sched  WITH (NOLOCK)
				INNER JOIN #PRP_ds_interventions rev
				 ON rev.gen_intervention_id = sched.intervention_id
				 and sched.fac_id = rev.fac_id

				LEFT JOIN dbo.cp_unscheduled_documentation_history doc WITH (NOLOCK)
				 ON doc.schedule_id = sched.schedule_id
				    AND
					  ISNULL(doc.effective_date,@vfil_ds_schedule_date) >= @vfil_ds_schedule_date AND
					  ISNULL( doc.effective_date,@vfil_ds_schedule_date2) <= @vfil_ds_schedule_date2_tzadj

				LEFT JOIN dbo.cp_unscheduled_documentation_strikeout_history strike WITH (NOLOCK)
				 ON doc.cp_unscheduled_documentation_history_id = strike.cp_unscheduled_documentation_history_id

				LEFT JOIN dbo.cp_strikeout_reason_audit strikeaudit WITH (NOLOCK)
				 ON strikeaudit.cp_strikeout_reason_audit_id = strike.cp_strikeout_reason_audit_id

				LEFT JOIN dbo.cp_sec_user_audit strike_audit WITH (NOLOCK)
				 ON strike.cp_sec_user_audit_id = strike_audit.cp_sec_user_audit_id

				LEFT JOIN dbo.cp_unscheduled_response_history resp WITH (NOLOCK)
				 ON	 resp.cp_unscheduled_documentation_history_id = doc.cp_unscheduled_documentation_history_id

				 left JOIN #stdQuestionIdTable stdQId WITH (NOLOCK)
				  on  rev.std_intervention_id = stdqid.stdinterventionid
					     and rev.gen_intervention_id = stdqid.genInterventionId
						 and rev.intervention_id = stdqid.interventionId
				         and  resp.std_question_id=stdQId.stdQuestionId
						 and stdQId.stdQuestionRank = 1

				LEFT JOIN dbo.cp_sec_user_audit audit WITH (NOLOCK)
					on doc.cp_sec_user_audit_id = audit.cp_sec_user_audit_id
				where sched.schedule_Type = 40 AND
					  sched.fac_id=@vFacId
					  AND (sched.retired_date IS NULL  OR sched.retired_date >= @vfil_ds_schedule_date_tzadj);
			END
	if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'
	if @debug_me = 'Y'
	  select '#cp_documentation_responses_historical' as stdFinalPickListTable, * from #cp_documentation_responses a  order by 1

	END

       SELECT @vStep = 20, @step_start_time = getdate()
		IF @debug_me='Y' PRINT 'BEGIN STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' Timezone and shift name adjustment at ' + CONVERT(VARCHAR, @step_start_time)


  -- DAY LIGHT SAVING DATE
      UPDATE a
       SET schedule_date=CASE
                             WHEN dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_date) >= @vdaylightStart and schedule_date <= @vdaylightStart

                             THEN dateadd(hh,+1, schedule_date)

                             WHEN dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_date) >=  @vdaylightEnd and schedule_date <= @vdaylightend
                             THEN dateadd(hh,-1, schedule_date)
							 else schedule_date

                         END,
           completed_date=CASE
                             WHEN dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,completed_date) >= @vdaylightStart and completed_date <= @vdaylightStart

                             THEN dateadd(hh,+1, completed_date)

                             WHEN dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,completed_date) >=  @vdaylightEnd and completed_date <= @vdaylightend
                             THEN dateadd(hh,-1, completed_date)
							 else completed_date

                         END,
	      schedule_start_date=CASE
                             WHEN dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_start_date) >= @vdaylightStart and schedule_start_date <= @vdaylightStart

                             THEN dateadd(hh,+1, schedule_start_date)

                             WHEN dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_start_date) >=  @vdaylightEnd and schedule_start_date <= @vdaylightend
                             THEN dateadd(hh,-1, schedule_start_date)
							 else schedule_start_date


                         END
    FROM #cp_documentation_responses a
    WHERE @vAdjtoDST = 'Y'
		and (month(completed_date) = month(@vdaylightStart)
			or month(schedule_date) = month(@vdaylightStart)
			or month(completed_date) = month(@vdaylightEnd)
			or month(schedule_date) = month(@vdaylightEnd)
			)


      UPDATE #cp_documentation_responses
       SET schedule_time=   REPLACE(CONVERT( VARCHAR(5), dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, schedule_date), 108), ':', '');

      if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'

      SELECT @vStep = 21, @step_start_time = getdate()
	 IF @debug_me='Y' PRINT 'BEGIN STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' Getting POC Document base of Timezone  description  at ' + CONVERT(VARCHAR, @step_start_time)

	   -- Update short codes accerding to POC generatl configuration

	   INSERT INTO @pocShortCodesConfig([default_value_id], [name], [value], [effective_date], [ineffective_date])
	   SELECT
			 CASE   WHEN name = 'short_code_not_applicable' THEN '-97'
				    WHEN name = 'short_code_resident_refused' THEN '-98'
				    WHEN name = 'short_code_resident_not_available' THEN '-99'
			 END AS [default_value_id],
			 [name], RTRIM(LTRIM([value])), [effective_date], [ineffective_date]
	   FROM  @pocGeneralConfig
	   WHERE name IN ('short_code_not_applicable','short_code_resident_not_available','short_code_resident_refused')

	   if @debug_me = 'y' SELECT '@pocShortCodesConfig' pocShortCodesConfig,* from @pocShortCodesConfig

	   -- Short codes updated according to POC General Configuration
	   UPDATE r
	   SET r.[item_value_id] = ISNULL(NULLIF(RTRIM(LTRIM(c.[value])), ''), r.[item_value_id])
	   FROM #cp_documentation_responses r
		  INNER JOIN @pocShortCodesConfig c
		  ON r.item_value_id = c.[default_value_id] AND (dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, r.completed_date) BETWEEN [effective_date] AND [ineffective_date])
		  AND r.item_value_id <> '-901'

	   -- Update for Multiselect
	   UPDATE r
	   SET r.[item_value_id] =  dbo.fn_poc_get_Multiselect_DocumentCodeAsString(item_value, stdQuestionId, c1.value, c2.value, c3.value)
	   FROM #cp_documentation_responses r
		  INNER JOIN @pocShortCodesConfig c1
		  ON (dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, r.completed_date) BETWEEN c1.[effective_date] AND c1.[ineffective_date]) AND c1.default_value_id = '-99'
		  INNER JOIN @pocShortCodesConfig c2
		  ON (dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, r.completed_date) BETWEEN c2.[effective_date] AND c2.[ineffective_date]) AND c2.default_value_id = '-98'
		  INNER JOIN @pocShortCodesConfig c3
		  ON (dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, r.completed_date) BETWEEN c3.[effective_date] AND c3.[ineffective_date]) AND c3.default_value_id = '-97'
		  where r.item_value_id = '-901'

	if @debug_me = 'y'
		select 'responses after mlt update', * from #cp_documentation_responses

	-- needed to map the scheduled time with corresponding shifts
	delete from #prp_shift_link
	where shift_id not in (select distinct std_shift_id from #cp_documentation_responses where schedule_date >= @vfil_ds_schedule_date and std_shift_id is not null);



	insert into  #prp_shifts(shift_id,
                        shift_name,
                        start_time,
                        end_time,
                        group_name,
                        position_id,
                        flg)

 SELECT DISTINCT sh.shift_id,
                       sh.shift_name,
                       sh.start_time,
                       2400-1,
                       '',
                       NULL,
                       0
					   from #prp_shift_link sh
			where (CONVERT(INT, sh.end_time)-CONVERT(INT, sh.start_time))<0
			and not exists (select 1 from #prp_shifts b where b.shift_id = sh.shift_id and b.flg = 0);

insert into  #prp_shifts(shift_id,
                        shift_name,
                        start_time,
                        end_time,
                        group_name,
                        position_id,
                        flg)
 SELECT DISTINCT sh.shift_id,
                       sh.shift_name,
                       '0',
                       sh.end_time-1,
                       '',
                       NULL,
                       1
 from #prp_shift_link sh
 where CONVERT(INT, sh.end_time)-CONVERT(INT, sh.start_time)<0
 and not exists (select 1 from #prp_shifts b where b.shift_id = sh.shift_id and b.flg = 1);

 insert into  #prp_shifts(shift_id,
                        shift_name,
                        start_time,
                        end_time,
                        group_name,
                        position_id,
                        flg)
 SELECT DISTINCT sh.shift_id,
                       sh.shift_name,
                       sh.start_time,
                       sh.end_time-1,
                       '',
                       NULL,
                       0
 from #prp_shift_link sh
 where  not exists (select 1 from #prp_shifts b where b.shift_id = sh.shift_id and b.flg = 0);


	 if @debug_me = 'Y'  select '#cp_documentation_responses' cp_documentation_responses,* from #cp_documentation_responses --where std_shift_id in (354,355,356) ;

		    --   Qshift

	    INSERT INTO #pocData(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,
				schedule_type,flag,schedule_time,short_code )

		 select  schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,a.stdQuestionId ,stdQuestionContorlType,stdQuestionText,a.sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,
		  CASE
			  WHEN ( [shift].end_time - [shift].start_time ) < 0
				  AND ( replace(convert(varchar(5),dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacId ,schedule_date),108),':','')>= [shift].start_time
					    OR replace(convert(varchar(5),dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacId ,schedule_date),108),':','') <= [shift].end_time ) THEN
			  [shift].shift_name
			  WHEN ( shift.end_time - [shift].start_time ) > 0
				  AND ( replace(convert(varchar(5),dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacId ,schedule_date),108),':','') >= [shift].start_time
					   AND replace(convert(varchar(5),dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacId ,schedule_date),108),':','') <= [shift].end_time ) THEN
			  [shift].shift_name
			END                                                AS Shift1,
			a.start_time ,a.end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time,
				case
				  when stdQuestionContorlType in ('bls',  'os2', 'het','num','tmp','pls','wgt') and isnumeric(a.item_value)=1 and isnull(a.item_value,'') not in ('<RNA/>','<NA/>','<RR/>') then a.item_value
				  when stdQuestionContorlType in ( 'rsp', 'sgn')   then a.item_value
				  when stdQuestionContorlType='bpr' and isnumeric(a.item_value)=1 then a.item_value+'/'+cast( item_value_id as varchar(max))
					else cast( item_value_id as varchar(max))
				end item_value_id
				, a.item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type  ,
				case Substring(a.schedule_detail_id,Charindex('_', a.schedule_detail_id) + 1,1)
				 when 'Q' then 'Qshift'
				 when 'P' then 'PRN'
				 when 'S' then 'Schedule'
				 when 'U' then 'Unscheduled'
				 when 'D' then 'Duration' end
				 ,schedule_time
				 , vpl.short_code
		  from #cp_documentation_responses a
		   INNER JOIN dbo.#prp_shift_link [shift]
				   ON a.std_shift_id = [shift].shift_id
			left outer join #vprpPickList vpl
					on a.stdPickListId = vpl.std_pick_list_id
					and a.gen_intervention_id = vpl.genInterventionId
					and a.stdQuestionId  = vpl.stdQuestionId
					and a.item_value_id = vpl.item_value
					and (a.schedule_date >= vpl.effective_date and a.schedule_date < vpl.ineffective_date)

		 where a.schedule_type <>40 and schedule_type<>8  -- No PRN and UnSchedule
		 and schedule_date is not null
		 and schedule_date>= DATEADD(DD, -1, @vfil_ds_schedule_date)
		 and schedule_date<DATEADD(DD, 1, @vfil_ds_schedule_date2) ;



		 -- schedule time
	    INSERT INTO #pocData(
				    schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				    stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				    documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				    created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,
				    schedule_type,flag,schedule_time, short_code)

			select

			schedule_detail_id ,cpsd.client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,cpsd.stdQuestionId ,stdQuestionContorlType,stdQuestionText,cpsd.sequence,
				    stdPickListId,cpsd.fac_id , schedule_id ,
		  Cast(shift.shift_id AS VARCHAR) + '-'
		 + Cast(shift.flg AS VARCHAR)                       shift_id,

		   shift.shift_name  ,
		-- END                                                AS Shift,

		cpsd.start_time ,cpsd.end_time,shift_date,schedule_start_date,
		  case when Substring(cpsd.schedule_detail_id,Charindex('_', cpsd.schedule_detail_id) + 1,1) = 'p' THEN
		    case when resolved_date is not null and  retired_date is null then resolved_date
		  	    when resolved_date is null and  retired_date is not null then retired_date
			    when resolved_date is not null	and  retired_date is not null and 	resolved_date<=retired_date then resolved_date
			    when resolved_date is not null	and  retired_date is not null and 	resolved_date>=retired_date then retired_date
		    else 	schedule_end_date END
	       else schedule_end_date end schedule_end_date
		    ,
		 case
		   when  right(shift.flg,1) in (1,0) and b.std_shift_id is not null and Substring(cpsd.schedule_detail_id,Charindex('_', cpsd.schedule_detail_id) + 1,1) = 'S'
		   THEN schedule_date
		   when Substring(cpsd.schedule_detail_id,Charindex('_', cpsd.schedule_detail_id) + 1,1) = 'p' AND
			   cast(cpsd.end_time as int) -cast(cpsd.start_time as int)<0
			    AND schedule_time < cast(cpsd.start_time as int) THEN dateadd(d, -1, cpsd.schedule_date)
		ELSE schedule_date END schedule_date , documentation_id ,completed_date, entered_date, task_time,
				    case
					 when stdQuestionContorlType in ('bls',  'os2', 'het','num','tmp','pls','wgt') and isnumeric(cpsd.item_value)=1 and isnull(cpsd.item_value,'') not in ('<RNA/>','<NA/>','<RR/>') then cpsd.item_value
					 when stdQuestionContorlType in ('rsp', 'sgn') then cpsd.item_value
					 when stdQuestionContorlType='bpr' and isnumeric(cpsd.item_value)=1 then cpsd.item_value+'/'+cast( item_value_id as varchar(max))	  else cast( item_value_id as varchar(max)) end item_value_id
				    , cpsd.item_value,retired_date,resolved_date,
				    created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type  ,
				    case Substring(cpsd.schedule_detail_id,Charindex('_',cpsd.schedule_detail_id) + 1,1)
					when 'Q' then 'Qshift'
					when 'P' then 'PRN'
					when 'S' then 'Schedule'
					when 'U' then 'Unscheduled'
					when 'D' then 'Duration' end
					,schedule_time
					, vpl.short_code
    FROM   #cp_documentation_responses cpsd
	 INNER JOIN  #PRP_ClientList c on c.client_id=cpsd.client_id
		 INNER JOIN #prp_shifts shift
		 ON 1 = CASE
							WHEN Substring(cpsd.schedule_detail_id, Charindex('_', cpsd.schedule_detail_id) + 1, 1)  = 'P'
								   AND cpsd.std_shift_id =[shift].shift_id and [shift].flg=0 THEN 1
							WHEN Substring(cpsd.schedule_detail_id,Charindex('_', cpsd.schedule_detail_id) + 1,1) = 'S'
								   AND cpsd.std_shift_id IS NULL
								   AND 1 = CASE  WHEN
															( shift.end_time - shift.start_time ) < 0
															AND
															(cpsd.schedule_time >= shift.start_time
															OR cpsd.schedule_time <= shift.end_time )
															THEN 	1

														WHEN ( shift.end_time - shift.start_time ) > 0
															AND (	cpsd.schedule_time >= shift.start_time
															AND cpsd.schedule_time <= shift.end_time ) THEN 	1
														ELSE 0
												END
							THEN 1

							ELSE 0
					END
	  left join dbo.cp_std_shift b  WITH (NOLOCK)
					on b.std_shift_id=shift_id  and cast(b.end_time as int )-cast(b.start_time as int)<0
      left outer join #vprpPickList vpl
					on cpsd.stdPickListId = vpl.std_pick_list_id
					and cpsd.gen_intervention_id = vpl.genInterventionId
					and cpsd.stdQuestionId  = vpl.stdQuestionId
					and cpsd.item_value_id = vpl.item_value
					and (cpsd.schedule_date >= vpl.effective_date and cpsd.schedule_date < vpl.ineffective_date)

    WHERE  cpsd.schedule_type <> 40   --unschedual

		  and Substring(cpsd.schedule_detail_id, Charindex('_', cpsd.schedule_detail_id) +1, 1)<> 'D'
	 	 		and ( schedule_date is null OR
		 (  case when  right(shift.flg,1) in (1,0) and b.std_shift_id is not null and Substring(cpsd.schedule_detail_id,Charindex('_', cpsd.schedule_detail_id) + 1,1) = 'S'
		 THEN schedule_date else schedule_date end  >= DATEADD(DD, -1, @vfil_ds_schedule_date)
		 and case when  right(shift.flg,1) in (1,0) and b.std_shift_id is not null and Substring(cpsd.schedule_detail_id,Charindex('_', cpsd.schedule_detail_id) + 1,1) = 'S'
		 THEN schedule_date else schedule_date end<=@vfil_ds_schedule_date2_tzadj_plus1

		 )
    )  ;

	 ---- Just Duration
         INSERT INTO #pocData(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,
				schedule_type,flag,schedule_time, short_code)

		 select  distinct
		 schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,cpsd.stdQuestionId ,stdQuestionContorlType,stdQuestionText,cpsd.sequence,
				stdPickListId,fac_id , schedule_id ,

	   case when  completed_date is not null  and strikeout_flag<>'Y' and CAST(REPLACE(CONVERT(VARCHAR(5), schedule_date, 108), ':', '') AS INT)>=shift.start_time
				   AND CAST(REPLACE(CONVERT(VARCHAR(5), schedule_date, 108), ':', '') AS INT)<=shift.end_time	 then Cast(shift.shift_id AS VARCHAR) + '-' + Cast(shift.flg AS VARCHAR)
			 when  completed_date is  null  then Cast(shift.shift_id AS VARCHAR) + '-' + Cast(shift.flg AS VARCHAR)  else null end
                               shift_id,
        case when  completed_date is not null   and strikeout_flag<>'Y' and 	CAST(REPLACE(CONVERT(VARCHAR(5), schedule_date, 108), ':', '') AS INT)>=shift.start_time
				   AND CAST(REPLACE(CONVERT(VARCHAR(5), schedule_date, 108), ':', '') AS INT)<=shift.end_time	 then shift.shift_name
			 when  completed_date is  null  then shift.shift_name  else null end shift_name  ,
      cpsd.start_time ,cpsd.end_time,shift_date,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_start_date), dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date) ,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time,
				case
				  when stdQuestionContorlType in ('bls',  'os2', 'het','num','tmp','pls','wgt') and isnumeric(cpsd.item_value)=1 and isnull(cpsd.item_value,'') not in ('<RNA/>','<NA/>','<RR/>') then cpsd.item_value
				  when stdQuestionContorlType in ( 'rsp', 'sgn') then cpsd.item_value
				  when stdQuestionContorlType='bpr' and isnumeric(cpsd.item_value)=1 then cpsd.item_value+'/'+cast( item_value_id as varchar(max))	  else cast( item_value_id as varchar(max)) end item_value_id
				, cpsd.item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type  ,
				case Substring(cpsd.schedule_detail_id,Charindex('_',cpsd.schedule_detail_id) + 1,1)
				 when 'Q' then 'Qshift'
				 when 'P' then 'PRN'
				 when 'S' then 'Schedule'
				 when 'U' then 'Unscheduled'
				 when 'D' then 'Duration' end
				 ,schedule_time
				 , vpl.short_code
FROM    #prp_shifts shift
  left join #cp_documentation_responses  cpsd
  ON 1 = CASE  WHEN   completed_date is not null  and strikeout_flag<>'Y' and  	CAST(REPLACE(CONVERT(VARCHAR(5), completed_date, 108), ':', '') AS INT)>=shift.start_time
				   AND CAST(REPLACE(CONVERT(VARCHAR(5), completed_date, 108), ':', '') AS INT)<=shift.end_time	 then 1
			 when  (completed_date is  null  and strikeout_flag<>'Y') or strikeout_flag='Y'   then 1 else 0 end
    left outer join #vprpPickList vpl
					on cpsd.stdPickListId = vpl.std_pick_list_id
					and cpsd.gen_intervention_id = vpl.genInterventionId
					and cpsd.stdQuestionId  = vpl.stdQuestionId
					and cpsd.item_value_id = vpl.item_value
					and (cpsd.schedule_date >= vpl.effective_date and cpsd.schedule_date < vpl.ineffective_date)

WHERE  cpsd.schedule_type <> 40   --unschedual
       and Substring(cpsd.schedule_detail_id, Charindex('_', cpsd.schedule_detail_id) + 1, 1) = 'D'
		  and ( schedule_date is null OR  ( schedule_date>= DATEADD(DD, -1, @vfil_ds_schedule_date) and schedule_date< @vfil_ds_schedule_date2_tzadj_plus1))   ;

	 ----  Unschedule
	    INSERT INTO #pocData(
				schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,stdQuestionId ,stdQuestionContorlType,stdQuestionText,sequence,
				stdPickListId,fac_id , schedule_id , std_shift_id ,description ,start_time ,end_time,shift_date,schedule_start_date, schedule_end_date,schedule_date ,
				documentation_id ,completed_date, entered_date, task_time, item_value_id, item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,
				schedule_type,flag,schedule_time, short_code)

	 	 select  schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,cpsd.stdQuestionId ,stdQuestionContorlType,stdQuestionText,cpsd.sequence,
				stdPickListId,fac_id , schedule_id ,
        Cast(shift.shift_id AS VARCHAR) + '-'
       + Cast(shift.flg AS VARCHAR)                       shift_id,

          CASE
         WHEN Substring(cpsd.schedule_detail_id, Charindex('_', cpsd.schedule_detail_id) +
                                             1, 1)
              = 'D'
              AND ( shift.end_time - shift.start_time ) < 0
              AND ( cpsd.schedule_time >= shift.start_time
                     OR cpsd.schedule_time <= shift.end_time ) THEN
         shift.shift_name
         WHEN Substring(cpsd.schedule_detail_id, Charindex('_', cpsd.schedule_detail_id) +
                                             1, 1)
              = 'D'
              AND ( shift.end_time - shift.start_time ) > 0
              AND ( cpsd.schedule_time >= shift.start_time
                    AND cpsd.schedule_time <= shift.end_time ) THEN
         shift.shift_name
         WHEN Substring(cpsd.schedule_detail_id, Charindex('_', cpsd.schedule_detail_id) +
                                             1, 1)
              <> 'D'THEN shift.shift_name
       END                          AS Shift_name  ,
      -- END                                                AS Shift,

      cpsd.start_time ,cpsd.end_time,shift_date,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_start_date), dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date),
	  case when  right(shift.flg,1)=1 and Substring(cpsd.schedule_detail_id,Charindex('_', cpsd.schedule_detail_id) + 1,1) = 'S'
	  THEN schedule_date
																  ELSE schedule_date
															 END

	 schedule_date ,
				documentation_id ,completed_date, entered_date, task_time,
				case
				  when stdQuestionContorlType in ('bls',  'os2', 'het','num','tmp','pls','wgt') and isnumeric(cpsd.item_value)=1 and isnull(cpsd.item_value,'') not in ('<RNA/>','<NA/>','<RR/>') then cpsd.item_value
				  when stdQuestionContorlType in ( 'rsp', 'sgn') then cpsd.item_value
				  when stdQuestionContorlType='bpr' and isnumeric(cpsd.item_value)=1 then cpsd.item_value+'/'+cast( item_value_id as varchar(max))	  else cast( item_value_id as varchar(max)) end item_value_id
				, cpsd.item_value,retired_date,resolved_date,
				created_by_longname,created_by_position,  initials,strikeout_flag, strikeout_id, strikeout_description, strikeout_by, strikeout_date,schedule_type  ,
				case Substring(cpsd.schedule_detail_id,Charindex('_',cpsd.schedule_detail_id) + 1,1)
				 when 'Q' then 'Qshift'
				 when 'P' then 'PRN'
				 when 'S' then 'Schedule'
				 when 'U' then 'Unscheduled'
				 when 'D' then 'Duration' end
				 ,schedule_time
				 , vpl.short_code
FROM   #cp_documentation_responses cpsd

       INNER JOIN #prp_shifts shift
	  ON 1 = CASE
                        WHEN Substring(cpsd.schedule_detail_id,
                             Charindex('_', cpsd.schedule_detail_id) + 1,
                             1)
                             = 'D'

                             AND cpsd.std_shift_id IS NULL THEN 1
                        WHEN Substring(cpsd.schedule_detail_id,
                             Charindex('_', cpsd.schedule_detail_id) + 1,
                             1) IN ( 'U', 'S' )

                             AND cpsd.std_shift_id IS NULL
                             AND 1 = CASE
                                       WHEN
                                 ( shift.end_time - shift.start_time ) < 0
                                 AND
                        (
                          cpsd.schedule_time >= shift.start_time
                           OR cpsd.schedule_time <= shift.end_time ) THEN
                          1
                          WHEN ( shift.end_time - shift.start_time ) > 0
                               AND (
                          cpsd.schedule_time >= shift.start_time
                          AND cpsd.schedule_time <= shift.end_time ) THEN
                          1
                          ELSE 0
                        END THEN 1
                        WHEN Substring(schedule_detail_id,
                             Charindex('_', schedule_detail_id) + 1,
                             1)
                             = 'S'

                             AND cpsd.std_shift_id IS NULL
                             AND cpsd.schedule_time >= shift.start_time
                             AND cpsd.schedule_time <= shift.end_time THEN 1
                        ELSE 0
                      END
 left outer join #vprpPickList vpl
					on cpsd.stdPickListId = vpl.std_pick_list_id
					and cpsd.gen_intervention_id = vpl.genInterventionId
					and cpsd.stdQuestionId  = vpl.stdQuestionId
					and cpsd.item_value_id = vpl.item_value
					and (cpsd.schedule_date >= vpl.effective_date and cpsd.schedule_date < vpl.ineffective_date)

	  WHERE  cpsd.schedule_type =40   --unschedual
	   AND cpsd.schedule_type <> 8
       and Substring(cpsd.schedule_detail_id, Charindex('_', cpsd.schedule_detail_id) + 1, 1) = 'U'
   and ( schedule_date is null OR  ( schedule_date>= DATEADD(DD, -1, @vfil_ds_schedule_date) and schedule_date<DATEADD(DD, 1, @vfil_ds_schedule_date2)))   ;

	     UPDATE a
			SET description=b.shift_name,
			    std_shift_id=CAST(b.shift_id AS VARCHAR)+'-'+CAST(b.flg AS VARCHAR)
	   FROM #pocData a INNER JOIN
				    #prp_shifts b
				    ON CAST(REPLACE(CONVERT(VARCHAR(5), schedule_date, 108), ':', '') AS INT)>=b.start_time
				   AND CAST(REPLACE(CONVERT(VARCHAR(5), schedule_date, 108), ':', '') AS INT)<=b.end_time
	   WHERE a.description IS NULL;

	     DELETE FROM #pocData
           WHERE description IS NULL
		  AND SUBSTRING(schedule_detail_id, CHARINDEX('_', schedule_detail_id)+1, 1)<>'D';

       --Qshift
	   UPDATE a
			SET a.completed_date=dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, completed_date)
			,a.schedule_date=DATEADD(MI, CONVERT(int, SUBSTRING(start_time, 3, 2))+1, DATEADD(HH, CONVERT(int, SUBSTRING(start_time, 1, 2)), shift_date)) -- dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, schedule_date)
			,a.schedule_time=CONVERT(int, SUBSTRING(start_time, 3, 2))+1
	   FROM #pocData a
	   WHERE SUBSTRING(schedule_detail_id, CHARINDEX('_', schedule_detail_id)+1, 1)='Q';

       --NonQshift--- Nightshift
	   UPDATE a SET
	   schedule_date=cast(convert(varchar(20),b.day_date,101)
				    +' '
				    +convert(varchar(5),dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacId ,schedule_date ),108) as datetime),
				    completed_date =cast(convert(varchar(20),c.day_date,101)
				    +' '
				    +convert(varchar(5),dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacId ,completed_date ),108) as datetime)

	    from #pocData a
	    inner join @Dateadjust b
	    on b.std_shift_id=cast(substring(a.std_shift_id,1,charindex('-',a.std_shift_id)-1) as int)
	    and cast(convert(varchar(20),a.schedule_date,101) as datetime)=cast(convert(varchar(20),b.s_date,101) as datetime)
	    left join @Dateadjust c
	    on c.std_shift_id=cast(substring(a.std_shift_id,1,charindex('-',a.std_shift_id)-1) as int)
	    and cast(convert(varchar(20),a.completed_date,101) as datetime)=cast(convert(varchar(20),c.s_date,101) as datetime)
	   where substring(a.schedule_detail_id,charindex('_',a.schedule_detail_id)+1,1) not in ('S','Q','D')
	   and right(a.std_shift_id,1)=1  ;

		UPDATE a SET
			a.schedule_date=dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, schedule_date),
			a.completed_date=dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, completed_date)
		FROM #pocData a
		WHERE SUBSTRING(a.schedule_detail_id,CHARINDEX('_',a.schedule_detail_id)+1,1)  in ('S')


	    --- DAY AND EVEING
	   UPDATE a
		 SET a.schedule_date=
		  case when  b.std_shift_id is not null then cast(convert(varchar(20),a.schedule_date,101) +' ' +convert(varchar(5),dbo.fn_adjust_time_fac_time_zone_base_on_date (@vFacId ,a.schedule_date ),108) as datetime)
		   else dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, schedule_date) end,
			a.completed_date=dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, completed_date)
		  FROM #pocData a
		  left join dbo.cp_std_shift b  WITH (NOLOCK)
			on b.std_shift_id=cast(left(a.std_shift_id,charindex('-',a.std_shift_id)-1 ) as int ) and  cast(b.end_time as int )-cast(b.start_time as int)<0
		  WHERE SUBSTRING(schedule_detail_id, CHARINDEX('_', schedule_detail_id)+1, 1) not in ('Q','D', 'S')
		  		    AND RIGHT(a.std_shift_id, 1)=0;

	   UPDATE a
		 SET a.schedule_date=dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, schedule_date),
			a.completed_date=dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, completed_date)
		  FROM #pocData a
		  WHERE SUBSTRING(schedule_detail_id, CHARINDEX('_', schedule_detail_id)+1, 1)='D'


		 -- Re-insert schedules which was used for documentation on night shift after midnight.
		 -- We still want to see this schedule available for documentation for previous day on report (not displayed as X)
		 -- Just copy of schedule, not copy of documentation
		INSERT INTO #pocData(schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,
							fac_id, schedule_id, std_shift_id, description, start_time, end_time, shift_date, schedule_start_date, schedule_end_date, schedule_date,
							strikeout_flag, schedule_type, flag, schedule_time, day_of_month, short_code )
		 SELECT DISTINCT schedule_detail_id ,client_id ,gen_intervention_id,intervention_id,std_intervention_id,text1,
				fac_id, schedule_id, std_shift_id, description, start_time, end_time, shift_date, schedule_start_date, schedule_end_date, schedule_date,
				strikeout_flag, schedule_type, flag, schedule_time, day_of_month, short_code
		 FROM #pocData a
		 WHERE documentation_id IS NOT NULL
			AND DATEPART(DAY, completed_date) > DATEPART(DAY, schedule_date)
			AND NOT EXISTS (
								SELECT 1 FROM #pocData b
								WHERE a.client_id = b.client_id
										AND a.schedule_detail_id = b.schedule_detail_id
										AND a.gen_intervention_id = b.gen_intervention_id
										AND a.intervention_id = b.intervention_id
										AND a.std_intervention_id = b.std_intervention_id
										AND a.schedule_date = b.schedule_date
										AND b.documentation_id is null
										AND b.completed_date is null
							)


 if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'

if @debug_me = 'Y'  select '#pocData' pocData,* from #pocData;
   -----  User Legend
 SELECT @vStep = 22, @step_start_time = getdate()
 IF @debug_me='Y' PRINT 'BEGIN STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' Getting User Legend INFO  at ' + CONVERT(VARCHAR, @step_start_time)

	   INSERT INTO #PRP_tbUserLegend	(client_id,document_by,initials)
	   SELECT  distinct client_id,created_by_longname,initials
	   FROM #pocData b
	    WHERE b.strikeout_flag='N'
	    and documentation_id is not null;

		-- include 2nd signature in the legend
		 INSERT INTO #PRP_tbUserLegend	(client_id,document_by,initials)
		select distinct re.client_id, su.long_username, re.item_value
				from #cp_documentation_responses re
				inner join dbo.sec_user su with (nolock) on re.item_value_id = convert(varchar(20),su.userid)
				and re.stdQuestionContorlType = 'sgn'
		where not exists (select 1 from #PRP_tbUserLegend t where t.document_by = su.long_username and t.initials = re.item_value )
			and re.strikeout_flag = 'N'
			and re.documentation_id is not null;


 if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'
 if @debug_me = 'Y'  select '#PRP_tbUserLegend' name,* from #PRP_tbUserLegend;


 --INSERT INTO  #poc_doc_ids
 --SELECT DISTINCT gen_intervention_id ,intervention_id ,std_intervention_id FROM #pocData;


--- Client Information into the base table

  SELECT @vStep = 23, @vStepName = 'Client Information into the base table ', @step_start_time = getdate()
 IF @debug_me='Y' PRINT 'BEGIN STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' Client Information into the base table  at ' + CONVERT(VARCHAR, @step_start_time)

 INSERT INTO @PRP_ds_interv_schedule (row_type,row_id,seq,fac_id,client_id,client_name,admint_date,date_of_birth,location	,photo ,photo_date ,mrn_number,user_legend,report_header)
select 1 row_type,0 row_id,'0000' seq, @vFacId   fac_id,c.client_id,c.client_name,
--isnull(convert(char(10),c.admission_date, 101),'') admission_date,
 admission_date,
date_of_birth ,location,photo,photo_date,mrn_number,
       case when @vIncludeUserLegend='1' then UserLegend.user_legend else null end user_legend	,
       @vTermClient+': '+ c.client_name+  case when   @vfil_ds_task_choice is not null then
												@vTab+ @vTermTask +': '+CASE WHEN  @vfil_ds_task_choice = 1 THEN @vTermIntervention + ' Only'
															WHEN @vfil_ds_task_choice = 2 THEN @vTermTask + ' Only'
															WHEN @vfil_ds_task_choice = 3 THEN @vTermIntervention +' and ' + @vTermTask end  else '' end+
	  CASE WHEN @vfil_ds_type=1 THEN  + @vTab+'Type: '+ ( SELECT fst_type_description
												FROM dbo.cp_fst_type fst with (nolock)
												 LEFT JOIN #PRP_Filters f_ds_type WITH (NOLOCK) ON
													   f_ds_type.filter_name = 'ds_type'
												    AND f_ds_type.filter_value = convert(varchar(max),fst.fst_type_id)
					                                 WHERE (fst.fac_id = -1 OR fst.fac_id = @vFacId)  AND fst.deleted = 'N'
											          AND (@vfil_ds_type is null or (@vfil_ds_type = '1' and f_ds_type.filter_value is not null))  )

			 else  @vTab+'Type: All'end +@vTab+'Schedule: '+DATENAME( MONTH , @vfil_ds_schedule_date )+' '+CAST(YEAR(@vfil_ds_schedule_date) as VARCHAR)
from #PRP_ClientList c
Outer apply (
					Select * from
					(	
                        --if user initial contains double quote("), then replace it with '|||||' 
						--above is to avoid an error when converting tab/row seperated user legend into each field on Jasper report
						Select CASE WHEN CHARINDEX('"', initials) > 0 THEN REPLACE(initials, '"', @vPlaceHolder ) 
								ELSE initials END + @vtab + CASE WHEN CHARINDEX('"', document_by) > 0 THEN REPLACE(document_by, '"', @vPlaceHolder )
								ELSE document_by END + @vnewline
						From #PRP_tbUserLegend a
						where a.client_id = c.client_id
						order by initials,document_by
						FOR XML PATH ('')
					) a (user_legend)
		) UserLegend ;

 if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'
 if @debug_me = 'Y' select '@PRP_ds_interv_schedule' name,* from @PRP_ds_interv_schedule

  SELECT @vStep = 24, @vStepName = 'POC Info  ', @step_start_time = getdate()
 IF @debug_me='Y' PRINT 'BEGIN STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' POC Info   at ' + CONVERT(VARCHAR, @step_start_time)

	 if @debug_me = 'Y'  select '@PRP_ds_interv_schedule_clientInfo' name,* from @PRP_ds_interv_schedule;

;WITH documentedData
	AS
		(SELECT DISTINCT fac_id,documentation_id,
              client_id,
			  gen_intervention_id,
			  intervention_id,
                 std_intervention_id,
                 schedule_detail_id,
                 schedule_id,
                 description,
                   case when SUBSTRING(schedule_detail_id, CHARINDEX('_', schedule_detail_id)+1, 1) in ('Q', 'P', 'S', 'U', 'D') and completed_date is not null then completed_date else schedule_date end  schedule_date,
                 completed_date,
                 entered_date,
                 task_time,
                 schedule_time,
                 flag,
			  schedule_start_date,
                 schedule_end_date,
			   case
			   when DATEPART(dd, completed_date) is not null and DATEPART(dd, schedule_date)= DATEPART(dd, completed_date) then  DATEPART(dd, schedule_date)
			   when DATEPART(dd, completed_date) is not null and  DATEPART(dd, schedule_date)<> DATEPART(dd, completed_date) then  DATEPART(dd, completed_date)
			  else  DATEPART(dd, schedule_date) end day_of_month,
                 text1,
                   initials,
                  CONVERT( VARCHAR(5), completed_date, 108)  documet_time,
					case when flag = 'Duration' then
					 (
							 SELECT
								case
									-- If control_type = 'ntv' and it's not system response, then display '0' instead of full response
									when stdQuestionContorlType = 'ntv' then isnull(item_value_id, IIF(item_value is null, '', '0')) + ' '
									else isnull(short_code, item_value_id)
								end + ',' AS [text()]
							 FROM
								(select distinct fac_id,client_id,gen_intervention_id,intervention_id,std_intervention_id,schedule_detail_id,schedule_id,item_value_id,

										 case
											when SUBSTRING(schedule_detail_id, CHARINDEX('_', schedule_detail_id)+1, 1) in ('Q', 'P', 'S', 'U', 'D') and completed_date is not null then completed_date
											else schedule_date
										end  schedule_date,
										completed_date,entered_date,task_time,schedule_time,flag,schedule_start_date,schedule_end_date,sequence,stdQuestionId	,

										case
										   when DATEPART(dd, completed_date) is not null and DATEPART(dd, schedule_date)= DATEPART(dd, completed_date) then  DATEPART(dd, schedule_date)
										   when DATEPART(dd, completed_date) is not null and  DATEPART(dd, schedule_date)<> DATEPART(dd, completed_date) then  DATEPART(dd, completed_date)
											else  DATEPART(dd, schedule_date)
										end day_of_month

										, text1,initials
										 , CONVERT( VARCHAR(5), completed_date, 108)  documet_time
										 ,strikeout_flag
										 , short_code
								  from #pocData b where b.flag='Duration'   and b.strikeout_flag='N'
								) a
							 WHERE a.std_intervention_id=b.std_intervention_id
							  AND a.gen_intervention_id=b.gen_intervention_id
							  AND a.intervention_id=b.intervention_id
							   AND a.client_id=b.client_id
							   AND a.fac_id=b.fac_id
							   AND a.schedule_detail_id=b.schedule_detail_id
							   AND a.schedule_id=b.schedule_id
							   AND a.schedule_date=(
													  case   when SUBSTRING(b.schedule_detail_id, CHARINDEX('_', b.schedule_detail_id)+1, 1) in ('Q', 'P', 'S', 'U', 'D') and completed_date is not null
														 then b.completed_date
														 else b.schedule_date
													  end
												   )
							  and a.strikeout_flag=b.strikeout_flag
							  and a.completed_date=b.completed_date
							  and a.entered_date=b.entered_date

							 ORDER BY fac_id, client_id, std_intervention_id, schedule_date, schedule_time, sequence
							 FOR XML PATH('')
						)
					else
						(
							SELECT
								case
									-- If control_type = 'ntv' and it's not system response, then display '0' instead of full response
									when stdQuestionContorlType = 'ntv' then isnull(item_value_id, IIF(item_value is null, '', '0')) + ' '
									else isnull(short_code, item_value_id)
								end + ',' AS [text()]
							FROM #pocData a
							WHERE a.strikeout_flag='N'
							and a.std_intervention_id=b.std_intervention_id
							AND a.gen_intervention_id=b.gen_intervention_id
							AND a.intervention_id=b.intervention_id
							AND a.client_id=b.client_id
							AND a.fac_id=b.fac_id
							AND a.schedule_detail_id=b.schedule_detail_id
							AND a.schedule_id=b.schedule_id
							AND a.schedule_date=b.schedule_date
							and a.strikeout_flag=b.strikeout_flag
							and a.documentation_id=b.documentation_id
							and a.std_shift_id = b.std_shift_id --to prevent responses from multiplying for overlaping shifts

							ORDER BY fac_id, client_id, std_intervention_id, schedule_date, schedule_time, sequence
							FOR XML PATH('')
				) end respone
				,
							  CASE WHEN flag = 'QShift'	THEN '0010'
								   WHEN flag = 'Schedule'		THEN '0020'
								   WHEN flag = 'Duration'		THEN '0030'
								   WHEN flag = 'PRN'		THEN '0040'
								   WHEN flag = 'Unscheduled'	THEN '0050'
								   ELSE	'0020'	-- Special cases of SCH (e.g. QnH)
							  END
							 seq
			 FROM #pocData b

			  where  b.strikeout_flag='N'

	)
,
 allPocData as (

	select DISTINCT b.fac_id,
	            b.documentation_id ,
                 b.client_id,
			  b.gen_intervention_id,
			  b.intervention_id,
                 b.std_intervention_id,
			  schedule_detail_id,
                 b.schedule_id,
                 b.description,

			  case when SUBSTRING(schedule_detail_id, CHARINDEX('_', schedule_detail_id)+1, 1) in ('Q', 'P', 'S', 'U', 'D') and completed_date is not null  then completed_date else schedule_date end  schedule_date,

                  case
			   when CONVERT( VARCHAR(10), b.completed_date, 101)<>CONVERT( VARCHAR(10), b.schedule_date, 101) then null
			   else b.completed_date end completed_date,


			   case
			   when CONVERT( VARCHAR(10), b.completed_date, 101)<>CONVERT( VARCHAR(10), b.schedule_date, 101) then null
			   else b.entered_date end entered_date	,


                 b.task_time,
                 b.schedule_time,
                 b.flag,
			  b.schedule_start_date,

			  	 case when  SUBSTRING(b.schedule_detail_id, CHARINDEX('_', b.schedule_detail_id)+1, 1)='P' THEN
			    case when ( (cast (REPLACE(CONVERT( VARCHAR(5), dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, b.schedule_end_date), 108), ':', '') as int)>= cast(b.start_time as int))
			      and (cast (REPLACE(CONVERT( VARCHAR(5), dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, b.schedule_end_date), 108), ':', '') as int)< cast(b.end_time as int)) )
				 or
				  ( (cast (REPLACE(CONVERT( VARCHAR(5), dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, b.schedule_end_date), 108), ':', '') as int)< cast(b.start_time as int))
			      and (cast (REPLACE(CONVERT( VARCHAR(5), dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, b.schedule_end_date), 108), ':', '') as int)> cast(b.end_time as int)) )
				  or
				  ( (cast (REPLACE(CONVERT( VARCHAR(5), dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, b.schedule_end_date), 108), ':', '') as int)< cast(b.start_time as int))
			      and (cast (REPLACE(CONVERT( VARCHAR(5), dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, b.schedule_end_date), 108), ':', '') as int)>= cast(b.end_time as int)) )
				 then dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, b.schedule_end_date)
			     else null end
			 else
			   dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, b.schedule_end_date)
			 end schedule_end_date,

			    DATEPART(dd,
			    case when SUBSTRING(b.schedule_detail_id, CHARINDEX('_', b.schedule_detail_id)+1, 1) in ('Q', 'P', 'S', 'U', 'D') and completed_date is not null then b.completed_date else b.schedule_date end


			    )   day_of_month,
                 b.text1,
			  case
			   when CONVERT( VARCHAR(10), b.completed_date, 101)<>CONVERT( VARCHAR(10), b.schedule_date, 101) then 'N'
			   else b.strikeout_flag end strikeout_flag,

			  CASE
			   when CONVERT( VARCHAR(10), b.completed_date, 101)<>CONVERT( VARCHAR(10), b.schedule_date, 101) then NULL
			  else b.initials end initials ,
                 case
			  when CONVERT( VARCHAR(10), b.completed_date, 101)<>CONVERT( VARCHAR(10), b.schedule_date, 101) then NULL
			  else CONVERT( VARCHAR(5), b.completed_date, 108) end  documet_time,
                 case
			   when CONVERT( VARCHAR(10), b.completed_date, 101)<>CONVERT( VARCHAR(10), b.schedule_date, 101) then null
			   else
			 	case when flag = 'Duration'  then
		 (
     SELECT isnull(short_code, item_value_id) +',' AS [text()]
     FROM
	(select distinct fac_id,client_id,gen_intervention_id,intervention_id,std_intervention_id,schedule_detail_id,schedule_id,item_value_id	,

				   case when SUBSTRING(schedule_detail_id, CHARINDEX('_', schedule_detail_id)+1, 1) in ('Q', 'P', 'S', 'U', 'D') and completed_date is not null then completed_date else schedule_date end  schedule_date,

                 completed_date,entered_date,task_time,schedule_time,flag,schedule_start_date,schedule_end_date,sequence,stdQuestionId	,
			   case
			   when DATEPART(dd, completed_date) is not null and DATEPART(dd, schedule_date)= DATEPART(dd, completed_date) then  DATEPART(dd, schedule_date)
			   when DATEPART(dd, completed_date) is not null and  DATEPART(dd, schedule_date)<> DATEPART(dd, completed_date) then  DATEPART(dd, completed_date)
			  else  DATEPART(dd, schedule_date) end day_of_month,
                 text1,initials, CONVERT( VARCHAR(5), completed_date, 108)  documet_time,strikeout_flag
				 , short_code
		  from #pocData b where b.flag='Duration' and b.strikeout_flag='N'
	) a
     WHERE a.std_intervention_id=b.std_intervention_id
	  AND a.gen_intervention_id=b.gen_intervention_id
	  AND a.intervention_id=b.intervention_id
       AND a.client_id=b.client_id
       AND a.fac_id=b.fac_id
       AND a.schedule_detail_id=b.schedule_detail_id
       AND a.schedule_id=b.schedule_id
       AND a.schedule_date=(
							  case   when SUBSTRING(b.schedule_detail_id, CHARINDEX('_', b.schedule_detail_id)+1, 1) in ('Q', 'P', 'S', 'U', 'D') and completed_date is not null
								 then b.completed_date
								 else b.schedule_date
							  end
						   )
	  and a.strikeout_flag=b.strikeout_flag
	  and a.completed_date=b.completed_date
	  and a.entered_date=b.entered_date


     ORDER BY fac_id, client_id, std_intervention_id, schedule_date, schedule_time, sequence
     FOR XML PATH(''))
		else
                 (
     SELECT  isnull(short_code, item_value_id)  +',' AS [text()]
     FROM #pocData a
     WHERE a.strikeout_flag='N' and a.std_intervention_id=b.std_intervention_id
	  AND a.gen_intervention_id=b.gen_intervention_id
	  AND a.intervention_id=b.intervention_id
       AND a.client_id=b.client_id
       AND a.fac_id=b.fac_id
       AND a.schedule_detail_id=b.schedule_detail_id
       AND a.schedule_id=b.schedule_id
       AND a.schedule_date=b.schedule_date
	  and a.strikeout_flag=b.strikeout_flag
	  and a.documentation_id=b.documentation_id

     ORDER BY fac_id, client_id, std_intervention_id, schedule_date, schedule_time, sequence
     FOR XML PATH('')) end end respone 	,
				  CASE WHEN b.flag = 'QShift'	THEN '0010'
					   WHEN b.flag = 'Schedule'		THEN '0020'
					   WHEN b.flag = 'Duration'		THEN '0030'
					   WHEN b.flag = 'PRN'		THEN '0040'
					   WHEN b.flag = 'Unscheduled'	THEN '0050'
					   ELSE	'0020'	-- Special cases of SCH (e.g. QnH)
				  END
				 seq
   FROM #pocData b

   where
    1= case
			when b.strikeout_flag='N'  and  flag='Duration' and completed_date is null then 1
			when b.strikeout_flag='N'  and  flag='Duration' and completed_date< =schedule_end_date  and completed_date>=	schedule_date
			then 1
			when b.strikeout_flag='N'   then 1
			else 0 end


 )
 ,  poc as (
  select b.seq,
         b.fac_id,
  	    c.documentation_id documentation_id,
        b.client_id,
	   b.gen_intervention_id,
	   b.intervention_id,
        b.std_intervention_id,
	   b.text1,
        b.schedule_id,
        b.description, b.schedule_date b,
	   b.schedule_date  schedule_date,
	   b.schedule_start_date,
        b.schedule_end_date,
	   b.day_of_month, strikeout_flag,
	    case when b.flag='Duration'
			     then datediff(day,cast(CONVERT( VARCHAR(10), b.schedule_start_date, 101) as datetime) ,cast(CONVERT( VARCHAR(10),  b.schedule_end_date, 101) as datetime))
				 else 0 end duration,
        c.completed_date,
        b.task_time,
        b.schedule_time,
        b.flag,
	   replace(replace(replace(replace(


           isnull(
		  case
		   WHEN LTRIM(RTRIM(c.respone))='' THEN ''
		   WHEN ISNULL(c.respone,'')='' THEN ''
            ELSE
		  case when @vIncludeDocumentRespon='1' then LEFT(c.respone, LEN(c.respone)-1)	else '' end
		  +case
		     when  @vIncludeInitial='0' then  ''
		     when @vIncludeDocumentRespon='1'  and @vIncludeInitial='1' and c.initials is not null then  @vNewLine+isnull(c.initials,'')
			when @vIncludeDocumentRespon='1'  and @vIncludeInitial='1' and c.initials is null then ''
			when @vIncludeDocumentRespon='0'  and @vIncludeInitial='1' then  isnull(c.initials,'')
		   end
		  + case
		     when @vIncludeDocumentTime='0' then ''
			when @vIncludeDocumentTime='1' and @vIncludeInitial='1' then  @vNewLine+CONVERT( VARCHAR(5), c.completed_date, 108)
			when @vIncludeDocumentTime='1' and @vIncludeInitial='0' and @vIncludeDocumentRespon='1' then  @vNewLine+CONVERT( VARCHAR(5), c.completed_date, 108)
			when @vIncludeDocumentTime='1' and @vIncludeInitial='0' and @vIncludeDocumentRespon='0' then  CONVERT( VARCHAR(5), c.completed_date, 108)
		   end
        END,' Y ')

	   ,'&lt;','<'),'&gt;','>'),'&amp;lt;','<'),'&amp;gt;','>')  doc
 from allPocData b
 left join documentedData c
    on c.fac_id=b.fac_id AND
       c.client_id=b.client_id AND
	  c.std_intervention_id=b.std_intervention_id
	  AND c.gen_intervention_id=b.gen_intervention_id
	  AND c.intervention_id=b.intervention_id
       AND c.schedule_id=b.schedule_id
	  and c.description=b.description
	  and c.schedule_detail_id=b.schedule_detail_id
	  and c.documentation_id=b.documentation_id
	  and 1=
	   case
	      when b.flag='Duration' and CONVERT( VARCHAR(10), c.completed_date, 101) is not null  then 1
           when b.flag<> 'Duration' and  b.flag<> 'PRN' and CONVERT( VARCHAR(10), c.completed_date, 101)=CONVERT( VARCHAR(10), b.schedule_date, 101) then 1
	      when b.flag in ( 'PRN'  , 'Qshift')  then 1
	    else 0 end
	    )

INSERT INTo #poc
 (seq,fac_id,client_id,admission_date,documentation_id,detail_id,gen_intervention_id,intervention_id,std_intervention_id ,text1,schedule_id ,shift_name	,
  schedule_date,schedule_start_date,schedule_end_date,day_of_month,strikeout_flag,completed_date,task_time,schedule_time,flag,doc)

  select

  seq, fac_id, poc.client_id,admission_date,documentation_id, null detail_id, gen_intervention_id, intervention_id, std_intervention_id,
	   text1,schedule_id,description,schedule_date  ,schedule_start_date,
	  case when flag='prn' and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<=@vfil_ds_schedule_date2  then schedule_end_date
	       when flag='prn' and schedule_end_date>=@vfil_ds_schedule_date2	 then null
	  when schedule_end_date is null then schedule_end_date else schedule_end_date end  schedule_end_date, day_of_month, strikeout_flag,
      completed_date,task_time, schedule_time,flag,doc
 from POC	 poc
 inner join  #PRP_ClientList client on client.client_id=poc.client_id
  where
    schedule_date>=@vfil_ds_schedule_date   and  schedule_date < @vfil_ds_schedule_date2 and
  1=  case
  when std_intervention_id=-1
  and schedule_date<client.admission_date then 1
   when  flag ='Unscheduled' and convert(varchar(10),dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, schedule_start_date),110)=convert(varchar(10),schedule_date,110)
  and schedule_date<client.admission_date then 1
  when  admission_date=dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, schedule_start_date)   and  schedule_date<client.admission_date then 1
  when  flag  in ('Schedule','Qshift')	 and  admission_date<>dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, schedule_start_date)  and  client.admission_date> schedule_date then 1
  when  flag not in ('Schedule','Qshift')  and admission_date<>dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, schedule_start_date)  and  client.admission_date> schedule_date then 0
  else 1
  end  ;

   if @debug_me = 'Y' select '#poc' poc,* from #poc;
 if @debug_me='h' Print 'STEP1_H ' +   ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@step_start_time,getdate()))))+ ' ms'
-- day time
-----------------------------------------------------------
	-- Handeling Multi Documentation PRN and Qshift
-----------------------------------------------------------
  SELECT @vStep = 25, @vStepName = 'Handeling Multi Documentation PRN and Qshift  ', @step_start_time = getdate()
 IF @debug_me='h' PRINT 'BEGIN STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' Handeling Multi Documentation PRN and Qshift   at ' + CONVERT(VARCHAR, @step_start_time)

;with  dayTable as (
SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
      case when day_of_month=1 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else
	 case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case
	                                     when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date
								  when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date
								  else schedule_start_date end )<=1 and
								  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),
								  datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=1  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>1  or datepart(day,@vfil_ds_schedule_date2-1)<1 )  then '*'  end
	 end	 as day_1
 from #poc

 where flag in ( 'PRN'  , 'Qshift')
 and day_of_month=1

union all
SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
	 case when day_of_month=2 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=2 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=2  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>2  or datepart(day,@vfil_ds_schedule_date2-1)<2 )  then '*'  end
	 end	 as day_2
from #poc
 where flag in ( 'PRN'  , 'Qshift')
 and day_of_month=2
 union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
	 case when day_of_month=3 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=3 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=3  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>3  or datepart(day,@vfil_ds_schedule_date2-1)<3 )  then '*'  end
	 end	 as day_3
from #poc
 where flag in ( 'PRN'  , 'Qshift')
 and day_of_month=3
 union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=4 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and  datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=4 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=4  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>4  or datepart(day,@vfil_ds_schedule_date2-1)<4 )  then '*'  end
	 end	 as day_4
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=4
 union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=5 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=5 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=5  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>5  or datepart(day,@vfil_ds_schedule_date2-1)<5 )  then '*'  end
	 end	 as day_5
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=5
 union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=6 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=6 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=6  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>6  or datepart(day,@vfil_ds_schedule_date2-1)<6 )  then '*'  end
	 end	 as day_6
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=6
 union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=7 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=7 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=7  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>7  or datepart(day,@vfil_ds_schedule_date2-1)<7 )  then '*'  end
	 end	 as day_7
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=7
 union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=8 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=8 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=8  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>8  or datepart(day,@vfil_ds_schedule_date2-1)<8 )  then '*'  end
	 end	 as day_8
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=8
 union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=9 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1  and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=9 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=9  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>9  or datepart(day,@vfil_ds_schedule_date2-1)<9 )  then '*'  end
	 end	 as day_9
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=9
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=10 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=10 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=10  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>10  or datepart(day,@vfil_ds_schedule_date2-1)<10 )  then '*'  end
	 end	 as day_10
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=10
    union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=11 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=11 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=11  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>11  or datepart(day,@vfil_ds_schedule_date2-1)<11 )  then '*'  end
	 end	 as day_11
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=11
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=12 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=12 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=12  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>12  or datepart(day,@vfil_ds_schedule_date2-1)<12 )  then '*'  end
	 end	 as day_12
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=12
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=13 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=13 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=13  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>13  or datepart(day,@vfil_ds_schedule_date2-1)<13 )  then '*'  end
	 end	 as day_13
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=13
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=14 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=14 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=14  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>14  or datepart(day,@vfil_ds_schedule_date2-1)<14 )  then '*'  end
	 end	 as day_14
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=14
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=15 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=15 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=15  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>15  or datepart(day,@vfil_ds_schedule_date2-1)<15 )  then '*'  end
	 end	 as day_15
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=15
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=16 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=16 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=16  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>16  or datepart(day,@vfil_ds_schedule_date2-1)<16 )  then '*'  end
	 end	 as day_16
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=16
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=17 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=17 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=17  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>17  or datepart(day,@vfil_ds_schedule_date2-1)<17 )  then '*'  end
	 end	 as day_17
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=17
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=18 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=18 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=18  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>18  or datepart(day,@vfil_ds_schedule_date2-1)<18 )  then '*'  end
	 end	 as day_18
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=18
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=19 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=19 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=19  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>19  or datepart(day,@vfil_ds_schedule_date2-1)<19 )  then '*'  end
	 end	 as day_19
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=19
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=20 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=20 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=20  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>20  or datepart(day,@vfil_ds_schedule_date2-1)<20 )  then '*'  end
	 end	 as day_20
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=20
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=21 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=21 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=21  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>21  or datepart(day,@vfil_ds_schedule_date2-1)<21 )  then '*'  end
	 end	 as day_21
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=21
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=22 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=22 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=22  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>22  or datepart(day,@vfil_ds_schedule_date2-1)<22 )  then '*'  end
	 end	 as day_22
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=22
     union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=23 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	  when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=23 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=23  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>23  or datepart(day,@vfil_ds_schedule_date2-1)<23 )  then '*'  end
	 end	 as day_23
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=23
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=24 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	  when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=24 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=24 then ' Y '
	  when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>24  or datepart(day,@vfil_ds_schedule_date2-1)<24 )  then '*'  end
	 end	 as day_24
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=24
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=25 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=25 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=25  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>25  or datepart(day,@vfil_ds_schedule_date2-1)<25 )  then '*'  end
	 end	 as day_25
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=25
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=26 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=26 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=26  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>26  or datepart(day,@vfil_ds_schedule_date2-1)<26 )  then '*'  end
	 end	 as day_26
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=26
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=27 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	  when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=27 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=27  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>27  or datepart(day,@vfil_ds_schedule_date2-1)<27 )  then '*'  end
	 end	 as day_27
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=27
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=28 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=28 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=28  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>28  or datepart(day,@vfil_ds_schedule_date2-1)<28 )  then '*'  end
	 end	 as day_28
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=28
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=29 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	  when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=29 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=29  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>29  or datepart(day,@vfil_ds_schedule_date2-1)<29 )  then '*'  end
	 end	 as day_29
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=29
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=30 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=30 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=30  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>30  or datepart(day,@vfil_ds_schedule_date2-1)<30 )  then '*'  end
	 end	 as day_30
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=30
   union all

SELECT day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag,
row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,documentation_id, flag
                  order by shift_name) row_id ,
       case when day_of_month=31 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end
	 else case
	 when flag='PRN' and len(@vIs_chart)=1 and datepart(day, case when schedule_end_date is null and  month(schedule_start_date)<month(@vfil_ds_schedule_date) then @vfil_ds_schedule_date   when month(schedule_start_date)=month(@vfil_ds_schedule_date) and schedule_start_date<admission_date then admission_date else schedule_start_date end )<=31 and  isnull(datepart(day,dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId,schedule_end_date)),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>=31  then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>31  or datepart(day,@vfil_ds_schedule_date2-1)<31 )  then '*'  end
	 end	 as day_31
from #poc
 where flag in ( 'PRN'  , 'Qshift')
  and day_of_month=31 )

INSERT INTO @dayTable(day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,row_id,day_n)
  select day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,
  row_number() over (partition by day_of_month,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name, flag
                  order by shift_name)	,day_1
  from(
  select distinct  day_of_month,seq,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name, flag, day_1

  from(
	select a.*
	from dayTable a
	where
	not exists(select 1 from dayTable b where a.std_intervention_id=b.std_intervention_id
	  and a.intervention_id=b.intervention_id
	  and a.gen_intervention_id=b.gen_intervention_id	and a.client_id=b.client_id and a.shift_name=b.shift_name and a.day_of_month=b.day_of_month and
	  a.seq=b.seq and b.day_1<>a.day_1)

	 union all
	  select a.*
	from dayTable a
	where  a.day_1<>' y ' ) tt
) alldoc

if @debug_me = 'Y' select '@dayTable' dayTable,* from @dayTable;
 if @debug_me='h' Print 'STEP1_H ' +   ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@step_start_time,getdate()))))+ ' ms'

 SELECT @vStep = 26, @vStepName = 'Handeling Multi Documentation PRN and Qshift  ', @step_start_time = getdate()
 IF @debug_me='h' PRINT 'BEGIN STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' Handeling Multi Documentation PRN and Qshift   at ' + CONVERT(VARCHAR, @step_start_time)

  ;with duplicate_date as (
    select  distinct  day_of_month,seq,poc.text1,poc.flag,poc.fac_id,poc.client_id,poc.gen_intervention_id, poc.intervention_id,poc.std_intervention_id
	        ,shift_name ,schedule_start_date,schedule_end_date,documentation_id
	 from  #poc	 poc
      where poc.flag in ('prn','qshift')   and  documentation_id is not null
      group by  day_of_month,seq,poc.text1,poc.flag,poc.fac_id,poc.client_id,poc.gen_intervention_id, poc.intervention_id,poc.std_intervention_id,shift_name
	 ,schedule_start_date,schedule_end_date ,documentation_id )

	,cte_main  as
 (SELECT seq,fac_id,flag,client_id,gen_intervention_id, intervention_id,std_intervention_id,text1,shift_name
        ,schedule_start_date,schedule_end_date,
         row_number() over (partition by client_id,gen_intervention_id, intervention_id,std_intervention_id,shift_name,flag
                  order by shift_name) row_id
from (

select seq,fac_id,flag,client_id,text1,gen_intervention_id, intervention_id,std_intervention_id,shift_name
       ,schedule_start_date,schedule_end_date,max(cnt) count_shift
     from(
	   select  day_of_month,seq,text1,flag,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id ,shift_name ,schedule_start_date,
	   schedule_end_date,count(1) cnt
   from(
    select day_of_month,seq,poc.text1,poc.flag,poc.fac_id,poc.client_id,poc.gen_intervention_id, poc.intervention_id,poc.std_intervention_id
	        ,shift_name ,schedule_start_date,schedule_end_date,documentation_id
	 from #poc poc
	 where  poc.flag in ('prn','qshift')
	 and not exists  (select 1 from  duplicate_date tt where tt.client_id= poc.client_id and tt.shift_name=poc.shift_name
  and  tt.std_intervention_id=poc.std_intervention_id
  and  tt.gen_intervention_id=poc.gen_intervention_id
  and  tt.intervention_id=poc.intervention_id
  and  tt.fac_id=poc.fac_id
  and tt.day_of_month=poc.day_of_month)

  union

   select  distinct  day_of_month,seq,text1,flag,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id
	        ,shift_name ,schedule_start_date,schedule_end_date,documentation_id
	 from  duplicate_date tt
	 )oo
    group by day_of_month,seq,text1,flag,fac_id,client_id,gen_intervention_id, intervention_id,std_intervention_id ,shift_name ,schedule_start_date,schedule_end_date

	 )  tt
   group by  seq,fac_id,flag,client_id,text1,gen_intervention_id, intervention_id,std_intervention_id,shift_name ,schedule_start_date,schedule_end_date
   ) base ,[dbo].[pcc_num_sequence] n
   where n.num<=base.count_shift
 )

 INSERT INTO #PRP_ds_interv_schedule_cte (row_type,row_id,seq,seq_name,fac_id,client_id,client_name,gen_intervention_id,intervention_id,std_intervention_id ,intervention_desc,text1,schedule_id ,shift_name	,schedule_time	,
							 day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15,
							 day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30,
							 day_31 )
 select

  2 row_type,null row_id,
  cte.seq,cte.flag,cte.fac_id,cte.client_id,client.client_name,cte.gen_intervention_id,
	   cte.intervention_id,cte.std_intervention_id,cte.text1 , inter.text1,

        null schedule_id,cte.shift_name,null,

	 case
	     when flag='PRN' and len(@vIs_chart)=1  and day_1.day_n <> ' Y ' then day_1.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_1.day_n  = ' Y '  or isnull(day_1.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<1 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>1 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		 when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=1 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=1 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<1  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>1  then ' Y '

		 when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>1  or datepart(day,@vfil_ds_schedule_date2-1)<1 )  then '*'
		 when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<1  AND datepart(day,@vfil_ds_schedule_date2-1)<1 ) or (datepart(day,@vfil_ds_schedule_date)>1  AND datepart(day,@vfil_ds_schedule_date2-1)>1 ) ) THEN '*'
           when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=1  AND datepart(day,@vfil_ds_schedule_date2-1)>=1 ) THEN
	     case when  day_1.day_n <> ' Y ' then day_1.day_n
		     when  (day_1.day_n  = ' Y '  or isnull(day_1.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<1 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>1 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),@vfil_ds_last_day_of_month,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=1 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=1 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<1  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>1  then ' Y '
		else day_1.day_n end
	    else  day_1.day_n end day_1 ,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_2.day_n <> ' Y ' then day_2.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_2.day_n  = ' Y '  or isnull(day_2.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		 when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		  when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		  when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=2 and
		  isnull(datepart(day,
		  case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<2  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>2  then ' Y '

		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>2  or datepart(day,@vfil_ds_schedule_date2-1)<2 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<2  AND datepart(day,@vfil_ds_schedule_date2-1)<2 ) or (datepart(day,@vfil_ds_schedule_date)>2  AND datepart(day,@vfil_ds_schedule_date2-1)>2 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=2  AND datepart(day,@vfil_ds_schedule_date2-1)>=2 ) THEN
	     case when  day_2.day_n <> ' Y ' then day_2.day_n
		     when (day_2.day_n  = ' Y '  or isnull(day_2.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=2 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<2  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>2  then ' Y '
		else day_2.day_n end
	    else  day_2.day_n end day_2 ,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_3.day_n <> ' Y ' then day_3.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_3.day_n  = ' Y '  or isnull(day_3.day_n,'')='' ) and datepart(day,
		case when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<3 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>3 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=3 and
		isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=3 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<3  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>3  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>3  or datepart(day,@vfil_ds_schedule_date2-1)<3 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<3  AND datepart(day,@vfil_ds_schedule_date2-1)<3 ) or (datepart(day,@vfil_ds_schedule_date)>3  AND datepart(day,@vfil_ds_schedule_date2-1)>3 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=3  AND datepart(day,@vfil_ds_schedule_date2-1)>=3 ) THEN
	     case when  day_3.day_n <> ' Y ' then day_3.day_n
		     when (day_3.day_n  = ' Y '  or isnull(day_3.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<3 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>3 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=3 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=3 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<3  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>3  then ' Y '
		else day_3.day_n end
	    else day_3.day_n end day_3,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_4.day_n <> ' Y ' then day_4.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_4.day_n  = ' Y '  or isnull(day_4.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<4 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>4 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=4 and
		isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=4 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<4  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>4  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>4  or datepart(day,@vfil_ds_schedule_date2-1)<4 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<4  AND datepart(day,@vfil_ds_schedule_date2-1)<4 ) or (datepart(day,@vfil_ds_schedule_date)>4  AND datepart(day,@vfil_ds_schedule_date2-1)>4 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=4  AND datepart(day,@vfil_ds_schedule_date2-1)>=4 ) THEN
	     case when  day_4.day_n <> ' Y ' then day_4.day_n
		     when (day_4.day_n  = ' Y '  or isnull(day_4.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<4 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>4 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=4 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=4 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<4  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>4  then ' Y '
		else day_4.day_n end
	    else day_4.day_n end day_4,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_5.day_n <> ' Y ' then day_5.day_n
		 when flag='PRN' and len(@vIs_chart)=1  and (day_5.day_n  = 'Y'  or isnull(day_5.day_n,'')='' ) and datepart(day,
		 case
		 when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		 when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		 when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<5 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		 when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>5 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		 when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=5 and
		 isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=5 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<5  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>5  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>5  or datepart(day,@vfil_ds_schedule_date2-1)<5 )  then '*'
          when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<5  AND datepart(day,@vfil_ds_schedule_date2-1)<5 ) or (datepart(day,@vfil_ds_schedule_date)>5  AND datepart(day,@vfil_ds_schedule_date2-1)>5 ) ) THEN '*'
	     when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=5  AND datepart(day,@vfil_ds_schedule_date2-1)>=5 ) THEN
	     case when  day_5.day_n <> ' Y ' then day_5.day_n
		     when (day_5.day_n  = ' Y '  or isnull(day_5.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<5 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>5 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=5 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=5 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<5  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>5  then ' Y '
		else day_5.day_n end
	    else day_5.day_n end day_5,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_6.day_n <> ' Y ' then day_6.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_6.day_n  = ' Y '  or isnull(day_6.day_n,'')='' ) and datepart(day,
		case
		 when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		 when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		 when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<6 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		 when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>6 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		 when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=6 and
		  isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=6 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<6  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>6  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>6  or datepart(day,@vfil_ds_schedule_date2-1)<6 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<6  AND datepart(day,@vfil_ds_schedule_date2-1)<6 ) or (datepart(day,@vfil_ds_schedule_date)>6  AND datepart(day,@vfil_ds_schedule_date2-1)>6 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=6  AND datepart(day,@vfil_ds_schedule_date2-1)>=6 ) THEN
	     case when  day_6.day_n <> ' Y ' then day_6.day_n
		     when (day_6.day_n  = ' Y '  or isnull(day_6.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<6 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>6 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=6 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=6 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<6  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>6  then ' Y '
		else day_6.day_n end
	    else  day_6.day_n end  day_6,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_7.day_n <> ' Y ' then day_7.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_7.day_n  = ' Y '  or isnull(day_7.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<7 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>7 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=7 and  isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=7 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<7  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>7  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>7  or datepart(day,@vfil_ds_schedule_date2-1)<7 )  then '*'
          when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<7  AND datepart(day,@vfil_ds_schedule_date2-1)<7 ) or (datepart(day,@vfil_ds_schedule_date)>7  AND datepart(day,@vfil_ds_schedule_date2-1)>7 ) ) THEN '*'
		when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=7  AND datepart(day,@vfil_ds_schedule_date2-1)>=7 ) THEN
	     case when  day_7.day_n <> ' Y ' then day_7.day_n
		     when (day_7.day_n  = ' Y '  or isnull(day_7.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<7 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>7 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=7 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=7 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<7  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>7  then ' Y '
		else day_7.day_n end
	    else  day_7.day_n end day_7,
	      case
	     when flag='PRN' and len(@vIs_chart)=1  and day_8.day_n <> ' Y ' then day_8.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_8.day_n  = ' Y '  or isnull(day_8.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<8 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>8 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=8 and
		 isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=8 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<8  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>8  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>8  or datepart(day,@vfil_ds_schedule_date2-1)<8 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<8  AND datepart(day,@vfil_ds_schedule_date2-1)<8 ) or (datepart(day,@vfil_ds_schedule_date)>8  AND datepart(day,@vfil_ds_schedule_date2-1)>8 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=8  AND datepart(day,@vfil_ds_schedule_date2-1)>=8 ) THEN
	     case when  day_8.day_n <> ' Y ' then day_8.day_n
		     when (day_8.day_n  = ' Y '  or isnull(day_8.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<8 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>8 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=8 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=8 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<8  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>8  then ' Y '
		else day_8.day_n end
	    else day_8.day_n end day_8,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_9.day_n <> ' Y ' then day_9.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_9.day_n  = ' Y '  or isnull(day_9.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<9 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>9 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=9 and
		 isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=9 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<9  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>9  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>9  or datepart(day,@vfil_ds_schedule_date2-1)<9 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<9  AND datepart(day,@vfil_ds_schedule_date2-1)<9 ) or (datepart(day,@vfil_ds_schedule_date)>9  AND datepart(day,@vfil_ds_schedule_date2-1)>9 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=9 AND datepart(day,@vfil_ds_schedule_date2-1)>=9 ) THEN
	     case when  day_9.day_n <> ' Y ' then day_9.day_n
		     when (day_9.day_n  = ' Y '  or isnull(day_9.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<9 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>9 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=9 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=9 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<9  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>9  then ' Y '
		else day_9.day_n end
	    else day_9.day_n end day_9
	    ,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_10.day_n <> ' Y ' then day_10.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_10.day_n  = ' Y '  or isnull(day_10.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<10 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		 when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>10 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		 when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=10 and
		 isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=10 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<10  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>10  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>10 or datepart(day,@vfil_ds_schedule_date2-1)<10 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<10  AND datepart(day,@vfil_ds_schedule_date2-1)<10 ) or (datepart(day,@vfil_ds_schedule_date)>10  AND datepart(day,@vfil_ds_schedule_date2-1)>10 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=10  AND datepart(day,@vfil_ds_schedule_date2-1)>=10 ) THEN
	     case when  day_10.day_n <> ' Y ' then day_10.day_n
		     when (day_10.day_n  = ' Y '  or isnull(day_10.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<10 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>10 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=10 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=10 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<10  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>10  then ' Y '
		else day_10.day_n end
	    else  day_10.day_n end day_10,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_11.day_n <> ' Y ' then day_11.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_11.day_n  = ' Y '  or isnull(day_11.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<11 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>11 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=11 and
		 isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=11 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<11  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>11  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>11 or datepart(day,@vfil_ds_schedule_date2-1)<11 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<11  AND datepart(day,@vfil_ds_schedule_date2-1)<11 ) or (datepart(day,@vfil_ds_schedule_date)>11  AND datepart(day,@vfil_ds_schedule_date2-1)>11 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=11  AND datepart(day,@vfil_ds_schedule_date2-1)>=11 ) THEN
	     case when  day_11.day_n <> ' Y ' then day_11.day_n
		     when (day_11.day_n  = ' Y '  or isnull(day_11.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<11 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>11 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=11 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=11 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<11  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>11  then ' Y '
		else day_11.day_n end
	    else day_11.day_n end day_11,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_12.day_n <> ' Y ' then day_12.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_12.day_n  = ' Y '  or isnull(day_12.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<12 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>12 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=12 and
		isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=12 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<12  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>12  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>12 or datepart(day,@vfil_ds_schedule_date2-1)<12 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<12  AND datepart(day,@vfil_ds_schedule_date2-1)<12 ) or (datepart(day,@vfil_ds_schedule_date)>12  AND datepart(day,@vfil_ds_schedule_date2-1)>12 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=12  AND datepart(day,@vfil_ds_schedule_date2-1)>=12 ) THEN
	     case when  day_12.day_n <> ' Y ' then day_12.day_n
		     when (day_12.day_n  = ' Y '  or isnull(day_12.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<12 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>12 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=12 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=12 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<12  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>12  then ' Y '
		else day_12.day_n end
	    else day_12.day_n end day_12,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_13.day_n <> ' Y ' then day_13.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_13.day_n  = ' Y '  or isnull(day_13.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<13 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>13 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=13 and
		isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=13 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<13  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>13  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>13 or datepart(day,@vfil_ds_schedule_date2-1)<13 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<13  AND datepart(day,@vfil_ds_schedule_date2-1)<13 ) or (datepart(day,@vfil_ds_schedule_date)>13  AND datepart(day,@vfil_ds_schedule_date2-1)>13 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=13  AND datepart(day,@vfil_ds_schedule_date2-1)>=13 ) THEN
	     case when  day_13.day_n <> ' Y ' then day_13.day_n
		     when (day_13.day_n  = ' Y '  or isnull(day_13.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<13 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>13 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=13 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=13 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<13  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>13  then ' Y '
		else day_13.day_n end
	    else day_13.day_n end day_13,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_14.day_n <> ' Y ' then day_14.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_14.day_n  = ' Y '  or isnull(day_14.day_n,'')='' ) and datepart(day,
		case
		 when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		 when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		 when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<14 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		 when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>14 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		 when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=14 and
		 isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=14 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<14  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>14  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>14 or datepart(day,@vfil_ds_schedule_date2-1)<14 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<14  AND datepart(day,@vfil_ds_schedule_date2-1)<14 ) or (datepart(day,@vfil_ds_schedule_date)>14  AND datepart(day,@vfil_ds_schedule_date2-1)>14 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=14  AND datepart(day,@vfil_ds_schedule_date2-1)>=14 ) THEN
	     case when  day_14.day_n <> ' Y ' then day_14.day_n
		     when (day_14.day_n  = ' Y '  or isnull(day_14.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<14 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>14 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=14 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=14 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<14  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>14  then ' Y '
		else day_14.day_n end
	    else day_14.day_n end day_14,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_15.day_n <> ' Y ' then day_15.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_15.day_n  = ' Y '  or isnull(day_15.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<15 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>15 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=15 and
		isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=15 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<15  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>15  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>15 or datepart(day,@vfil_ds_schedule_date2-1)<15 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<15  AND datepart(day,@vfil_ds_schedule_date2-1)<15 ) or (datepart(day,@vfil_ds_schedule_date)>15  AND datepart(day,@vfil_ds_schedule_date2-1)>15 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=15  AND datepart(day,@vfil_ds_schedule_date2-1)>=15 ) THEN
	     case when  day_15.day_n <> ' Y ' then day_15.day_n
		     when (day_15.day_n  = ' Y '  or isnull(day_15.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<15 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>15 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=15 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=15 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<15  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>15  then ' Y '
		else day_15.day_n end
	    else day_15.day_n end day_15,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_16.day_n <> ' Y ' then day_16.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_16.day_n  = ' Y '  or isnull(day_16.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<16 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>16 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=16 and
		 isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=16 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<16  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>16  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>16 or datepart(day,@vfil_ds_schedule_date2-1)<16 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<16  AND datepart(day,@vfil_ds_schedule_date2-1)<16 ) or (datepart(day,@vfil_ds_schedule_date)>16  AND datepart(day,@vfil_ds_schedule_date2-1)>16 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=16  AND datepart(day,@vfil_ds_schedule_date2-1)>=16 ) THEN
	     case when  day_16.day_n <> ' Y ' then day_16.day_n
		     when (day_16.day_n  = ' Y '  or isnull(day_16.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<16 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>16 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=16 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=16 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<16  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>16  then ' Y '
		else day_16.day_n  end
	    else day_16.day_n end day_16,
	      case
	     when flag='PRN' and len(@vIs_chart)=1  and day_17.day_n <> ' Y ' then day_17.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_17.day_n  = ' Y '  or isnull(day_17.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<17 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>17 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=17 and
		 isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=17 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<17  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>17  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>17 or datepart(day,@vfil_ds_schedule_date2-1)<17 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<17  AND datepart(day,@vfil_ds_schedule_date2-1)<17 ) or (datepart(day,@vfil_ds_schedule_date)>17  AND datepart(day,@vfil_ds_schedule_date2-1)>17 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=17  AND datepart(day,@vfil_ds_schedule_date2-1)>=17 ) THEN
	     case when  day_17.day_n <> ' Y ' then day_17.day_n
		     when (day_17.day_n  = ' Y '  or isnull(day_17.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<17 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>17 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=17 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=17 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<17  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>17  then ' Y '
		else day_17.day_n end
	    else day_17.day_n end  day_17,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_18.day_n <> ' Y ' then day_18.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_18.day_n  = ' Y '  or isnull(day_18.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<18 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>18 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=18 and
		 isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=18 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<18  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>18  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>18 or datepart(day,@vfil_ds_schedule_date2-1)<18 )  then '*'
          when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<18  AND datepart(day,@vfil_ds_schedule_date2-1)<18 ) or (datepart(day,@vfil_ds_schedule_date)>18  AND datepart(day,@vfil_ds_schedule_date2-1)>18 ) ) THEN '*'
		when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=18  AND datepart(day,@vfil_ds_schedule_date2-1)>=18 ) THEN
	     case when  day_18.day_n <> ' Y ' then day_18.day_n
		     when (day_18.day_n  = ' Y '  or isnull(day_18.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<18 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>18 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=18 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=18 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<18  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>18  then ' Y '
		else day_18.day_n end
	    else  day_18.day_n end day_18,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_19.day_n <> ' Y ' then day_19.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_19.day_n  = ' Y '  or isnull(day_19.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<19 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>19 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=19 and
		isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=19 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<19  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>19  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>19 or datepart(day,@vfil_ds_schedule_date2-1)<19 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<19  AND datepart(day,@vfil_ds_schedule_date2-1)<19 ) or (datepart(day,@vfil_ds_schedule_date)>19  AND datepart(day,@vfil_ds_schedule_date2-1)>19 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=19  AND datepart(day,@vfil_ds_schedule_date2-1)>=19 ) THEN
	     case when  day_19.day_n <> ' Y ' then day_19.day_n
		     when (day_19.day_n  = ' Y '  or isnull(day_19.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<19 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>19 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=19 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=19 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<19  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>19  then ' Y '
		else day_19.day_n end
	    else  day_19.day_n end day_19,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_20.day_n <> ' Y ' then day_20.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_20.day_n  = ' Y '  or isnull(day_20.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<20 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>20 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=20 and
		 isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=20 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<20  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>20  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>20 or datepart(day,@vfil_ds_schedule_date2-1)<20 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<20  AND datepart(day,@vfil_ds_schedule_date2-1)<20 ) or (datepart(day,@vfil_ds_schedule_date)>20  AND datepart(day,@vfil_ds_schedule_date2-1)>20 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=20  AND datepart(day,@vfil_ds_schedule_date2-1)>=20 ) THEN
	     case when  day_20.day_n <> ' Y ' then day_20.day_n
		     when (day_20.day_n  = ' Y '  or isnull(day_20.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<20 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>20 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=20 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=20 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<20  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>20  then ' Y '
		else day_20.day_n end
	    else day_20.day_n end day_20,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_21.day_n <> ' Y ' then day_21.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_21.day_n  = ' Y '  or isnull(day_21.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<21 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>21 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=21 and
		 isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=21 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<21  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>21  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>21 or datepart(day,@vfil_ds_schedule_date2-1)<21 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<21  AND datepart(day,@vfil_ds_schedule_date2-1)<21 ) or (datepart(day,@vfil_ds_schedule_date)>21  AND datepart(day,@vfil_ds_schedule_date2-1)>21 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=21  AND datepart(day,@vfil_ds_schedule_date2-1)>=21 ) THEN
	     case when  day_21.day_n <> ' Y ' then day_21.day_n
		     when (day_21.day_n  = ' Y '  or isnull(day_21.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<21 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>21 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=21 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=21 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<21  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>21  then ' Y '
		else day_21.day_n end
	    else day_21.day_n end day_21,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_22.day_n <> ' Y ' then day_22.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_22.day_n  = ' Y '  or isnull(day_22.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<22 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>22 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		 when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=22 and
		   isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=22 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<22  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>22  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>22 or datepart(day,@vfil_ds_schedule_date2-1)<22 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<22  AND datepart(day,@vfil_ds_schedule_date2-1)<22 ) or (datepart(day,@vfil_ds_schedule_date)>22  AND datepart(day,@vfil_ds_schedule_date2-1)>22 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=22  AND datepart(day,@vfil_ds_schedule_date2-1)>=22 ) THEN
	     case when  day_22.day_n <> ' Y ' then day_22.day_n
		     when (day_22.day_n  = ' Y '  or isnull(day_22.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<22 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>22 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=22 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=22 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<22  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>22  then ' Y '
		else day_22.day_n end
	    else day_22.day_n end day_22,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_23.day_n <> ' Y ' then day_23.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_23.day_n  = ' Y '  or isnull(day_23.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<23 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>23 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=23 and
		isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=23 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<23  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>23  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>23 or datepart(day,@vfil_ds_schedule_date2-1)<23 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<23  AND datepart(day,@vfil_ds_schedule_date2-1)<23 ) or (datepart(day,@vfil_ds_schedule_date)>23  AND datepart(day,@vfil_ds_schedule_date2-1)>23 ) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=23  AND datepart(day,@vfil_ds_schedule_date2-1)>=23 ) THEN
	     case when  day_23.day_n <> ' Y ' then day_23.day_n
		     when (day_23.day_n  = ' Y '  or isnull(day_23.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<23 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>23 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=23 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=23 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<23  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>23  then ' Y '
		else day_23.day_n end
	    else day_23.day_n end day_23,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_24.day_n <> ' Y ' then day_24.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_24.day_n  = ' Y '  or isnull(day_24.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<24 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>24 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=24 and
		 isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=24 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<24  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>24  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>24 or datepart(day,@vfil_ds_schedule_date2-1)<24)  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<24  AND datepart(day,@vfil_ds_schedule_date2-1)<24 ) or (datepart(day,@vfil_ds_schedule_date)>24  AND datepart(day,@vfil_ds_schedule_date2-1)>24) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=24  AND datepart(day,@vfil_ds_schedule_date2-1)>=24 ) THEN
	     case when  day_24.day_n <> ' Y ' then day_24.day_n
		     when (day_24.day_n  = ' Y '  or isnull(day_24.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<24 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>24 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=24 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=24 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<24  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>24  then ' Y '
		else day_24.day_n end
	    else day_24.day_n end day_24,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_25.day_n <> ' Y ' then day_25.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_25.day_n  = ' Y '  or isnull(day_25.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<25 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>25 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=25 and
		 isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=25 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<25  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>25  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>25 or datepart(day,@vfil_ds_schedule_date2-1)<25 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<25  AND datepart(day,@vfil_ds_schedule_date2-1)<25 ) or (datepart(day,@vfil_ds_schedule_date)>25  AND datepart(day,@vfil_ds_schedule_date2-1)>25) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=25  AND datepart(day,@vfil_ds_schedule_date2-1)>=25 ) THEN
	     case when  day_25.day_n <> ' Y ' then day_25.day_n
		     when (day_25.day_n  = ' Y '  or isnull(day_25.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<25 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>25 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=25 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=25 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<25  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>25  then ' Y '
		else day_25.day_n end
	    else day_25.day_n end day_25,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_26.day_n <> ' Y ' then day_26.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_26.day_n  = ' Y '  or isnull(day_26.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<26 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>26 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=26 and
		isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=26 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<26  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>26  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>26 or datepart(day,@vfil_ds_schedule_date2-1)<26 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<26  AND datepart(day,@vfil_ds_schedule_date2-1)<26 ) or (datepart(day,@vfil_ds_schedule_date)>26  AND datepart(day,@vfil_ds_schedule_date2-1)>26) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=26  AND datepart(day,@vfil_ds_schedule_date2-1)>=26 ) THEN
	     case when  day_26.day_n <> ' Y ' then day_26.day_n
		     when (day_26.day_n  = ' Y '  or isnull(day_26.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<26 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>26 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=26 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=26 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<26  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>26  then ' Y '
		else day_26.day_n  end
	    else day_26.day_n end day_26,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_27.day_n <> ' Y ' then day_27.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_27.day_n  = ' Y '  or isnull(day_27.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<27 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>27 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=27 and
		 isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=27 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<27  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>27  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>27 or datepart(day,@vfil_ds_schedule_date2-1)<27 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<27  AND datepart(day,@vfil_ds_schedule_date2-1)<27 ) or (datepart(day,@vfil_ds_schedule_date)>27  AND datepart(day,@vfil_ds_schedule_date2-1)>27) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=27  AND datepart(day,@vfil_ds_schedule_date2-1)>=27 ) THEN
	     case when  day_27.day_n <> ' Y ' then day_27.day_n
		     when (day_27.day_n  = ' Y '  or isnull(day_27.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<27 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>27 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=27 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=27 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<27  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>27  then ' Y '
		else day_27.day_n end
	    else day_27.day_n end day_27,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_28.day_n <> ' Y ' then day_28.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_28.day_n  = ' Y '  or isnull(day_28.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<28 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>28 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=28 and
		 isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=28 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<28  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>28  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>28 or datepart(day,@vfil_ds_schedule_date2-1)<28 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<28  AND datepart(day,@vfil_ds_schedule_date2-1)<28 ) or (datepart(day,@vfil_ds_schedule_date)>28  AND datepart(day,@vfil_ds_schedule_date2-1)>28) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=28  AND datepart(day,@vfil_ds_schedule_date2-1)>=28 ) THEN
	     case when  day_28.day_n <> ' Y ' then day_28.day_n
		     when (day_28.day_n  = ' Y '  or isnull(day_28.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<28 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>28 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=28 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=28 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<28 then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>28  then ' Y '
		else day_28.day_n end
	    else day_28.day_n end day_28,
	   case
	     when flag='PRN' and len(@vIs_chart)=1  and day_29.day_n <> ' Y ' then day_29.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_29.day_n  = ' Y '  or isnull(day_29.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<29 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>29 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=29 and
		  isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=29 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<29  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>29  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>29 or datepart(day,@vfil_ds_schedule_date2-1)<29 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<29  AND datepart(day,@vfil_ds_schedule_date2-1)<29 ) or (datepart(day,@vfil_ds_schedule_date)>29  AND datepart(day,@vfil_ds_schedule_date2-1)>29) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=29  AND datepart(day,@vfil_ds_schedule_date2-1)>=29 ) THEN
	     case when  day_29.day_n <> ' Y ' then day_29.day_n
		     when (day_29.day_n  = ' Y '  or isnull(day_29.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<29 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>29 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=29 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=20 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<29  then resolved_date else schedule_end_date end  ),datepart(day,DATEADD(d,-1,DATEADD(mm, DATEDIFF(m,0,@vfil_ds_schedule_date)+1,0))))>29  then ' Y '
		else day_29.day_n end
	    else  day_29.day_n end day_29,
	    case
	     when flag='PRN' and len(@vIs_chart)=1  and day_30.day_n <> ' Y ' then day_30.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_30.day_n  = ' Y '  or isnull(day_30.day_n,'')='' ) and
		datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<30 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>30 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=30 and
		isnull(datepart(day,
		case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=30 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<30  then resolved_date else schedule_end_date end  ),31)>30  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>30 or datepart(day,@vfil_ds_schedule_date2-1)<30 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<30  AND datepart(day,@vfil_ds_schedule_date2-1)<30 ) or (datepart(day,@vfil_ds_schedule_date)>30  AND 31>30) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=30  AND datepart(day,@vfil_ds_schedule_date2-1)>=30 ) THEN
	     case when  day_30.day_n <> ' Y ' then day_30.day_n
		     when (day_30.day_n  = ' Y '  or isnull(day_30.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<30 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>30 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=30 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=30 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<30  then resolved_date else schedule_end_date end  ),31)>30  then ' Y '
		else day_30.day_n end
	    else day_30.day_n end day_30,
	   case
	     when flag='PRN' and len(@vIs_chart)=1  and day_31.day_n <> ' Y ' then day_31.day_n
		when flag='PRN' and len(@vIs_chart)=1  and (day_31.day_n  = ' Y '  or isnull(day_31.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date2 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)<31 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and datepart(day,schedule_end_date)>31 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=31 and
		 isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_schedule_date2  and  datepart(day,schedule_end_date)>=31 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_schedule_date2 and  datepart(day,resolved_date)<31  then resolved_date else schedule_end_date end  ),32)>31  then ' Y '
		when len(@vIs_chart)>1 and flag<>'PRN' and (datepart(day,@vfil_ds_schedule_date)>31 or datepart(day,@vfil_ds_schedule_date2-1)<31 )  then '*'
		when len(@vIs_chart)>1 and flag='PRN'  and ((datepart(day,@vfil_ds_schedule_date)<31  AND datepart(day,@vfil_ds_schedule_date2-1)<31 ) or (datepart(day,@vfil_ds_schedule_date)>31  AND 32>31) ) THEN '*'
          when len(@vIs_chart)>1 and flag='PRN'  and (datepart(day,@vfil_ds_schedule_date)<=31  AND datepart(day,@vfil_ds_schedule_date2-1)>=31 ) THEN
	     case when  day_31.day_n <> ' Y ' then day_31.day_n
		     when (day_31.day_n  = ' Y '  or isnull(day_31.day_n,'')='' ) and datepart(day,
		case
		when schedule_end_date is null and  schedule_start_date<=@vfil_ds_schedule_date then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_last_day_of_month  and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime)  then @vfil_ds_schedule_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)<31 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and datepart(day,schedule_end_date)>31 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then @vfil_ds_schedule_date
		when month(schedule_start_date)=month(@vfil_ds_schedule_date) and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then client.admission_date else schedule_start_date end  )<=31 and

	     isnull(datepart(day, case
		when schedule_end_date is not null and schedule_end_date>=@vfil_ds_schedule_date and schedule_end_date<@vfil_ds_last_day_of_month  and  datepart(day,schedule_end_date)>=31 and cast(convert(varchar(20),schedule_start_date,101) as datetime)<cast(convert(varchar(20),client.admission_date)as datetime) then schedule_end_date
		when schedule_end_date is null and resolved_date>=@vfil_ds_schedule_date and resolved_date<@vfil_ds_last_day_of_month and  datepart(day,resolved_date)<31  then resolved_date else schedule_end_date end  ),32)>31  then ' Y '
		else day_31.day_n end
	    else day_31.day_n end day_31

  from
  cte_main cte
  inner join  #PRP_ClientList client on client.client_id=cte.client_id
  left join #PRP_ds_interventions b
 on cte.std_intervention_id=b.std_intervention_id
 and cte.gen_intervention_id=b.gen_intervention_id
 and cte.intervention_id=b.intervention_id
  left join @QuestionXML	 inter
   on inter.stdinterventionid=cte.std_intervention_id
  and inter.interventionid=cte.intervention_id
  and inter.geninterventionid=cte.gen_intervention_id
  left join   @dayTable  day_1
  on cte.client_id= day_1.client_id and cte.shift_name=day_1.shift_name
  and  cte.std_intervention_id=day_1.std_intervention_id
  and  cte.gen_intervention_id=day_1.gen_intervention_id
  and  cte.intervention_id=day_1.intervention_id
  and  cte.fac_id=day_1.fac_id
   and  cte.row_id=day_1.row_id
   and  cte.seq=day_1.seq
   and day_1.day_of_month=1
  left join   @dayTable  day_2
  on cte.client_id= day_2.client_id and cte.shift_name=day_2.shift_name
  and  cte.std_intervention_id=day_2.std_intervention_id
  and  cte.gen_intervention_id=day_2.gen_intervention_id
  and  cte.intervention_id=day_2.intervention_id
  and  cte.fac_id=day_2.fac_id
   and  cte.row_id=day_2.row_id
   and  cte.seq=day_2.seq
   and day_2.day_of_month=2
 left join   @dayTable  day_3
  on cte.client_id= day_3.client_id and cte.shift_name=day_3.shift_name
  and  cte.std_intervention_id=day_3.std_intervention_id
  and  cte.gen_intervention_id=day_3.gen_intervention_id
  and  cte.intervention_id=day_3.intervention_id
  and  cte.fac_id=day_3.fac_id
   and  cte.row_id=day_3.row_id
   and  cte.seq=day_3.seq
   and day_3.day_of_month=3
 left join   @dayTable  day_4
  on cte.client_id= day_4.client_id and cte.shift_name=day_4.shift_name
  and  cte.std_intervention_id=day_4.std_intervention_id
  and  cte.gen_intervention_id=day_4.gen_intervention_id
  and  cte.intervention_id=day_4.intervention_id
  and  cte.fac_id=day_4.fac_id
   and  cte.row_id=day_4.row_id
   and  cte.seq=day_4.seq
   and day_4.day_of_month=4
 left join   @dayTable  day_5
  on cte.client_id= day_5.client_id and cte.shift_name=day_5.shift_name
  and  cte.std_intervention_id=day_5.std_intervention_id
  and  cte.gen_intervention_id=day_5.gen_intervention_id
  and  cte.intervention_id=day_5.intervention_id
  and  cte.fac_id=day_5.fac_id
   and  cte.row_id=day_5.row_id
   and  cte.seq=day_5.seq
   and day_5.day_of_month=5
 left join   @dayTable  day_6
  on cte.client_id= day_6.client_id and cte.shift_name=day_6.shift_name
  and  cte.std_intervention_id=day_6.std_intervention_id
  and  cte.gen_intervention_id=day_6.gen_intervention_id
  and  cte.intervention_id=day_6.intervention_id
  and  cte.fac_id=day_6.fac_id
   and  cte.row_id=day_6.row_id
   and  cte.seq=day_6.seq
   and day_6.day_of_month=6
 left join   @dayTable  day_7
  on cte.client_id= day_7.client_id and cte.shift_name=day_7.shift_name
  and  cte.std_intervention_id=day_7.std_intervention_id
  and  cte.gen_intervention_id=day_7.gen_intervention_id
  and  cte.intervention_id=day_7.intervention_id
  and  cte.fac_id=day_7.fac_id
   and  cte.row_id=day_7.row_id
   and  cte.seq=day_7.seq
   and day_7.day_of_month=7
 left join   @dayTable  day_8
  on cte.client_id= day_8.client_id and cte.shift_name=day_8.shift_name
  and  cte.std_intervention_id=day_8.std_intervention_id
  and  cte.gen_intervention_id=day_8.gen_intervention_id
  and  cte.intervention_id=day_8.intervention_id
  and  cte.fac_id=day_8.fac_id
   and  cte.row_id=day_8.row_id
   and  cte.seq=day_8.seq
   and day_8.day_of_month=8
 left join   @dayTable  day_9
  on cte.client_id= day_9.client_id and cte.shift_name=day_9.shift_name
  and  cte.std_intervention_id=day_9.std_intervention_id
  and  cte.gen_intervention_id=day_9.gen_intervention_id
  and  cte.intervention_id=day_9.intervention_id
  and  cte.fac_id=day_9.fac_id
   and  cte.row_id=day_9.row_id
   and  cte.seq=day_9.seq
   and day_9.day_of_month=9
 left join   @dayTable  day_10
  on cte.client_id= day_10.client_id and cte.shift_name=day_10.shift_name
  and  cte.std_intervention_id=day_10.std_intervention_id
  and  cte.gen_intervention_id=day_10.gen_intervention_id
  and  cte.intervention_id=day_10.intervention_id
  and  cte.fac_id=day_10.fac_id
   and  cte.row_id=day_10.row_id
   and  cte.seq=day_10.seq
   and day_10.day_of_month=10
 left join   @dayTable  day_11
  on cte.client_id= day_11.client_id and cte.shift_name=day_11.shift_name
  and  cte.std_intervention_id=day_11.std_intervention_id
  and  cte.gen_intervention_id=day_11.gen_intervention_id
  and  cte.intervention_id=day_11.intervention_id
  and  cte.fac_id=day_11.fac_id
   and  cte.row_id=day_11.row_id
   and  cte.seq=day_11.seq
   and day_11.day_of_month=11
 left join   @dayTable  day_12
  on cte.client_id= day_12.client_id and cte.shift_name=day_12.shift_name
  and  cte.std_intervention_id=day_12.std_intervention_id
  and  cte.gen_intervention_id=day_12.gen_intervention_id
  and  cte.intervention_id=day_12.intervention_id
  and  cte.fac_id=day_12.fac_id
   and  cte.row_id=day_12.row_id
   and  cte.seq=day_12.seq
   and day_12.day_of_month=12
 left join   @dayTable  day_13
  on cte.client_id= day_13.client_id and cte.shift_name=day_13.shift_name
  and  cte.std_intervention_id=day_13.std_intervention_id
  and  cte.gen_intervention_id=day_13.gen_intervention_id
  and  cte.intervention_id=day_13.intervention_id
  and  cte.fac_id=day_13.fac_id
   and  cte.row_id=day_13.row_id
   and  cte.seq=day_13.seq
   and day_13.day_of_month=13
 left join   @dayTable  day_14
  on cte.client_id= day_14.client_id and cte.shift_name=day_14.shift_name
  and  cte.std_intervention_id=day_14.std_intervention_id
  and  cte.gen_intervention_id=day_14.gen_intervention_id
  and  cte.intervention_id=day_14.intervention_id
  and  cte.fac_id=day_14.fac_id
   and  cte.row_id=day_14.row_id
   and  cte.seq=day_14.seq
   and day_14.day_of_month=14
 left join   @dayTable  day_15
  on cte.client_id= day_15.client_id and cte.shift_name=day_15.shift_name
  and  cte.std_intervention_id=day_15.std_intervention_id
  and  cte.gen_intervention_id=day_15.gen_intervention_id
  and  cte.intervention_id=day_15.intervention_id
  and  cte.fac_id=day_15.fac_id
   and  cte.row_id=day_15.row_id
   and  cte.seq=day_15.seq
   and day_15.day_of_month=15
 left join   @dayTable  day_16
  on cte.client_id= day_16.client_id and cte.shift_name=day_16.shift_name
  and  cte.std_intervention_id=day_16.std_intervention_id
  and  cte.gen_intervention_id=day_16.gen_intervention_id
  and  cte.intervention_id=day_16.intervention_id
  and  cte.fac_id=day_16.fac_id
   and  cte.row_id=day_16.row_id
   and  cte.seq=day_16.seq
   and day_16.day_of_month=16
 left join   @dayTable  day_17
  on cte.client_id= day_17.client_id and cte.shift_name=day_17.shift_name
  and  cte.std_intervention_id=day_17.std_intervention_id
  and  cte.gen_intervention_id=day_17.gen_intervention_id
  and  cte.intervention_id=day_17.intervention_id
  and  cte.fac_id=day_17.fac_id
   and  cte.row_id=day_17.row_id
   and  cte.seq=day_17.seq
   and day_17.day_of_month=17
 left join   @dayTable  day_18
  on cte.client_id= day_18.client_id and cte.shift_name=day_18.shift_name
  and  cte.std_intervention_id=day_18.std_intervention_id
  and  cte.gen_intervention_id=day_18.gen_intervention_id
  and  cte.intervention_id=day_18.intervention_id
  and  cte.fac_id=day_18.fac_id
   and  cte.row_id=day_18.row_id
   and  cte.seq=day_18.seq
   and day_18.day_of_month=18
 left join   @dayTable  day_19
  on cte.client_id= day_19.client_id and cte.shift_name=day_19.shift_name
  and  cte.std_intervention_id=day_19.std_intervention_id
  and  cte.gen_intervention_id=day_19.gen_intervention_id
  and  cte.intervention_id=day_19.intervention_id
  and  cte.fac_id=day_19.fac_id
   and  cte.row_id=day_19.row_id
   and  cte.seq=day_19.seq
   and day_19.day_of_month=19
 left join   @dayTable  day_20
  on cte.client_id= day_20.client_id and cte.shift_name=day_20.shift_name
  and  cte.std_intervention_id=day_20.std_intervention_id
  and  cte.gen_intervention_id=day_20.gen_intervention_id
  and  cte.intervention_id=day_20.intervention_id
  and  cte.fac_id=day_20.fac_id
   and  cte.row_id=day_20.row_id
   and  cte.seq=day_20.seq
   and day_20.day_of_month=20
 left join   @dayTable  day_21
  on cte.client_id= day_21.client_id and cte.shift_name=day_21.shift_name
  and  cte.std_intervention_id=day_21.std_intervention_id
  and  cte.gen_intervention_id=day_21.gen_intervention_id
  and  cte.intervention_id=day_21.intervention_id
  and  cte.fac_id=day_21.fac_id
   and  cte.row_id=day_21.row_id
   and  cte.seq=day_21.seq
   and day_21.day_of_month=21
 left join   @dayTable  day_22
  on cte.client_id= day_22.client_id and cte.shift_name=day_22.shift_name
  and  cte.std_intervention_id=day_22.std_intervention_id
  and  cte.gen_intervention_id=day_22.gen_intervention_id
  and  cte.intervention_id=day_22.intervention_id
  and  cte.fac_id=day_22.fac_id
   and  cte.row_id=day_22.row_id
   and  cte.seq=day_22.seq
   and day_22.day_of_month=22
 left join   @dayTable  day_23
  on cte.client_id= day_23.client_id and cte.shift_name=day_23.shift_name
  and  cte.std_intervention_id=day_23.std_intervention_id
  and  cte.gen_intervention_id=day_23.gen_intervention_id
  and  cte.intervention_id=day_23.intervention_id
  and  cte.fac_id=day_23.fac_id
   and  cte.row_id=day_23.row_id
   and  cte.seq=day_23.seq
   and day_23.day_of_month=23
 left join   @dayTable  day_24
  on cte.client_id= day_24.client_id and cte.shift_name=day_24.shift_name
  and  cte.std_intervention_id=day_24.std_intervention_id
  and  cte.gen_intervention_id=day_24.gen_intervention_id
  and  cte.intervention_id=day_24.intervention_id
  and  cte.fac_id=day_24.fac_id
   and  cte.row_id=day_24.row_id
   and  cte.seq=day_24.seq
   and day_24.day_of_month=24
 left join   @dayTable  day_25
  on cte.client_id= day_25.client_id and cte.shift_name=day_25.shift_name
  and  cte.std_intervention_id=day_25.std_intervention_id
  and  cte.gen_intervention_id=day_25.gen_intervention_id
  and  cte.intervention_id=day_25.intervention_id
  and  cte.fac_id=day_25.fac_id
   and  cte.row_id=day_25.row_id
   and  cte.seq=day_25.seq
   and day_25.day_of_month=25
 left join   @dayTable  day_26
  on cte.client_id= day_26.client_id and cte.shift_name=day_26.shift_name
  and  cte.std_intervention_id=day_26.std_intervention_id
  and  cte.gen_intervention_id=day_26.gen_intervention_id
  and  cte.intervention_id=day_26.intervention_id
  and  cte.fac_id=day_26.fac_id
   and  cte.row_id=day_26.row_id
   and  cte.seq=day_26.seq
   and day_26.day_of_month=26
 left join   @dayTable  day_27
  on cte.client_id= day_27.client_id and cte.shift_name=day_27.shift_name
  and  cte.std_intervention_id=day_27.std_intervention_id
  and  cte.gen_intervention_id=day_27.gen_intervention_id
  and  cte.intervention_id=day_27.intervention_id
  and  cte.fac_id=day_27.fac_id
   and  cte.row_id=day_27.row_id
   and  cte.seq=day_27.seq
   and day_27.day_of_month=27
 left join   @dayTable  day_28
  on cte.client_id= day_28.client_id and cte.shift_name=day_28.shift_name
  and  cte.std_intervention_id=day_28.std_intervention_id
  and  cte.gen_intervention_id=day_28.gen_intervention_id
  and  cte.intervention_id=day_28.intervention_id
  and  cte.fac_id=day_28.fac_id
   and  cte.row_id=day_28.row_id
   and  cte.seq=day_28.seq
   and day_28.day_of_month=28
 left join   @dayTable  day_29
  on cte.client_id= day_29.client_id and cte.shift_name=day_29.shift_name
  and  cte.std_intervention_id=day_29.std_intervention_id
  and  cte.gen_intervention_id=day_29.gen_intervention_id
  and  cte.intervention_id=day_29.intervention_id
  and  cte.fac_id=day_29.fac_id
   and  cte.row_id=day_29.row_id
   and  cte.seq=day_29.seq
   and day_29.day_of_month=29
 left join   @dayTable  day_30
  on cte.client_id= day_30.client_id and cte.shift_name=day_30.shift_name
  and  cte.std_intervention_id=day_30.std_intervention_id
  and  cte.gen_intervention_id=day_30.gen_intervention_id
  and  cte.intervention_id=day_30.intervention_id
  and  cte.fac_id=day_30.fac_id
   and  cte.row_id=day_30.row_id
   and  cte.seq=day_30.seq
   and day_30.day_of_month=30
 left join   @dayTable  day_31
  on cte.client_id= day_31.client_id and cte.shift_name=day_31.shift_name
  and  cte.std_intervention_id=day_31.std_intervention_id
  and  cte.gen_intervention_id=day_31.gen_intervention_id
  and  cte.intervention_id=day_31.intervention_id
  and  cte.fac_id=day_31.fac_id
   and  cte.row_id=day_31.row_id
   and  cte.seq=day_31.seq
   and day_31.day_of_month=31

 where cte.flag in ('Prn','Qshift')   ;

  if @debug_me='h' Print 'STEP1_H ' +   ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@step_start_time,getdate()))))+ ' ms'


if @debug_me = 'Y'
select '#PRP_ds_interv_schedule_cte(prn,Qshift)' ,* from  #PRP_ds_interv_schedule_cte   order by seq,seq_name,client_id,gen_intervention_id,
	   intervention_id,std_intervention_id,shift_name

SELECT @vStep = 27, @vStepName = 'Handeling Multi Documentation PRN and Qshift  ', @step_start_time = getdate()
 IF @debug_me='h' PRINT 'BEGIN STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' Handeling Multi Documentation PRN and Qshift   at ' + CONVERT(VARCHAR, @step_start_time)


INSERT INTO #PRP_ds_interv_schedule_cte (row_type,row_id,seq,seq_name,fac_id,client_id,client_name,gen_intervention_id,intervention_id,std_intervention_id ,intervention_desc,text1,schedule_id ,shift_name	,schedule_time	,
							 day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15,
							 day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30,
							 day_31,document_id )
select
2 row_type,
       null row_id,
        seq,
	    poc.flag ,
	   poc.fac_id,
        poc.client_id,
	   client.client_name,
	   poc.gen_intervention_id,
	   poc.intervention_id,
        poc.std_intervention_id,
	   poc.text1,inter.text1	,
        schedule_id,
        shift_name,
 	          max(case when flag in ('Schedule','unscheduled') then +cast (schedule_time as varchar)  else ' Y ' end )	,

	  Replace (Isnull(max( case when day_of_month=1 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=1 and
							           datepart(day,schedule_end_date)>=1 and doc='') then ' Y '
		when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>1  or datepart(day,@vfil_ds_schedule_date2-1)<1 )  then '*'  end end),'X'),' Y ','') as day_1,

	 Replace (Isnull(max( case when day_of_month=2 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=2 and
							           datepart(day,schedule_end_date)>=2 and doc='') then ' Y '
		 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>2  or datepart(day,@vfil_ds_schedule_date2-1)<2 )  then '*'  end end),'X'),' Y ','') as day_2,

	 Replace (Isnull(max( case when day_of_month=3 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=3 and
							           datepart(day,schedule_end_date)>=3 and doc='') then ' Y '
		when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>3  or datepart(day,@vfil_ds_schedule_date2-1)<3 )  then '*' end end),'X'),' Y ','') as day_3,

	 Replace (Isnull(max( case when day_of_month=4 THEN case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                            ( datepart(day,schedule_date)<=4 and
							           datepart(day,schedule_end_date)>=4 and doc='') then ' Y '
		 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>4  or datepart(day,@vfil_ds_schedule_date2-1)<4 )  then '*'   end end),'X'),' Y ','') as day_4,

	 Replace (Isnull(max(

	 case when day_of_month=5 THEN   case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=5 and
							           datepart(day,schedule_end_date)>=5 and doc='') then ' Y '
		 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>5  or datepart(day,@vfil_ds_schedule_date2-1)<5 )  then '*' end end),'X'),' Y ','') as day_5,

	 Replace (Isnull(max(  case when day_of_month=6 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end 	 else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=6 and
							           datepart(day,schedule_end_date)>=6 and doc='') then ' Y '
		when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>6  or datepart(day,@vfil_ds_schedule_date2-1)<6 )  then '*'  end end),'X'),' Y ','') as day_6,

	 Replace (Isnull(max( case  when day_of_month=7 THEN case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=7 and
							           datepart(day,schedule_end_date)>=7 and doc='') then ' Y '
	      when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>7  or datepart(day,@vfil_ds_schedule_date2-1)<7 )  then '*'  end end),'X'),' Y ','') as day_7,

	 Replace (Isnull(max( case when day_of_month=8 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=8 and
							           datepart(day,schedule_end_date)>=8 and doc='') then ' Y '
		 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>8  or datepart(day,@vfil_ds_schedule_date2-1)<8 )  then '*'   end end),'X'),' Y ','') as day_8,

	 Replace (Isnull(max( case when day_of_month=9 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=9 and
							           datepart(day,schedule_end_date)>=9 and doc='')  then ' Y '
		when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>9  or datepart(day,@vfil_ds_schedule_date2-1)<9 )  then '*'  end end),'X'),' Y ','') as day_9,

	 Replace (Isnull(max( case when day_of_month=10 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration' and   datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=10 and
							           datepart(day,schedule_end_date)>=10 and doc='') then ' Y '
		 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>10  or datepart(day,@vfil_ds_schedule_date2-1)<10 )  then '*'  end end),'X'),' Y ','') as day_10,

	 Replace (Isnull(max( case when day_of_month=11 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=11 and
							           datepart(day,schedule_end_date)>=11 and doc='') then ' Y '
		 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>11  or datepart(day,@vfil_ds_schedule_date2-1)<11 )  then '*'  end end),'X'),' Y ','') as day_11,

	 Replace (Isnull(max( case when day_of_month=12 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	 when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=12 and
							           datepart(day,schedule_end_date)>=12 and doc='') then ' Y '
	when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>12  or datepart(day,@vfil_ds_schedule_date2-1)<12 )  then '*'  end end),'X'),' Y ','') as day_12,

	 Replace (Isnull(max( case when day_of_month=13 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end	 else case

	 when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=13 and
							           datepart(day,schedule_end_date)>=13 and doc='') then ' Y '
	 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>13  or datepart(day,@vfil_ds_schedule_date2-1)<13 )  then '*'  end end),'X'),' Y ','') as day_13,

	 Replace (Isnull(max( case when day_of_month=14 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end  else  case

	     when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=14 and
							           datepart(day,schedule_end_date)>=14 and doc='') then ' Y '
		when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>14  or datepart(day,@vfil_ds_schedule_date2-1)<14 )  then '*'   end end  ),'X'),' Y ','') as day_14
									 ,

	 Replace (Isnull(max( case when day_of_month=15 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	     when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=15 and
							           datepart(day,schedule_end_date)>=15 and doc='') then ' Y '
		when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>15  or datepart(day,@vfil_ds_schedule_date2-1)<15 ) then '*'
		end end),'X'),' Y ','') as day_15
									 ,

	 Replace (Isnull(max( case when day_of_month=16 THEN case when isnull(doc,'') = '' then  ' Y ' else  doc end	 else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=16 and
							           datepart(day,schedule_end_date)>=16 and doc='') then ' Y '
		 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>16  or datepart(day,@vfil_ds_schedule_date2-1)<16 )  then '*' end end),'X'),' Y ','') as day_16,

	 Replace (Isnull(max( case when day_of_month=17 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=17 and
							           datepart(day,schedule_end_date)>=17 and doc='') then ' Y '
		 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>17  or datepart(day,@vfil_ds_schedule_date2-1)<17 )  then '*'  end end),'X'),' Y ','') as day_17,

	 Replace (Isnull(max( case when day_of_month=18 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=18 and
							           datepart(day,schedule_end_date)>=18 and doc='') then ' Y '
		 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>18  or datepart(day,@vfil_ds_schedule_date2-1)<18 )  then '*'  end end),'X'),' Y ','') as day_18,

	 Replace (Isnull(max( case when day_of_month=19 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=19 and
							           datepart(day,schedule_end_date)>=19 and doc='') then ' Y '
		 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>19  or datepart(day,@vfil_ds_schedule_date2-1)<19 )  then '*'  end end),'X'),' Y ','') as day_19,

	 Replace (Isnull(max( case when day_of_month=20 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=20 and
							           datepart(day,schedule_end_date)>=20 and doc='') then ' Y '
		 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>20  or datepart(day,@vfil_ds_schedule_date2-1)<20 )  then '*'  end end),'X'),' Y ','') as day_20,

	 Replace (Isnull(max( case when day_of_month=21 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=21 and
							           datepart(day,schedule_end_date)>=21 and doc='') then ' Y '
		 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>21  or datepart(day,@vfil_ds_schedule_date2-1)<21 )  then '*' end end),'X'),' Y ','') as day_21,

	 Replace (Isnull(max( case when day_of_month=22 THEN case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=22 and
							           datepart(day,schedule_end_date)>=22 and doc='') then ' Y '
		 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>22  or datepart(day,@vfil_ds_schedule_date2-1)<22 )  then '*'  end end),'X'),' Y ','') as day_22,

	 Replace (Isnull(max( case when day_of_month=23 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=23 and
							           datepart(day,schedule_end_date)>=23 and doc='')then ' Y '
		when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>23  or datepart(day,@vfil_ds_schedule_date2-1)<23 )  then '*'  end end),'X'),' Y ','') as day_23,

	 Replace (Isnull(max( case when day_of_month=24 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=24 and
							           datepart(day,schedule_end_date)>=24 and doc='') then ' Y '
		 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>24  or datepart(day,@vfil_ds_schedule_date2-1)<24 )  then '*'  end end),'X'),' Y ','') as day_24,

	 Replace (Isnull(max( case when day_of_month=25 THEN case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	case
	     when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=25 and
							           datepart(day,schedule_end_date)>=25 and doc='') then ' Y '
		when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>25  or datepart(day,@vfil_ds_schedule_date2-1)<25 )  then '*'  end end),'X'),' Y ','') as day_25,

	 Replace (Isnull(max( case when day_of_month=26 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=26 and
							           datepart(day,schedule_end_date)>=26 and doc='') then ' Y '
		 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>26  or datepart(day,@vfil_ds_schedule_date2-1)<26 )  then '*'  end end),'X'),' Y ','') as day_26,

	 Replace (Isnull(max( case when day_of_month=27 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end	 else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=27 and
							           datepart(day,schedule_end_date)>=27 and doc='') then ' Y '
		when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>27  or datepart(day,@vfil_ds_schedule_date2-1)<27 )  then '*'   end end),'X'),' Y ','') as day_27,

	 Replace (Isnull(max( case when day_of_month=28 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=28 and
							           datepart(day,schedule_end_date)>=28 and doc='') then ' Y '
		 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>28  or datepart(day,@vfil_ds_schedule_date2-1)<28 )  then '*'  end end),'X'),' Y ','') as day_28,

	 Replace (Isnull(max( case when day_of_month=29 THEN  case when  doc='' then ' Y ' else doc end	 else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=29 and
							           datepart(day,schedule_end_date)>=29 and doc='') then ' Y '
		when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>29  or datepart(day,@vfil_ds_schedule_date2-1)<29 )  then '*'   end end),'X'),' Y ','') as day_29,

	 Replace (Isnull(max( case when day_of_month=30 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=30 and
							           datepart(day,schedule_end_date)>=30 and doc='') then ' Y '
		when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>30  or datepart(day,@vfil_ds_schedule_date2-1)<30 )  then '*'  end end),'X'),' Y ','') as day_30,

	 Replace (Isnull(max( case when day_of_month=31 THEN  case when isnull(doc,'') = '' then  ' Y ' else  doc end else
	 case
	      when flag='Duration'   and datepart(day,schedule_date)<=datepart(day,schedule_end_date) and
		                             ( datepart(day,schedule_date)<=31 and
							           datepart(day,schedule_end_date)>=31 and doc='') then ' Y '
		 when len(@vIs_chart)>1 and (datepart(day,@vfil_ds_schedule_date)>31  or datepart(day,@vfil_ds_schedule_date2-1)<31 )  then '*'  end end),'X'),' Y ','') as day_31
	, null documentation_id
from  #poc	 poc
inner join  #PRP_ClientList client on client.client_id=poc.client_id
left join @QuestionXML	 inter on
  inter.stdinterventionid=poc.std_intervention_id
  and inter.interventionid=poc.intervention_id
  and inter.geninterventionid=poc.gen_intervention_id
where poc.flag not in ('PRN','Qshift')
 group by seq,
	   fac_id,
        poc.client_id,
	   client.client_name,
        poc.std_intervention_id,poc.gen_intervention_id,
	   poc.intervention_id,inter.text1,poc.text1,
        schedule_id,
	   schedule_time,
        shift_name,
        flag;

  if @debug_me='h' Print 'STEP1_H ' +   ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@step_start_time,getdate()))))+ ' ms'



if @debug_me = 'Y'
select '#PRP_ds_interv_schedule_cte(other)' PRP_ds_interv_schedule_cteother ,* from  #PRP_ds_interv_schedule_cte   order by seq,seq_name,client_id,gen_intervention_id,
	   intervention_id,std_intervention_id,shift_name


  --- Final Schedule table

INSERT INTO @PRP_ds_interv_schedule (row_type,row_id,seq,seq_name,fac_id,client_id,client_name,gen_intervention_id,intervention_id,std_intervention_id ,intervention_desc,text1,schedule_id ,shift_name	,schedule_time	,
							 day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15,
							 day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30,
							 day_31 )

select row_type,
	  ROW_NUMBER() over (ORDER BY seq,fac_id, client_id,intervention_desc,right(replicate('0',4)+cast(schedule_time as varchar(4)),4), shift_name) row_id,
	  --ROW_NUMBER() over (ORDER BY seq,fac_id, client_id,intervention_desc, shift_name) row_id,

	  seq,seq_name,fac_id,client_id,client_name,gen_intervention_id,intervention_id,std_intervention_id ,intervention_desc,text1,schedule_id ,shift_name	,schedule_time	,
	  replace(isnull(day_1,'X'),' Y ','') ,
	  replace(isnull(day_2, 'X'),' Y ',''),
	  replace(isnull(day_3,'X'),' Y ','') ,
	  replace(isnull(day_4,'X'),' Y ','') ,
	  replace(isnull(day_5,'X'),' Y ','') ,
	  replace(isnull(day_6,'X'),' Y ','') ,
	  replace(isnull(day_7,'X'),' Y ','') ,
	  replace(isnull(day_8,'X'),' Y ','') ,
	  replace(isnull(day_9,'X'),' Y ','') ,
	  replace(isnull(day_10,'X'),' Y ',''),
	  replace(isnull(day_11,'X'),' Y ',''),
	  replace(isnull(day_12,'X'),' Y ',''),
	  replace(isnull(day_13,'X'),' Y ',''),
	  replace(isnull(day_14,'X'),' Y ',''),
	  replace(isnull(day_15,'X'),' Y ',''),
	  replace(isnull(day_16,'X'),' Y ',''),
	  replace(isnull(day_17,'X'),' Y ',''),
	  replace(isnull(day_18,'X'),' Y ',''),
	  replace(isnull(day_19,'X'),' Y ',''),
	  replace(isnull(day_20,'X'),' Y ',''),
	  replace(isnull(day_21,'X'),' Y ',''),
	  replace(isnull(day_22,'X'),' Y ',''),
	  replace(isnull(day_23,'X'),' Y ',''),
	  replace(isnull(day_24,'X'),' Y ',''),
	  replace(isnull(day_25,'X'),' Y ',''),
	  replace(isnull(day_26,'X'),' Y ',''),
	  replace(isnull(day_27,'X'),' Y ',''),
	  replace(isnull(day_28,'X'),' Y ',''),
	  replace(isnull(day_29,'X'),' Y ',''),
	  replace(isnull(day_30,'X'),' Y ',''),
	  replace(isnull(day_31,'X'),' Y ','')

 from  #PRP_ds_interv_schedule_cte a ;

 if @debug_me = 'Y'
select '@PRP_ds_interv_schedule_final' PRP_ds_interv_schedule_final,* FROM @PRP_ds_interv_schedule	;

if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'
if @debug_me = 'Y' select '@PRP_ds_interv_schedule_all' PRP_ds_interv_schedule_all,* from @PRP_ds_interv_schedule  order by row_id


 SELECT @vStep = 28, @vStepName = 'Final result  ', @step_start_time = getdate()
 IF @debug_me='Y' PRINT 'BEGIN STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' Final result  at ' + CONVERT(VARCHAR, @step_start_time)

 --select isnull((select count(1) from @PRP_ds_interv_schedule),0), @status_code

 if isnull((select count(1) from @PRP_ds_interv_schedule),0)=0
 BEGIN
  Select
		NULL as row_type,NULL as row_id , NULL as seq ,NULL as seq_name ,NULL as fac_id ,NULL as client_id ,NULL as client_name,NULL as admit_date,NULL as date_of_birth,
		NULL as location,NULL as photo,NULL as photo_date,NULL as mrn_number ,NULL as user_legend,NULL as report_header,
          NULL as gen_intervention_id,NULL as intervention_id,NULL as std_intervention_id ,NULL intervention_desc,NULL as text1 ,NULL as schedule_id ,NULL as shift_id ,NULL as shift_name ,NULL as schedule_date,NULL as schedule_time
		, NULL as day_1
		, NULL as day_2
		, NULL as day_3
		, NULL as day_4
		, NULL as day_5
		, NULL as day_6
		, NULL as day_7
		, NULL as day_8
		, NULL as day_9
		, NULL as day_10
		, NULL as day_11
		, NULL as day_12
		, NULL as day_13
		, NULL as day_14
		, NULL as day_15
		, NULL as day_16
		, NULL as day_17
		, NULL as day_18
		, NULL as day_19
		, NULL as day_20
		, NULL as day_21
		, NULL as day_22
		, NULL as day_23
		, NULL as day_24
		, NULL as day_25
		, NULL as day_26
		, NULL as day_27
		, NULL as day_28
		, NULL as day_29
		, NULL as day_30
		, NULL as day_31
		, NULL as systempicklist
		, NULL as question_text_1
		, NULL as completed_date
		, NULL as question
		, NULL as response
		, NULL as document_by
		, NULL as stdQuestionId
		, @status_code as status_code
		, @status_text as status_text

 END
else if isnull((select count(1) from @PRP_ds_interv_schedule where row_type<>1),0)=0
begin
 Select row_type, row_id , seq , seq_name ,NULL as fac_id , client_id , client_name
	, isnull( convert(varchar(10), admint_date, @vdateFormatStyle) ,'')			as	admit_date

 ,date_of_birth,
 location, photo, photo_date, mrn_number , user_legend,report_header,
         gen_intervention_id, intervention_id, std_intervention_id ,intervention_desc, text1 , schedule_id , shift_id , shift_name , schedule_date, schedule_time
		, day_1
		, day_2
		,  day_3
		,  day_4
		,  day_5
		,  day_6
		,  day_7
		,  day_8
		,  day_9
		,  day_10
		,  day_11
		,  day_12
		,  day_13
		,  day_14
		,  day_15
		,  day_16
		,  day_17
		,  day_18
		,  day_19
		,  day_20
		,  day_21
		,  day_22
		,  day_23
		,  day_24
		,  day_25
		,  day_26
		,  day_27
		,  day_28
		,  day_29
		,  day_30
		,  day_31
		, null systempicklist,
		  NULL question_text_1,NULL completed_date,NULL	question ,NULL response, NULL  document_by,NULL stdQuestionId
		, @status_code as status_code
		, @status_text as status_text
    from @PRP_ds_interv_schedule
    where row_type=1 ;
 end
ELSE
BEGIN



 if @vIncludeStruckOut=0

			  select  row_type, row_id , seq ,
	   case when seq_name='Schedule' then right(replicate('0',4)+cast(schedule_time as varchar(4)),4) --cast(schedule_time as varchar)
	        when seq_name='Duration' then 'MD' else seq_name end seq_name, fac_id , client_id , client_name
			  ,	isnull(convert(varchar(10), admint_date, @vdateFormatStyle) ,'') as	admit_date

				, date_of_birth, location, photo, photo_date, mrn_number
	       , user_legend,report_header, gen_intervention_id, intervention_id, std_intervention_id , intervention_desc, text1 , schedule_id , shift_id
		  , shift_name , schedule_date, schedule_time
		  ,   day_1 , day_2  , day_3  , day_4  , day_5  , day_6  , day_7  , day_8  , day_9  , day_10
		  , day_11, day_12 , day_13 , day_14 , day_15 , day_16 , day_17 , day_18 , day_19 , day_20
		  , day_21 , day_22 , day_23 , day_24 , day_25 , day_26 , day_27 , day_28 , day_29 , day_30 , day_31 ,
		  case
		  when @vfil_fuq_options= 1  and row_id = 0 then 'System Response available for all questions: '+ @SystemPicklist+
		  case when len(@vIs_chart)>1then':  -*-Data not Requested'  else '' end
		    when @vfil_fuq_options= 0  and row_id = 0 then
		    case when len(@vIs_chart)>1then'System Response available for all questions: '+' -*-Data not Requested' else '' end end systempicklist,
		  NULL question_text_1,NULL completed_date,NULL	question ,NULL response, NULL  document_by,NULL stdQuestionId,
		  Case when row_id = 0 then @status_code else NULL end as status_code ,
		  CASE when row_id = 0 then @status_text else NULL end as status_text
	   from @PRP_ds_interv_schedule


else

			  select row_type, row_id , seq ,
	   case when seq_name='Schedule' then right(replicate('0',4)+cast(schedule_time as varchar(4)),4)--cast(schedule_time as varchar)
	        when seq_name='Duration' then 'MD' else seq_name end seq_name, fac_id , client_id , client_name
			,  	isnull(convert(varchar(10), admint_date, @vdateFormatStyle) ,'')	as	admit_date

				, date_of_birth, location, photo, photo_date, mrn_number
	       , user_legend,report_header, gen_intervention_id, intervention_id, std_intervention_id , intervention_desc, text1 , schedule_id , shift_id
		  , shift_name , schedule_date, schedule_time
		  ,   day_1 , day_2  , day_3  , day_4  , day_5  , day_6  , day_7  , day_8  , day_9  , day_10
		  , day_11, day_12 , day_13 , day_14 , day_15 , day_16 , day_17 , day_18 , day_19 , day_20
		  , day_21 , day_22 , day_23 , day_24 , day_25 , day_26 , day_27 , day_28 , day_29 , day_30 , day_31 ,
		  case
		  when @vfil_fuq_options= 1  and row_id = 0 then 'System Response available for all questions: '+ @SystemPicklist+
		  case when len(@vIs_chart)>1then':  -*-Data not Requested'  else '' end
		    when @vfil_fuq_options= 0  and row_id = 0 then
		    case when len(@vIs_chart)>1then'System Response available for all questions: '+' -*-Data not Requested' else '' end end systempicklist,
		  NULL question_text_1,NULL completed_date,NULL	question ,NULL response, NULL  document_by,NULL stdQuestionId,
		  Case when row_id = 0 then @status_code else NULL end as status_code ,
		  CASE when row_id = 0 then @status_text else NULL end as status_text
	   from @PRP_ds_interv_schedule



		union all
			 select
		 3 as row_type,NULL as row_id , NULL as seq ,NULL as seq_name ,@vFacId as fac_id ,client_id as client_id ,NULL as client_name,NULL as admit_date,NULL as date_of_birth,
		 NULL as location,NULL as photo,NULL as photo_date,NULL as mrn_number ,NULL as user_legend,NULL as report_header,
          gen_intervention_id as gen_intervention_id,intervention_id as intervention_id,std_Intervention_Id as std_intervention_id ,intervention_desc ,text1 ,NULL as schedule_id ,NULL as shift_id ,NULL as shift_name ,NULL as schedule_date,NULL as schedule_time
		, NULL as day_1, NULL as day_2 , NULL as day_3, NULL as day_4, NULL as day_5, NULL as day_6, NULL as day_7, NULL as day_8, NULL as day_9, NULL as day_10
		, NULL as day_11, NULL as day_12, NULL as day_13, NULL as day_14, NULL as day_15, NULL as day_16, NULL as day_17, NULL as day_18, NULL as day_19, NULL as day_20
		, NULL as day_21, NULL as day_22, NULL as day_23, NULL as day_24, NULL as day_25, NULL as day_26, NULL as day_27, NULL as day_28, NULL as day_29, NULL as day_30
		, NULL as day_31, NULL as systempicklist ,question_text_1,completed_date,	question ,response, document_by,stdQuestionId ,NULL  as status_code , NULL  status_text
		from
		(
	    	select
		 distinct
		   a.client_id	 ,
		   a.strikeout_by + '<br>' + (

				convert(varchar(10), ( dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, a.strikeout_date)), @vdateFormatStyle)
				+ ' ' + convert( varchar(8),  dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, a.strikeout_date), 108)
				) intervention_desc,
		   a.strikeout_description text1,
		 '<b>'+a.text1 +'</b>  '+cast(b.sequence as varchar)+'- '+
		  CASE WHEN ISNULL(question.system_control_flag,'N')='Y' and (question.mds_question_key_old like 'G01%' or question.mds_question_key_old like 'G2%')
					 THEN isnull(question_text,'-')  ELSE  replace(replace(isnull(question_text,'-'),'<b>',''),'</b>','') END+' '+b.picklist_text
					 question_text_1,

		 (

				convert(varchar(10), ( dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, a.entered_date)), @vdateFormatStyle)
				+ ' '+ convert( varchar(8),  dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, a.entered_date), 108)
				)completed_date

		 --convert(varchar(19), dbo.fn_adjust_time_fac_time_zone_base_on_date(@vFacId, a.entered_date), 120)  completed_date
		 ,
					 CASE WHEN ISNULL(question.system_control_flag,'N')='Y' and (question.mds_question_key_old like 'G01%' or question.mds_question_key_old like 'G2%')
					 THEN isnull(question_text,'-')  ELSE question.stdquestiontext END question,
					IIF(a.item_value_id is null, '', cast(a.item_value_id as varchar(max)))
					+ CASE WHEN a.stdquestioncontorltype='mlt' or a.stdquestioncontorltype='itv' or a.stdquestioncontorltype='bhv' or (a.stdquestioncontorltype='ntv' and a.item_value_id is null) THEN '' ELSE '-' END
					+
				 CASE
				    WHEN a.stdquestioncontorltype  in ('bls',  'os2', 'het','num','tmp','pls','wgt') AND ISNUMERIC(a.item_value)=1 AND ISNULL(a.item_value,'') NOT IN ('<RNA/>','<NA/>','<RR/>') THEN a.item_value
					WHEN a.stdquestioncontorltype in ('rsp', 'sgn') then a.item_value
				    WHEN a.stdquestioncontorltype ='bpr' and isnumeric(a.item_value)=1 then a.item_value+'/'+CAST( a.item_value_id AS VARCHAR)	  ELSE
					   CASE WHEN CAST( a.item_value AS VARCHAR (max)) ='<NA/>'  THEN 'Not Applicable'
						   WHEN cast( a.item_value AS VARCHAR(max)) ='<RR/>'  THEN 'Resident Refused'
						   WHEN cast( a.item_value AS VARCHAR(max)) ='<RNA/>' THEN 'Resident Not Available'
						   ELSE
								CASE WHEN a.stdquestioncontorltype='mlt' or a.stdquestioncontorltype='itv' or a.stdquestioncontorltype='bhv' THEN  ''
								ELSE
									cast( a.item_value AS VARCHAR(max))
								END
						   END
					   END response ,
			a.created_by_longname document_by,
			a.gen_intervention_id,a.intervention_id,a.stdQuestionId,a.std_Intervention_Id

			 from #pocData a

			 left join #FollowUpQuestionandPicklistItem b  on
			  a.gen_Intervention_Id=b.genInterventionId
			  and a.intervention_Id=b.interventionId
			  and a.std_Intervention_Id=b.stdInterventionId
			   and a.stdQuestionId=b.stdQuestionId
			   and isnull(a.stdpicklistid,0)=isnull(std_pick_list_id,0)

			   left outer JOIN #stdQuestionIdTable question
					ON question.stdquestionid = a.stdquestionId
					  and question.stdinterventionid=a.std_intervention_id
					  and question.genInterventionId=a.gen_intervention_id
					  and question.InterventionId=a.intervention_Id
					 and question.sequence=a.sequence

			 where a.strikeout_flag='Y'
			 and (a.completed_date>=isnull(b.period_start_date,  a.completed_date) and a.completed_date<=isnull(b.period_end_date,  a.completed_date))
		) tt

			  order by row_type,row_id,completed_date,question_text_1	;
		;
	  

 end
  if @debug_me = 'Y' Print 'END STEP ' +  convert(varchar(20), @vStep)  + ' Step Time = ' + convert(varchar, datediff(ms, @step_start_time, getdate())) + ' milliseconds'	
  
 

 --end


  END TRY 

BEGIN CATCH 
	 IF @status_code = 0 
            SET @status_code = 1; 

          --- only when unexpected error occured otherwise it could be handled error series 1000 like threshold
      IF @status_code <> 2 
            SELECT @status_text = 
                   Rtrim(LEFT('Stored Procedure failed with Error Code : ' 
                              + Cast(Error_number() AS VARCHAR(10)) 
                              + ', Line Number : ' 
                              + Cast(Error_line() AS VARCHAR(10)) 
                              + ', Description : ' + Error_message(), 3000) 
                   ) 

			
			insert into dbo.execution_statistics 
					(program_name, start_time, end_time, who_done_it, return_code, parm1_name, parm1_value, parm2_name, parm2_value, parm3_name, parm3_value, parm5_name, parm5_value)
			values(@vgs_program_name, @vgs_start_time, getdate(), LEFT(@vgs_execution_user,30),@status_code, 'field_list', LEFT(@vFieldList, 1500), 'filter_list', LEFT(@vFilterList, 1500), 'step_number', convert(varchar(10), @vStep), 'error_msg', LEFT(@status_text, 1500)  )		

	Select 
		NULL as row_type,NULL as row_id , NULL as seq ,NULL as seq_name ,NULL as fac_id ,NULL as client_id ,NULL as client_name,NULL as admit_date,NULL as date_of_birth,
		NULL as location,NULL as photo,NULL as photo_date,NULL as mrn_number ,NULL as user_legend,NULL as report_header, 
          NULL as gen_intervention_id, NULL intervention_id, NULL std_intervention_id , NULL intervention_desc ,NULL as text1 ,NULL as schedule_id ,NULL as shift_id ,NULL as shift_name ,NULL as schedule_date,NULL as schedule_time 
		, NULL as day_1
		, NULL as day_2
		, NULL as day_3
		, NULL as day_4
		, NULL as day_5
		, NULL as day_6
		, NULL as day_7
		, NULL as day_8
		, NULL as day_9
		, NULL as day_10
		, NULL as day_11
		, NULL as day_12
		, NULL as day_13
		, NULL as day_14
		, NULL as day_15
		, NULL as day_16
		, NULL as day_17
		, NULL as day_18
		, NULL as day_19
		, NULL as day_20
		, NULL as day_21
		, NULL as day_22
		, NULL as day_23
		, NULL as day_24
		, NULL as day_25
		, NULL as day_26
		, NULL as day_27
		, NULL as day_28
		, NULL as day_29
		, NULL as day_30
		, NULL as day_31 
		, NULL as systempicklist
		, NULL as question_text_1
		, NULL as completed_date
		, NULL as question 
		, NULL as response
		, NULL as document_by
		, NULL as stdQuestionId
		, @status_code as status_code
		, @status_text as status_text
		
END CATCH 

RETURN 

END
GO
GRANT EXECUTE ON  dbo.sproc_prp_rl_poc_documentation_survey_hybrid   to PUBLIC
GO

GO

print 'C_Branch/04_StoredProcedures/sproc_prp_rl_poc_documentation_survey_hybrid.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_poc_documentation_survey_hybrid.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_poc_planned_actual_service_time.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- PCC-52764      :   script to create sproc_prp_rl_poc_planned_actual_service_time Procedure  
--						-- 
-- Written By:          Ritch Moore
-- Reviewed By:         
-- 
-- Script Type:         DDL 
-- Target DB Type:      Client
-- Target ENVIRONMENT:  BOTH (US/CA) 
-- 
-- 
-- Re-Runable:          YES 
-- 
-- Description of Script : Create sproc_prp_rl_poc_planned_actual_service_time Procedure for Service Tracking reporting
-- 
-- Special Instruction: 

-- 
-- ================================================================================

/***********************************************************************************
Revision History:
2013-09-24  Ritch Moore		PCC-52764	3.7.3 Initial creation of this stored proc
2014-02-28  Ritch Moore		PCC-54566	3.7.3 Corrected Planned - Actual problem
2014-03-15  Henny Ehghaghi	PCC-54689	3.7.3.1 
2014-03-25  Henny Ehghaghi	PCC-55402	3.7.3.2 
2014-03-25  Henny Ehghaghi	PCC-56339	3.7.3.2 
2014-04-07  Henny Ehghaghi	PCC-56251	3.7.4 Assigne Alias name before all column names 
2014-05-20  Henny Ehghaghi  PCC-57972   3.7.4.1 Fixing Shift descreption (when start or end time is zero)

***********************************************************************************/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_prp_rl_poc_planned_actual_service_time' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE dbo.sproc_prp_rl_poc_planned_actual_service_time
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO



Create Procedure dbo.sproc_prp_rl_poc_planned_actual_service_time

  @fac_id int
--, @floor_id int = -1
, @unit_id int = -1
, @shift_id varchar(max) = '-1'
, @include_unscheduled char(1) = 'N'
, @include_prn char(1) = 'N'
, @week_date datetime = Null
, @position_times varchar(max)
, @execution_user_login varchar(60)
, @rows_returned int out
, @debug_me char(1)  = 'N'
, @status_code int  out 
, @status_text varchar(3000) out
/********************************************************************************
			   
Declare  @rows_ret int		,@statuscode int		,@statustext varchar(3000)
exec dbo.sproc_prp_rl_poc_planned_actual_service_time
@fac_id =  '1'
,@shift_id = '-1'
,@include_unscheduled = 'Y'
,@include_prn = 'N'
,@week_date='2/25/2014'
,@position_times ='19091,7.5;19059,7.5;60580,8.0;19777,7.25;60250,8.25'
,@execution_user_login='pcc-niakhk'
,@rows_returned = null
,@debug_me = 'N'
,@status_code = null
,@status_text = null

**********************************************************************************/

as
Begin


SET NOCOUNT ON;
--declare Standard local variables required for any store proc
DECLARE  @vStep int
		,@vErr varchar(max)
		,@vdelim char(1)
		,@vCharNewLine  char(2)
	    ,@vSeparator char(6)
		,@vSeparator2 char(6)
		,@vReportDate datetime
		,@vRowCount int

--Facility Related variables, also used in capturing execution Statistics 
Declare @vFacIDs varchar(max)		
Declare @PRP_FacList as table(FacId int)
Declare @vFacWarningMsg varchar(max) --- to know whether it the returned list is restricted

----Local Variables
DECLARE @vFacId int
	, @vFacName varchar(500)
	, @vFacAddress varchar(max)
	, @vRegId int
	, @vWeekDate datetime
	, @vFloorId	int
	, @vUnitId int
	, @vShiftId varchar(max)
	, @vIncludeUnscheduled char(1) 
	, @vStartDate datetime
	, @vEndDate datetime
	, @vPositionTimes varchar(max)
	, @vSortBy varchar(50)
	, @vIncludePRN CHAR(1)
	, @vIncludePRNbit BIT; 
;

-----Governor and Statistics Variables 
Declare  @vgs_program_name varchar(200)
		 ,@vgs_start_time datetime
		 ,@vgs_execution_user varchar(60)
		 ,@vgs_fill_end_time datetime
		 ,@vGeneric_statuscode int 
		 ,@vGeneric_statustext varchar(3000)
		 ,@vgsStepStartTime datetime
		 ,@vgsStepEndTime datetime

declare @selected_shifts table (shift_id int);

------TERMINOLOGY VARIABLES and COMMON VARIABLES FOR A FAC 

Declare @vClientWarningMsg varchar(max)--- to know whether it the returned list is restricted

CREATE table #PRP_Position_Times (position_id int, hours decimal(8,2));

CREATE TABLE #prp_shifts( 
		  shift_id int
		, shift_name varchar(50) 
		, start_time int
		, end_time int
		, group_name varchar(15)
		, position_id int
		, flg int
);

CREATE TABLE #prp_shift_link( 
		  shift_id int
		, shift_name varchar(50) 
		, start_time int
		, end_time int
		, group_name varchar(15)
		, position_id int
);

CREATE TABLE #prp_poc_details( 
		  id_key varchar(20)
		, first_name varchar(50)
		, last_name varchar(50) 
		, bed_id int
		, bed_desc varchar(30)
		, discharge_date datetime
		, client_id_number varchar(35)
		, photo_small varchar(55)
		, room_desc varchar(60)
		, unit_id int
		, unit_desc varchar(35)
		, admission_date datetime
		, client_id int
		, effective_date datetime
		, ineffective_date datetime
		, current_row varchar(1)
		, intervention_desc  varchar(2000)
		, date_initiated datetime
		, std_intervention_id  int
		, require_time_tracking bit
		, baseline_time smallint
		, intervention_id  int
		, schedule_id  int
		, schedule_type  int
		, std_shift_ids  varchar(500)
		, start_time varchar(4)
		, end_time varchar(4)
		, xxminutes  int
		, fac_id  int 
		, date_of_month int
		, schedule_detail_id varchar(100)
		, std_shift_id int
		, shift_date datetime
		, schedule_date datetime
		, schedule_time int
		, schedule_end_date datetime
		, documentation_id varchar(100)
		, completed_date datetime
		, strikeout_date datetime
		, entered_date datetime
		, task_time smallint
		, cp_sec_user_audit_id int
		, struckout_cp_sec_user_audit_id int
		);


CREATE TABLE #prp_poc_planned( 
		  fac_id int
		, shift varchar(50)
		, group_name varchar(15) 
		, position_id int
		, position varchar(254) 
		, hour_type varchar (60)
		, sunday decimal(8,2) default 0
		, monday decimal(8,2) default 0
		, tuesday decimal(8,2) default 0
		, wednesday decimal(8,2) default 0
		, thursday decimal(8,2) default 0
		, friday decimal(8,2) default 0
		, saturday decimal(8,2) default 0
		, total decimal(10,2) default 0
		, ordr tinyint
);

CREATE TABLE #prp_poc_planned_final( 
		  fac_id int
		, shift varchar(50)
		, group_name varchar(15) 
		, position_id int
		, position varchar(254)  
		, hour_type varchar (60)
		, sunday decimal(8,2) default 0
		, monday decimal(8,2) default 0
		, tuesday decimal(8,2) default 0
		, wednesday decimal(8,2) default 0
		, thursday decimal(8,2) default 0
		, friday decimal(8,2) default 0
		, saturday decimal(8,2) default 0
		, total decimal(10,2) default 0
		, ordr tinyint
);
 DECLARE @ROWDATA TABLE
 (
 id_key int IDENTITY(1,1),
  schedule_detail_id varchar(250),
  shift_id           varchar(50),
  shift_name         varchar(max),
  group_name         varchar(max),
  position_id        int,
  position           varchar(max),
  day_of_week        int,
  total_minutes      int,
  timeFlag           int,
  completed_date     datetime,
  schedule_date      datetime,
  document_id       varchar(250),
  sFlag              int,--struckout flag
    PRIMARY KEY (schedule_detail_id, timeflag, shift_id,id_key),
     UNIQUE CLUSTERED (schedule_date,completed_date,id_key)  );
 
  declare @Dateadjust as TABLE
( day_date	    datetime,
  std_shift_id	int,
  shift_name    varchar(max),
  fac_id	    int,
  s_date	    datetime,
  dd            datetime,
  tm            int);
  
 
 DECLARE @day_week table
(
	dw int IDENTITY(1,1),
	date_day datetime,day_num int);

 DECLARE 
 @daylightStart DATETIME , 
 @daylightEnd  DATETIME;

BEGIN TRY

	Set @status_code = 0   ---- Status Code 0 = Success, 1 = Exception
	set @status_text = null;
	set @rows_returned = 0;
	Set @vgs_program_name  = Object_name(@@ProcID);  ---Current Store Proc Name
	Set @vgs_start_time = getdate();
	Set @vgs_execution_user = @execution_user_login;

	select @vStep = 0
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Executing store proc :  ' + @vgs_program_name  + convert(varchar(26),getdate(),109)

	--set Standard variables
	set @vdelim = ';'
	set @vCharNewLine  = Char(13) + char(10);
	set @vSeparator = 'ZYXWVU';
	set @vSeparator2 = 'UVWXYZ';

	----Parameter Sniffing - use local variables when they are used in a where clause
	SET @vFacID					= @fac_id;
	SET @vWeekDate				= @week_date;
	SET @vPositionTimes			= @position_times
	set @vUnitId				= @unit_id
	SET @vShiftId				= @shift_id
	set @vIncludeUnscheduled	= @include_unscheduled
	set @vStartDate				= @vWeekDate
	set @vEndDate				= dateadd(dd,7,@vStartDate)
	set	@vEndDate				= (select convert(datetime, convert(varchar(4), datepart(yyyy, @vEndDate))
									+ '-' + convert(varchar(2), datepart(MM, @vEndDate))
									+ '-' + convert(varchar(2), datepart(dd, @vEndDate))
									+ ' 23:59:59'));
	SET @vIncludePRN	= ISNULL(@include_prn, 'N');
	SELECT @vIncludePRNbit = IIF(@vIncludePRN = 'N', 0, 1);

	SELECT @daylightStart=start_date,@daylightEnd=end_date
	FROM day_light_savings_dates
	WHERE datepart(yyyy,start_date )=datepart(yyyy,@vWeekDate );

	if @debug_me='Y' Print 'Start Date = ' +  convert(varchar(26),@vStartDate) + ' End date = '+convert(varchar(26),@vEndDate)

	IF isnull(@vShiftId,'-1')<>'-1'
	begin
		insert INTO @selected_shifts select Cast(items as int) from dbo.Split(@vShiftId,@vdelim)
	end

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep = 10
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Validating Input Parameters  ' +  convert(varchar(26),getdate(),109)

	----Validate all input parameters
	if (
		@fac_id is NULL 
		or @execution_user_login is null
		or @week_date is null
		)
	begin
		set @vErr = 'One or more of the following input parameters is invalid... '
					+ ' @fac_id=' + isnull(convert(varchar(10),@fac_id),'null/empty')
					+ ' @week_date=' + isnull(convert(varchar(10),@week_date, 101),'null/empty')
					+ ', @execution_user_login=' + isnull(@execution_user_login,'null/empty')
	
		RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);
	end

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	Select @vStep = 20;
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Getting user access fac list ' + convert(varchar(26),getdate(),109);

	Select @vFacIds = fac_id
		  ,@vFacWarningMsg = msg
	From  dbo.fn_prp_get_facility_access_list_delim(@vFacId ,@vgs_execution_user); ---filter the fac list with user access

	--facilities warnings
	if @vFacWarningMsg is NOT NULL --- NOT NULL stands for restricted facilities access warning message
	Begin
		Set @status_code = 2 ; ----Set it warning
		Set @status_text = isnull(@status_text,'') + @vFacWarningMsg ;
	End 
	
	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	-------------------------------------------------------------
	-- Inserting records in temp table.
	-------------------------------------------------------------
	
	select @vStep = 50
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' getting raw data ' + convert(varchar(26),getdate(),109)

	insert INTO  #prp_poc_details 
		( id_key
		, first_name
		, last_name
		, bed_id
		, bed_desc
		, discharge_date
		, client_id_number
		, photo_small
		, room_desc
		, unit_id
		, unit_desc
		, admission_date
		, client_id
		, effective_date  
		, ineffective_date  
		, current_row
		, intervention_desc
		, date_initiated
		, std_intervention_id
		, require_time_tracking
		, baseline_time
		, intervention_id
		, schedule_id
		, schedule_type
		, std_shift_ids
		, start_time 
		, end_time 
		, xxminutes
		, fac_id
		, date_of_month 
		, schedule_detail_id
		, std_shift_id
		, shift_date 
		, schedule_date
		, schedule_end_date
		, documentation_id
		, completed_date
		, strikeout_date
		, entered_date
		, task_time
		, cp_sec_user_audit_id
		, struckout_cp_sec_user_audit_id
		)
	exec dbo.sproc_prp_pcc_poc_getScheduleDetails
	@vFacId,
	-1,--@vShiftId,--@shiftID_param int,
	-1,--@myPositionID_param int,
	-1,--@assignmentID_param int,
	@vUnitId,--@unitID_param int,
	-1,--@selectedPositionID_param int,
	@vStartDate,--'2014-01-26 00:00:00',--@shiftStartTime_param datetime,
	@vEndDate,--'2014-02-01 23:59:59'--@shiftEndTime_param datetime,
	NULL,--'7445,7455,7465',--@stdInts_param varchar(8000),
	-1,--@clientID_param int,
	@vStartDate,--'2014-01-26 00:00:00',--@localStartTime_param datetime,
	@vEndDate,--'2014-02-01 23:59:59'--@localEndTime_param datetime,
	Null,--@max_details_param int = 2147483647,
	@vIncludePRNbit,--@include_prn_param bit = 1,
	'N',--@debug				char(1)  = 'N',
	Null,--@status_code		int	out,
	Null--@status_text		varchar(3000) out
	
	set @vRowCount = @@rowcount
		if  (@vRowCount = 0)
	begin
	 Set @status_code = 2
	 Set @status_text = isnull(@status_text,'') + 'No Data Found' ;
	 Raiserror( 'sproc_prp_pcc_poc_getScheduleDetails returned 0 rows.', 10, 1 );
	 
	 end
	 

    update #prp_poc_details
     set schedule_date= case when completed_date is not null then completed_date else schedule_date end  
	from #prp_poc_details
	where substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)='D'
	
	-- DAY LIGHT SAVING DATE 
        update  a set
            schedule_date=case 
              when schedule_date= dateadd(hh,1,@daylightStart) then @daylightStart
              when schedule_date= dateadd(hh,-1,@daylightEnd) then @daylightEnd
             end   ,
            completed_date=case 
              when completed_date= dateadd(hh,1,@daylightStart) then  @daylightStart
              when completed_date= dateadd(hh,-1,@daylightEnd) then  @daylightEnd
              end 
        from #prp_poc_details a
         where schedule_date= dateadd(hh,1,@daylightStart) or schedule_date= dateadd(hh,-1,@daylightEnd)
         or completed_date= dateadd(hh,1,@daylightStart) or completed_date= dateadd(hh,-1,@daylightEnd)


	update #prp_poc_details 
	set schedule_time=cast(replace(convert(varchar(5),dbo.fn_adjust_time_fac_time_zone (@vFacId ,schedule_date),108),':','') as int)
	
	
	 delete					        
    from #prp_poc_details
    where ineffective_date is not null
    and schedule_date>ineffective_date;


    delete from #prp_poc_details
    where ineffective_date is  null
    and schedule_date<effective_date;
    
    
 
	if @debug_me='Y' select * from #prp_poc_details order BY std_intervention_id,schedule_date,std_shift_id
	
    INSERT INTO @day_week 
    SELECT day_date, 
           day_num 
    FROM   date_dim 
    WHERE  day_date >= @vStartDate 
           AND day_date <= @vEndDate;
    
     if @debug_me='Y' select * FROM @day_week
    
	CREATE  CLUSTERED INDEX _temp1_prppocdetails 
	on #prp_poc_details(id_key,intervention_id,schedule_type,schedule_detail_id,std_intervention_id,schedule_time,std_shift_id,strikeout_date)


	Insert into #PRP_Position_Times
	Select left(items,(CHARINDEX(',',items)-1)),
	right(items,len(items) - CHARINDEX(',',items))
	from dbo.split(@vPositionTimes,@vDelim)

--It's using for QSHIFT
	INSERT INTO #prp_shift_link( shift_id , shift_name , start_time , end_time , group_name , position_id )
	select distinct shift.std_shift_id,
shift.description+' ('+
		case when left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end)) ='' then '0' ELSE

left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end))
end 
		+':'+right(cast(start_time as int),2)+(case when cast(start_time as int)>1200 THEN ' PM' ELSE ' AM' END) 
		+' - ' +
		case when rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end))))='' then '0'
		else
		rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end)))) end 
		+':'+right(cast(end_time as int),2)+(case when cast(end_time as int)>1200 THEN ' PM' ELSE ' AM' END) +')' shift_name,
		
	shift.start_time,cast(shift.end_time as int)-1  as end_time1,'',0
	from dbo.cp_std_shift shift WITH (NOLOCK)
	LEFT JOIN @selected_shifts ss on shift.std_shift_id=ss.shift_id
	WHERE
	shift.deleted='N' 
	and (shift.fac_id=@vFacId or shift.fac_id=-1)	
	and (@vShiftId='-1' OR ss.shift_id IS not NULL)

	if @debug_me='Y' select * from #prp_shift_link order BY shift_name
	
	
--It's using for Non-QSHIFT
	INSERT INTO #prp_shifts (shift_id , shift_name, start_time , end_time , group_name, position_id , flg) 
	select distinct  shift.std_shift_id,
	shift.description+' ('+
		case when left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end)) ='' then '0' ELSE

left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end))
end 
		+':'+right(cast(start_time as int),2)+(case when cast(start_time as int)>1200 THEN ' PM' ELSE ' AM' END) 
		+' - ' +
		case when rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end))))='' then '0'
		else
		rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end)))) end 
		+':'+right(cast(end_time as int),2)+(case when cast(end_time as int)>1200 THEN ' PM' ELSE ' AM' END) +')' shift_name,
	
	shift.start_time,shift.end_time-1,'',grpass.position_id,0
	from dbo.pho_assignment_group_assoc  grpass WITH (NOLOCK)
	INNER JOIN dbo.pho_assignment_group grp WITH (NOLOCK) ON 
	    grpass.pho_assignment_group_id=grp.pho_assignment_group_id 
	    and grp.fac_id=@vFacId and grp.deleted='N'
        and grpass.fac_id=@vFacId and grpass.position_id is not null
	INNER JOIN dbo.cp_std_shift shift WITH (NOLOCK) ON 
	    grpass.std_shift_id=shift.std_shift_id and shift.deleted='N'
	LEFT JOIN @selected_shifts ss on shift.std_shift_id=ss.shift_id 
	WHERE (@vShiftId='-1' OR ss.shift_id IS not NULL)
	and	convert(int,shift.end_time)-convert(int,shift.start_time)>0; 
	    
	INSERT INTO #prp_shifts (shift_id , shift_name, start_time , end_time , group_name, position_id , flg) 
	select distinct shift.std_shift_id,
	shift.description+' ('+
		case when left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end)) ='' then '0' ELSE

left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end))
end 
		+':'+right(cast(start_time as int),2)+(case when cast(start_time as int)>1200 THEN ' PM' ELSE ' AM' END) 
		+' - ' +
		case when rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end))))='' then '0'
		else
		rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end)))) end 
		+':'+right(cast(end_time as int),2)+(case when cast(end_time as int)>1200 THEN ' PM' ELSE ' AM' END) +')'
	,shift.start_time,2400-1,'',grpass.position_id,0
	from dbo.pho_assignment_group_assoc  grpass WITH (NOLOCK)
	INNER JOIN dbo.pho_assignment_group grp WITH (NOLOCK) ON grpass.pho_assignment_group_id=grp.pho_assignment_group_id 
	and grp.fac_id=@vFacId and grp.deleted='N'
		and grpass.fac_id=@vFacId and grpass.position_id is not null
	INNER JOIN dbo.cp_std_shift shift WITH (NOLOCK) ON grpass.std_shift_id=shift.std_shift_id and shift.deleted='N' 
	LEFT JOIN @selected_shifts ss on shift.std_shift_id=ss.shift_id 
     WHERE (@vShiftId='-1' OR ss.shift_id IS not NULL)
     and convert(int,shift.end_time)-convert(int,shift.start_time)<0 ;
     
     INSERT INTO #prp_shifts (shift_id , shift_name, start_time , end_time , group_name, position_id , flg) 
     select distinct shift.std_shift_id,
     shift.description+' ('+
		case when left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end)) ='' then '0' ELSE

left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end))
end 
		+':'+right(cast(start_time as int),2)+(case when cast(start_time as int)>1200 THEN ' PM' ELSE ' AM' END) 
		+' - ' +
		case when rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end))))='' then '0'
		else
		rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end)))) end 
		+':'+right(cast(end_time as int),2)+(case when cast(end_time as int)>1200 THEN ' PM' ELSE ' AM' END) +')' shift_name
     ,'0',shift.end_time-1,'',grpass.position_id,1
	from dbo.pho_assignment_group_assoc  grpass WITH (NOLOCK)
	INNER JOIN dbo.pho_assignment_group grp WITH (NOLOCK) ON grpass.pho_assignment_group_id=grp.pho_assignment_group_id 
	and grp.fac_id=@vFacId and grp.deleted='N'
		and grpass.fac_id=@vFacId and grpass.position_id is not null
	INNER JOIN dbo.cp_std_shift shift WITH (NOLOCK) ON grpass.std_shift_id=shift.std_shift_id and shift.deleted='N' 	 
    LEFT JOIN @selected_shifts ss on shift.std_shift_id=ss.shift_id
		 WHERE (@vShiftId='-1' OR ss.shift_id IS not NULL)
		 and convert(int,shift.end_time)-convert(int,shift.start_time)<0;
		 
		 
	



INSERT INTO @Dateadjust (day_date,std_shift_id,shift_name ,fac_id,s_date, dd ,tm )
      SELECT a.day_date, 
       a.std_shift_id, 
       ss.shift_name, 
       a.fac_id, 
       a.s_date, 
       Cast(CONVERT(VARCHAR(10), a.s_date, 120) AS DATETIME)          dd, 
       Cast(Replace(CONVERT(VARCHAR(5), s_date, 108), ':', '') AS INT)tm 
FROM   view_cp_shift_dates a 
       INNER JOIN #prp_shifts ss 
               ON a.std_shift_id = ss.shift_id 
       INNER JOIN #prp_position_times b 
               ON b.position_id = ss.position_id 
 WHERE  a.fac_id = @vFacId 
       AND ss.flg = 1 
       AND Datepart(yyyy, a.day_date) = Datepart(yyyy, @vEndDate) 
       AND Datepart(mm, a.day_date) BETWEEN Datepart(mm, @vEndDate) - 1 AND 
                                            Datepart(mm, @vEndDate) + 1;  
      
      delete from @Dateadjust where day_date<dateadd(dd,-1,@vStartDate) or day_date>@vEndDate
      


	CREATE  CLUSTERED INDEX _temp1_prpshifts on #prp_shifts(position_id,start_time,end_time)

	if @debug_me='Y' select * from #prp_shifts order BY shift_name

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	Set @vgs_fill_end_time  = getdate() ; -- fill end time

	select @vStep = 60
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' loading and calculating pivoted table ' + convert(varchar(26),getdate(),109)
-------------------------------------------------------------
-- Row data for Planned Hours
-------------------------------------------------------------	
	
--Qshift
INSERT INTO @ROWDATA (schedule_detail_id,shift_id,shift_name,group_name,position_id,position,day_of_week,total_minutes,timeFlag,completed_date,schedule_date,document_id,sFlag)
SELECT cpsd.schedule_detail_id, 
       shift.shift_id, 
       CASE 
         WHEN ( shift.end_time - shift.start_time ) < 0 
              AND ( cpsd.schedule_time >= shift.start_time 
                     OR cpsd.schedule_time <= shift.end_time ) THEN 
         shift.shift_name 
         WHEN ( shift.end_time - shift.start_time ) > 0 
              AND ( cpsd.schedule_time >= shift.start_time 
                    AND cpsd.schedule_time <= shift.end_time ) THEN 
         shift.shift_name 
       END                                                AS Shift1, 
       shift.group_name, 
       crr.service_tracking_position_id                   AS position_id, 
       cc.item_description                                AS position, 
       Datepart(dd, cpsd.shift_date)                      AS day_of_week, 
       COALESCE(cpsd.baseline_time, cpstdi.baseline_time) AS total_minutes, 
       1 timeFlag, 
       cpsd.completed_date, 
       cpsd.shift_date                                    AS schedule_date, 
       cpsd.documentation_id, 
       CASE 
         WHEN cpsd.strikeout_date IS NOT NULL THEN 1 
         ELSE 0 
       END                                                sFlag 
FROM   #prp_poc_details cpsd 
       INNER JOIN cp_rev_intervention crr WITH (nolock) 
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.common_code cc WITH (nolock) 
               ON crr.service_tracking_position_id = cc.item_id 
       INNER JOIN dbo.#prp_shift_link shift 
               ON cpsd.std_shift_id = shift.shift_id 
       INNER JOIN dbo.#prp_position_times pt 
               ON pt.position_id = crr.service_tracking_position_id 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       AND ( Isnull(@vPositionTimes, '-1') = '-1' 
              OR pt.position_id IS NOT NULL );  
	
	
	
--NonQshift
INSERT INTO @ROWDATA (schedule_detail_id,shift_id,shift_name,group_name,position_id,position,day_of_week,total_minutes,timeFlag,completed_date,schedule_date,document_id,sFlag)
	SELECT cpsd.schedule_detail_id, 
       Cast(shift.shift_id AS VARCHAR) + '-' 
       + Cast(shift.flg AS VARCHAR)                       shift_id, 
       CASE 
         WHEN 
       Substring(cpsd.schedule_detail_id, 
       Charindex('_', cpsd.schedule_detail_id) + 1, 1) = 'D' 
       AND ( shift.end_time - shift.start_time ) < 0 
       AND ( cpsd.schedule_time >= shift.start_time 
              OR cpsd.schedule_time <= shift.end_time ) THEN shift.shift_name 
         WHEN 
       Substring(cpsd.schedule_detail_id, 
       Charindex('_', cpsd.schedule_detail_id) + 1, 1) = 'D' 
       AND ( shift.end_time - shift.start_time ) > 0 
       AND ( cpsd.schedule_time >= shift.start_time 
             AND cpsd.schedule_time <= shift.end_time ) THEN shift.shift_name 
         WHEN 
       Substring(cpsd.schedule_detail_id, 
       Charindex('_', cpsd.schedule_detail_id) + 1, 1) <> 'D' THEN 
         shift.shift_name 
       END                                                AS Shift, 
       shift.group_name, 
       CASE 
         WHEN Isnull(cpstdi.require_time_tracking, 0) = 1 THEN 
         crr.service_tracking_position_id 
         WHEN Isnull(cpstdi.require_time_tracking, 0) = 0 
              AND Isnull(crr.require_time_tracking, 0) = 1 THEN 
         crr.service_tracking_position_id 
       END                                                AS position_id, 
       cc.item_description                                AS position, 
       Datepart(dd, cpsd.schedule_date)                   AS day_of_week, 
       COALESCE(cpsd.baseline_time, cpstdi.baseline_time) AS total_minutes, 
       1 timeFlag, 
       cpsd.completed_date, 
       cpsd.schedule_date, 
       cpsd.documentation_id, 
       CASE 
         WHEN cpsd.strikeout_date IS NOT NULL THEN 1 
         ELSE 0 
       END                                                sFlag 
FROM   #prp_poc_details cpsd 
       INNER JOIN cp_rev_intervention crr WITH (nolock) 
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.common_code cc WITH (nolock) 
               ON cc.item_id = CASE 
                                 WHEN Isnull(cpstdi.require_time_tracking, 0) = 
                                      1 THEN 
                                 crr.service_tracking_position_id 
                                 WHEN 
                  Isnull(cpstdi.require_time_tracking, 0) = 0 
                  AND Isnull(crr.require_time_tracking, 0) = 1 THEN 
                                 crr.service_tracking_position_id 
                               END 
       INNER JOIN dbo.#prp_shifts shift 
               ON 1 = CASE 
                        WHEN 
                      Substring(cpsd.schedule_detail_id, 
                      Charindex('_', cpsd.schedule_detail_id) + 1, 1) = 'D' 
                      AND crr.service_tracking_position_id = shift.position_id 
                      AND cpsd.std_shift_id IS NULL THEN 1 
                        WHEN 
                      Substring(cpsd.schedule_detail_id, 
                      Charindex('_', cpsd.schedule_detail_id) + 1, 1) = 'S' 
                      AND crr.service_tracking_position_id = shift.position_id 
                      AND cpsd.std_shift_id IS NULL 
                      AND 1 = CASE 
                                WHEN ( shift.end_time - shift.start_time ) < 0 
                                     AND ( 
                                cpsd.schedule_time >= shift.start_time 
                                 OR cpsd.schedule_time <= shift.end_time ) 
                              THEN 1 
                                WHEN ( shift.end_time - shift.start_time ) > 0 
                                     AND ( 
                                cpsd.schedule_time >= shift.start_time 
                                AND cpsd.schedule_time <= shift.end_time ) 
                              THEN 1 
                                ELSE 0 
                              END THEN 1 
                        ELSE 0 
                      END 
       INNER JOIN dbo.#prp_position_times pt 
               ON pt.position_id = crr.service_tracking_position_id 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       AND cpsd.std_shift_id IS NULL 
       AND ( Isnull(@vPositionTimes, '-1') = '-1' 
              OR pt.position_id IS NOT NULL );  
	
-------------------------------------------------------------
-- Row data for Actual Hours
-------------------------------------------------------------
update #prp_poc_details 
	    set schedule_time=replace(convert(varchar(5),dbo.fn_adjust_time_fac_time_zone (@vFacId ,completed_date),108),':','')
 where completed_date is not null 
 and substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)<>'Q' 
 
 
--QSHIFT	
INSERT INTO @ROWDATA (schedule_detail_id,shift_id,shift_name,group_name,position_id,position,day_of_week,total_minutes,timeFlag,completed_date,schedule_date,document_id)
SELECT cpsd.schedule_detail_id, 
       shift.shift_id, 
       CASE 
         WHEN ( shift.end_time - shift.start_time ) < 0 
              AND ( cpsd.schedule_time >= shift.start_time 
                     OR cpsd.schedule_time <= shift.end_time ) THEN 
         shift.shift_name 
         WHEN ( shift.end_time - shift.start_time ) > 0 
              AND ( cpsd.schedule_time >= shift.start_time 
                    AND cpsd.schedule_time <= shift.end_time ) THEN 
         shift.shift_name 
       END                       AS Shift1, 
       shift.group_name, 
       usr.position_id, 
       CASE 
         WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown' 
         ELSE usr.position_description 
       END                       AS position, 
       Datepart(dd, shift_date)  AS day_of_week, 
       Isnull(cpsd.task_time, 0) AS total_minutes, 
       2 timeFlag, 
       cpsd.completed_date, 
       cpsd.shift_date           AS schedule_date, 
       cpsd.documentation_id 
FROM   #prp_poc_details cpsd 
       INNER JOIN cp_rev_intervention crr WITH (nolock) 
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.#prp_shift_link shift 
               ON cpsd.std_shift_id = shift.shift_id 
       INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock) 
               ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id 
       INNER JOIN dbo.#prp_position_times pt 
               ON pt.position_id = crr.service_tracking_position_id 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       AND cpsd.completed_date IS NOT NULL 
       AND cpsd.strikeout_date IS NULL;  

--NonQshift

INSERT INTO @ROWDATA (schedule_detail_id,shift_id,shift_name,group_name,position_id,position,day_of_week,total_minutes,timeFlag,completed_date,schedule_date,document_id)
SELECT cpsd.schedule_detail_id, 
       Cast(shift.shift_id AS VARCHAR) + '-' 
       + Cast(shift.flg AS VARCHAR)     shift_id, 
       CASE 
         WHEN 
       Substring(cpsd.schedule_detail_id, 
       Charindex('_', cpsd.schedule_detail_id) + 1, 1) = 'D' 
       AND ( shift.end_time - shift.start_time ) < 0 
       AND ( cpsd.schedule_time >= shift.start_time 
              OR cpsd.schedule_time <= shift.end_time ) THEN shift.shift_name 
         WHEN 
       Substring(cpsd.schedule_detail_id, 
       Charindex('_', cpsd.schedule_detail_id) + 1, 1) = 'D' 
       AND ( shift.end_time - shift.start_time ) > 0 
       AND ( cpsd.schedule_time >= shift.start_time 
             AND cpsd.schedule_time <= shift.end_time ) THEN shift.shift_name 
         WHEN 
       Substring(cpsd.schedule_detail_id, 
       Charindex('_', cpsd.schedule_detail_id) + 1, 1) <> 'D'THEN 
         shift.shift_name 
       END                              AS Shift, 
       shift.group_name, 
       usr.position_id, 
       CASE 
         WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown' 
         ELSE usr.position_description 
       END                              AS position, 
       Datepart(dd, cpsd.schedule_date) AS day_of_week, 
       Isnull(cpsd.task_time, 0)        AS total_minutes, 
       2 timeFlag, 
       cpsd.completed_date, 
       cpsd.schedule_date, 
       cpsd.documentation_id 
FROM   #prp_poc_details cpsd 
       INNER JOIN cp_rev_intervention crr WITH (nolock) 
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.#prp_shifts shift 
               ON 1 = CASE 
                        WHEN 
                      Substring(cpsd.schedule_detail_id, 
                      Charindex('_', cpsd.schedule_detail_id) + 1, 1) = 'D' 
                      AND crr.service_tracking_position_id = shift.position_id 
                      AND cpsd.std_shift_id IS NULL THEN 1 
                        WHEN 
                      Substring(cpsd.schedule_detail_id, 
                      Charindex('_', cpsd.schedule_detail_id) + 1, 1) IN ( 'U', 
                      'S' ) 
                      AND crr.service_tracking_position_id = shift.position_id 
                      AND cpsd.std_shift_id IS NULL 
                      AND 1 = CASE 
                                WHEN ( shift.end_time - shift.start_time ) < 0 
                                     AND ( 
                                cpsd.schedule_time >= shift.start_time 
                                 OR cpsd.schedule_time <= shift.end_time ) 
                              THEN 1 
                                WHEN ( shift.end_time - shift.start_time ) > 0 
                                     AND ( 
                                cpsd.schedule_time >= shift.start_time 
                                AND cpsd.schedule_time <= shift.end_time ) 
                              THEN 1 
                                ELSE 0 
                              END THEN 1 
                        WHEN Substring(cpsd.schedule_detail_id, 
                             Charindex('_', cpsd.schedule_detail_id) + 1, 
                                    1) = 'S' 
                             AND crr.service_tracking_position_id = -1 
                             AND cpsd.std_shift_id IS NULL 
                             AND cpsd.schedule_time >= shift.start_time 
                             AND cpsd.schedule_time <= shift.end_time THEN 1 
                        ELSE 0 
                      END 
       INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock) 
               ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id 
       INNER JOIN dbo.#prp_position_times pt 
               ON pt.position_id = crr.service_tracking_position_id 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       AND cpsd.completed_date IS NOT NULL 
       AND cpsd.std_shift_id IS NULL 
       AND cpsd.strikeout_date IS NULL  ;
	

if @vIncludeUnscheduled='Y'
begin 
INSERT INTO @ROWDATA (schedule_detail_id,shift_id,shift_name,group_name,position_id,position,day_of_week,total_minutes,timeFlag,completed_date,schedule_date,document_id)
SELECT cpsd.schedule_detail_id, 
       Cast(shift_id AS VARCHAR) + '-' 
       + Cast(shift.flg AS VARCHAR)     shift_id, 
       CASE 
         WHEN 
       Substring(cpsd.schedule_detail_id, 
       Charindex('_', cpsd.schedule_detail_id) + 1, 1) = 'D' 
       AND ( shift.end_time - shift.start_time ) < 0 
       AND ( cpsd.schedule_time >= shift.start_time 
              OR cpsd.schedule_time <= shift.end_time ) THEN shift.shift_name 
         WHEN 
       Substring(cpsd.schedule_detail_id, 
       Charindex('_', cpsd.schedule_detail_id) + 1, 1) = 'D' 
       AND ( shift.end_time - shift.start_time ) > 0 
       AND ( cpsd.schedule_time >= shift.start_time 
             AND cpsd.schedule_time <= shift.end_time ) THEN shift.shift_name 
         WHEN 
       Substring(cpsd.schedule_detail_id, 
       Charindex('_', cpsd.schedule_detail_id) + 1, 1) <> 'D'THEN 
         shift.shift_name 
       END                              AS Shift, 
       shift.group_name, 
       usr.position_id, 
       CASE 
         WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown' 
         ELSE usr.position_description 
       END                              AS position, 
       Datepart(dd, cpsd.schedule_date) AS day_of_week, 
       Isnull(cpsd.task_time, 0)        AS total_minutes, 
       2 timeFlag, 
       cpsd.completed_date, 
       cpsd.schedule_date, 
       cpsd.documentation_id 
FROM   #prp_poc_details cpsd 
       INNER JOIN cp_rev_intervention crr WITH (nolock) 
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.#prp_shifts shift 
               ON 1 = CASE 
                        WHEN 
                      Substring(cpsd.schedule_detail_id, 
                      Charindex('_', cpsd.schedule_detail_id) + 1, 1) = 'D' 
                      AND crr.service_tracking_position_id = shift.position_id 
                      AND cpsd.std_shift_id IS NULL THEN 1 
                        WHEN 
                      Substring(cpsd.schedule_detail_id, 
                      Charindex('_', cpsd.schedule_detail_id) + 1, 1) IN ( 'U', 
                      'S' ) 
                      AND crr.service_tracking_position_id = shift.position_id 
                      AND cpsd.std_shift_id IS NULL 
                      AND 1 = CASE 
                                WHEN ( shift.end_time - shift.start_time ) < 0 
                                     AND ( 
                                cpsd.schedule_time >= shift.start_time 
                                 OR cpsd.schedule_time <= shift.end_time ) 
                              THEN 1 
                                WHEN ( shift.end_time - shift.start_time ) > 0 
                                     AND ( 
                                cpsd.schedule_time >= shift.start_time 
                                AND cpsd.schedule_time <= shift.end_time ) 
                              THEN 1 
                                ELSE 0 
                              END THEN 1 
                        WHEN Substring(cpsd.schedule_detail_id, 
                             Charindex('_', cpsd.schedule_detail_id) + 1, 
                                    1) = 'S' 
                             AND crr.service_tracking_position_id = -1 
                             AND cpsd.std_shift_id IS NULL 
                             AND cpsd.schedule_time >= shift.start_time 
                             AND cpsd.schedule_time <= shift.end_time THEN 1 
                        ELSE 0 
                      END 
       INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock) 
               ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id 
       INNER JOIN dbo.#prp_position_times pt 
               ON pt.position_id = crr.service_tracking_position_id 
WHERE  cpsd.schedule_type = 40 
       AND cpsd.schedule_type <> 8 
       AND completed_date IS NOT NULL 
       AND cpsd.std_shift_id IS NULL 
       AND cpsd.strikeout_date IS NULL  
end


IF @vIncludePRN='Y'
BEGIN 
	INSERT INTO @ROWDATA (schedule_detail_id,shift_id,shift_name,group_name,position_id,position,day_of_week,total_minutes,timeFlag,completed_date,schedule_date,document_id)
	SELECT cpsd.schedule_detail_id, 
		   shift_id,
		   shift.shift_name as Shift, 
		   shift.group_name, 
		   usr.position_id, 
		   CASE 
			 WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown' 
			 ELSE usr.position_description 
		   END                              AS position, 
		   Datepart(dd, cpsd.schedule_date) AS day_of_week, 
		   Isnull(cpsd.task_time, 0)        AS total_minutes, 
		   2 as timeFlag, 
		   dbo.fn_adjust_time_fac_time_zone(@vFacId, cpsd.completed_date) as completed_date, 
		   dbo.fn_adjust_time_fac_time_zone(@vFacId, cpsd.schedule_date) as schedule_date,
		   cpsd.documentation_id 
	FROM   #prp_poc_details cpsd 
		   INNER JOIN cp_rev_intervention crr WITH (nolock) 
				   ON crr.clientid = cpsd.client_id 
					  AND crr.current_row = 'Y' 
					  AND crr.gen_intervention_id = cpsd.intervention_id 
					  AND crr.require_time_tracking = 1 
		   LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
				  ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
					 AND cpstdi.poc_flowsheet = 'Y' 
		   INNER JOIN dbo.#prp_shift_link shift 
				   ON shift.shift_id = cpsd.std_shift_id				   
		   INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock) 
				   ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id 
		   INNER JOIN dbo.#prp_position_times pt 
				   ON pt.position_id = crr.service_tracking_position_id 
	WHERE  cpsd.schedule_type = 8 
		   AND completed_date IS NOT NULL  
		   AND cpsd.strikeout_date IS NULL
END

--ADJUST SHIFT NAME BASE OF COMPLETED DATE OR SCHEDULE DATE


update a set shift_name=b.shift_name,shift_id=cast(b.shift_id as varchar)+'-'+cast(b.flg as varchar)
 from @ROWDATA a
 inner join #prp_shifts b on cast(replace(convert(varchar(5),schedule_date,108),':','') as int)>=b.start_time and 
 cast(replace(convert(varchar(5),schedule_date,108),':','') as int)<=b.end_time 
 inner join #PRP_Position_Times c on c.position_id=b.position_id
where a.shift_name is null 
 


delete from @ROWDATA 
where shift_name is null 
and substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)<>'D' 

--------------- DELETE DUPLICATE

;WITH CTE_1  AS
(
select schedule_detail_id,shift_name,group_name,position_id,position,total_minutes,timeFlag,
case when timeFlag=1 then null else completed_date end completed_date ,
case when timeFlag=1 then null else document_id end document_id,
row_number() over(PARTITION BY schedule_detail_id,shift_name,group_name,position_id,position,total_minutes,timeFlag,case when timeFlag=1 then null else completed_date end,case when timeFlag=1 then null else document_id end
order by schedule_detail_id,shift_name,group_name,position_id,position,total_minutes,timeFlag,case when timeFlag=1 then null else completed_date end,
case when timeFlag=1 then null else document_id end) row_id
from @ROWDATA
) 

delete from cte_1 where  row_id>1


--Qshift
update  a set 
  a.completed_date=  dbo.fn_adjust_time_fac_time_zone (@vFacId ,completed_date ) 
from @ROWDATA a
where substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)='Q'  

--NonQshift
    --- Nightshift
    update a SET
    schedule_date=cast(convert(varchar(20),b.day_date,110)
    +' '
    +convert(varchar(5),dbo.fn_adjust_time_fac_time_zone (@vFacId ,schedule_date ),108) as datetime),
    completed_date =cast(convert(varchar(20),c.day_date,110)
    +' '
    +convert(varchar(5),dbo.fn_adjust_time_fac_time_zone (@vFacId ,completed_date ),108) as datetime)

     from @ROWDATA a
     inner join @Dateadjust b on b.std_shift_id=cast(substring(a.shift_id,1,charindex('-',a.shift_id)-1) as int)
     and cast(convert(varchar(20),a.schedule_date,110) as datetime)=cast(convert(varchar(20),b.s_date,110) as datetime)
     left join @Dateadjust c on c.std_shift_id=cast(substring(a.shift_id,1,charindex('-',a.shift_id)-1) as int)
     and cast(convert(varchar(20),a.completed_date,110) as datetime)=cast(convert(varchar(20),c.s_date,110) as datetime)
    where substring(a.schedule_detail_id,charindex('_',a.schedule_detail_id)+1,1)<>'Q'
        and right(shift_id,1)=1;

    --- DAY AND EVEING 
    UPDATE a SET 
      a.schedule_date  =  dbo.fn_adjust_time_fac_time_zone (@vFacId ,schedule_date ),
      a.completed_date =  dbo.fn_adjust_time_fac_time_zone (@vFacId ,completed_date ) 
     FROM   @ROWDATA a 
    WHERE  Substring(schedule_detail_id, Charindex('_', schedule_detail_id) + 1, 1) <> 'Q' 
       AND RIGHT(shift_id, 1) = 0;  


--------------- showing actual and plan in the same day
DELETE  
FROM @ROWDATA WHERE (schedule_date <@vStartDate or schedule_date>DATEADD(dd,-1,@vEndDate)) and  schedule_date is not null;



DELETE  a
FROM @ROWDATA a 
where a.timeflag=1
AND ( NOT EXISTS (SELECT 1 FROM @ROWDATA b WHERE b.schedule_detail_id=a.schedule_detail_id AND b.timeFlag=2 AND a.document_id=b.document_id) )
AND SUBSTRING(schedule_detail_id,CHARINDEX('_',schedule_detail_id)+1,1)='D';

UPDATE  a SET 
  day_of_week= CASE 
                WHEN SUBSTRING(schedule_detail_id,CHARINDEX('_',schedule_detail_id)+1,1) in ('D') AND a.completed_date IS NOT NULL 
                  THEN DATEPART(dd,completed_date)
                WHEN timeflag=1 THEN DATEPART(dd,schedule_date)
                WHEN timeflag in (2,3)  and SUBSTRING(schedule_detail_id,CHARINDEX('_',schedule_detail_id)+1,1) <>'Q'
                 THEN DATEPART(dd,completed_date) ELSE DATEPART(dd,schedule_date)
                END
FROM @ROWDATA a;  

              


update a set day_of_week=dw.dw
from @ROWDATA  a
INNER JOIN @day_week dw on dw.date_day=
 CASE 
  WHEN SUBSTRING(schedule_detail_id,CHARINDEX('_',schedule_detail_id)+1,1) in ('D') AND a.completed_date IS NOT NULL  
    THEN CAST(CONVERT(VARCHAR(10),completed_date, 120)  AS DATETIME)
  WHEN timeflag=1 THEN CAST(CONVERT(VARCHAR(10),schedule_date, 120)  AS DATETIME) 
  WHEN timeflag IN (2,3)  AND SUBSTRING(schedule_detail_id,CHARINDEX('_',schedule_detail_id)+1,1) <>'Q'
                 THEN CAST(CONVERT(VARCHAR(10),completed_date, 120)  AS DATETIME) ELSE CAST(CONVERT(VARCHAR(10),schedule_date, 120)  AS DATETIME)
  
  end

--if @debug_me='Y' SELECT * FROM @ROWDATA	 order by timeFlag

----------------------------------------------------------------------

INSERT INTO #prp_poc_planned 
	select
	  @vFacId,shift_name,group_name,position_id,position,'Planned Hours' as hour_type,
	  [1] as Sunday,[2] as Monday, [3] as    Tuesday, [4] as Wednesday, [5] as Thursday, [6] as Friday, 
	  [7] as Saturday, 0 as total, 0 as ordr
	from
	(select schedule_detail_id,shift_name,group_name,position_id,position,day_of_week,total_minutes,timeFlag 
     from @ROWDATA
     where timeFlag=1
	) as rawdata
	PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7])) as pivotdata
	ORDER BY 1,2

	
	INSERT INTO #prp_poc_planned 
	select @vFacId,shift_name,group_name,position_id,position,'Actual Hours' as hour_type,[1] as Sunday,[2] as Monday, [3] as Tuesday, [4] as Wednesday, [5] as Thursday, [6] as Friday, 
		[7] as Saturday, 0 as total, 1 as ordr
	from
	(
	select schedule_detail_id,shift_name,group_name,position_id,position,day_of_week,total_minutes,timeFlag 
     from @ROWDATA
     where timeFlag=2
	) as rawdata
	PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7])) as pivotdata
	ORDER BY 1,2
	
	

---------------------------------------------------------------------------	
	--insert dummy actual row if the corresponding planned ro has no data
---------------------------------------------------------------------------

	
	INSERT INTO #prp_poc_planned
	select @vFacId,planned.Shift,planned.group_name,planned.position_id,planned.position,'Actual Hours' as hour_type,
		0 as Sunday, 0 as Monday, 0 as Tuesday, 0 as Wednesday, 0 as Thursday, 0 as Friday, 0 as Saturday, 0 as total, 1 as ordr
		from #prp_poc_planned planned
		 where  planned.ordr=0
		  and not exists  (select 1 from #prp_poc_planned actual where  actual.ordr=1 and planned.shift=actual.shift and planned.position_id=actual.position_id )
	 

	if @debug_me='Y' select * from #prp_poc_planned
	
	

    insert into #prp_poc_planned_final
	select @vFacId,
	Shift,group_name,position_id,position,hour_type,
	sum(Sunday) Sunday,sum(Monday) Monday,sum(Tuesday) Tuesday,sum(Wednesday) Wednesday,sum(Thursday) Thursday,
	sum(Friday) Friday,sum(Saturday),sum(total) total,ordr
		from #prp_poc_planned  
		group by Shift,group_name,position_id,position,hour_type,ordr
		order by shift,ordr

CREATE  CLUSTERED INDEX _temp1_prp_poc_planned_final on #prp_poc_planned_final(Shift,position,ordr)	

INSERT INTO #prp_poc_planned_final
select @vFacId,
	pre.Shift,pre.group_name,pre.position_id,pre.position,'Planned '+CHAR(45)+' Actual = ' as hour_type,
	(isnull(pre.Sunday,0)-isnull(nxt.Sunday,0)) as Sunday,
	(isnull(pre.Monday,0)-isnull(nxt.Monday,0)) as Monday, 
	(isnull(pre.Tuesday,0)-isnull(nxt.Tuesday,0)) as Tuesday, 
	(isnull(pre.Wednesday,0)-isnull(nxt.Wednesday,0)) as Wednesday, 
	(isnull(pre.Thursday,0)-isnull(nxt.Thursday,0)) as Thursday, 
	(isnull(pre.Friday,0)-isnull(nxt.Friday,0)) as Friday, 
	(isnull(pre.Saturday,0)-isnull(nxt.Saturday,0)) as Saturday, 
	0 as total, 2 as ordr
	from (select Shift
			,group_name
			,position_id 
			,position
			,Sunday
			,Monday
			,Tuesday
			,Wednesday
			,Thursday
			,Friday
			,Saturday
		from #prp_poc_planned_final where ordr=0) pre
		join (select Shift
			,group_name
			,position_id 
			,position
			,Sunday
			,Monday
			,Tuesday
			,Wednesday
			,Thursday
			,Friday
			,Saturday
		from #prp_poc_planned_final a where ordr=1
		and EXISTS (select 1 from #prp_poc_planned_final b where a.fac_id=b.fac_id and a.shift=b.shift 
		and a.position_id=b.position_id and b.ordr=0)) nxt
		on pre.position=nxt.position
		and pre.shift=nxt.shift;
	
	

	insert INTO #prp_poc_planned_final
		select pocplan.fac_id,pocplan.Shift,pocplan.group_name,pocplan.position_id, pocplan.position,'Planned FTEs' as hour_type,
		(pocplan.Sunday/pt.hours) as Sunday,
		(pocplan.Monday/pt.hours) as Monday,
		(pocplan.Tuesday/pt.hours) as Tuesday,
		(pocplan.Wednesday/pt.hours) as Wednesday,
		(pocplan.Thursday/pt.hours) as Thursday,
		(pocplan.Friday/pt.hours) as Friday,
		(pocplan.Saturday/pt.hours) as Saturday,
		0 as Total, 3 as ordr
		from #prp_poc_planned_final pocplan
		inner JOIN #PRP_Position_Times pt on pocplan.position_id=pt.position_id and pocplan.ordr=0

	
	insert INTO #prp_poc_planned_final
		select pocplan.fac_id,pocplan.Shift,pocplan.group_name,pocplan.position_id, pocplan.position,'Actual FTEs' as hour_type,
		(pocplan.Sunday/pt.hours) as Sunday,
		(pocplan.Monday/pt.hours) as Monday,
		(pocplan.Tuesday/pt.hours) as Tuesday,
		(pocplan.Wednesday/pt.hours) as Wednesday,
		(pocplan.Thursday/pt.hours) as Thursday,
		(pocplan.Friday/pt.hours) as Friday,
		(pocplan.Saturday/pt.hours) as Saturday,
		0 as Total, 4 as ordr
		from #prp_poc_planned_final pocplan
		inner JOIN #PRP_Position_Times pt on pocplan.position_id=pt.position_id and pocplan.ordr=1


	
	INSERT INTO pcc.#prp_poc_planned_final

	select @vFacId,pre.Shift,pre.group_name,pre.position_id,pre.position,'FTEs: Planned '+CHAR(45)+' Actual = ' as hour_type,
	(isnull(pre.Sunday,0)-isnull(nxt.Sunday,0)) as Sunday,
	(isnull(pre.Monday,0)-isnull(nxt.Monday,0)) as Monday, 
	(isnull(pre.Tuesday,0)-isnull(nxt.Tuesday,0)) as Tuesday, 
	(isnull(pre.Wednesday,0)-isnull(nxt.Wednesday,0)) as Wednesday, 
	(isnull(pre.Thursday,0)-isnull(nxt.Thursday,0)) as Thursday, 
	(isnull(pre.Friday,0)-isnull(nxt.Friday,0)) as Friday, 
	(isnull(pre.Saturday,0)-isnull(nxt.Saturday,0)) as Saturday, 
	0 as total, 5 as ordr
	from (select Shift
			,group_name
			,position_id 
			,position
			,Sunday
			,Monday
			,Tuesday
			,Wednesday
			,Thursday
			,Friday
			,Saturday
		from #prp_poc_planned_final where ordr=3) pre
		join (select Shift
			,group_name
			,position_id 
			,position
			,Sunday
			,Monday
			,Tuesday
			,Wednesday
			,Thursday
			,Friday
			,Saturday
		from #prp_poc_planned_final a where ordr=4
		and EXISTS (select 1 from #prp_poc_planned_final b where a.fac_id=b.fac_id and a.shift=b.shift 
		and a.position_id=b.position_id and b.ordr=3)) nxt
		on pre.position=nxt.position
		and pre.shift=nxt.shift;

	--if @debug_me='Y' select * from #prp_poc_planned

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	Set @vgs_fill_end_time  = getdate() ; -- fill end time

	select @vStep = 70
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' updating pivoted table ' + convert(varchar(26),getdate(),109)

	update #prp_poc_planned_final SET 
		Sunday = case when hour_type like '%FTEs%' then ISNULL(Sunday, 0)/60 else ISNULL(Sunday, 0) end
		,Monday = case when hour_type like '%FTEs%' then ISNULL(Monday, 0)/60 else ISNULL(Monday, 0) end 
		,Tuesday = case when hour_type like '%FTEs%' then ISNULL(Tuesday, 0)/60 else ISNULL(Tuesday, 0) end 
		,Wednesday = case when hour_type like '%FTEs%' then ISNULL(Wednesday, 0)/60 else ISNULL(Wednesday, 0) end 
		,Thursday = case when hour_type like '%FTEs%' then ISNULL(Thursday, 0)/60 else ISNULL(Thursday, 0) end 
		,Friday = case when hour_type like '%FTEs%' then ISNULL(Friday, 0)/60 else ISNULL(Friday, 0) end 
		,Saturday = case when hour_type like '%FTEs%' then ISNULL(Saturday, 0)/60 else ISNULL(Saturday, 0) end 

	
	update #prp_poc_planned_final SET total= (Sunday + Monday + Tuesday + Wednesday + Thursday + Friday + Saturday)


	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	Set @vgs_fill_end_time  = getdate() ; -- fill end time

	select @vStep = 90
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' returning final result ' + convert(varchar(26),getdate(),109)
	--*********************************************************************************************************
	
	delete from #prp_poc_planned_final where position ='Unknown' and ordr in (0,2)


   
    
	select fac_id,Shift,Group_name,position as discipline,hour_type
		,CASE WHEN sum(Sunday) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(Sunday) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(Sunday)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(Sunday)), 0), 114) END as Sunday
		,CASE WHEN sum(Monday) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(Monday) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(Monday)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(Monday)), 0), 114) END as Monday
		,CASE WHEN sum(Tuesday) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(Tuesday) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(Tuesday)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(Tuesday)), 0), 114) END as Tuesday
		,CASE WHEN sum(Wednesday) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(Wednesday) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(Wednesday)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(Wednesday)), 0), 114) END as Wednesday
		,CASE WHEN sum(Thursday) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(Thursday) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(Thursday)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(Thursday)), 0), 114) END as Thursday
		,CASE WHEN sum(Friday) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(Friday) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(Friday)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(Friday)), 0), 114) END as Friday
		,CASE WHEN sum(Saturday) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(Saturday) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(Saturday)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(Saturday)), 0), 114) END as Saturday
		,CASE WHEN sum(Total) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(Total) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(Total)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(Total)), 0), 114) END as Total
		, @status_code as status_code, @status_text as status_text	
	from
	#prp_poc_planned_final
	group BY fac_id,Shift,Group_name,position,hour_type,ordr
	order BY shift,position,ordr

	Set @rows_returned = @@ROWCOUNT;

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	if @debug_me='Y' Print 'Successful execution of stored procedure ' + Object_name(@@ProcID) + convert(varchar(26),getdate(),109);

END TRY 

BEGIN CATCH 
	if @status_code = 0 Set @Status_Code = 1 else set @status_code = 2  --- convert 3 to 2
	if @status_code = 1
	BEGIN
		select @Status_Text = Rtrim(Left('Stored Procedure Failed with error Code : ' +   Cast(@@error as Varchar(10)) +  ' Line Number : ' +  Cast(ERROR_LINE() as Varchar(5)) + ' ' +  ERROR_MESSAGE(),3000))

		if @debug_me='Y' Print 'Stored procedure failure in step:'+ convert(varchar(3),@vstep) + '	' + convert(varchar(26),getdate())
		if @debug_me='Y' Print 'Error code: '+convert(varchar(3),@vStep) + '; Error description:	' + @Status_Text
	END 

	Select 
		NULL as fac_id
		, NULL as Shift
		, NULL as Group_name
		, NULL as discipline
		, NULL as hour_type
		, NULL as task
		, NULL as Sunday
		, NULL as Monday
		, NULL as Tuesday
		, NULL as Wednesday
		, NULL as Thursday 
		, NULL as Friday
		, NULL as Saturday
		, NULL as Total
		, @status_code as status_code
		, @status_text as status_text
		
END CATCH 

RETURN 

END
GO
GRANT EXECUTE ON  dbo.sproc_prp_rl_poc_planned_actual_service_time   to PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_prp_rl_poc_planned_actual_service_time.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_poc_planned_actual_service_time.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_poc_planned_actual_service_time_client.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- PCC-52767      :   script to create sproc_prp_rl_poc_planned_actual_service_time_client Procedure  
--						-- 
-- Written By:          Ritch Moore
-- Reviewed By:         
-- 
-- Script Type:         DDL 
-- Target DB Type:      Client
-- Target ENVIRONMENT:  BOTH (US/CA) 
-- 
-- 
-- Re-Runable:          YES 
-- 
-- Description of Script : Create sproc_prp_rl_poc_planned_actual_service_time_client Procedure for Service Tracking reporting
-- 
-- Special Instruction: 

-- 
-- =================================================================================

/***********************************************************************************
Revision History:
2013-09-24  Ritch Moore		PCC-52767	3.7.3 Initial creation of this stored proc
2014-02-28  Ritch Moore		PCC-52769	3.7.3 Fixed planned-Actual and updated Total logic
2014-03-28  Henny Ehghaghy	PCC-54689	3.7.3.1
2014-03-25  Henny Ehghaghy	PCC-55402	3.7.3.2 
2014-03-25  Henny Ehghaghy	PCC-56339	3.7.3.2  
2014-04-07  Henny Ehghaghy	PCC-56251	3.7.4 Assigne Alias name before all column names 
2014-05-20  Henny Ehghaghi  PCC-57972   3.7.4.1 Fixing Shift descreption (when start or end time is zero)

***********************************************************************************/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_prp_rl_poc_planned_actual_service_time_client' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE dbo.sproc_prp_rl_poc_planned_actual_service_time_client
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO



Create Procedure dbo.sproc_prp_rl_poc_planned_actual_service_time_client

  @fac_id int
, @client_id int = -1
, @include_unscheduled char(1) = 'N'
, @include_prn char(1) = 'N'
, @week_date datetime = Null
, @execution_user_login varchar(60)
, @rows_returned int out
, @debug_me char(1)  = 'N'
, @status_code int  out 
, @status_text varchar(3000) out
/********************************************************************************
			   
Declare  @rows_ret int		,@statuscode int		,@statustext varchar(3000)
exec dbo.sproc_prp_rl_poc_planned_actual_service_time_client
@fac_id =  '1'
,@client_id = '-1'--'388162'--262120--'-1'
--,@unit_id =  '-1'
--,@shift_id ='-1'
,@include_unscheduled  = 'Y'
,@week_date='2/24/2014'
--,@position_times ='19091,8;19059,8;60580,8'
,@execution_user_login='pcc-moorer'
,@rows_returned = null
,@debug_me = 'N'
,@status_code = null
,@status_text = null

**********************************************************************************/

as
Begin


SET NOCOUNT ON;
--declare Standard local variables required for any store proc
DECLARE  @vStep int
		,@vErr varchar(max)
		,@vReportDate datetime
		,@vRowCount int

--Facility Related variables, also used in capturing execution Statistics 
Declare @vFacIDs varchar(max)		
Declare @vFacWarningMsg varchar(max) --- to know whether it the returned list is restricted

----Local Variables
DECLARE @vFacId int
	, @vWeekDate datetime
	, @vClientId	int
	, @vIncludeUnscheduled char(1) 
	, @vStartDate datetime
	, @vEndDate datetime
	, @vIncludePRN CHAR(1)
	, @vIncludePRNbit BIT;

-----Governor and Statistics Variables 
Declare  @vgs_program_name varchar(200)
		 ,@vgs_execution_user varchar(60)
		 ,@vgsStepStartTime datetime
		 ,@vgsStepEndTime datetime


CREATE TABLE #prp_shifts( 
		  shift_id int
		, shift_name varchar(50) 
		, start_time int
		, end_time int
		, group_name varchar(15)
		, position_id int
		, flg int
);

CREATE TABLE #prp_shift_link( 
		  shift_id int
		, shift_name varchar(50) 
		, start_time int
		, end_time int
		, group_name varchar(15)
		, position_id int
);

CREATE TABLE #prp_poc_details( 
		  id_key varchar(20)
		, first_name varchar(50)
		, last_name varchar(50) 
		, bed_id int
		, bed_desc varchar(30)
		, discharge_date datetime
		, client_id_number varchar(35)
		, photo_small varchar(55)
		, room_desc varchar(60)
		, unit_id int
		, unit_desc varchar(35)
		, admission_date datetime
		, client_id int
		,effective_date datetime
		,ineffective_date datetime
		, current_row varchar(1)
		, intervention_desc  varchar(2000)
		, date_initiated datetime
		, std_intervention_id  int
		, require_time_tracking bit
		, baseline_time smallint
		, intervention_id  int
		, schedule_id  int
		, schedule_type  int
		, std_shift_ids  varchar(500)
		, start_time varchar(4)
		, end_time varchar(4)
		, xxminutes  int
		, fac_id  int 
		, date_of_month int
		, schedule_detail_id varchar(100)
		, std_shift_id int
		, shift_date datetime
		, schedule_date datetime
		, schedule_end_date datetime
		, documentation_id varchar(100)
		, completed_date datetime
		, strikeout_date datetime
		, entered_date datetime
		, task_time smallint
		, cp_sec_user_audit_id int
		, struckout_cp_sec_user_audit_id int
		);


CREATE TABLE #prp_poc_planned( 
		  fac_id int
		, client_id int
		, client_name varchar(250)
		, shift varchar(50)
		, group_name varchar(15) 
		, position_id int
		, position varchar(254) 
		, hour_type varchar (60)
		, sunday decimal(8,2) default 0
		, monday decimal(8,2) default 0
		, tuesday decimal(8,2) default 0
		, wednesday decimal(8,2) default 0
		, thursday decimal(8,2) default 0
		, friday decimal(8,2) default 0
		, saturday decimal(8,2) default 0
		, total decimal(10,2) default 0
		, ordr tinyint
);

CREATE TABLE #prp_poc_planned_final( 
		  fac_id int
		, client_id int
		, client_name varchar(250)
		, shift varchar(50)
		, group_name varchar(15) 
		, position_id int
		, position varchar(254) 
		, hour_type varchar (60)
		, sunday decimal(8,2) default 0
		, monday decimal(8,2) default 0
		, tuesday decimal(8,2) default 0
		, wednesday decimal(8,2) default 0
		, thursday decimal(8,2) default 0
		, friday decimal(8,2) default 0
		, saturday decimal(8,2) default 0
		, total decimal(10,2) default 0
		, ordr tinyint
);

DECLARE @ROWDATA TABLE
 (
 id_key int IDENTITY(1,1),
  schedule_detail_id varchar(250),
  client_id         int,
  client_name       varchar(max),
  shift_id           int,
  shift             varchar(50),
  group_name        varchar(15),
  service_tracking_position_id int,
  position_id        int,
  position           varchar(254),
  day_of_week        int,
  total_minutes      int,
  timeFlag           int,
  completed_date     datetime,
  schedule_date      datetime,
  document_id  varchar(250),
  sFlag              int,--struckout flag
    PRIMARY KEY (schedule_detail_id, timeflag, shift_id,id_key),
     UNIQUE CLUSTERED (schedule_date,completed_date,id_key) 

 );
 
  DECLARE @day_week table
(
	dw int IDENTITY(1,1),
	date_day datetime,day_num int);


declare 
@daylightStart datetime , 
@daylightEnd  datetime

BEGIN TRY

	Set @status_code = 0   ---- Status Code 0 = Success, 1 = Exception
	set @status_text = null;
	set @rows_returned = 0;
	Set @vgs_program_name  = Object_name(@@ProcID);  ---Current Store Proc Name
	Set @vgs_execution_user = @execution_user_login;

	select @vStep = 0
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Executing store proc :  ' + @vgs_program_name  + convert(varchar(26),getdate(),109)


	----Parameter Sniffing - use local variables when they are used in a where clause
	SET @vFacID					= @fac_id;
	SET @vWeekDate				= @week_date;
	set @vIncludeUnscheduled	= @include_unscheduled;
	SET @vIncludePRN	= ISNULL(@include_prn, 'N');
	SELECT @vIncludePRNbit = IIF(@vIncludePRN = 'N', 0, 1);

	set @vClientId				= @client_id;
	set @vStartDate				= @vWeekDate;
	set @vEndDate				= dateadd(dd,6,@vStartDate);
	set	@vEndDate				= (select convert(datetime, convert(varchar(4), datepart(yyyy, @vEndDate))
									+ '-' + convert(varchar(2), datepart(MM, @vEndDate))
									+ '-' + convert(varchar(2), datepart(dd, @vEndDate))
									+ ' 23:59:59'));
	SELECT @daylightStart=start_date,@daylightEnd=end_date
	FROM day_light_savings_dates
	WHERE datepart(yyyy,start_date )=datepart(yyyy,@vWeekDate );

if @debug_me='Y' Print ' @vStartDate: '+convert(varchar(26),@vStartDate,109)

if @debug_me='Y' Print ' @vEndDate: '+convert(varchar(26),@vEndDate,109)



	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep = 10
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Validating Input Parameters  ' +  convert(varchar(26),getdate(),109)

	----Validate all input parameters
	if (
		@fac_id is NULL 
		or @execution_user_login is null
		or @week_date is null
		)
	begin
		set @vErr = 'One or more of the following input parameters is invalid... '
					+ ' @fac_id=' + isnull(convert(varchar(10),@fac_id),'null/empty')
					+ ' @week_date=' + isnull(convert(varchar(10),@week_date, 101),'null/empty')
					+ ', @execution_user_login=' + isnull(@execution_user_login,'null/empty')
	
		RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);
	end

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	Select @vStep = 20;
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Getting user access fac list ' + convert(varchar(26),getdate(),109);

	Select @vFacIds = fac_id
		  ,@vFacWarningMsg = msg
	From  dbo.fn_prp_get_facility_access_list_delim(@vFacId ,@vgs_execution_user); ---filter the fac list with user access

	--facilities warnings
	if @vFacWarningMsg is NOT NULL --- NOT NULL stands for restricted facilities access warning message
	Begin
		Set @status_code = 2 ; ----Set it warning
		Set @status_text = isnull(@status_text,'') + @vFacWarningMsg ;
	End 
	
	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	-------------------------------------------------------------
	-- Inserting records in temp table.
	-------------------------------------------------------------
	
	select @vStep = 50
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' getting raw data ' + convert(varchar(26),getdate(),109)

	insert INTO  #prp_poc_details 
		( id_key
		, first_name
		, last_name
		, bed_id
		, bed_desc
		, discharge_date
		, client_id_number
		, photo_small
		, room_desc
		, unit_id
		, unit_desc
		, admission_date
		, client_id
		, effective_date  
		, ineffective_date  
		, current_row
		, intervention_desc
		, date_initiated
		, std_intervention_id
		, require_time_tracking
		, baseline_time
		, intervention_id
		, schedule_id
		, schedule_type
		, std_shift_ids
		, start_time 
		, end_time 
		, xxminutes
		, fac_id
		, date_of_month 
		, schedule_detail_id
		, std_shift_id
		, shift_date 
		, schedule_date
		, schedule_end_date
		, documentation_id
		, completed_date
		, strikeout_date
		, entered_date
		, task_time
		, cp_sec_user_audit_id
		, struckout_cp_sec_user_audit_id
		)
	exec dbo.sproc_prp_pcc_poc_getScheduleDetails
	@vFacId,
	-1,--@vShiftId,--@shiftID_param int,
	-1,--@myPositionID_param int,
	-1,--@assignmentID_param int,
	-1,--@unitID_param int,
	-1,--@selectedPositionID_param int,
	@vStartDate,--'2014-01-26 00:00:00',--@shiftStartTime_param datetime,
	@vEndDate,--'2014-02-01 23:59:59'--@shiftEndTime_param datetime,
	NULL,--'7445,7455,7465',--@stdInts_param varchar(8000),
	@vClientId,--@clientID_param int,@vClientId
	@vStartDate,--'2014-01-26 00:00:00',--@localStartTime_param datetime,
	@vEndDate,--'2014-02-01 23:59:59'--@localEndTime_param datetime,
	Null,--@max_details_param int = 2147483647,
	@vIncludePRNbit,--@include_prn_param bit = 1,
	'N',--@debug				char(1)  = 'N',
	Null,--@status_code		int	out,
	Null--@status_text		varchar(3000) out
	
	set @vRowCount = @@rowcount
		if  (@vRowCount = 0)
	 begin
	 Set @status_code = 2
	 Set @status_text = isnull(@status_text,'') + 'No Data Found' ;
	 Raiserror( 'sproc_prp_pcc_poc_getScheduleDetails returned 0 rows.', 10, 1 );
	 
	 end
	 

-- DAY LIGHT SAVING DATE 
        update  a set
            schedule_date=case 
              when schedule_date= dateadd(hh,1,@daylightStart) then @daylightStart
              when schedule_date= dateadd(hh,-1,@daylightEnd) then @daylightEnd
             end   ,
            completed_date=case 
              when completed_date= dateadd(hh,1,@daylightStart) then  @daylightStart
              when completed_date= dateadd(hh,-1,@daylightEnd) then  @daylightEnd
              end 
        from #prp_poc_details a
         where schedule_date= dateadd(hh,1,@daylightStart) or schedule_date= dateadd(hh,-1,@daylightEnd)
         or completed_date= dateadd(hh,1,@daylightStart) or completed_date= dateadd(hh,-1,@daylightEnd)



		update #prp_poc_details 
	        set
	        schedule_date =case 
	                        when substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)='D'  and completed_date is not null THEN
	                            completed_date
	                        else schedule_date end ;

	
	 
 	 delete					        
    from #prp_poc_details
    where ineffective_date is not null
    and schedule_date>ineffective_date;


    delete from #prp_poc_details
    where ineffective_date is  null
    and schedule_date<effective_date;

	CREATE  CLUSTERED INDEX _temp1_prppocdetails on #prp_poc_details(id_key,client_id,intervention_id,std_intervention_id)


	if @debug_me='Y' select * from #prp_poc_details order BY client_id, schedule_date
	
	insert into @day_week 
    select  day_date,day_num
     from date_dim
    where day_date>=@vStartDate and day_date<=@vEndDate;
    
    if @debug_me='Y' select * from @day_week

--It's using for QSHIFT
	INSERT INTO #prp_shift_link( shift_id , shift_name , start_time , end_time , group_name , position_id )
	select distinct shift.std_shift_id,shift.description,
	shift.start_time,shift.end_time,'',0
	from dbo.cp_std_shift shift WITH (NOLOCK)
	WHERE
	shift.deleted='N' and (shift.fac_id=@vFacId or shift.fac_id=-1)
	
	if @debug_me='Y' select * from #prp_shift_link order BY shift_name

--It's using for Non-QSHIFT
INSERT INTO #prp_shifts (shift_id , shift_name, start_time , end_time , group_name, position_id , flg)
	select distinct shift.std_shift_id,
	
		shift.description+' ('+
		case when left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end)) ='' then '0' ELSE

left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end))
end 
		+':'+right(cast(start_time as int),2)+(case when cast(start_time as int)>1200 THEN ' PM' ELSE ' AM' END) 
		+' - ' +
		case when rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end))))='' then '0'
		else
		rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end)))) end 
		+':'+right(cast(end_time as int),2)+(case when cast(end_time as int)>1200 THEN ' PM' ELSE ' AM' END) +')' shift_name,
		
	shift.start_time,cast(shift.end_time as int) end_time,'',0 position_id,
	case when shift.start_time - ( cast(shift.end_time as int)-1 )>0 then 1 else 0 end
	from dbo.cp_std_shift shift WITH (NOLOCK) 
    WHERE
	shift.deleted='N' and (shift.fac_id=@vFacId or shift.fac_id=-1);
	
	

	CREATE  CLUSTERED INDEX _temp1_prpshifts on #prp_shifts(position_id,start_time,end_time)

	if @debug_me='Y' select * from #prp_shifts order BY shift_name;
	      	
	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep = 60
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' loading and calculating pivoted table ' + convert(varchar(26),getdate(),109)

-------------------------------------------------------------
-- Row data for Planned Hours
-------------------------------------------------------------
--Qshift
INSERT INTO @ROWDATA 
            (schedule_detail_id, 
             client_id, 
             client_name,
             shift_id, 
             shift, 
             group_name, 
             position_id, 
             position, 
             day_of_week, 
             total_minutes, 
             timeflag, 
             completed_date,
             schedule_date,document_id,sFlag) 
SELECT cpsd.schedule_detail_id, 
       cpsd.client_id, 
       cpsd.last_name + ', ' + cpsd.first_name + ' (' 
       + cpsd.client_id_number + ')'                      AS client_name,shift_id, 
       'Scheduled'                                        AS Shift, 
       ''                                                 AS group_name, 
       crr.service_tracking_position_id                   AS position_id, 
       cc.item_description                                AS position, 
       Datepart(dd, cpsd.shift_date)                      AS day_of_week, 
       COALESCE(cpsd.baseline_time, cpstdi.baseline_time) AS total_minutes, 
       1, 
       cpsd.completed_date ,cpsd.shift_date as schedule_date,cpsd.documentation_id,
       case when cpsd.strikeout_date is not null then 1 else 0 end sFlag   
FROM   #prp_poc_details cpsd 
       inner join cp_rev_intervention crr WITH (NOLOCK) on crr.clientid=cpsd.client_id
       and crr.current_row='Y'
       and crr.gen_intervention_id=cpsd.intervention_id
       and crr.require_time_tracking = 1
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
               ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                  AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.common_code cc WITH (nolock) 
               ON crr.service_tracking_position_id = cc.item_id 
       INNER JOIN dbo.#prp_shift_link shift 
               ON cpsd.std_shift_id = shift.shift_id 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8;
	
	
	

	------------
	--Non-Qshift
INSERT INTO @ROWDATA 
            (schedule_detail_id, 
             client_id, 
             client_name,shift_id, 
             shift, 
             group_name, 
             position_id, 
             position, 
             day_of_week, 
             total_minutes, 
             timeflag, 
             completed_date,schedule_date,document_id,sFlag) 
SELECT cpsd.schedule_detail_id, 
       cpsd.client_id, 
       cpsd.last_name + ', ' + cpsd.first_name + ' (' 
       + cpsd.client_id_number + ')'                      AS client_name,shift_id, 
       'Scheduled'                                        AS Shift, 
       ''                                                 AS group_name,
       case 
         when isnull(cpstdi.require_time_tracking,0) = 1  then crr.service_tracking_position_id 
         when  isnull(cpstdi.require_time_tracking,0)=0 and isnull(crr.require_time_tracking,0)=1 then crr.service_tracking_position_id
       end  AS position_id,
 
       cc.item_description                                AS position, 
       Datepart(dd, cpsd.schedule_date)                        AS day_of_week, 
       COALESCE(cpsd.baseline_time, cpstdi.baseline_time) AS total_minutes, 
       1, 
       cpsd.completed_date,cpsd.schedule_date,cpsd.documentation_id ,
       case when cpsd.strikeout_date is not null then 1 else 0 end sFlag
FROM   #prp_poc_details cpsd 
       inner join cp_rev_intervention crr WITH (NOLOCK) on crr.clientid=cpsd.client_id
       and crr.current_row='Y'
       and crr.gen_intervention_id=cpsd.intervention_id
       and crr.require_time_tracking = 1
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
               ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                  AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.common_code cc WITH (nolock) 
               ON   cc.item_id = crr.service_tracking_position_id

       INNER JOIN dbo.#prp_shifts shift 
               ON 1 = CASE 
                        WHEN Substring(cpsd.schedule_detail_id,Charindex('_', cpsd.schedule_detail_id) + 1,1)  = 'D' 
                             AND cpsd.std_shift_id IS NULL THEN 1 
                        WHEN Substring(cpsd.schedule_detail_id,Charindex('_', cpsd.schedule_detail_id) + 1,1) = 'S' 
                             AND cpsd.std_shift_id IS NULL 
                            
                             THEN 1 
                        
                        ELSE 0 
                      END 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       AND cpsd.std_shift_id IS NULL;
	    
-------------------------------------------------------------
-- Row data for Actual Hours
-------------------------------------------------------------
 
INSERT INTO @ROWDATA --Qshift
            (schedule_detail_id, 
             client_id, 
             client_name,shift_id, 
             shift, 
             group_name,
             service_tracking_position_id, 
             position_id, 
             position, 
             day_of_week, 
             total_minutes, 
             timeflag, 
             completed_date,schedule_date,document_id) 
SELECT cpsd.schedule_detail_id, 
       cpsd.client_id, 
       cpsd.last_name + ', ' + cpsd.first_name + ' (' 
       + cpsd.client_id_number + ')' AS client_name, 
       shift.shift_id, 
       'Scheduled'                   AS Shift, 
       ''                            AS group_name, 
       crr.service_tracking_position_id, 
       usr.position_id, 
       CASE 
         WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown' 
         ELSE usr.position_description 
       END                           AS position, 
       Datepart(dd, cpsd.shift_date)      AS day_of_week, 
       Isnull(cpsd.task_time, 0)     AS total_minutes, 
       2 timeflag, 
       cpsd.completed_date, 
       cpsd.shift_date                    AS schedule_date, 
       cpsd.documentation_id 
FROM   #prp_poc_details cpsd 
       INNER JOIN cp_rev_intervention crr WITH (nolock) 
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.#prp_shift_link shift 
               ON cpsd.std_shift_id = shift.shift_id 
       INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock) 
               ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       AND cpsd.completed_date IS NOT NULL 
       AND cpsd.strikeout_date IS NULL; 
       
        
INSERT INTO @ROWDATA --Non-Qshift
            (schedule_detail_id, 
             client_id, 
             client_name,shift_id, 
             shift, 
             group_name, 
             service_tracking_position_id,
             position_id, 
             position, 
             day_of_week, 
             total_minutes, 
             timeflag, 
             completed_date,schedule_date,document_id) 
            SELECT cpsd.schedule_detail_id, 
       cpsd.client_id, 
       cpsd.last_name + ', ' + cpsd.first_name + ' (' 
       + cpsd.client_id_number + ')' AS client_name, 
       shift.shift_id, 
       'Scheduled'                   AS Shift, 
       ''                            AS group_name, 
       CASE 
         WHEN Isnull(cpstdi.require_time_tracking, 0) = 1 THEN 
         crr.service_tracking_position_id 
         WHEN Isnull(cpstdi.require_time_tracking, 0) = 0 
              AND Isnull(crr.require_time_tracking, 0) = 1 THEN 
         crr.service_tracking_position_id 
       END                           AS position_id, 
       usr.position_id, 
       CASE 
         WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown' 
         ELSE usr.position_description 
       END                           AS position, 
       Datepart(dd, cpsd.schedule_date)   AS day_of_week, 
       Isnull(cpsd.task_time, 0)     AS total_minutes, 
       2 timeflag, 
       cpsd.completed_date, 
       cpsd.schedule_date, 
       cpsd.documentation_id 
FROM   #prp_poc_details cpsd 
       INNER JOIN cp_rev_intervention crr WITH (nolock) 
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.#prp_shifts shift 
               ON 1 = CASE 
                        WHEN Substring(cpsd.schedule_detail_id, 
                             Charindex('_', cpsd.schedule_detail_id) + 1, 
                             1) 
                             = 'D' 
                             AND cpsd.std_shift_id IS NULL THEN 1 
                        WHEN Substring(cpsd.schedule_detail_id, 
                             Charindex('_', cpsd.schedule_detail_id) + 1, 
                             1) 
                             IN ( 'U', 'S' ) 
                             AND cpsd.std_shift_id IS NULL THEN 1 
                        ELSE 0 
                      END 
       INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock) 
               ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       AND completed_date IS NOT NULL 
       AND cpsd.std_shift_id IS NULL 
       AND cpsd.strikeout_date IS NULL;  
       
       
IF @vIncludeUnscheduled = 'Y'
BEGIN
        INSERT INTO @ROWDATA 
            (schedule_detail_id, 
             client_id, 
             client_name,
             shift_id, 
             shift, 
             group_name, 
             position_id, 
             position, 
             day_of_week, 
             total_minutes, 
             timeflag, 
             completed_date,schedule_date,document_id) 
       SELECT cpsd.schedule_detail_id, 
		   cpsd.client_id, 
		   cpsd.last_name + ', ' + cpsd.first_name + ' (' 
		   + cpsd.client_id_number + ')' AS client_name, 
		   shift.shift_id, 
		   'Unscheduled'                 AS Shift, 
		   ''                            AS group_name, 
		   usr.position_id, 
		   CASE 
			 WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown' 
			 ELSE usr.position_description 
		   END                           AS position, 
		   Datepart(dd, cpsd.schedule_date)   AS day_of_week, 
		   Isnull(cpsd.task_time, 0)     AS total_minutes, 
		   3 timeflag, 
		   cpsd.completed_date, 
		   cpsd.schedule_date, 
		   cpsd.documentation_id 
	FROM   #prp_poc_details cpsd 
       INNER JOIN cp_rev_intervention crr WITH (NOLOCK)
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.#prp_shifts shift WITH (nolock) 
               ON 1 = CASE 
                        WHEN Substring(cpsd.schedule_detail_id, 
                             Charindex('_', cpsd.schedule_detail_id) + 1, 
                             1) 
                             = 'D' 
                             AND cpsd.std_shift_id IS NULL THEN 1 
                        WHEN Substring(cpsd.schedule_detail_id, 
                             Charindex('_', cpsd.schedule_detail_id) + 1, 
                             1) 
                             IN ( 
                                    'U' ) 
                             AND cpsd.std_shift_id IS NULL THEN 1 
                        ELSE 0 
                      END 
       INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock) 
               ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id 
	WHERE  cpsd.schedule_type = 40 
       AND cpsd.completed_date IS NOT NULL 
       AND cpsd.strikeout_date IS NULL;  
       
       
END;

IF @vIncludePRN = 'Y'
BEGIN
	INSERT INTO @rowdata
				(schedule_detail_id,
				 client_id,
				 client_name,
				 shift_id,
				 shift,
				 group_name,
				 position_id,
				 position,
				 day_of_week,
				 total_minutes,
				 timeflag,
				 completed_date,
				 schedule_date,
				 document_id)
			SELECT cpsd.schedule_detail_id,
		   cpsd.client_id,
		   cpsd.last_name + ', ' + cpsd.first_name + ' ('
		   + cpsd.client_id_number + ')' AS client_name,
		   shift.std_shift_id as shift_id,
		   'PRN'                   AS Shift,
		   ''                            AS group_name,
		   usr.position_id,
		   CASE
			 WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown'
			 ELSE usr.position_description
		   END                           AS position,
		   Datepart(dd, schedule_date)   AS day_of_week,
		   Isnull(cpsd.task_time, 0)     AS total_minutes,
		   4 as timeflag,
		   cpsd.completed_date,
		   cpsd.schedule_date,
		   cpsd.documentation_id
	FROM   #prp_poc_details cpsd
		   INNER JOIN dbo.cp_rev_intervention crr  WITH (nolock)
				   ON crr.clientid = cpsd.client_id
					  AND crr.current_row = 'Y'
					  AND crr.gen_intervention_id = cpsd.intervention_id
					  AND crr.require_time_tracking = 1
		   LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock)
				  ON cpsd.std_intervention_id = cpstdi.std_intervention_id
					 AND cpstdi.poc_flowsheet = 'Y'
		   INNER JOIN dbo.cp_std_shift shift WITH (NOLOCK)
					 ON shift.std_shift_id = cpsd.std_shift_id
		   INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock)
				   ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id
	WHERE  cpsd.schedule_type = 8
		   AND completed_date IS NOT NULL
		   AND cpsd.strikeout_date IS NULL;
END;

--------------- Delete duplicate
;WITH CTE_1  AS
(
select  schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,
  position ,total_minutes,timeFlag ,case when timeFlag=1 then null else completed_date end completed_date ,
  case when timeFlag=1 then null else document_id end document_id,
row_number() over(PARTITION BY  schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,
  position ,total_minutes,timeFlag ,case when timeFlag=1 then null else completed_date end ,case when timeFlag=1 then null else document_id end 
order by  schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,
  position ,total_minutes,timeFlag ,case when timeFlag=1 then null else completed_date end,case when timeFlag=1 then null else document_id end  ) row_id
from @ROWDATA
) 

delete from cte_1 where  row_id>1;
-------------------------------------------------------------------
update  a set 
  a.schedule_date=   case when substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)<>'Q' 
   then dbo.fn_adjust_time_fac_time_zone (@vFacId ,schedule_date ) else schedule_date end,
  a.completed_date=  dbo.fn_adjust_time_fac_time_zone (@vFacId ,completed_date ) 
from @ROWDATA a;


----------------- showing actual and plan in the same day----------

delete  from @ROWDATA where (schedule_date <@vStartDate or schedule_date>@vEndDate) and  schedule_date is not null

delete  a
from @ROWDATA a 
where a.timeflag=1
and not exists (select 1 from @ROWDATA b where b.schedule_detail_id=a.schedule_detail_id and b.timeFlag=2 and a.document_id=b.document_id)
and substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)='D';


update  a set 
  day_of_week= case 
                when substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1) in ('D') and a.completed_date is not null 
                  then datepart(dd,completed_date)
                when timeflag=1 then datepart(dd,schedule_date)
                when timeflag in (2,3,4) and substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)<>'Q'
                  then datepart(dd,completed_date) else datepart(dd,schedule_date)
                end
from @ROWDATA a ; 

	
update a set day_of_week=dw.dw
from @ROWDATA  a
INNER JOIN @day_week dw on dw.date_day=
 case 
  when substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1) in ('D') and a.completed_date is not null  
    then cast(convert(varchar(10),completed_date, 120)  as datetime)
  when timeflag=1 then cast(convert(varchar(10),schedule_date, 120)  as datetime) 
  when timeflag in (2,3,4) and substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)<>'Q' 
  then cast(convert(varchar(10),completed_date, 120)  as datetime) 
  ELSE cast(convert(varchar(10),schedule_date, 120)  as datetime)
  end;

----------------------------------------------------------------------
	INSERT INTO #prp_poc_planned --
	select @vFacId,client_id,client_name,Shift,group_name,position_id,position,'Planned' as hour_type,
	isnull([1],0) as Sunday,isnull([2],0) as Monday, isnull([3],0) as Tuesday, isnull([4],0) as Wednesday,
	 isnull([5],0) as Thursday, isnull([6],0) as Friday, isnull([7],0) as Saturday, 0 as total, 0 as ordr
	from
	(select schedule_detail_id ,client_id,client_name ,shift ,group_name,position_id,
  position ,day_of_week ,total_minutes,timeFlag ,completed_date  from @ROWDATA where timeFlag=1
	) as rawdata
	PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7])) as pivotdata



	INSERT INTO #prp_poc_planned --
	select @vFacId,client_id,client_name,Shift,group_name,position_id,position,'Actual' as hour_type,
	isnull([1],0) as Sunday,isnull([2],0) as Monday, isnull([3],0) as Tuesday, isnull([4],0) as Wednesday,
	 isnull([5],0) as Thursday, isnull([6],0) as Friday, isnull([7],0) as Saturday, 0 as total, 
		  CASE 
		   WHEN (service_tracking_position_id<>position_id or position_id is null)  THEN 3
		    else 1 end as ordr
	from
	(select schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,
  position ,day_of_week ,total_minutes,timeFlag ,completed_date  from @ROWDATA where timeFlag=2
	) as rawdata
	PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7])) as pivotdata

	
	IF @vIncludeUnscheduled = 'Y'
	BEGIN
		INSERT INTO #prp_poc_planned --
		select @vFacId,client_id,client_name,Shift,group_name,position_id,position,'Actual' as hour_type,
		[1] as Sunday,[2] as Monday, [3] as Tuesday, [4] as Wednesday, [5] as Thursday, [6] as Friday, 
			[7] as Saturday, 0 as total, 
			  10  as ordr
		from
		(select schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,
	  position ,day_of_week ,total_minutes,timeFlag ,completed_date  from @ROWDATA where timeFlag=3
		) as rawdata
		PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7])) as pivotdata
	END

	IF @vIncludePRN = 'Y'
	BEGIN
		INSERT INTO #prp_poc_planned
			(fac_id, client_id, client_name, shift, group_name, position_id, position, hour_type,
			sunday, monday, tuesday, wednesday, thursday, friday, saturday, total, ordr)
		SELECT
			@vFacId, client_id, client_name, Shift, group_name, position_id, position,'Actual' as hour_type,
			[1] as Sunday,[2] as Monday, [3] as Tuesday, [4] as Wednesday, [5] as Thursday, [6] as Friday,
			[7] as Saturday, 0 as total,
			20  as ordr
		FROM
			(select schedule_detail_id, client_id, client_name, shift, group_name, service_tracking_position_id, position_id,
			  position, day_of_week, total_minutes, timeFlag, completed_date
			  from @rowdata
			  where timeFlag=4
			) as rawdata
		PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7])) as pivotdata

		INSERT INTO #prp_poc_planned
			(fac_id, client_id, client_name, shift, group_name, position_id, position, hour_type,
			sunday, monday, tuesday, wednesday, thursday, friday, saturday, total, ordr)
		SELECT
			fac_id,client_id,client_name,Shift,group_name, 0, 'ZZZZ', '' as hour_type,sum(Sunday) as Sunday,sum(Monday) as Monday, sum(Tuesday) as Tuesday, 
			sum(Wednesday) as Wednesday, sum(Thursday) as Thursday, sum(Friday) as Friday, sum(Saturday) as Saturday, sum(total) as total, 21 as ordr
		FROM #prp_poc_planned
		WHERE ordr = 20
		GROUP BY fac_id,client_id,client_name,Shift,group_name

		--insert dummy actual row if the corresponding planned ro has no data
		INSERT INTO #prp_poc_planned
			(fac_id, client_id, client_name, shift, group_name, position_id, position, hour_type, 
			sunday, monday, tuesday, wednesday, thursday, friday, saturday, total, ordr)
		SELECT 
			distinct planned.fac_id,planned.client_id,planned.client_name,'No PRN Tasks Documented' as Shift,'' as group_name, 0 as position_id,'ZZZZ' as position,'Actual' as hour_type,
			0 as Sunday, 0 as Monday, 0 as Tuesday, 0 as Wednesday, 0 as Thursday, 0 as Friday, 0 as Saturday, 0 as total, 20 as ordr
		FROM #prp_poc_planned planned WITH (NOLOCK) 
		LEFT JOIN (select client_id from #prp_poc_planned WITH (NOLOCK) where ordr=20 group by client_id) clients 
			ON planned.client_id = clients.client_id and planned.ordr=0
		WHERE planned.ordr=0 and clients.client_id is null

	END


---------------------------------------------------------------------------	
	--insert dummy actual row if the corresponding planned ro has no data
---------------------------------------------------------------------------
	INSERT INTO #prp_poc_planned
	select @vFacId,planned.client_id,planned.client_name,planned.Shift,planned.group_name,planned.position_id,planned.position,'Planned' as hour_type,
		0 as Sunday, 0 as Monday, 0 as Tuesday, 0 as Wednesday, 0 as Thursday, 0 as Friday, 0 as Saturday, 0 as total, 0 as ordr
		from #prp_poc_planned planned
		 where  planned.ordr=1
		  and not exists  (select 1 from #prp_poc_planned actual where  actual.ordr=0 and planned.shift=actual.shift and planned.position_id=actual.position_id )
	
		
	INSERT INTO #prp_poc_planned
	select @vFacId,planned.client_id,planned.client_name,planned.Shift,planned.group_name,planned.position_id,planned.position,'Actual' as hour_type,
		0 as Sunday, 0 as Monday, 0 as Tuesday, 0 as Wednesday, 0 as Thursday, 0 as Friday, 0 as Saturday, 0 as total, 1 as ordr
		from #prp_poc_planned planned
		 where  planned.ordr=0
		  and not exists  (select 1 from #prp_poc_planned actual where  actual.ordr=1 and planned.shift=actual.shift and planned.position_id=actual.position_id )
	
	IF @vIncludeUnscheduled = 'Y'
	begin
		
		INSERT INTO #prp_poc_planned
		select fac_id,client_id,client_name,Shift,group_name,0,'ZZZZ','' as hour_type,sum(Sunday) as Sunday,sum(Monday) as Monday, sum(Tuesday) as Tuesday, 
			sum(Wednesday) as Wednesday, sum(Thursday) as Thursday, sum(Friday) as Friday, sum(Saturday) as Saturday, sum(total) as total, 11 as ordr
		from #prp_poc_planned
		where ordr = 10
		group BY fac_id,client_id,client_name,Shift,group_name

		--insert dummy actual row if the corresponding planned ro has no data
		INSERT INTO #prp_poc_planned
		select distinct planned.fac_id,planned.client_id,planned.client_name,'No Unscheduled Tasks Documented' as Shift,'' as group_name, 0 as position_id,'ZZZZ' as position,'Actual' as hour_type,
			0 as Sunday, 0 as Monday, 0 as Tuesday, 0 as Wednesday, 0 as Thursday, 0 as Friday, 0 as Saturday, 0 as total, 10 as ordr
		from #prp_poc_planned planned WITH (NOLOCK) 
		left JOIN (select client_id from #prp_poc_planned WITH (NOLOCK) where ordr=10 group by client_id) clients 
			ON planned.client_id = clients.client_id and planned.ordr=0
		where planned.ordr=0 and clients.client_id is null


	end



	if @debug_me='Y' select * from #prp_poc_planned
	
	update #prp_poc_planned SET total= (isnull(Sunday,0) + isnull(Monday,0) + isnull(Tuesday,0) + isnull(Wednesday,0) + isnull(Thursday,0) + isnull(Friday,0) + isnull(Saturday,0))

	insert into #prp_poc_planned_final
	select 
		@vFacId , client_id , client_name , shift , group_name , position_id , position , hour_type ,
		sum(Sunday) Sunday,sum(Monday) Monday,sum(Tuesday) Tuesday,sum(Wednesday) Wednesday,sum(Thursday) Thursday,
		sum(Friday) Friday,sum(Saturday),sum(total) total,ordr
	from #prp_poc_planned  
	group by client_id , client_name , shift , group_name , position_id , position , hour_type ,ordr

	CREATE  CLUSTERED INDEX _temp1_prp_poc_planned_final on #prp_poc_planned_final(Shift,position,ordr)	

	update #prp_poc_planned_final 
	SET total= (isnull(Sunday,0) + isnull(Monday,0) + isnull(Tuesday,0) + isnull(Wednesday,0) + isnull(Thursday,0) + isnull(Friday,0) + isnull(Saturday,0))

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep = 70
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' updating pivoted table ' + convert(varchar(26),getdate(),109)

	update #prp_poc_planned_final 
	SET 
		Sunday = ISNULL(Sunday, 0)
		,Monday = ISNULL(Monday, 0)
		,Tuesday = ISNULL(Tuesday, 0)
		,Wednesday = ISNULL(Wednesday, 0)
		,Thursday = ISNULL(Thursday, 0)
		,Friday = ISNULL(Friday, 0)
		,Saturday = ISNULL(Saturday, 0)

	
	INSERT INTO pcc.#prp_poc_planned_final
	select @vFacId,pre.client_id,pre.client_name,pre.Shift,pre.group_name,pre.position_id,pre.position,'Planned '+CHAR(45)+' Actual = ' as hour_type,
		(isnull(pre.Sunday,0)-isnull(nxt.Sunday,0)) as Sunday,
		(isnull(pre.Monday,0)-isnull(nxt.Monday,0)) as Monday, 
		(isnull(pre.Tuesday,0)-isnull(nxt.Tuesday,0)) as Tuesday, 
		(isnull(pre.Wednesday,0)-isnull(nxt.Wednesday,0)) as Wednesday, 
		(isnull(pre.Thursday,0)-isnull(nxt.Thursday,0)) as Thursday, 
		(isnull(pre.Friday,0)-isnull(nxt.Friday,0)) as Friday, 
		(isnull(pre.Saturday,0)-isnull(nxt.Saturday,0)) as Saturday,
		0 as total, 2 as ordr
	from (select client_id
			,client_name
			,Shift
			,group_name
			,position_id 
			,position
			,Sunday
			,Monday
			,Tuesday
			,Wednesday
			,Thursday
			,Friday
			,Saturday
			,ROW_NUMBER() OVER ( PARTITION BY client_id--,position
				order by  client_id,position) as rwnum
		from #prp_poc_planned_final where ordr=0) pre
		join (select client_id
			,client_name
			,Shift
			,group_name
			,position_id 
			,position
			,Sunday
			,Monday
			,Tuesday
			,Wednesday
			,Thursday
			,Friday
			,Saturday
			,ROW_NUMBER() OVER ( PARTITION BY client_id--,position 
				order by  client_id,position) as rwnum
		from #prp_poc_planned_final a 
		where ordr=1
		and EXISTS (select 1 from #prp_poc_planned_final b where a.fac_id=b.fac_id and a.client_id=b.client_id and a.shift=b.shift 
		and a.position_id=b.position_id and b.ordr=0)) nxt
		on pre.client_id=nxt.client_id and pre.position=nxt.position and pre.rwnum=nxt.rwnum

	update #prp_poc_planned_final 
	SET total= (Sunday + Monday + Tuesday + Wednesday + Thursday + Friday + Saturday)

	INSERT INTO #prp_poc_planned_final
	select fac_id,client_id,client_name,Shift,group_name,0,'ZZZZ','Planned' as hour_type,sum(Sunday) as Sunday,sum(Monday) as Monday, sum(Tuesday) as Tuesday, 
		sum(Wednesday) as Wednesday, sum(Thursday) as Thursday, sum(Friday) as Friday, sum(Saturday) as Saturday, sum(total) as total, 4 as ordr
	from #prp_poc_planned_final
	where ordr = 0
	group BY fac_id,client_id,client_name,Shift,group_name

	INSERT INTO #prp_poc_planned_final
	select fac_id,client_id,client_name,Shift,group_name,0,'ZZZZ','Actual' as hour_type,sum(Sunday) as Sunday,sum(Monday) as Monday, sum(Tuesday) as Tuesday, 
		sum(Wednesday) as Wednesday, sum(Thursday) as Thursday, sum(Friday) as Friday, sum(Saturday) as Saturday, sum(total) as total, 5 as ordr
	from #prp_poc_planned_final
	where ordr = 1 or ordr = 3
	group BY fac_id,client_id,client_name,Shift,group_name



	INSERT INTO #prp_poc_planned_final
	select @vFacId,pre.client_id,pre.client_name,pre.Shift,pre.group_name,pre.position_id,pre.position,'Planned '+CHAR(45)+' Actual = ' as hour_type,
		(isnull(pre.Sunday,0)-isnull(nxt.Sunday,0)) as Sunday,
		(isnull(pre.Monday,0)-isnull(nxt.Monday,0)) as Monday, 
		(isnull(pre.Tuesday,0)-isnull(nxt.Tuesday,0)) as Tuesday, 
		(isnull(pre.Wednesday,0)-isnull(nxt.Wednesday,0)) as Wednesday, 
		(isnull(pre.Thursday,0)-isnull(nxt.Thursday,0)) as Thursday, 
		(isnull(pre.Friday,0)-isnull(nxt.Friday,0)) as Friday, 
		(isnull(pre.Saturday,0)-isnull(nxt.Saturday,0)) as Saturday,  
	0 as total, 6 as ordr
	from (select client_id
			,client_name
			,Shift
			,group_name
			,position_id 
			,position
			,Sunday
			,Monday
			,Tuesday
			,Wednesday
			,Thursday
			,Friday
			,Saturday
			,ROW_NUMBER() OVER ( PARTITION BY client_id--,position
				order by  client_id,position) as rwnum
		from #prp_poc_planned_final where ordr=4) pre
		join (select client_id
			,client_name
			,Shift
			,group_name
			,position_id 
			,position
			,Sunday
			,Monday
			,Tuesday
			,Wednesday
			,Thursday
			,Friday
			,Saturday
			,ROW_NUMBER() OVER ( PARTITION BY client_id--,position 
				order by  client_id,position) as rwnum
		from #prp_poc_planned_final a 
		where ordr=5
		and EXISTS (select 1 from #prp_poc_planned_final b where a.fac_id=b.fac_id and a.client_id=b.client_id and a.shift=b.shift 
		and a.position_id=b.position_id and b.ordr=4)) nxt
		on pre.client_id=nxt.client_id and pre.position=nxt.position and pre.rwnum=nxt.rwnum


	--Insert summary data. Need to provide output only if either PRN or Unscheduled tasks were checked off

	IF (@vIncludeUnscheduled = 'Y' OR @vIncludePRN = 'Y')
	BEGIN
		INSERT INTO #prp_poc_planned_final
			(fac_id ,client_id   , client_name , shift  , group_name, position_id, position  , hour_type   , 
			sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)
		SELECT 
			fac_id,client_id,client_name,'Summary' as Shift,group_name,0,'','Planned' as hour_type,
			sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , 30 as ordr
		FROM #prp_poc_planned_final
		WHERE ordr = 4

		INSERT INTO #prp_poc_planned_final
			(fac_id ,client_id   , client_name , shift  , group_name, position_id, position  , hour_type   , 
			sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)
		SELECT 
			fac_id,client_id,client_name,'Summary' as Shift,'' as group_name,0, '', 'Actual *' as hour_type,
			sum(Sunday) as Sunday,sum(Monday) as Monday, sum(Tuesday) as Tuesday, 
			sum(Wednesday) as Wednesday, sum(Thursday) as Thursday, sum(Friday) as Friday, sum(Saturday) as Saturday, sum(total) as total, 31 as ordr
		FROM #prp_poc_planned_final
		WHERE ordr = 5 or ordr = 21 or ordr = 11
		GROUP BY fac_id,client_id,client_name
		
		
		INSERT INTO #prp_poc_planned_final
			(fac_id ,client_id   , client_name , shift  , group_name, position_id, position, hour_type   , 
			sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)
		SELECT 
			@vFacId,pre.client_id,pre.client_name,pre.Shift,pre.group_name,pre.position_id, pre.position, 'Planned '+CHAR(45)+' Actual = ' as hour_type,
			(isnull(pre.Sunday,0)-isnull(nxt.Sunday,0)) as Sunday,
			(isnull(pre.Monday,0)-isnull(nxt.Monday,0)) as Monday, 
			(isnull(pre.Tuesday,0)-isnull(nxt.Tuesday,0)) as Tuesday, 
			(isnull(pre.Wednesday,0)-isnull(nxt.Wednesday,0)) as Wednesday, 
			(isnull(pre.Thursday,0)-isnull(nxt.Thursday,0)) as Thursday, 
			(isnull(pre.Friday,0)-isnull(nxt.Friday,0)) as Friday, 
			(isnull(pre.Saturday,0)-isnull(nxt.Saturday,0)) as Saturday,  
			0 as total, 32 as ordr
		FROM (select client_id
					,client_name
					,Shift
					,group_name
					,position_id
					,position
					,Sunday
					,Monday
					,Tuesday
					,Wednesday
					,Thursday
					,Friday
					,Saturday
				from #prp_poc_planned_final where ordr=30) pre
				join (select client_id
					,client_name
					,Shift
					,group_name
					,position_id
					,position
					,Sunday
					,Monday
					,Tuesday
					,Wednesday
					,Thursday
					,Friday
					,Saturday
				from #prp_poc_planned_final a where ordr=31) nxt
				on pre.client_id=nxt.client_id and pre.Shift=nxt.Shift

	END
		
	
	update #prp_poc_planned_final 
	SET total= (isnull(Sunday,0) + isnull(Monday,0) + isnull(Tuesday,0) + isnull(Wednesday,0) + isnull(Thursday,0) + isnull(Friday,0) + isnull(Saturday,0))

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep = 90
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' returning final result ' + convert(varchar(26),getdate(),109)
	--*********************************************************************************************************
	

	select fac_id,client_name,Shift,Group_name,case when position='ZZZZ' then 'Total' else position end as discipline,hour_type
		,CASE WHEN sum(Sunday) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Sunday) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Sunday)), 0), 114) as Sunday
		,CASE WHEN sum(Monday) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Monday) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Monday)), 0), 114) as Monday
		,CASE WHEN sum(Tuesday) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Tuesday) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Tuesday)), 0), 114) as Tuesday
		,CASE WHEN sum(Wednesday) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Wednesday) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Wednesday)), 0), 114) as Wednesday
		,CASE WHEN sum(Thursday) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Thursday) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Thursday)), 0), 114) as Thursday
		,CASE WHEN sum(Friday) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Friday) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Friday)), 0), 114) as Friday
		,CASE WHEN sum(Saturday) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Saturday) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Saturday)), 0), 114) as Saturday
		,CASE WHEN sum(Total) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Total) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Total)), 0), 114) as Total
		, @status_code as status_code, @status_text as status_text	
	from
	#prp_poc_planned_final
	group BY fac_id,client_name,Shift,Group_name,position,hour_type,ordr
	order BY
	client_name,
	case Shift when 'Scheduled' then 1
		when 'PRN' then 2
		when 'No PRN Tasks Documented' then 2
		when 'Unscheduled' then 3
		when 'No Unscheduled Tasks Documented' then 3
		when 'Summary' then 4
	else 5 end,
	position, ordr;


	Set @rows_returned = @@ROWCOUNT;

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	if @debug_me='Y' Print 'Successful execution of stored procedure ' + Object_name(@@ProcID) + convert(varchar(26),getdate(),109);

END TRY 

BEGIN CATCH 
	if @status_code = 0 Set @Status_Code = 1 else set @status_code = 2  --- convert 3 to 2
	if @status_code = 1
	BEGIN
		select @Status_Text = Rtrim(Left('Stored Procedure Failed with error Code : ' +   Cast(@@error as Varchar(10)) +  ' Line Number : ' +  Cast(ERROR_LINE() as Varchar(5)) + ' ' +  ERROR_MESSAGE(),3000))

		if @debug_me='Y' Print 'Stored procedure failure in step:'+ convert(varchar(3),@vstep) + '	' + convert(varchar(26),getdate())
		if @debug_me='Y' Print 'Error code: '+convert(varchar(3),@vStep) + '; Error description:	' + @Status_Text
	END 

	Select 
		NULL as fac_id
		, NULL as client_name
		, NULL as Shift
		, NULL as Group_name
		, NULL as discipline
		, NULL as hour_type
		, NULL as task
		, NULL as Sunday
		, NULL as Monday
		, NULL as Tuesday
		, NULL as Wednesday
		, NULL as Thursday 
		, NULL as Friday
		, NULL as Saturday
		, NULL as Total
		, @status_code as status_code
		, @status_text as status_text
		
END CATCH 

RETURN 

END
GO
GRANT EXECUTE ON  dbo.sproc_prp_rl_poc_planned_actual_service_time_client   to PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_prp_rl_poc_planned_actual_service_time_client.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_poc_planned_actual_service_time_client.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_poc_planned_actual_service_time_client_monthly.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- PCC-52767       :   script to create sproc_prp_rl_poc_planned_actual_service_time_client_monthly Procedure  
--						-- 
-- Written By:          Ritch Moore
-- Reviewed By:         
-- 
-- Script Type:         DDL 
-- Target DB Type:      Client
-- Target ENVIRONMENT:  BOTH (US/CA) 
-- 
-- 
-- Re-Runable:          YES 
-- 
-- Description of Script : Create sproc_prp_rl_poc_planned_actual_service_time_client_monthly Procedure for Service Tracking reporting
-- 
-- Special Instruction: 

-- 
-- =================================================================================

/***********************************************************************************
Revision History:
2014-02-06  Ritch Moore		PCC-52767	3.7.3 revise weekly Sp to Monthly
2014-02-28  Ritch Moore		PCC-52769	3.7.3 Fixed planned-Actual and updated Total logic
2014-03-15  Henny Ehghaghi	PCC-54689	3.7.3.1 
2014-03-25  Henny Ehghaghi	PCC-55402	3.7.3.2 
2014-04-07  Henny Ehghaghi	PCC-56251	3.7.4 Assigne Alias name before all column names 
2014-05-20  Henny Ehghaghi  PCC-57972   3.7.4.1 Fixing Shift descreption (when start or end time is zero)

***********************************************************************************/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_prp_rl_poc_planned_actual_service_time_client_monthly' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE dbo.sproc_prp_rl_poc_planned_actual_service_time_client_monthly
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO



Create Procedure dbo.sproc_prp_rl_poc_planned_actual_service_time_client_monthly
 @fac_id int
, @client_id int = -1
, @include_unscheduled char(1) = 'N'
, @include_prn char(1) = 'N'
, @month varchar(20)
, @execution_user_login varchar(60)
, @rows_returned int out
, @debug_me char(1)  = 'N'
, @status_code int  out 
, @status_text varchar(3000) out
/********************************************************************************
			   
Declare  @rows_ret int		,@statuscode int		,@statustext varchar(3000)
exec dbo.sproc_prp_rl_poc_planned_actual_service_time_client_monthly
@fac_id =  '1'
,@client_id = '-1'--'388162'--262120--'-1'
--,@unit_id =  '-1'
--,@shift_id = '1;2'
,@include_unscheduled  = 'Y'
,@month='2014,2'
--,@position_times ='19091,8.25;19059,8;60580,8'
,@execution_user_login =  'pcc-moorer'
,@rows_returned = null
,@debug_me = 'N'
,@status_code = null
,@status_text = null

**********************************************************************************/

as
Begin


SET NOCOUNT ON;
--declare Standard local variables required for any store proc
DECLARE  @vStep int
		,@vErr varchar(max)
		,@vdelim char(1)
		,@vCharNewLine  char(2)
	    ,@vSeparator char(6)
		,@vSeparator2 char(6)
		,@vReportDate datetime
		,@vRowCount int

--Facility Related variables, also used in capturing execution Statistics 
Declare @vFacIDs varchar(max)		
Declare @PRP_FacList as table(FacId int)
Declare @vFacWarningMsg varchar(max) --- to know whether it the returned list is restricted

----Local Variables

DECLARE @vFacId int
	, @vFacName varchar(500)
	, @vFacAddress varchar(max)
	, @vRegId int
	, @vWeekDate datetime
	, @vClientId int
	, @vIncludeUnscheduled char(1) 
	, @vSortBy varchar(50)
	, @Vmonth varchar(20)
	, @vStartDate datetime
	, @vEndDate datetime
	, @Vshift int
	, @Vstatus int
	, @vIncludePRN CHAR(1)
	, @vIncludePRNbit BIT;


-----Governor and Statistics Variables 
Declare  @vgs_program_name varchar(200)
		 ,@vgs_start_time datetime
		 ,@vgs_execution_user varchar(60)
		 ,@vgs_fill_end_time datetime
		 ,@vGeneric_statuscode int 
		 ,@vGeneric_statustext varchar(3000)
		 ,@vgsStepStartTime datetime
		 ,@vgsStepEndTime datetime

------TERMINOLOGY VARIABLES and COMMON VARIABLES FOR A FAC 
Declare @vClientWarningMsg varchar(max)--- to know whether it the returned list is restricted


Declare  @freq TABLE (
            day_num int
           ,day_date datetime
           ,colname varchar(20)); 

CREATE TABLE #prp_shifts( 
		  shift_id int
		, shift_name varchar(50) 
		, start_time int
		, end_time int
		, group_name varchar(15)
		, position_id int
		, flg int
);

CREATE TABLE #prp_shift_link( 
		  shift_id int
		, shift_name varchar(50) 
		, start_time int
		, end_time int
		, group_name varchar(15)
		, position_id int
);

CREATE TABLE #prp_poc_details( 
		  id_key varchar(20)
		, first_name varchar(50)
		, last_name varchar(50) 
		, bed_id int
		, bed_desc varchar(30)
		, discharge_date datetime
		, client_id_number varchar(35)
		, photo_small varchar(55)
		, room_desc varchar(60)
		, unit_id int
		, unit_desc varchar(35)
		, admission_date datetime
		, client_id int
		,effective_date datetime
		,ineffective_date datetime
		, current_row varchar(1)
		, intervention_desc  varchar(2000)
		, date_initiated datetime
		, std_intervention_id  int
		, require_time_tracking bit
		, baseline_time smallint
		, intervention_id  int
		, schedule_id  int
		, schedule_type  int
		, std_shift_ids  varchar(500)
		, start_time varchar(4)
		, end_time varchar(4)
		, xxminutes  int
		, fac_id  int 
		, date_of_month int
		, schedule_detail_id varchar(100)
		, std_shift_id int
		, shift_date datetime
		, schedule_date datetime
		, schedule_time int
		, schedule_end_date datetime
		, documentation_id varchar(100)
		, completed_date datetime
		, strikeout_date datetime
		, entered_date datetime
		, task_time smallint
		, cp_sec_user_audit_id int
		, struckout_cp_sec_user_audit_id int
		);         

CREATE TABLE #prp_poc_planned( 
		  fac_id int
		, client_id int
		, client_name varchar(250)
		, shift varchar(50)
		, group_name varchar(15) 
		, position_id int
		, position varchar(254) 
		, hour_type varchar (60)
		, day_1 decimal(8,2) default 0
		, day_2 decimal(8,2) default 0
		, day_3 decimal(8,2) default 0
		, day_4 decimal(8,2) default 0
		, day_5 decimal(8,2) default 0
		, day_6 decimal(8,2) default 0
		, day_7 decimal(8,2) default 0
		, day_8 decimal(8,2) default 0
		, day_9 decimal(8,2) default 0
		, day_10 decimal(8,2) default 0
		, day_11 decimal(8,2) default 0
		, day_12 decimal(8,2) default 0
		, day_13 decimal(8,2) default 0
		, day_14 decimal(8,2) default 0
		, day_15 decimal(8,2) default 0
		, day_16 decimal(8,2) default 0
		, day_17 decimal(8,2) default 0
		, day_18 decimal(8,2) default 0
		, day_19 decimal(8,2) default 0
		, day_20 decimal(8,2) default 0
		, day_21 decimal(8,2) default 0
		, day_22 decimal(8,2) default 0
		, day_23 decimal(8,2) default 0
		, day_24 decimal(8,2) default 0
		, day_25 decimal(8,2) default 0
		, day_26 decimal(8,2) default 0
		, day_27 decimal(8,2) default 0
		, day_28 decimal(8,2) default 0
		, day_29 decimal(8,2) default 0
		, day_30 decimal(8,2) default 0
		, day_31 decimal(8,2) default 0
		, total  decimal(20,2) default 0
		, ordr tinyint
);

CREATE TABLE #prp_poc_planned_final( 
		  fac_id int
		, client_id int
		, client_name varchar(250)
		, shift varchar(50)
		, group_name varchar(15) 
		, position_id int
		, position varchar(254) 
		, hour_type varchar (60)
		, day_1 decimal(8,2) default 0
		, day_2 decimal(8,2) default 0
		, day_3 decimal(8,2) default 0
		, day_4 decimal(8,2) default 0
		, day_5 decimal(8,2) default 0
		, day_6 decimal(8,2) default 0
		, day_7 decimal(8,2) default 0
		, day_8 decimal(8,2) default 0
		, day_9 decimal(8,2) default 0
		, day_10 decimal(8,2) default 0
		, day_11 decimal(8,2) default 0
		, day_12 decimal(8,2) default 0
		, day_13 decimal(8,2) default 0
		, day_14 decimal(8,2) default 0
		, day_15 decimal(8,2) default 0
		, day_16 decimal(8,2) default 0
		, day_17 decimal(8,2) default 0
		, day_18 decimal(8,2) default 0
		, day_19 decimal(8,2) default 0
		, day_20 decimal(8,2) default 0
		, day_21 decimal(8,2) default 0
		, day_22 decimal(8,2) default 0
		, day_23 decimal(8,2) default 0
		, day_24 decimal(8,2) default 0
		, day_25 decimal(8,2) default 0
		, day_26 decimal(8,2) default 0
		, day_27 decimal(8,2) default 0
		, day_28 decimal(8,2) default 0
		, day_29 decimal(8,2) default 0
		, day_30 decimal(8,2) default 0
		, day_31 decimal(8,2) default 0
		, total  decimal(20,2) default 0
		, ordr tinyint
);

DECLARE @ROWDATA TABLE
 (
 id_key int IDENTITY(1,1),
  schedule_detail_id varchar(250),
  client_id         int,
  client_name       varchar(max),
  shift_id           int,
  shift             varchar(50),
  group_name        varchar(15),
  service_tracking_position_id int,
  position_id        int,
  position           varchar(254),
  day_of_week        int,
  total_minutes      int,
  timeFlag           int,
  completed_date     datetime,
  schedule_date      datetime,
  document_id  varchar(250),
  sFlag              int,--struckout flag
    PRIMARY KEY (schedule_detail_id, timeflag, shift_id,id_key),
     UNIQUE CLUSTERED (schedule_date,completed_date,id_key) 

 );
 

  declare @daylightStart datetime , 
		@daylightEnd  datetime;
 
BEGIN TRY

	Set @status_code = 0   ---- Status Code 0 = Success, 1 = Exception
	set @status_text = null;
	set @rows_returned = 0;
	Set @vgs_program_name  = Object_name(@@ProcID);  ---Current Store Proc Name
	Set @vgs_start_time = getdate();
	Set @vgs_execution_user = @execution_user_login;
--	Set @vLocationWithUnit ='1'

	select @vStep = 0
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Executing store proc :  ' + @vgs_program_name  + convert(varchar(26),getdate(),109)

	--set Standard variables
	set @vdelim = ';'
	set @vCharNewLine  = char(10);
	set @vSeparator = 'ZYXWVU';
	set @vSeparator2 = 'UVWXYZ';

	----Parameter Sniffing - use local variables when they are used in a where clause
	SET @vFacID			= @fac_id;

	set @vClientId				= @client_id;
	set @vIncludeUnscheduled	= @include_unscheduled;
    SET @Vmonth         = @month;
	SET @vIncludePRN	= ISNULL(@include_prn, 'N');
	SELECT @vIncludePRNbit = IIF(@vIncludePRN = 'N', 0, 1);

   	SET @vStartDate     = CAST(SUBSTRING(@Vmonth,1,CHARINDEX(',',@Vmonth)-1)+'-'+SUBSTRING(@Vmonth,CHARINDEX(',',@Vmonth)+1,LEN(@Vmonth))+'-01' AS DATETIME);
    SET @vEndDate       =  CAST(CONVERT(VARCHAR(10),DATEADD(s,-1,DATEADD(mm, DATEDIFF(m,0,@vStartDate)+1,0)),12) AS DATETIME);
 	SET	@vEndDate		= (select convert(datetime, convert(varchar(4), datepart(yyyy, @vEndDate))
							+ '-' + convert(varchar(2), datepart(MM, @vEndDate))
							+ '-' + convert(varchar(2), datepart(dd, @vEndDate))
							+ ' 23:59:59'))

   SELECT @daylightStart=start_date,@daylightEnd=end_date
	FROM day_light_savings_dates
	WHERE datepart(yyyy,start_date )=left(@month,4);
    --select 11,@vPositionTimes
    
     if @debug_me='Y' select @vStartDate startDate,@vEndDate endDate,DATEADD(dd,-(DAY(DATEADD(mm,1,@vEndDate))-1),DATEADD(mm,1,@vEndDate))

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep = 10
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Validating Input Parameters  ' +  convert(varchar(26),getdate(),109)

	----Validate all input parameters
	if (
		@fac_id is NULL 
		or @execution_user_login is null
		or @Vmonth is null
		)
	begin
		set @vErr = 'One or more of the following input parameters is invalid... '
					+ ' @fac_id=' + isnull(convert(varchar(10),@fac_id),'null/empty')
					+ ' @Vmonth=' + isnull(convert(varchar(10),@Vmonth, 101),'null/empty')
					+ ', @execution_user_login=' + isnull(@execution_user_login,'null/empty')
	
		RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);
	end

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	Select @vStep = 20;
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Getting user access fac list ' + convert(varchar(26),getdate(),109);

	Select @vFacIds = fac_id
		  ,@vFacWarningMsg = msg
	From  dbo.fn_prp_get_facility_access_list_delim(@vFacId ,@vgs_execution_user); ---filter the fac list with user access

	--facilities warnings
	if @vFacWarningMsg is NOT NULL --- NOT NULL stands for restricted facilities access warning message
	Begin
		Set @status_code = 2 ; ----Set it warning
		Set @status_text = isnull(@status_text,'') + @vFacWarningMsg ;
	End 

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	-------------------------------------------------------------
	-- Inserting records in temp table.
	-------------------------------------------------------------
	select @vStep = 50
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' getting raw data ' + convert(varchar(26),getdate(),109)

		insert INTO  #prp_poc_details 
		( id_key
		, first_name
		, last_name
		, bed_id
		, bed_desc
		, discharge_date
		, client_id_number
		, photo_small
		, room_desc
		, unit_id
		, unit_desc
		, admission_date
		, client_id
		, effective_date  
		, ineffective_date  
		, current_row
		, intervention_desc
		, date_initiated
		, std_intervention_id
		, require_time_tracking
		, baseline_time
		, intervention_id
		, schedule_id
		, schedule_type
		, std_shift_ids
		, start_time 
		, end_time 
		, xxminutes
		, fac_id
		, date_of_month 
		, schedule_detail_id
		, std_shift_id
		, shift_date 
		, schedule_date
		, schedule_end_date
		, documentation_id
		, completed_date
		, strikeout_date
		, entered_date
		, task_time
		, cp_sec_user_audit_id
		, struckout_cp_sec_user_audit_id
		)
	exec dbo.sproc_prp_pcc_poc_getScheduleDetails
	@vFacId,
	-1,--@vShiftId,--@shiftID_param int,
	-1,--@myPositionID_param int,
	-1,--@assignmentID_param int,
	-1,--@unitID_param int,
	-1,--@selectedPositionID_param int,
	@vStartDate,--'2014-01-26 00:00:00',--@shiftStartTime_param datetime,
	@vEndDate,--'2014-02-01 23:59:59'--@shiftEndTime_param datetime,
	NULL,--'7445,7455,7465',--@stdInts_param varchar(8000),
	@vClientId,--@clientID_param int,
	@vStartDate,--'2014-01-26 00:00:00',--@localStartTime_param datetime,
	@vEndDate,--'2014-02-01 23:59:59'--@localEndTime_param datetime,
	Null,--@max_details_param int = 2147483647,
	@vIncludePRNbit,--@include_prn_param bit = 1,
	'N',--@debug				char(1)  = 'N',
	Null,--@status_code		int	out,
	Null--@status_text		varchar(3000) out


    set @vRowCount = @@rowcount
		if  (@vRowCount = 0)
	begin
	 Set @status_code = 2
	 Set @status_text = isnull(@status_text,'') + 'No Data Found' ;
	 Raiserror( 'sproc_prp_pcc_poc_getScheduleDetails returned 0 rows.', 10, 1 );
	 
	 end
	 
	 
-- DAY LIGHT SAVING DATE 
        update  a set
            schedule_date=case 
              when schedule_date= dateadd(hh,1,@daylightStart) then @daylightStart
              when schedule_date= dateadd(hh,-1,@daylightEnd) then @daylightEnd
             end   ,
            completed_date=case 
              when completed_date= dateadd(hh,1,@daylightStart) then  @daylightStart
              when completed_date= dateadd(hh,-1,@daylightEnd) then  @daylightEnd
              end 
        from #prp_poc_details a
         where schedule_date= dateadd(hh,1,@daylightStart) or schedule_date= dateadd(hh,-1,@daylightEnd)
         or completed_date= dateadd(hh,1,@daylightStart) or completed_date= dateadd(hh,-1,@daylightEnd)


 
	update #prp_poc_details 
	        set 
	        schedule_date =case 
	                        when substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)='D'  and completed_date is not null THEN
	                            completed_date
	                        else schedule_date end ;
	

	
 	delete					        
    from #prp_poc_details
    where ineffective_date is not null
    and schedule_date>ineffective_date;


    delete from #prp_poc_details
    where ineffective_date is  null
    and schedule_date<effective_date;

 
 
	CREATE  CLUSTERED INDEX _temp1_prppocdetails on #prp_poc_details(id_key,client_id,intervention_id,std_intervention_id)


	if @debug_me='Y' select * from #prp_poc_details order BY client_id, schedule_date

--It's using for QSHIFT

	INSERT INTO #prp_shift_link( shift_id , shift_name , start_time , end_time , group_name , position_id )
	select distinct shift.std_shift_id,shift.description,
	shift.start_time,shift.end_time,'',0
	from dbo.cp_std_shift shift WITH (NOLOCK)
	WHERE
	shift.deleted='N' and (shift.fac_id=@vFacId or shift.fac_id=-1)

	if @debug_me='Y' select * from #prp_shift_link order BY shift_name

--It's using for Non-QSHIFT

	INSERT INTO #prp_shifts (shift_id , shift_name, start_time , end_time , group_name, position_id , flg)
	select distinct shift.std_shift_id,
	shift.description+' ('+
		case when left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end)) ='' then '0' ELSE

left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end))
end 
		+':'+right(cast(start_time as int),2)+(case when cast(start_time as int)>1200 THEN ' PM' ELSE ' AM' END) 
		+' - ' +
		case when rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end))))='' then '0'
		else
		rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end)))) end 
		+':'+right(cast(end_time as int),2)+(case when cast(end_time as int)>1200 THEN ' PM' ELSE ' AM' END) +')' shift_name,
		
	shift.start_time,cast(shift.end_time as int) end_time,'',0 position_id,
	case when shift.start_time - ( cast(shift.end_time as int)-1 )>0 then 1 else 0 end
	from dbo.cp_std_shift shift WITH (NOLOCK) 
    WHERE
	shift.deleted='N' and (shift.fac_id=@vFacId or shift.fac_id=-1)
	
	
	CREATE  CLUSTERED INDEX _temp1_prpshifts on #prp_shifts(position_id,start_time,end_time)

	if @debug_me='Y' select * from #prp_shifts order BY shift_name
	
	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	Set @vgs_fill_end_time  = getdate() ; -- fill end time

	select @vStep = 60
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' loading and calculating pivoted table ' + convert(varchar(26),getdate(),109)

--Qshift
INSERT INTO @ROWDATA 
            (schedule_detail_id, 
             client_id, 
             client_name,
             shift_id, 
             shift, 
             group_name, 
             position_id, 
             position, 
             day_of_week, 
             total_minutes, 
             timeflag, 
             completed_date,
             schedule_date,document_id,sFlag) 
SELECT cpsd.schedule_detail_id, 
       cpsd.client_id, 
       cpsd.last_name + ', ' + cpsd.first_name + ' (' 
       + cpsd.client_id_number + ')'                      AS client_name,shift_id, 
       'Scheduled'                                        AS Shift, 
       ''                                                 AS group_name, 
       crr.service_tracking_position_id                AS position_id, 
       cc.item_description                                AS position, 
       Datepart(dd, cpsd.shift_date)                        AS day_of_week, 
       COALESCE(cpsd.baseline_time, cpstdi.baseline_time) AS total_minutes, 
       1, 
       cpsd.completed_date ,cpsd.shift_date as schedule_date,cpsd.documentation_id,
       case when cpsd.strikeout_date is not null then 1 else 0 end sFlag
FROM   #prp_poc_details cpsd 
       inner join cp_rev_intervention crr WITH (NOLOCK) on crr.clientid=cpsd.client_id
       and crr.current_row='Y'
       and crr.gen_intervention_id=cpsd.intervention_id
       and crr.require_time_tracking = 1
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
               ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                  AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.common_code cc WITH (nolock) 
               ON crr.service_tracking_position_id = cc.item_id 
       INNER JOIN dbo.#prp_shift_link shift 
               ON cpsd.std_shift_id = shift.shift_id 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       ;
	
	
	

	------------
	--Non-Qshift
INSERT INTO @ROWDATA 
            (schedule_detail_id, 
             client_id, 
             client_name,shift_id, 
             shift, 
             group_name, 
             position_id, 
             position, 
             day_of_week, 
             total_minutes, 
             timeflag, 
             completed_date,schedule_date,document_id,sFlag) 
SELECT cpsd.schedule_detail_id, 
       cpsd.client_id, 
       cpsd.last_name + ', ' + cpsd.first_name + ' (' 
       + cpsd.client_id_number + ')'                      AS client_name,shift_id, 
       'Scheduled'                                        AS Shift, 
       ''                                                 AS group_name,
       case when isnull(cpstdi.require_time_tracking,0) = 1  then crr.service_tracking_position_id 
       when  isnull(cpstdi.require_time_tracking,0)=0 and isnull(crr.require_time_tracking,0)=1 then crr.service_tracking_position_id
       end  AS position_id,
 
       cc.item_description                                AS position, 
       Datepart(dd, cpsd.schedule_date)                   AS day_of_week, 
       COALESCE(cpsd.baseline_time, cpstdi.baseline_time) AS total_minutes, 
       1, 
       cpsd.completed_date,cpsd.schedule_date ,cpsd.documentation_id,
       case when cpsd.strikeout_date is not null then 1 else 0 end sFlag
FROM   #prp_poc_details cpsd 
       inner join cp_rev_intervention crr WITH (NOLOCK) on crr.clientid=cpsd.client_id
       and crr.current_row='Y'
       and crr.gen_intervention_id=cpsd.intervention_id
       and crr.require_time_tracking = 1
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
               ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                  AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.common_code cc WITH (nolock) 
               ON   cc.item_id = crr.service_tracking_position_id

       INNER JOIN dbo.#prp_shifts shift 
               ON 1 = CASE 
                        WHEN Substring(schedule_detail_id,Charindex('_', schedule_detail_id) + 1,1)  = 'D' 
                             AND cpsd.std_shift_id IS NULL THEN 1 
                        WHEN Substring(schedule_detail_id,Charindex('_', schedule_detail_id) + 1,1) = 'S' 
                             AND cpsd.std_shift_id IS NULL 
                             THEN 1 
                        
                        ELSE 0 
                      END 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       AND cpsd.std_shift_id IS NULL 
      ; 
-------------------------------------------------------------
-- Row data for Actual Hours
-------------------------------------------------------------
 
INSERT INTO @ROWDATA --Qshift
            (schedule_detail_id, 
             client_id, 
             client_name,shift_id, 
             shift, 
             group_name,
             service_tracking_position_id, 
             position_id, 
             position, 
             day_of_week, 
             total_minutes, 
             timeflag, 
             completed_date,schedule_date,document_id) 
SELECT cpsd.schedule_detail_id, 
       cpsd.client_id, 
       cpsd.last_name + ', ' + cpsd.first_name + ' (' 
       + cpsd.client_id_number + ')' AS client_name, 
       shift.shift_id, 
       'Scheduled'                   AS Shift, 
       ''                            AS group_name, 
       crr.service_tracking_position_id, 
       usr.position_id, 
       CASE 
         WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown' 
         ELSE usr.position_description 
       END                           AS position, 
       Datepart(dd, cpsd.shift_date)      AS day_of_week, 
       Isnull(cpsd.task_time, 0)     AS total_minutes, 
       2 timeflag, 
       cpsd.completed_date, 
       cpsd.shift_date                    AS schedule_date, 
       cpsd.documentation_id 
FROM   #prp_poc_details cpsd 
       INNER JOIN cp_rev_intervention crr WITH (nolock) 
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.#prp_shift_link shift 
               ON cpsd.std_shift_id = shift.shift_id 
       INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock) 
               ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       AND cpsd.completed_date IS NOT NULL 
       AND cpsd.strikeout_date IS NULL;  

INSERT INTO @ROWDATA --Non-Qshift
            (schedule_detail_id, 
             client_id, 
             client_name,shift_id, 
             shift, 
             group_name, 
             service_tracking_position_id,
             position_id, 
             position, 
             day_of_week, 
             total_minutes, 
             timeflag, 
             completed_date,schedule_date,document_id) 
            SELECT cpsd.schedule_detail_id, 
       cpsd.client_id, 
       cpsd.last_name + ', ' + cpsd.first_name + ' (' 
       + cpsd.client_id_number + ')' AS client_name, 
       shift.shift_id, 
       'Scheduled'                   AS Shift, 
       ''                            AS group_name, 
       CASE 
         WHEN Isnull(cpstdi.require_time_tracking, 0) = 1 THEN 
         crr.service_tracking_position_id 
         WHEN Isnull(cpstdi.require_time_tracking, 0) = 0 
              AND Isnull(crr.require_time_tracking, 0) = 1 THEN 
         crr.service_tracking_position_id 
       END                           AS position_id, 
       usr.position_id, 
       CASE 
         WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown' 
         ELSE usr.position_description 
       END                           AS position, 
       Datepart(dd, cpsd.schedule_date)   AS day_of_week, 
       Isnull(cpsd.task_time, 0)     AS total_minutes, 
       2 timeflag, 
       cpsd.completed_date, 
       cpsd.schedule_date, 
       cpsd.documentation_id 
FROM   #prp_poc_details cpsd 
       INNER JOIN cp_rev_intervention crr WITH (nolock) 
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.#prp_shifts shift 
               ON 1 = CASE 
                        WHEN Substring(cpsd.schedule_detail_id, 
                             Charindex('_', cpsd.schedule_detail_id) + 1, 
                             1) 
                             = 'D' 
                              AND cpsd.std_shift_id IS NULL THEN 1 
                        WHEN Substring(cpsd.schedule_detail_id, 
                             Charindex('_', cpsd.schedule_detail_id) + 1, 
                             1) 
                             IN ( 
                                    'U', 'S' ) 
                              AND cpsd.std_shift_id IS NULL THEN 1 
                        ELSE 0 
                      END 
       INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock) 
               ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       AND cpsd.completed_date IS NOT NULL 
       AND cpsd.std_shift_id IS NULL 
       AND cpsd.strikeout_date IS NULL;  
       
       
       
IF @vIncludeUnscheduled = 'Y'

    BEGIN
        INSERT INTO @ROWDATA 
            (schedule_detail_id, 
             client_id, 
             client_name,
             shift_id, 
             shift, 
             group_name, 
             position_id, 
             position, 
             day_of_week, 
             total_minutes, 
             timeflag, 
             completed_date,schedule_date,document_id) 
        SELECT cpsd.schedule_detail_id, 
       cpsd.client_id, 
       cpsd.last_name + ', ' + cpsd.first_name + ' (' 
       + cpsd.client_id_number + ')' AS client_name, 
       shift.shift_id, 
       'Unscheduled'                 AS Shift, 
       ''                            AS group_name, 
       usr.position_id, 
       CASE 
         WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown' 
         ELSE usr.position_description 
       END                           AS position, 
       Datepart(dd, cpsd.schedule_date)   AS day_of_week, 
       Isnull(cpsd.task_time, 0)     AS total_minutes, 
       3 timeflag, 
       cpsd.completed_date, 
       cpsd.schedule_date, 
       cpsd.documentation_id 
FROM   #prp_poc_details cpsd 
       INNER JOIN cp_rev_intervention crr 
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.#prp_shifts shift WITH (nolock) 
               ON 1 = CASE 
                        WHEN Substring(cpsd.schedule_detail_id, 
                             Charindex('_', cpsd.schedule_detail_id) + 1, 
                             1) 
                             = 'D' 
                             AND cpsd.std_shift_id IS NULL THEN 1 
                        WHEN Substring(cpsd.schedule_detail_id, 
                             Charindex('_', cpsd.schedule_detail_id) + 1, 
                             1) 
                             IN ('U' ) 
                             AND cpsd.std_shift_id IS NULL THEN 1 
                        ELSE 0 
                      END 
       INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock) 
               ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id 
WHERE  cpsd.schedule_type = 40 
       AND cpsd.completed_date IS NOT NULL 
       AND cpsd.strikeout_date IS NULL;  
    END;


IF @vIncludePRN = 'Y'
BEGIN
	INSERT INTO @rowdata
				(schedule_detail_id,
				 client_id,
				 client_name,
				 shift_id,
				 shift,
				 group_name,
				 position_id,
				 position,
				 day_of_week,
				 total_minutes,
				 timeflag,
				 completed_date,
				 schedule_date,
				 document_id)
			SELECT cpsd.schedule_detail_id,
		   cpsd.client_id,
		   cpsd.last_name + ', ' + cpsd.first_name + ' ('
		   + cpsd.client_id_number + ')' AS client_name,
		   shift.std_shift_id as shift_id,
		   'PRN' AS Shift,
		   '' AS group_name,
		   usr.position_id,
		   CASE
			 WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown'
			 ELSE usr.position_description
		   END                           AS position,
		   Datepart(dd, schedule_date)   AS day_of_week,
		   Isnull(cpsd.task_time, 0)     AS total_minutes,
		   4 as timeflag,
		   cpsd.completed_date,
		   cpsd.schedule_date,
		   cpsd.documentation_id
	FROM   #prp_poc_details cpsd
		   INNER JOIN dbo.cp_rev_intervention crr  WITH (nolock)
				   ON crr.clientid = cpsd.client_id
					  AND crr.current_row = 'Y'
					  AND crr.gen_intervention_id = cpsd.intervention_id
					  AND crr.require_time_tracking = 1
		   LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock)
				  ON cpsd.std_intervention_id = cpstdi.std_intervention_id
					 AND cpstdi.poc_flowsheet = 'Y'
		   INNER JOIN dbo.cp_std_shift shift WITH (NOLOCK)
					 ON shift.std_shift_id = cpsd.std_shift_id
		   INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock)
				   ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id
	WHERE  cpsd.schedule_type = 8
		   AND completed_date IS NOT NULL
		   AND cpsd.strikeout_date IS NULL;
END

--------------- Delete duplicate

;WITH CTE_1  AS
(
select  schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,
  position ,total_minutes,timeFlag ,case when timeFlag=1 then null else completed_date end completed_date ,
  case when timeFlag=1 then null else document_id end document_id,

row_number() over(PARTITION BY  schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,
  position ,total_minutes,timeFlag ,case when timeFlag=1 then null else completed_date end , case when timeFlag=1 then null else document_id end 
order by  schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,
  position ,total_minutes,timeFlag ,case when timeFlag=1 then null else completed_date end, case when timeFlag=1 then null else document_id end  ) row_id
from @ROWDATA
) 

delete from cte_1 where  row_id>1;

-------------------------------------------------------------------
update  a set 
  a.schedule_date=   case when substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)<>'Q' 
   then dbo.fn_adjust_time_fac_time_zone (@vFacId ,schedule_date ) else schedule_date end,
  a.completed_date=  dbo.fn_adjust_time_fac_time_zone (@vFacId ,completed_date ) 
from @ROWDATA a;


	
----------------- showing actual and plan in the same day

delete  from @ROWDATA where (schedule_date <@vStartDate or schedule_date>@vEndDate) and  schedule_date is not null;

delete  a
from @ROWDATA a 
where a.timeflag=1
and not exists (select 1 from @ROWDATA b where b.schedule_detail_id=a.schedule_detail_id and b.timeFlag=2 and a.document_id=b.document_id)
and substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)='D';


update  a set 
  day_of_week= case 
                when substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1) in ('D') and a.completed_date is not null 
                  then datepart(dd,completed_date)
                when timeflag=1 then datepart(dd,schedule_date)
                when timeflag in (2,3,4) and substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)<>'Q' then datepart(dd,completed_date) else datepart(dd,schedule_date)
                end
from @ROWDATA a  ;
----------------------------------------------

             
	INSERT INTO #prp_poc_planned 
	select @vFacId,client_id,client_name,Shift,group_name,position_id,position,'Planned' as hour_type,
	isnull([1],0) as day_1,isnull([2],0) as day_2, isnull([3],0) as day_3, isnull([4],0) as day_4, isnull([5],0) as day_5,
	isnull([6],0) as day_6, isnull([7],0) as day_7,	isnull([8],0) as day_8,isnull([9],0) as day_9,isnull([10],0) as day_10,
	isnull([11],0) as day_11,isnull([12],0) as day_12,isnull([13],0) as day_13,isnull([14],0) as day_14,isnull([15],0) as day_15,
	isnull([16],0) as day_16,isnull([17],0) as day_17,isnull([18],0) as day_18,isnull([19],0) as day_19,isnull([20],0) as day_20,
	isnull([21],0) as day_21,isnull([22],0) as day_22,isnull([23],0) as day_23,isnull([24],0) as day_24,isnull([25],0) as day_25,
	isnull([26],0) as day_26,isnull([27],0) as day_27,isnull([28],0) as day_28,isnull([29],0) as day_29,isnull([30],0) as day_30,
	isnull([31],0) as day_31, 0 as total,  0 as ordr
	from
	(select schedule_detail_id ,client_id,client_name ,shift ,group_name,position_id,
  position ,day_of_week ,total_minutes,timeFlag ,completed_date  from @ROWDATA where timeFlag=1
	) as rawdata
	PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17],[18],[19],[20],[21],[22],[23],
		[24],[25],[26],[27],[28],[29],[30],[31])) as pivotdata



	INSERT INTO #prp_poc_planned 
	select @vFacId,client_id,client_name,Shift,group_name,position_id,position,'Actual' as hour_type,
	isnull([1],0) as day_1,isnull([2],0) as day_2, isnull([3],0) as day_3, isnull([4],0) as day_4, isnull([5],0) as day_5,
	isnull([6],0) as day_6, isnull([7],0) as day_7,	isnull([8],0) as day_8,isnull([9],0) as day_9,isnull([10],0) as day_10,
	isnull([11],0) as day_11,isnull([12],0) as day_12,isnull([13],0) as day_13,isnull([14],0) as day_14,isnull([15],0) as day_15,
	isnull([16],0) as day_16,isnull([17],0) as day_17,isnull([18],0) as day_18,isnull([19],0) as day_19,isnull([20],0) as day_20,
	isnull([21],0) as day_21,isnull([22],0) as day_22,isnull([23],0) as day_23,isnull([24],0) as day_24,isnull([25],0) as day_25,
	isnull([26],0) as day_26,isnull([27],0) as day_27,isnull([28],0) as day_28,isnull([29],0) as day_29,isnull([30],0) as day_30,
	isnull([31],0) as day_31, 0 as total, 
	CASE WHEN service_tracking_position_id<>position_id or position_id is null THEN 3 else 1 end as ordr
	from
	(select schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,
  position ,day_of_week ,total_minutes,timeFlag ,completed_date  from @ROWDATA where timeFlag=2
	) as rawdata
	PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17],[18],[19],[20],[21],[22],[23],
		[24],[25],[26],[27],[28],[29],[30],[31])) as pivotdata

	IF @vIncludeUnscheduled = 'Y'
	BEGIN
		INSERT INTO #prp_poc_planned 
		select @vFacId,client_id,client_name,Shift,group_name,position_id,position,'Actual' as hour_type,
			isnull([1],0) as day_1,isnull([2],0) as day_2, isnull([3],0) as day_3, isnull([4],0) as day_4, isnull([5],0) as day_5,
		isnull([6],0) as day_6, isnull([7],0) as day_7,	isnull([8],0) as day_8,isnull([9],0) as day_9,isnull([10],0) as day_10,
		isnull([11],0) as day_11,isnull([12],0) as day_12,isnull([13],0) as day_13,isnull([14],0) as day_14,isnull([15],0) as day_15,
		isnull([16],0) as day_16,isnull([17],0) as day_17,isnull([18],0) as day_18,isnull([19],0) as day_19,isnull([20],0) as day_20,
		isnull([21],0) as day_21,isnull([22],0) as day_22,isnull([23],0) as day_23,isnull([24],0) as day_24,isnull([25],0) as day_25,
		isnull([26],0) as day_26,isnull([27],0) as day_27,isnull([28],0) as day_28,isnull([29],0) as day_29,isnull([30],0) as day_30,
		isnull([31],0) as day_31, 0 as total,  10 as ordr
		from
		(select schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,
		position ,day_of_week ,total_minutes,timeFlag ,completed_date  from @ROWDATA where timeFlag=3
		) as rawdata
		PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17],[18],[19],[20],[21],[22],[23],
		[24],[25],[26],[27],[28],[29],[30],[31])) as pivotdata
	END

	IF @vIncludePRN = 'Y'
	BEGIN
		INSERT INTO #prp_poc_planned 
			(fac_id ,client_id, client_name, shift, group_name, position_id ,position, hour_type, 
			day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
			day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
			day_31, total, ordr)
		select @vFacId,client_id,client_name,Shift,group_name,position_id,position,'Actual' as hour_type,
			isnull([1],0) as day_1,isnull([2],0) as day_2, isnull([3],0) as day_3, isnull([4],0) as day_4, isnull([5],0) as day_5,
			isnull([6],0) as day_6, isnull([7],0) as day_7,	isnull([8],0) as day_8,isnull([9],0) as day_9,isnull([10],0) as day_10,
			isnull([11],0) as day_11,isnull([12],0) as day_12,isnull([13],0) as day_13,isnull([14],0) as day_14,isnull([15],0) as day_15,
			isnull([16],0) as day_16,isnull([17],0) as day_17,isnull([18],0) as day_18,isnull([19],0) as day_19,isnull([20],0) as day_20,
			isnull([21],0) as day_21,isnull([22],0) as day_22,isnull([23],0) as day_23,isnull([24],0) as day_24,isnull([25],0) as day_25,
			isnull([26],0) as day_26,isnull([27],0) as day_27,isnull([28],0) as day_28,isnull([29],0) as day_29,isnull([30],0) as day_30,
			isnull([31],0) as day_31, 0 as total,  20 as ordr
		from
		(select schedule_detail_id, client_id, client_name, shift, group_name, service_tracking_position_id, position_id, position, 
			day_of_week, total_minutes, timeFlag, completed_date  
		from @rowdata 
		where timeFlag=4
		) as rawdata
		PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17],[18],[19],[20],[21],[22],[23],
		[24],[25],[26],[27],[28],[29],[30],[31])) as pivotdata

		INSERT INTO #prp_poc_planned
			(fac_id, client_id, client_name, shift, group_name, position_id, position, hour_type, 
			day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15,
			day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30,
			day_31, total, ordr) 
		select fac_id,client_id,client_name,Shift,group_name,0,'ZZZZ','' as hour_type,sum(day_1) as day_1,sum(day_2) as day_2, sum(day_3) as day_3, 
			sum(day_4) as day_4, sum(day_5) as day_5, sum(day_6) as day_6, sum(day_7) as day_7,sum(day_8) as day_8,sum(day_9) as day_9, sum(day_10) as day_10, 
			sum(day_11) as day_11, sum(day_12) as day_12, sum(day_13) as day_13, sum(day_14) as day_14,sum(day_15) as day_15,sum(day_16) as day_16, sum(day_17) as day_17, 
			sum(day_18) as day_18, sum(day_19) as day_19, sum(day_20) as day_20, sum(day_21) as day_21,sum(day_22) as day_22,sum(day_23) as day_23, sum(day_24) as day_24, 
			sum(day_25) as day_25, sum(day_26) as day_26, sum(day_27) as day_27, sum(day_28) as day_28,sum(day_29) as day_29,sum(day_30) as day_30, sum(day_31) as day_31, 
			sum(total) as total, 21 as ordr
		from #prp_poc_planned
		where ordr = 20
		group BY fac_id,client_id,client_name,Shift,group_name

		--insert dummy actual row if the corresponding planned ro has no data
		INSERT INTO #prp_poc_planned
		(fac_id, client_id, client_name, shift, group_name, position_id, position, hour_type,
		day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15,
		day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30,
		day_31, total, ordr) 
		select distinct planned.fac_id,planned.client_id,planned.client_name,'No PRN Tasks Documented' as Shift,'' as group_name, 
			0 as position_id,'ZZZZ' as position,'Actual' as hour_type,
			0 as day_1, 0 as day_2, 0 as day_3, 0 as day_4, 0 as day_5, 0 as day_6, 0 as day_7,
			0 as day_8, 0 as day_9, 0 as day_10, 0 as day_11, 0 as day_12, 0 as day_13, 0 as day_14, 0 as day_15, 0 as day_16, 0 as day_17,
			0 as day_18, 0 as day_19, 0 as day_20, 0 as day_21, 0 as day_22, 0 as day_23, 0 as day_24, 0 as day_25, 0 as day_26, 0 as day_27,
			0 as day_28, 0 as day_29, 0 as day_30, 0 as day_31,  0 as total, 20 as ordr
		from #prp_poc_planned planned WITH (NOLOCK) 
		left JOIN (select client_id from #prp_poc_planned WITH (NOLOCK) where ordr=20 group by client_id) clients 
			ON planned.client_id = clients.client_id and planned.ordr=0
		where planned.ordr=0 and clients.client_id is null

	END

	--insert dummy actual row if the corresponding planned ro has no data
	--INSERT INTO #prp_poc_planned
	--select @vFacId,planned.client_id,planned.client_name,planned.Shift,planned.group_name,planned.position_id,planned.position,'Planned' as hour_type,
	--	0 as day_1, 0 as day_2, 0 as day_3, 0 as day_4, 0 as day_5, 0 as day_6, 0 as day_7,
	--	0 as day_8, 0 as day_9, 0 as day_10, 0 as day_11, 0 as day_12, 0 as day_13, 0 as day_14, 0 as day_15, 0 as day_16, 0 as day_17,
	--	0 as day_18, 0 as day_19, 0 as day_20, 0 as day_21, 0 as day_22, 0 as day_23, 0 as day_24, 0 as day_25, 0 as day_26, 0 as day_27,
	--	0 as day_28, 0 as day_29, 0 as day_30, 0 as day_31, 0 as total, 0 as ordr
	--from #prp_poc_planned planned
	--	 where  planned.ordr=1
	--	  and not exists  (select 1 from #prp_poc_planned actual where  actual.ordr=0 and planned.shift=actual.shift and planned.position_id=actual.position_id and actual.client_id=planned.client_id )
	
	
INSERT INTO #prp_poc_planned
	select @vFacId,planned.client_id,planned.client_name,planned.Shift,planned.group_name,planned.position_id,planned.position,'Actual' as hour_type,
		0 as day_1, 0 as day_2, 0 as day_3, 0 as day_4, 0 as day_5, 0 as day_6, 0 as day_7,
		0 as day_8, 0 as day_9, 0 as day_10, 0 as day_11, 0 as day_12, 0 as day_13, 0 as day_14, 0 as day_15, 0 as day_16, 0 as day_17,
		0 as day_18, 0 as day_19, 0 as day_20, 0 as day_21, 0 as day_22, 0 as day_23, 0 as day_24, 0 as day_25, 0 as day_26, 0 as day_27,
		0 as day_28, 0 as day_29, 0 as day_30, 0 as day_31, 0 as total, 1 as ordr
	from #prp_poc_planned planned
		 where  planned.ordr=0
		  and not exists  (select 1 from #prp_poc_planned actual where  actual.ordr=1 and planned.shift=actual.shift and planned.position_id=actual.position_id and actual.client_id=planned.client_id )
	
		  
	

	IF @vIncludeUnscheduled = 'Y'
	begin
	
		INSERT INTO #prp_poc_planned
		select fac_id,client_id,client_name,Shift,group_name,0,'ZZZZ','' as hour_type,sum(day_1) as day_1,sum(day_2) as day_2, sum(day_3) as day_3, 
			sum(day_4) as day_4, sum(day_5) as day_5, sum(day_6) as day_6, sum(day_7) as day_7,sum(day_8) as day_8,sum(day_9) as day_9, sum(day_10) as day_10, 
			sum(day_11) as day_11, sum(day_12) as day_12, sum(day_13) as day_13, sum(day_14) as day_14,sum(day_15) as day_15,sum(day_16) as day_16, sum(day_17) as day_17, 
			sum(day_18) as day_18, sum(day_19) as day_19, sum(day_20) as day_20, sum(day_21) as day_21,sum(day_22) as day_22,sum(day_23) as day_23, sum(day_24) as day_24, 
			sum(day_25) as day_25, sum(day_26) as day_26, sum(day_27) as day_27, sum(day_28) as day_28,sum(day_29) as day_29,sum(day_30) as day_30, sum(day_31) as day_31, 
			sum(total) as total, 11 as ordr
		from #prp_poc_planned
		where ordr = 10
		group BY fac_id,client_id,client_name,Shift,group_name
		
		

		--insert dummy actual row if the corresponding planned ro has no data
		INSERT INTO #prp_poc_planned
		select distinct planned.fac_id,planned.client_id,planned.client_name,'No Unscheduled Tasks Documented' as Shift,'' as group_name, 0 as position_id,'ZZZZ' as position,'Actual' as hour_type,
			0 as day_1, 0 as day_2, 0 as day_3, 0 as day_4, 0 as day_5, 0 as day_6, 0 as day_7,
			0 as day_8, 0 as day_9, 0 as day_10, 0 as day_11, 0 as day_12, 0 as day_13, 0 as day_14, 0 as day_15, 0 as day_16, 0 as day_17,
			0 as day_18, 0 as day_19, 0 as day_20, 0 as day_21, 0 as day_22, 0 as day_23, 0 as day_24, 0 as day_25, 0 as day_26, 0 as day_27,
			0 as day_28, 0 as day_29, 0 as day_30, 0 as day_31,  0 as total, 10 as ordr
		from #prp_poc_planned planned WITH (NOLOCK) 
		left JOIN (select client_id from #prp_poc_planned WITH (NOLOCK) where ordr=10 group by client_id) clients 
			ON planned.client_id = clients.client_id and planned.ordr=0
		where planned.ordr=0 and clients.client_id is null

	end
	

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	Set @vgs_fill_end_time  = getdate() ; -- fill end time

	select @vStep = 70
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' updating pivoted table ' + convert(varchar(26),getdate(),109)


insert into #prp_poc_planned_final
	select @vFacId,
	planned.client_id,planned.client_name,planned.Shift,planned.group_name,planned.position_id,planned.position,hour_type,
	sum(day_1) day_1,sum(day_2) day_2,sum(day_3) day_3,sum(day_4) day_4,sum(day_5) day_5,sum(day_6) day_6,
	sum(day_7) day_7,sum(day_8) day_8,sum(day_9) day_9,sum(day_10) day_10,sum(day_11) day_11,sum(day_12) day_12,
	sum(day_13) day_13,sum(day_14) day_14,sum(day_15) day_15,sum(day_16) day_16,sum(day_17) day_17,sum(day_18) day_18,	
	sum(day_19) day_19,sum(day_20) day_20,sum(day_21) day_21,sum(day_22) day_22,sum(day_23) day_23,sum(day_24) day_24,	
	sum(day_25) day_25,sum(day_26) day_26,sum(day_27) day_27,sum(day_28) day_28,sum(day_29) day_29,sum(day_30) day_30,
	sum(day_31) day_31,sum(total) total,ordr
		from #prp_poc_planned  planned
		group by planned.client_id,planned.client_name,planned.Shift,planned.group_name,planned.position_id,planned.position,ordr,hour_type
		order by shift,ordr
		
		
	update #prp_poc_planned_final SET 
		day_1 = ISNULL(day_1, 0) 
		,day_2 = ISNULL(day_2, 0)
		,day_3 = ISNULL(day_3, 0)
		,day_4 = ISNULL(day_4, 0)
		,day_5 = ISNULL(day_5, 0)
		,day_6 = ISNULL(day_6, 0)
		,day_7 = ISNULL(day_7, 0)
		,day_8 = ISNULL(day_8, 0)
		,day_9 = ISNULL(day_9, 0)
		,day_10 = ISNULL(day_10, 0)
		,day_11 = ISNULL(day_11, 0)
		,day_12 = ISNULL(day_12, 0)
		,day_13 = ISNULL(day_13, 0)
		,day_14 = ISNULL(day_14, 0)
		,day_15 = ISNULL(day_15, 0)
		,day_16 = ISNULL(day_16, 0)
		,day_17 = ISNULL(day_17, 0)
		,day_18 = ISNULL(day_18, 0)
		,day_19 = ISNULL(day_19, 0)
		,day_20 = ISNULL(day_20, 0)
		,day_21 = ISNULL(day_21, 0)
		,day_22 = ISNULL(day_22, 0)
		,day_23 = ISNULL(day_23, 0)
		,day_24 = ISNULL(day_24, 0)
		,day_25 = ISNULL(day_25, 0)
		,day_26 = ISNULL(day_26, 0)
		,day_27 = ISNULL(day_27, 0)
		,day_28 = ISNULL(day_28, 0)
		,day_29 = ISNULL(day_29, 0)
		,day_30 = ISNULL(day_30, 0)
		,day_31 = ISNULL(day_31, 0)

		

	INSERT INTO #prp_poc_planned_final
	select @vFacId,pre.client_id,pre.client_name,pre.Shift,pre.group_name,pre.position_id,pre.position,'Planned '+CHAR(45)+' Actual = ' as hour_type,
	(isnull(pre.day_1,0)-isnull(nxt.day_1,0)) as day_1,
	(isnull(pre.day_2,0)-isnull(nxt.day_2,0)) as day_2, 
	(isnull(pre.day_3,0)-isnull(nxt.day_3,0)) as day_3, 
	(isnull(pre.day_4,0)-isnull(nxt.day_4,0)) as day_4, 
	(isnull(pre.day_5,0)-isnull(nxt.day_5,0)) as day_5, 
	(isnull(pre.day_6,0)-isnull(nxt.day_6,0)) as day_6, 
	(isnull(pre.day_7,0)-isnull(nxt.day_7,0)) as day_7,
	(isnull(pre.day_8,0)-isnull(nxt.day_8,0)) as day_8,
	(isnull(pre.day_9,0)-isnull(nxt.day_9,0)) as day_9, 
	(isnull(pre.day_10,0)-isnull(nxt.day_10,0)) as day_10, 
	(isnull(pre.day_11,0)-isnull(nxt.day_11,0)) as day_11, 
	(isnull(pre.day_12,0)-isnull(nxt.day_12,0)) as day_12, 
	(isnull(pre.day_13,0)-isnull(nxt.day_13,0)) as day_13, 
	(isnull(pre.day_14,0)-isnull(nxt.day_14,0)) as day_14, 
	(isnull(pre.day_15,0)-isnull(nxt.day_15,0)) as day_15,
	(isnull(pre.day_16,0)-isnull(nxt.day_16,0)) as day_16, 
	(isnull(pre.day_17,0)-isnull(nxt.day_17,0)) as day_17, 
	(isnull(pre.day_18,0)-isnull(nxt.day_18,0)) as day_18, 
	(isnull(pre.day_19,0)-isnull(nxt.day_19,0)) as day_19, 
	(isnull(pre.day_20,0)-isnull(nxt.day_20,0)) as day_20, 
	(isnull(pre.day_21,0)-isnull(nxt.day_21,0)) as day_21, 
	(isnull(pre.day_22,0)-isnull(nxt.day_22,0)) as day_22,
	(isnull(pre.day_23,0)-isnull(nxt.day_23,0)) as day_23, 
	(isnull(pre.day_24,0)-isnull(nxt.day_24,0)) as day_24, 
	(isnull(pre.day_25,0)-isnull(nxt.day_25,0)) as day_25, 
	(isnull(pre.day_26,0)-isnull(nxt.day_26,0)) as day_26, 
	(isnull(pre.day_27,0)-isnull(nxt.day_27,0)) as day_27, 
	(isnull(pre.day_28,0)-isnull(nxt.day_28,0)) as day_28, 
	(isnull(pre.day_29,0)-isnull(nxt.day_29,0)) as day_29, 
	(isnull(pre.day_30,0)-isnull(nxt.day_30,0)) as day_30, 
	(isnull(pre.day_31,0)-isnull(nxt.day_31,0))as day_31,   
	0 as total, 2 as ordr
	from (select client_id
			,client_name
			,Shift
			,group_name
			,position_id 
			,position
			,day_1
			,day_2
			,day_3
			,day_4
			,day_5
			,day_6
			,day_7
			,day_8
			,day_9
			,day_10
			,day_11
			,day_12
			,day_13
			,day_14
			,day_15
			,day_16
			,day_17
			,day_18
			,day_19
			,day_20
			,day_21
			,day_22
			,day_23
			,day_24
			,day_25
			,day_26
			,day_27
			,day_28
			,day_29
			,day_30
			,day_31
			,ROW_NUMBER() OVER ( PARTITION BY client_id--,position
				order by  client_id,position) as rwnum
		from #prp_poc_planned_final where ordr=0 ) pre
		join (select client_id
			,client_name
			,Shift
			,group_name
			,position_id 
			,position
			,day_1
			,day_2
			,day_3
			,day_4
			,day_5
			,day_6
			,day_7
			,day_8
			,day_9
			,day_10
			,day_11
			,day_12
			,day_13
			,day_14
			,day_15
			,day_16
			,day_17
			,day_18
			,day_19
			,day_20
			,day_21
			,day_22
			,day_23
			,day_24
			,day_25
			,day_26
			,day_27
			,day_28
			,day_29
			,day_30
			,day_31
			,ROW_NUMBER() OVER ( PARTITION BY client_id--,position 
				order by  client_id,position) as rwnum
		from #prp_poc_planned_final a where ordr=1
		and EXISTS (select 1 from #prp_poc_planned_final b where a.fac_id=b.fac_id and a.client_id=b.client_id and a.shift=b.shift 
		and a.position_id=b.position_id and b.ordr=0)) nxt
		on pre.client_id=nxt.client_id and pre.position=nxt.position and pre.rwnum=nxt.rwnum


	update #prp_poc_planned_final SET total= (day_1 + day_2 + day_3 + day_4 + day_5 + day_6 + day_7 + day_8 + day_9 + day_10 + day_11 + day_12
		+ day_13 + day_14 + day_15 + day_16 + day_17 + day_18 + day_19 + day_20 + day_21 + day_22 + day_23 + day_24 + day_25 + day_26
		+ day_27 + day_28 + day_29 + day_30 + day_31)



	INSERT INTO #prp_poc_planned_final
	select fac_id,client_id,client_name,Shift,group_name,0,'ZZZZ','Planned' as hour_type,sum(day_1) as day_1,sum(day_2) as day_2, sum(day_3) as day_3, 
			sum(day_4) as day_4, sum(day_5) as day_5, sum(day_6) as day_6, sum(day_7) as day_7,sum(day_8) as day_8,sum(day_9) as day_9, sum(day_10) as day_10, 
			sum(day_11) as day_11, sum(day_12) as day_12, sum(day_13) as day_13, sum(day_14) as day_14,sum(day_15) as day_15,sum(day_16) as day_16, sum(day_17) as day_17, 
			sum(day_18) as day_18, sum(day_19) as day_19, sum(day_20) as day_20, sum(day_21) as day_21,sum(day_22) as day_22,sum(day_23) as day_23, sum(day_24) as day_24, 
			sum(day_25) as day_25, sum(day_26) as day_26, sum(day_27) as day_27, sum(day_28) as day_28,sum(day_29) as day_29,sum(day_30) as day_30, sum(day_31) as day_31,  
			sum(total) as total, 4 as ordr
	from #prp_poc_planned_final
	where ordr = 0
	group BY fac_id,client_id,client_name,Shift,group_name


	INSERT INTO #prp_poc_planned_final
	select fac_id,client_id,client_name,Shift,group_name,0,'ZZZZ','Actual' as hour_type,sum(day_1) as day_1,sum(day_2) as day_2, sum(day_3) as day_3, 
			sum(day_4) as day_4, sum(day_5) as day_5, sum(day_6) as day_6, sum(day_7) as day_7,sum(day_8) as day_8,sum(day_9) as day_9, sum(day_10) as day_10, 
			sum(day_11) as day_11, sum(day_12) as day_12, sum(day_13) as day_13, sum(day_14) as day_14,sum(day_15) as day_15,sum(day_16) as day_16, sum(day_17) as day_17, 
			sum(day_18) as day_18, sum(day_19) as day_19, sum(day_20) as day_20, sum(day_21) as day_21,sum(day_22) as day_22,sum(day_23) as day_23, sum(day_24) as day_24, 
			sum(day_25) as day_25, sum(day_26) as day_26, sum(day_27) as day_27, sum(day_28) as day_28,sum(day_29) as day_29,sum(day_30) as day_30, sum(day_31) as day_31, 
			sum(total) as total, 5 as ordr
	from #prp_poc_planned_final
	where ordr = 1 or ordr = 3
	group BY fac_id,client_id,client_name,Shift,group_name



INSERT INTO #prp_poc_planned_final
	select @vFacId,pre.client_id,pre.client_name,pre.Shift,pre.group_name,0,'ZZZZ','Planned '+CHAR(45)+' Actual = ' as hour_type,
	(isnull(pre.day_1,0)-isnull(nxt.day_1,0)) as day_1,
	(isnull(pre.day_2,0)-isnull(nxt.day_2,0)) as day_2, 
	(isnull(pre.day_3,0)-isnull(nxt.day_3,0)) as day_3, 
	(isnull(pre.day_4,0)-isnull(nxt.day_4,0)) as day_4, 
	(isnull(pre.day_5,0)-isnull(nxt.day_5,0)) as day_5, 
	(isnull(pre.day_6,0)-isnull(nxt.day_6,0)) as day_6, 
	(isnull(pre.day_7,0)-isnull(nxt.day_7,0)) as day_7,
	(isnull(pre.day_8,0)-isnull(nxt.day_8,0)) as day_8,
	(isnull(pre.day_9,0)-isnull(nxt.day_9,0)) as day_9, 
	(isnull(pre.day_10,0)-isnull(nxt.day_10,0)) as day_10, 
	(isnull(pre.day_11,0)-isnull(nxt.day_11,0)) as day_11, 
	(isnull(pre.day_12,0)-isnull(nxt.day_12,0)) as day_12, 
	(isnull(pre.day_13,0)-isnull(nxt.day_13,0)) as day_13, 
	(isnull(pre.day_14,0)-isnull(nxt.day_14,0)) as day_14, 
	(isnull(pre.day_15,0)-isnull(nxt.day_15,0)) as day_15,
	(isnull(pre.day_16,0)-isnull(nxt.day_16,0)) as day_16, 
	(isnull(pre.day_17,0)-isnull(nxt.day_17,0)) as day_17, 
	(isnull(pre.day_18,0)-isnull(nxt.day_18,0)) as day_18, 
	(isnull(pre.day_19,0)-isnull(nxt.day_19,0)) as day_19, 
	(isnull(pre.day_20,0)-isnull(nxt.day_20,0)) as day_20, 
	(isnull(pre.day_21,0)-isnull(nxt.day_21,0)) as day_21, 
	(isnull(pre.day_22,0)-isnull(nxt.day_22,0)) as day_22,
	(isnull(pre.day_23,0)-isnull(nxt.day_23,0)) as day_23, 
	(isnull(pre.day_24,0)-isnull(nxt.day_24,0)) as day_24, 
	(isnull(pre.day_25,0)-isnull(nxt.day_25,0)) as day_25, 
	(isnull(pre.day_26,0)-isnull(nxt.day_26,0)) as day_26, 
	(isnull(pre.day_27,0)-isnull(nxt.day_27,0)) as day_27, 
	(isnull(pre.day_28,0)-isnull(nxt.day_28,0)) as day_28, 
	(isnull(pre.day_29,0)-isnull(nxt.day_29,0)) as day_29, 
	(isnull(pre.day_30,0)-isnull(nxt.day_30,0)) as day_30, 
	(isnull(pre.day_31,0)-isnull(nxt.day_31,0))as day_31,   
	0 as total,  6 as ordr
	from (select client_id
			,client_name
			,Shift
			,group_name
			,position_id 
			,position
			,day_1
			,day_2
			,day_3
			,day_4
			,day_5
			,day_6
			,day_7
			,day_8
			,day_9
			,day_10
			,day_11
			,day_12
			,day_13
			,day_14
			,day_15
			,day_16
			,day_17
			,day_18
			,day_19
			,day_20
			,day_21
			,day_22
			,day_23
			,day_24
			,day_25
			,day_26
			,day_27
			,day_28
			,day_29
			,day_30
			,day_31
			,ROW_NUMBER() OVER ( PARTITION BY client_id--,position
				order by  client_id,position) as rwnum
		from #prp_poc_planned_final where ordr=4) pre
		join (select client_id
			,client_name
			,Shift
			,group_name
			,position_id 
			,position
			,day_1
			,day_2
			,day_3
			,day_4
			,day_5
			,day_6
			,day_7
			,day_8
			,day_9
			,day_10
			,day_11
			,day_12
			,day_13
			,day_14
			,day_15
			,day_16
			,day_17
			,day_18
			,day_19
			,day_20
			,day_21
			,day_22
			,day_23
			,day_24
			,day_25
			,day_26
			,day_27
			,day_28
			,day_29
			,day_30
			,day_31
			,ROW_NUMBER() OVER ( PARTITION BY client_id--,position 
				order by  client_id,position) as rwnum
		from #prp_poc_planned_final a where ordr=5
		and EXISTS (select 1 from #prp_poc_planned_final b where a.fac_id=b.fac_id and a.client_id=b.client_id and a.shift=b.shift 
		and a.position_id=b.position_id and b.ordr=4)) nxt
		on pre.client_id=nxt.client_id and pre.position=nxt.position and pre.rwnum=nxt.rwnum

--Insert summary data. Need to provide output only if either PRN or Unscheduled tasks were checked off

	IF (@vIncludeUnscheduled = 'Y' OR @vIncludePRN = 'Y')
	BEGIN

		INSERT INTO #prp_poc_planned_final
		(fac_id, client_id, client_name, shift, group_name, position_id, position, hour_type, 
		day_1, day_2, day_3, day_4, day_5, day_6, day_7, day_8, day_9, day_10, day_11, day_12, day_13, day_14, day_15, 
		day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
		day_31, total, ordr) 
		select fac_id,client_id,client_name,'Summary' as Shift,group_name, 0, '', 'Planned' as hour_type,
			day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
			day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
			day_31, total, 30 as ordr
		from #prp_poc_planned_final
		where ordr = 4

		INSERT INTO #prp_poc_planned_final
		(fac_id, client_id, client_name, shift, group_name, position_id, position, hour_type,
		day_1, day_2, day_3, day_4, day_5, day_6, day_7, day_8, day_9, day_10, day_11, day_12, day_13, day_14, day_15,
		day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30,
		day_31, total, ordr)
		select fac_id,client_id,client_name,'Summary' as Shift,'',0, '', 'Actual *' as hour_type,
				sum(day_1) as day_1,sum(day_2) as day_2, sum(day_3) as day_3, 
				sum(day_4) as day_4, sum(day_5) as day_5, sum(day_6) as day_6, sum(day_7) as day_7,sum(day_8) as day_8,sum(day_9) as day_9, sum(day_10) as day_10, 
				sum(day_11) as day_11, sum(day_12) as day_12, sum(day_13) as day_13, sum(day_14) as day_14,sum(day_15) as day_15,sum(day_16) as day_16, sum(day_17) as day_17, 
				sum(day_18) as day_18, sum(day_19) as day_19, sum(day_20) as day_20, sum(day_21) as day_21,sum(day_22) as day_22,sum(day_23) as day_23, sum(day_24) as day_24, 
				sum(day_25) as day_25, sum(day_26) as day_26, sum(day_27) as day_27, sum(day_28) as day_28,sum(day_29) as day_29,sum(day_30) as day_30, sum(day_31) as day_31,  
				sum(total) as total, 31 as ordr
		from #prp_poc_planned_final
		where ordr = 5 or ordr = 21 or ordr = 11
		group BY fac_id,client_id,client_name

		INSERT INTO #prp_poc_planned_final
			(fac_id, client_id, client_name, shift, group_name, position_id, position, hour_type, 
			day_1, day_2, day_3, day_4, day_5, day_6, day_7, day_8, day_9, day_10, day_11, day_12, day_13, day_14, day_15, 
			day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
			day_31, total, ordr)
		select @vFacId,pre.client_id,pre.client_name,pre.Shift,pre.group_name,pre.position_id, pre.position,'Planned '+CHAR(45)+' Actual = ' as hour_type,
			(isnull(pre.day_1,0)-isnull(nxt.day_1,0)) as day_1,
			(isnull(pre.day_2,0)-isnull(nxt.day_2,0)) as day_2, 
			(isnull(pre.day_3,0)-isnull(nxt.day_3,0)) as day_3, 
			(isnull(pre.day_4,0)-isnull(nxt.day_4,0)) as day_4, 
			(isnull(pre.day_5,0)-isnull(nxt.day_5,0)) as day_5, 
			(isnull(pre.day_6,0)-isnull(nxt.day_6,0)) as day_6, 
			(isnull(pre.day_7,0)-isnull(nxt.day_7,0)) as day_7,
			(isnull(pre.day_8,0)-isnull(nxt.day_8,0)) as day_8,
			(isnull(pre.day_9,0)-isnull(nxt.day_9,0)) as day_9, 
			(isnull(pre.day_10,0)-isnull(nxt.day_10,0)) as day_10, 
			(isnull(pre.day_11,0)-isnull(nxt.day_11,0)) as day_11, 
			(isnull(pre.day_12,0)-isnull(nxt.day_12,0)) as day_12, 
			(isnull(pre.day_13,0)-isnull(nxt.day_13,0)) as day_13, 
			(isnull(pre.day_14,0)-isnull(nxt.day_14,0)) as day_14, 
			(isnull(pre.day_15,0)-isnull(nxt.day_15,0)) as day_15,
			(isnull(pre.day_16,0)-isnull(nxt.day_16,0)) as day_16, 
			(isnull(pre.day_17,0)-isnull(nxt.day_17,0)) as day_17, 
			(isnull(pre.day_18,0)-isnull(nxt.day_18,0)) as day_18, 
			(isnull(pre.day_19,0)-isnull(nxt.day_19,0)) as day_19, 
			(isnull(pre.day_20,0)-isnull(nxt.day_20,0)) as day_20, 
			(isnull(pre.day_21,0)-isnull(nxt.day_21,0)) as day_21, 
			(isnull(pre.day_22,0)-isnull(nxt.day_22,0)) as day_22,
			(isnull(pre.day_23,0)-isnull(nxt.day_23,0)) as day_23, 
			(isnull(pre.day_24,0)-isnull(nxt.day_24,0)) as day_24, 
			(isnull(pre.day_25,0)-isnull(nxt.day_25,0)) as day_25, 
			(isnull(pre.day_26,0)-isnull(nxt.day_26,0)) as day_26, 
			(isnull(pre.day_27,0)-isnull(nxt.day_27,0)) as day_27, 
			(isnull(pre.day_28,0)-isnull(nxt.day_28,0)) as day_28, 
			(isnull(pre.day_29,0)-isnull(nxt.day_29,0)) as day_29, 
			(isnull(pre.day_30,0)-isnull(nxt.day_30,0)) as day_30, 
			(isnull(pre.day_31,0)-isnull(nxt.day_31,0))as day_31,   
			0 as total,  32 as ordr
			from (select client_id
					,client_name
					,Shift
					,group_name
					,position_id
					,position
					,day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
					day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
					day_31
				from #prp_poc_planned_final where ordr=30) pre
				join (select client_id
					,client_name
					,Shift
					,group_name
					,position_id
					,position
					,day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
					day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
					day_31
				from #prp_poc_planned_final a where ordr=31) nxt
				on pre.client_id=nxt.client_id and pre.Shift=nxt.Shift		

	END

	if @debug_me='Y' select * from #prp_poc_planned_final
		--select 11,* from #prp_poc_planned_final order by client_id,shift,position,ordr

update #prp_poc_planned_final SET total= (day_1 + day_2 + day_3 + day_4 + day_5 + day_6 + day_7 + day_8 + day_9 + day_10 + day_11 + day_12
		+ day_13 + day_14 + day_15 + day_16 + day_17 + day_18 + day_19 + day_20 + day_21 + day_22 + day_23 + day_24 + day_25 + day_26
		+ day_27 + day_28 + day_29 + day_30 + day_31)
		
		
	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	Set @vgs_fill_end_time  = getdate() ; -- fill end time

	select @vStep = 90
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' returning final result ' + convert(varchar(26),getdate(),109)
	--*********************************************************************************************************
--- final select 


	select fac_id,client_name,Shift,Group_name,case when position='ZZZZ' then 'Total' else position end as discipline,hour_type
	,CASE WHEN sum(day_1) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_1) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_1)), 0), 114) as day_1
	,CASE WHEN sum(day_2) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_2) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_2)), 0), 114) as day_2
	,CASE WHEN sum(day_3) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_3) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_3)), 0), 114) as day_3
	,CASE WHEN sum(day_4) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_4) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_4)), 0), 114) as day_4 
	,CASE WHEN sum(day_5) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_5) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_5)), 0), 114) as day_5  
	,CASE WHEN sum(day_6) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_6) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_6)), 0), 114) as day_6  
	,CASE WHEN sum(day_7) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_7) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_7)), 0), 114) as day_7  
	,CASE WHEN sum(day_8) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_8) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_8)), 0), 114) as day_8 
	,CASE WHEN sum(day_9) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_9) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_9)), 0), 114) as day_9 
	,CASE WHEN sum(day_10) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_10) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_10)), 0), 114) as day_10 
	,CASE WHEN sum(day_11) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_11) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_11)), 0), 114) as day_11 
	,CASE WHEN sum(day_12) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_12) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_12)), 0), 114) as day_12 
	,CASE WHEN sum(day_13) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_13) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_13)), 0), 114) as day_13 
	,CASE WHEN sum(day_14) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_14) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_14)), 0), 114) as day_14 
	,CASE WHEN sum(day_15) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_15) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_15)), 0), 114) as day_15 
	,CASE WHEN sum(day_16) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_16) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_16)), 0), 114) as day_16 
	,CASE WHEN sum(day_17) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_17) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_17)), 0), 114) as day_17 
	,CASE WHEN sum(day_18) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_18) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_18)), 0), 114) as day_18 
	,CASE WHEN sum(day_19) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_19) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_19)), 0), 114) as day_19 
	,CASE WHEN sum(day_20) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_20) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_20)), 0), 114) as day_20 
	,CASE WHEN sum(day_21) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_21) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_21)), 0), 114) as day_21 
	,CASE WHEN sum(day_22) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_22) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_22)), 0), 114) as day_22 
	,CASE WHEN sum(day_23) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_23) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_23)), 0), 114) as day_23 
	,CASE WHEN sum(day_24) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_24) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_24)), 0), 114) as day_24 
	,CASE WHEN sum(day_25) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_25) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_25)), 0), 114) as day_25 
	,CASE WHEN sum(day_26) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_26) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_26)), 0), 114) as day_26 
	,CASE WHEN sum(day_27) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_27) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_27)), 0), 114) as day_27 
	,CASE WHEN sum(day_28) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_28) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_28)), 0), 114) as day_28 
	,CASE WHEN sum(day_29) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_29) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_29)), 0), 114) as day_29 
	,CASE WHEN sum(day_30) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_30) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_30)), 0), 114) as day_30 
	,CASE WHEN sum(day_31) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_31) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_31)), 0), 114) as day_31 
	,CASE WHEN sum(Total) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Total) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Total)), 0), 114) as Total 
	, @status_code as status_code, @status_text as status_text	
	from
	#prp_poc_planned_final
	group BY fac_id,client_name,Shift,Group_name,position,hour_type,ordr
	order BY 
	client_name,
	case Shift when 'Scheduled' then 1
		when 'PRN' then 2
		when 'No PRN Tasks Documented' then 2
		when 'Unscheduled' then 3
		when 'No Unscheduled Tasks Documented' then 3
		when 'Summary' then 4
	else 5 end,
	position, ordr

	Set @rows_returned = @@ROWCOUNT;

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	if @debug_me='Y' Print 'Successful execution of stored procedure ' + Object_name(@@ProcID) + convert(varchar(26),getdate(),109);

END TRY 

BEGIN CATCH 
	if @status_code = 0 Set @Status_Code = 1 else set @status_code = 2  --- convert 3 to 2
	if @status_code = 1
	BEGIN
		select @Status_Text = Rtrim(Left('Stored Procedure Failed with error Code : ' +   Cast(@@error as Varchar(10)) +  ' Line Number : ' +  Cast(ERROR_LINE() as Varchar(5)) + ' ' +  ERROR_MESSAGE(),3000))

		if @debug_me='Y' Print 'Stored procedure failure in step:'+ convert(varchar(3),@vstep) + '	' + convert(varchar(26),getdate())
		if @debug_me='Y' Print 'Error code: '+convert(varchar(3),@vStep) + '; Error description:	' + @Status_Text
	END 

	Select 
		  NULL as fac_id
		, NULL as client_name
		, NULL as Shift
		, NULL as Group_name
		, NULL as discipline
		, NULL as hour_type
		, NULL as day_1
		, NULL as day_2
		, NULL as day_3
		, NULL as day_4
		, NULL as day_5
		, NULL as day_6
		, NULL as day_7
		, NULL as day_8
		, NULL as day_9
		, NULL as day_10
		, NULL as day_11
		, NULL as day_12
		, NULL as day_13
		, NULL as day_14
		, NULL as day_15
		, NULL as day_16
		, NULL as day_17
		, NULL as day_18
		, NULL as day_19
		, NULL as day_20
		, NULL as day_21
		, NULL as day_22
		, NULL as day_23
		, NULL as day_24
		, NULL as day_25
		, NULL as day_26
		, NULL as day_27
		, NULL as day_28
		, NULL as day_29
		, NULL as day_30
		, NULL as day_31 
		, NULL as Total
		, @status_code as status_code
		, @status_text as status_text
		
END CATCH 

RETURN 

END
GO
GRANT EXECUTE ON  dbo.sproc_prp_rl_poc_planned_actual_service_time_client_monthly   to PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_prp_rl_poc_planned_actual_service_time_client_monthly.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_poc_planned_actual_service_time_client_monthly.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_poc_planned_actual_service_time_monthly.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- PCC-52764       :   script to create sproc_prp_rl_poc_planned_actual_service_time_monthly Procedure  
--						-- 
-- Written By:          Ritch Moore
-- Reviewed By:         
-- 
-- Script Type:         DDL 
-- Target DB Type:      Client
-- Target ENVIRONMENT:  BOTH (US/CA) 
-- 
-- 
-- Re-Runable:          YES 
-- 
-- Description of Script : Create sproc_prp_rl_poc_planned_actual_service_time_monthly Procedure for Service Tracking reporting
-- 
-- Special Instruction: 

-- 
-- =================================================================================

/***********************************************************************************
Revision History:
2014-02-06  Ritch Moore		PCC-52764	3.7.3 revise weekly Sp to Monthly
2014-02-28  Ritch Moore		PCC-54566	3.7.3 Corrected Planned - Actual problem
2014-03-15  Henny Ehghaghi	PCC-54689	3.7.3.1
2014-03-25  Henny Ehghaghi	PCC-55402	3.7.3.2
2014-03-25  Henny Ehghaghi	PCC-56339	3.7.3.2
2014-04-07  Henny Ehghaghi	PCC-56251	3.7.4 Assigne Alias name before all column names 
2014-05-20  Henny Ehghaghi  PCC-57972   3.7.4.1 Fixing Shift descreption (when start or end time is zero)
   

***********************************************************************************/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_prp_rl_poc_planned_actual_service_time_monthly' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE dbo.sproc_prp_rl_poc_planned_actual_service_time_monthly
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO



Create Procedure dbo.sproc_prp_rl_poc_planned_actual_service_time_monthly
 @fac_id int
, @unit_id int = -1
, @shift_id varchar(max)
, @include_unscheduled char(1) = 'N'
, @include_prn char(1) = 'N'
, @month varchar(20)
, @position_times varchar(max)
, @execution_user_login varchar(60)
, @rows_returned int out
, @debug_me char(1)  = 'N'
, @status_code int  out 
, @status_text varchar(3000) out
/********************************************************************************
			   
Declare  @rows_ret int		,@statuscode int		,@statustext varchar(3000)
exec dbo.sproc_prp_rl_poc_planned_actual_service_time_monthly
@fac_id =  '1'
,@shift_id = '-1'
,@include_unscheduled = 'N'
,@include_prn = 'N'
,@month='2014,2'
,@position_times ='19091,7.5;19059,7.5;60580,8.0;19777,7.25;60250,8.25'
,@execution_user_login =  'pcc-moorer'
,@rows_returned = null
,@debug_me = 'N'
,@status_code = null
,@status_text = null

**********************************************************************************/

as
Begin


SET NOCOUNT ON;
--declare Standard local variables required for any store proc
DECLARE  @vStep int
		,@vErr varchar(max)
		,@vdelim char(1)
		,@vCharNewLine  char(2)
	    ,@vSeparator char(6)
		,@vSeparator2 char(6)
		,@vReportDate datetime
		,@vRowCount int

--Facility Related variables, also used in capturing execution Statistics 
Declare @vFacIDs varchar(max)		
Declare @PRP_FacList as table(FacId int)
Declare @vFacWarningMsg varchar(max) --- to know whether it the returned list is restricted

----Local Variables

DECLARE @vFacId int
	, @vFacName varchar(500)
	, @vFacAddress varchar(max)
	, @vRegId int
	, @vWeekDate datetime
	, @vUnitId int
	, @vShiftId varchar(max)
	, @vIncludeUnscheduled char(1) 
	, @vSortBy varchar(50)
	, @Vmonth varchar(20)
	, @vStartDate datetime
	, @vEndDate datetime
	, @Vshift int
	, @Vstatus int
	, @vPositionTimes varchar(max)
	, @vIncludePRN CHAR(1)
	, @vIncludePRNbit BIT;


-----Governor and Statistics Variables 
Declare  @vgs_program_name varchar(200)
		 ,@vgs_start_time datetime
		 ,@vgs_execution_user varchar(60)
		 ,@vgs_fill_end_time datetime
		 ,@vGeneric_statuscode int 
		 ,@vGeneric_statustext varchar(3000)
		 ,@vgsStepStartTime datetime
		 ,@vgsStepEndTime datetime

declare @selected_shifts table (shift_id int);

------TERMINOLOGY VARIABLES and COMMON VARIABLES FOR A FAC 
	
Declare @vClientWarningMsg varchar(max)--- to know whether it the returned list is restricted



CREATE table #PRP_Position_Times (position_id int, hours decimal(8,2));

Declare  @freq TABLE (
            day_num int
           ,day_date datetime
           ,colname varchar(20)); 

CREATE TABLE #prp_shifts( 
		  shift_id int
		, shift_name varchar(50) 
		, start_time int
		, end_time int
		, group_name varchar(15)
		, position_id int
		, flg int
);

CREATE TABLE #prp_shift_link( 
		  shift_id int
		, shift_name varchar(50) 
		, start_time int
		, end_time int
		, group_name varchar(15)
		, position_id int
);

CREATE TABLE #prp_poc_details( 
		  id_key varchar(20)
		, first_name varchar(50)
		, last_name varchar(50) 
		, bed_id int
		, bed_desc varchar(30)
		, discharge_date datetime
		, client_id_number varchar(35)
		, photo_small varchar(55)
		, room_desc varchar(60)
		, unit_id int
		, unit_desc varchar(35)
		, admission_date datetime
		, client_id int
		, effective_date datetime
		, ineffective_date datetime
		, current_row varchar(1)
		, intervention_desc  varchar(2000)
		, date_initiated datetime
		, std_intervention_id  int
		, require_time_tracking bit
		, baseline_time smallint
		, intervention_id  int
		, schedule_id  int
		, schedule_type  int
		, std_shift_ids  varchar(500)
		, start_time varchar(4)
		, end_time varchar(4)
		, xxminutes  int
		, fac_id  int
		, day_of_month int 
		, schedule_detail_id varchar(100)
		, std_shift_id int
		, shift_date datetime
		, schedule_date datetime
		, schedule_time int
		, schedule_end_date datetime
		, documentation_id varchar(100)
		, completed_date datetime
		, strikeout_date datetime
		, entered_date datetime
		, task_time smallint
		, cp_sec_user_audit_id int
		, struckout_cp_sec_user_audit_id int
		);         

CREATE TABLE #prp_poc_planned( 
		  fac_id int
		, shift varchar(50)
		, group_name varchar(15) 
		, position_id int
		, position varchar(254) 
		, hour_type varchar (60)
		, day_1 decimal(8,2) default 0
		, day_2 decimal(8,2) default 0
		, day_3 decimal(8,2) default 0
		, day_4 decimal(8,2) default 0
		, day_5 decimal(8,2) default 0
		, day_6 decimal(8,2) default 0
		, day_7 decimal(8,2) default 0
		, day_8 decimal(8,2) default 0
		, day_9 decimal(8,2) default 0
		, day_10 decimal(8,2) default 0
		, day_11 decimal(8,2) default 0
		, day_12 decimal(8,2) default 0
		, day_13 decimal(8,2) default 0
		, day_14 decimal(8,2) default 0
		, day_15 decimal(8,2) default 0
		, day_16 decimal(8,2) default 0
		, day_17 decimal(8,2) default 0
		, day_18 decimal(8,2) default 0
		, day_19 decimal(8,2) default 0
		, day_20 decimal(8,2) default 0
		, day_21 decimal(8,2) default 0
		, day_22 decimal(8,2) default 0
		, day_23 decimal(8,2) default 0
		, day_24 decimal(8,2) default 0
		, day_25 decimal(8,2) default 0
		, day_26 decimal(8,2) default 0
		, day_27 decimal(8,2) default 0
		, day_28 decimal(8,2) default 0
		, day_29 decimal(8,2) default 0
		, day_30 decimal(8,2) default 0
		, day_31 decimal(8,2) default 0
		, total  decimal(20,2) default 0
		, ordr tinyint
);

CREATE TABLE #prp_poc_planned_final( 
		  fac_id int
		, shift varchar(50)
		, group_name varchar(15) 
		, position_id int
		, position varchar(254) 
		, hour_type varchar (60)
		, day_1 decimal(8,2) default 0
		, day_2 decimal(8,2) default 0
		, day_3 decimal(8,2) default 0
		, day_4 decimal(8,2) default 0
		, day_5 decimal(8,2) default 0
		, day_6 decimal(8,2) default 0
		, day_7 decimal(8,2) default 0
		, day_8 decimal(8,2) default 0
		, day_9 decimal(8,2) default 0
		, day_10 decimal(8,2) default 0
		, day_11 decimal(8,2) default 0
		, day_12 decimal(8,2) default 0
		, day_13 decimal(8,2) default 0
		, day_14 decimal(8,2) default 0
		, day_15 decimal(8,2) default 0
		, day_16 decimal(8,2) default 0
		, day_17 decimal(8,2) default 0
		, day_18 decimal(8,2) default 0
		, day_19 decimal(8,2) default 0
		, day_20 decimal(8,2) default 0
		, day_21 decimal(8,2) default 0
		, day_22 decimal(8,2) default 0
		, day_23 decimal(8,2) default 0
		, day_24 decimal(8,2) default 0
		, day_25 decimal(8,2) default 0
		, day_26 decimal(8,2) default 0
		, day_27 decimal(8,2) default 0
		, day_28 decimal(8,2) default 0
		, day_29 decimal(8,2) default 0
		, day_30 decimal(8,2) default 0
		, day_31 decimal(8,2) default 0
		, total  decimal(20,2) default 0
		, ordr tinyint
);

 DECLARE @ROWDATA TABLE
 (
 id_key int IDENTITY(1,1),
  schedule_detail_id varchar(250),
  shift_id           varchar(50),
  shift_name         varchar(max),
  group_name         varchar(max),
  position_id        int,
  position           varchar(max),
  day_of_week        int,
  total_minutes      int,
  timeFlag           int,
  completed_date     datetime,
  schedule_date      datetime,
  document_id        varchar(250),
  sFlag              int,--struckout flag
  PRIMARY KEY (schedule_detail_id, timeflag, shift_id,id_key),
     UNIQUE CLUSTERED (schedule_date,completed_date,id_key) 

 );
 
 declare @Dateadjust as TABLE
( day_date	    datetime,
  std_shift_id	int,
  shift_name    varchar(max),
  fac_id	    int,
  s_date	    datetime,
  dd            datetime,
  tm            int);
 
 declare @daylightStart datetime , @daylightEnd  datetime  
	

 
BEGIN TRY

	Set @status_code = 0   ---- Status Code 0 = Success, 1 = Exception
	set @status_text = null;
	set @rows_returned = 0;
	Set @vgs_program_name  = Object_name(@@ProcID);  ---Current Store Proc Name
	Set @vgs_start_time = getdate();
	Set @vgs_execution_user = @execution_user_login;
--	Set @vLocationWithUnit ='1'

	select @vStep = 0
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Executing store proc :  ' + @vgs_program_name  + convert(varchar(26),getdate(),109)

	--set Standard variables
	set @vdelim = ';'
	set @vCharNewLine  = char(10);
	set @vSeparator = 'ZYXWVU';
	set @vSeparator2 = 'UVWXYZ';

	----Parameter Sniffing - use local variables when they are used in a where clause
	SET @vFacID					= @fac_id;
    SET @vUnitId				= @unit_id;
	SET @vShiftId				= @shift_id
	set @vIncludeUnscheduled	= @include_unscheduled
    SET @vPositionTimes			= @position_times
    SET @Vmonth					= @month ;
   	SET @vStartDate				= CAST(SUBSTRING(@Vmonth,1,CHARINDEX(',',@Vmonth)-1)+'-'+SUBSTRING(@Vmonth,CHARINDEX(',',@Vmonth)+1,LEN(@Vmonth))+'-01' AS DATETIME);
    SET @vEndDate				=  CAST(CONVERT(VARCHAR(10),DATEADD(s,-1,DATEADD(mm, DATEDIFF(m,0,@vStartDate)+1,0)),12) AS DATETIME);
	SET	@vEndDate				= (select convert(datetime, convert(varchar(4), datepart(yyyy, @vEndDate))
									+ '-' + convert(varchar(2), datepart(MM, @vEndDate))
									+ '-' + convert(varchar(2), datepart(dd, @vEndDate))
									+ ' 23:59:59'));
	SET @vIncludePRN	= ISNULL(@include_prn, 'N');
	SELECT @vIncludePRNbit = IIF(@vIncludePRN = 'N', 0, 1);
									
	SELECT @daylightStart=start_date,@daylightEnd=end_date
	FROM day_light_savings_dates
	WHERE datepart(yyyy,start_date )=left(@Vmonth,4);
	

 
    IF isnull(@vShiftId,'-1')<>'-1'
	begin
		insert INTO @selected_shifts select Cast(items as int) from dbo.Split(@vShiftId,@vdelim)
	end
    
    --select 11,@vPositionTimes
    
     if @debug_me='Y' select @vStartDate startDate,@vEndDate endDate,DATEADD(dd,-(DAY(DATEADD(mm,1,@vEndDate))-1),DATEADD(mm,1,@vEndDate))

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep = 10
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Validating Input Parameters  ' +  convert(varchar(26),getdate(),109)

	----Validate all input parameters
	if (
		@fac_id is NULL 
		or @execution_user_login is null
		or @Vmonth is null
		)
	begin
		set @vErr = 'One or more of the following input parameters is invalid... '
					+ ' @fac_id=' + isnull(convert(varchar(10),@fac_id),'null/empty')
					+ ' @Vmonth=' + isnull(convert(varchar(10),@Vmonth, 101),'null/empty')
					+ ', @execution_user_login=' + isnull(@execution_user_login,'null/empty')
	
		RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);
	end

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	Select @vStep = 20;
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Getting user access fac list ' + convert(varchar(26),getdate(),109);

	Select @vFacIds = fac_id
		  ,@vFacWarningMsg = msg
	From  dbo.fn_prp_get_facility_access_list_delim(@vFacId ,@vgs_execution_user); ---filter the fac list with user access

	--facilities warnings
	if @vFacWarningMsg is NOT NULL --- NOT NULL stands for restricted facilities access warning message
	Begin
		Set @status_code = 2 ; ----Set it warning
		Set @status_text = isnull(@status_text,'') + @vFacWarningMsg ;
	End 
	
	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep = 30
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' getting raw data ' + convert(varchar(26),getdate(),109)

	insert INTO  #prp_poc_details 
		( id_key
		, first_name
		, last_name
		, bed_id
		, bed_desc
		, discharge_date
		, client_id_number
		, photo_small
		, room_desc
		, unit_id
		, unit_desc
		, admission_date
		, client_id
		, effective_date 
		, ineffective_date 
		, current_row
		, intervention_desc
		, date_initiated
		, std_intervention_id
		, require_time_tracking
		, baseline_time
		, intervention_id
		, schedule_id
		, schedule_type
		, std_shift_ids
		, start_time 
		, end_time 
		, xxminutes
		, fac_id
		, day_of_month 
		, schedule_detail_id
		, std_shift_id
		, shift_date
		, schedule_date
		, schedule_end_date
		, documentation_id
		, completed_date
		, strikeout_date
		, entered_date
		, task_time
		, cp_sec_user_audit_id
		, struckout_cp_sec_user_audit_id
		)
	exec dbo.sproc_prp_pcc_poc_getScheduleDetails
	@vFacId,
	-1,--@vShiftId,--@shiftID_param int,
	-1,--@myPositionID_param int,
	-1,--@assignmentID_param int,
	@vUnitId,--@unitID_param int,
	-1,--@selectedPositionID_param int,
	@vStartDate,--'2014-01-26 00:00:00',--@shiftStartTime_param datetime,
	@vEndDate,--'2014-02-01 23:59:59'--@shiftEndTime_param datetime,
	NULL,--'7445,7455,7465',--@stdInts_param varchar(8000),
	-1,--@clientID_param int,
	@vStartDate,--'2014-01-26 00:00:00',--@localStartTime_param datetime,
	@vEndDate,--'2014-02-01 23:59:59'--@localEndTime_param datetime,
	Null,--@max_details_param int = 2147483647,
	@vIncludePRNbit,--@include_prn_param bit = 1,
	'N',--@debug				char(1)  = 'N',
	Null,--@status_code		int	out,
	Null--@status_text		varchar(3000) out
	
	set @vRowCount = @@rowcount
		if  (@vRowCount = 0)
	begin
	 Set @status_code = 2
	 Set @status_text = isnull(@status_text,'') + 'No Data Found' ;
	 Raiserror( 'sproc_prp_pcc_poc_getScheduleDetails returned 0 rows.', 10, 1 );
	 
	 end
	 
        update #prp_poc_details
        set schedule_date= case when completed_date is not null then completed_date else schedule_date end  
        from #prp_poc_details
        where substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)='D';
        
-- DAY LIGHT SAVING DATE 
        update  a set
            schedule_date=case 
              when schedule_date= dateadd(hh,1,@daylightStart) then @daylightStart
              when schedule_date= dateadd(hh,-1,@daylightEnd) then @daylightEnd
             end   ,
            completed_date=case 
              when completed_date= dateadd(hh,1,@daylightStart) then  @daylightStart
              when completed_date= dateadd(hh,-1,@daylightEnd) then  @daylightEnd
              end 
        from #prp_poc_details a
         where schedule_date= dateadd(hh,1,@daylightStart) or schedule_date= dateadd(hh,-1,@daylightEnd)
         or completed_date= dateadd(hh,1,@daylightStart) or completed_date= dateadd(hh,-1,@daylightEnd)


	   update #prp_poc_details 
	    set schedule_time=replace(convert(varchar(5),dbo.fn_adjust_time_fac_time_zone (@vFacId ,schedule_date),108),':','')  
	
	
	      			
					
        delete					        
        from #prp_poc_details
        where ineffective_date is not null
        and schedule_date>ineffective_date;


        delete from #prp_poc_details
        where ineffective_date is  null
        and schedule_date<effective_date;
        
 
	CREATE  CLUSTERED INDEX _temp1_prppocdetails on #prp_poc_details(id_key,intervention_id,schedule_type,schedule_detail_id,std_intervention_id,schedule_time,std_shift_id,strikeout_date)
	
	 
	if @debug_me='Y' select * from #prp_poc_details  
	

	

	Insert into #PRP_Position_Times
	Select left(items,(CHARINDEX(',',items)-1)),
	right(items,len(items) - CHARINDEX(',',items))
	from dbo.split(@vPositionTimes,@vDelim)
	
	

--It's using for QSHIFT
	INSERT INTO #prp_shift_link( shift_id , shift_name , start_time , end_time , group_name , position_id )
	select distinct shift.std_shift_id,
	shift.description+' ('+
		case when left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end)) ='' then '0' ELSE

left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end))
end 
		+':'+right(cast(start_time as int),2)+(case when cast(start_time as int)>1200 THEN ' PM' ELSE ' AM' END) 
		+' - ' +
		case when rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end))))='' then '0'
		else
		rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end)))) end 
		+':'+right(cast(end_time as int),2)+(case when cast(end_time as int)>1200 THEN ' PM' ELSE ' AM' END) +')' shift_name,
		
	shift.start_time,cast(shift.end_time as int)-1  as end_time1,'',0
	from dbo.cp_std_shift shift WITH (NOLOCK)
	LEFT JOIN @selected_shifts ss on shift.std_shift_id=ss.shift_id
	WHERE
	shift.deleted='N' 
	and (shift.fac_id=@vFacId or shift.fac_id=-1) 
	and (@vShiftId='-1' OR ss.shift_id IS not NULL);
	
	
	if @debug_me='Y' select * from #prp_shift_link order BY shift_name
	
	
--It's using for Non-QSHIFT
	INSERT INTO #prp_shifts (shift_id , shift_name, start_time , end_time , group_name, position_id , flg) 
	select distinct  shift.std_shift_id,
	shift.description+' ('+
		case when left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end)) ='' then '0' ELSE

left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end))
end 
		+':'+right(cast(start_time as int),2)+(case when cast(start_time as int)>1200 THEN ' PM' ELSE ' AM' END) 
		+' - ' +
		case when rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end))))='' then '0'
		else
		rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end)))) end 
		+':'+right(cast(end_time as int),2)+(case when cast(end_time as int)>1200 THEN ' PM' ELSE ' AM' END) +')' shift_name,
	
	shift.start_time,shift.end_time-1,'',grpass.position_id,0
	from dbo.pho_assignment_group_assoc  grpass WITH (NOLOCK)
	INNER JOIN dbo.pho_assignment_group grp WITH (NOLOCK) ON 
	    grpass.pho_assignment_group_id=grp.pho_assignment_group_id 
	    and grp.fac_id=@vFacId and grp.deleted='N'
        and grpass.fac_id=@vFacId and grpass.position_id is not null
	INNER JOIN dbo.cp_std_shift shift WITH (NOLOCK) ON 
	    grpass.std_shift_id=shift.std_shift_id and shift.deleted='N'
	LEFT JOIN @selected_shifts ss on shift.std_shift_id=ss.shift_id 
	WHERE (@vShiftId='-1' OR ss.shift_id IS not NULL)
	and	convert(int,shift.end_time)-convert(int,shift.start_time)>0; 
	    
	INSERT INTO #prp_shifts (shift_id , shift_name, start_time , end_time , group_name, position_id , flg) 
	select distinct shift.std_shift_id,
	shift.description+' ('+
		case when left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end)) ='' then '0' ELSE

left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end))
end 
		+':'+right(cast(start_time as int),2)+(case when cast(start_time as int)>1200 THEN ' PM' ELSE ' AM' END) 
		+' - ' +
		case when rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end))))='' then '0'
		else
		rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end)))) end 
		+':'+right(cast(end_time as int),2)+(case when cast(end_time as int)>1200 THEN ' PM' ELSE ' AM' END) +')' 
	,shift.start_time,2400-1,'',grpass.position_id,0
	from dbo.pho_assignment_group_assoc  grpass WITH (NOLOCK)
	INNER JOIN dbo.pho_assignment_group grp WITH (NOLOCK) ON grpass.pho_assignment_group_id=grp.pho_assignment_group_id 
	and grp.fac_id=@vFacId and grp.deleted='N'
		and grpass.fac_id=@vFacId and grpass.position_id is not null
	INNER JOIN dbo.cp_std_shift shift WITH (NOLOCK) ON grpass.std_shift_id=shift.std_shift_id and shift.deleted='N' 
	LEFT JOIN @selected_shifts ss on shift.std_shift_id=ss.shift_id 
     WHERE (@vShiftId='-1' OR ss.shift_id IS not NULL)
     and convert(int,shift.end_time)-convert(int,shift.start_time)<0 ;
     
     INSERT INTO #prp_shifts (shift_id , shift_name, start_time , end_time , group_name, position_id , flg) 
     select distinct shift.std_shift_id,
     shift.description+' ('+
		case when left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end)) ='' then '0' ELSE

left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end))
end 
		+':'+right(cast(start_time as int),2)+(case when cast(start_time as int)>1200 THEN ' PM' ELSE ' AM' END) 
		+' - ' +
		case when rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end))))='' then '0'
		else
		rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end)))) end 
		+':'+right(cast(end_time as int),2)+(case when cast(end_time as int)>1200 THEN ' PM' ELSE ' AM' END) +')' shift_name
     ,'0',shift.end_time-1,'',grpass.position_id,1
	from dbo.pho_assignment_group_assoc  grpass WITH (NOLOCK)
	INNER JOIN dbo.pho_assignment_group grp WITH (NOLOCK) ON grpass.pho_assignment_group_id=grp.pho_assignment_group_id 
	and grp.fac_id=@vFacId and grp.deleted='N'
		and grpass.fac_id=@vFacId and grpass.position_id is not null
	INNER JOIN dbo.cp_std_shift shift WITH (NOLOCK) ON grpass.std_shift_id=shift.std_shift_id and shift.deleted='N' 	 
    LEFT JOIN @selected_shifts ss on shift.std_shift_id=ss.shift_id
		 WHERE (@vShiftId='-1' OR ss.shift_id IS not NULL)
		 and convert(int,shift.end_time)-convert(int,shift.start_time)<0;
		 
		 
	
	
	INSERT INTO @Dateadjust (day_date,std_shift_id,shift_name ,fac_id,s_date, dd ,tm )
      select a.day_date,a.std_shift_id,ss.shift_name,a.fac_id,a.s_date,cast(convert(varchar(10),a.s_date,120) as datetime) dd,
      cast(replace(convert(varchar(5),a.s_date,108),':','') as int)tm
      from view_cp_shift_dates a
      inner join #prp_shifts ss on a.std_shift_id=ss.shift_id 
      inner join #PRP_Position_Times b on b.position_id=ss.position_id
      --inner join (select max(start_time) sTime,min(end_time) eTime from #prp_shifts) sn on ss.start_time>=sn.sTime and ss.end_time<=sn.eTime 
      where a.fac_id=@vFacId
      and flg=1
      and datepart(yyyy,a.s_date)=left(@Vmonth,4)
      and datepart(mm,a.s_date) between substring(@Vmonth,charindex(',',@Vmonth)+1,len(@Vmonth)) -1
      and substring(@Vmonth,charindex(',',@Vmonth)+1,len(@Vmonth)) +1
      ;
      
      delete from @Dateadjust where day_date<dateadd(dd,-1,@vStartDate) or day_date>@vEndDate
      
          

     if @debug_me='Y' select * from @Dateadjust order BY 1
 
	
	CREATE  CLUSTERED INDEX _temp1_prpshifts on #prp_shifts(position_id,start_time,end_time)

	if @debug_me='Y' select * from #prp_shifts order BY shift_name
	
	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	Set @vgs_fill_end_time  = getdate() ; -- fill end time

	select @vStep = 60
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' loading and calculating pivoted table ' + convert(varchar(26),getdate(),109)

-------------------------------------------------------------
-- Row data for Planned Hours
-------------------------------------------------------------	
--Qshift
INSERT INTO @ROWDATA (schedule_detail_id,shift_id,shift_name,group_name,position_id,position,day_of_week,total_minutes,timeFlag,completed_date,schedule_date,document_id,sFlag)
SELECT cpsd.schedule_detail_id, 
       shift.shift_id, 
       CASE 
         WHEN ( shift.end_time - shift.start_time ) < 0 
              AND ( cpsd.schedule_time >= shift.start_time 
                     OR cpsd.schedule_time <= shift.end_time ) THEN 
         shift.shift_name 
         WHEN ( shift.end_time - shift.start_time ) > 0 
              AND ( cpsd.schedule_time >= shift.start_time 
                    AND cpsd.schedule_time <= shift.end_time ) THEN 
         shift.shift_name 
       END                                                AS Shift1, 
       shift.group_name, 
       crr.service_tracking_position_id                   AS position_id, 
       cc.item_description                                AS position, 
       Datepart(dd, cpsd.shift_date)                      AS day_of_week, 
       COALESCE(cpsd.baseline_time, cpstdi.baseline_time) AS total_minutes, 
       1, 
       cpsd.completed_date, 
       cpsd.shift_date                                    AS schedule_date, 
       cpsd.documentation_id, 
       CASE 
         WHEN cpsd.strikeout_date IS NOT NULL THEN 1 
         ELSE 0 
       END                                                sFlag 
FROM   #prp_poc_details cpsd 
       INNER JOIN cp_rev_intervention crr WITH (nolock) 
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.common_code cc WITH (nolock) 
               ON crr.service_tracking_position_id = cc.item_id 
       INNER JOIN dbo.#prp_shift_link shift 
               ON cpsd.std_shift_id = shift.shift_id 
       INNER JOIN dbo.#prp_position_times pt 
               ON pt.position_id = crr.service_tracking_position_id 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       AND ( Isnull(@vPositionTimes, '-1') = '-1' 
              OR pt.position_id IS NOT NULL );  	
	
	
	
--NonQshift
INSERT INTO @ROWDATA (schedule_detail_id,shift_id,shift_name,group_name,position_id,position,day_of_week,total_minutes,timeFlag,completed_date,schedule_date,document_id,sFlag)
	SELECT cpsd.schedule_detail_id, 
       Cast(shift.shift_id AS VARCHAR) + '-' 
       + Cast(shift.flg AS VARCHAR)                       shift_id, 
       CASE 
         WHEN Substring(cpsd.schedule_detail_id, Charindex('_', cpsd.schedule_detail_id) +1, 1)= 'D' 
              AND ( shift.end_time - shift.start_time ) < 0 
              AND ( cpsd.schedule_time >= shift.start_time OR cpsd.schedule_time <= shift.end_time ) THEN 
         shift.shift_name 
         WHEN Substring(cpsd.schedule_detail_id, Charindex('_', cpsd.schedule_detail_id) +1, 1)  = 'D' 
              AND ( shift.end_time - shift.start_time ) > 0 
              AND ( cpsd.schedule_time >= shift.start_time AND cpsd.schedule_time <= shift.end_time ) THEN 
         shift.shift_name 
         WHEN Substring(cpsd.schedule_detail_id, Charindex('_', cpsd.schedule_detail_id) +1, 1)  <> 'D' THEN 
         shift.shift_name 
       END                                                AS Shift, 
       shift.group_name, 
       CASE 
         WHEN Isnull(cpstdi.require_time_tracking, 0) = 1 THEN 
         crr.service_tracking_position_id 
         WHEN Isnull(cpstdi.require_time_tracking, 0) = 0 
              AND Isnull(crr.require_time_tracking, 0) = 1 THEN 
         crr.service_tracking_position_id 
       END                                                AS position_id, 
       cc.item_description                                AS position, 
       Datepart(dd, cpsd.schedule_date)                   AS day_of_week, 
       COALESCE(cpsd.baseline_time, cpstdi.baseline_time) AS total_minutes, 
       1, 
       cpsd.completed_date, 
       cpsd.schedule_date, 
       cpsd.documentation_id, 
       CASE 
         WHEN cpsd.strikeout_date IS NOT NULL THEN 1 
         ELSE 0 
       END                                                sFlag 
FROM   #prp_poc_details cpsd 
       INNER JOIN cp_rev_intervention crr WITH (nolock) 
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.common_code cc WITH (nolock) 
               ON cc.item_id = CASE 
                                 WHEN Isnull(cpstdi.require_time_tracking, 0) = 1 THEN 
                                 crr.service_tracking_position_id 
                                 WHEN isnull(cpstdi.require_time_tracking, 0) = 0 
                                AND Isnull(crr.require_time_tracking, 0) = 1 THEN 
                                 crr.service_tracking_position_id 
                               END 
       INNER JOIN dbo.#prp_shifts shift 
               ON 1 = CASE 
                        WHEN Substring(cpsd.schedule_detail_id, Charindex('_', cpsd.schedule_detail_id) + 1, 1) = 'D' 
                             AND 
                      crr.service_tracking_position_id = shift.position_id 
                             AND cpsd.std_shift_id IS NULL THEN 1 
                        WHEN Substring(cpsd.schedule_detail_id,Charindex('_', cpsd.schedule_detail_id) + 1,1) = 'S' 
                             AND 
                      crr.service_tracking_position_id = shift.position_id 
                             AND cpsd.std_shift_id IS NULL 
                             AND 1 = CASE 
                                       WHEN 
                                 ( shift.end_time - shift.start_time ) < 0 
                                 AND 
                        ( 
                          cpsd.schedule_time >= shift.start_time 
                           OR cpsd.schedule_time <= shift.end_time ) THEN 
                          1 
                          WHEN ( shift.end_time - shift.start_time ) > 0 
                               AND ( 
                          cpsd.schedule_time >= shift.start_time 
                          AND cpsd.schedule_time <= shift.end_time ) THEN 
                          1 
                          ELSE 0 
                        END THEN 1 
                        ELSE 0 
                      END 
       INNER JOIN dbo.#prp_position_times pt 
               ON pt.position_id = crr.service_tracking_position_id 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       AND cpsd.std_shift_id IS NULL 
       AND ( Isnull(@vPositionTimes, '-1') = '-1' 
              OR pt.position_id IS NOT NULL )  ;

-------------------------------------------------------------
-- Row data for Actual Hours
-------------------------------------------------------------
 update #prp_poc_details 
	    set schedule_time=replace(convert(varchar(5),dbo.fn_adjust_time_fac_time_zone (@vFacId ,completed_date),108),':','')
 where completed_date is not null
 and substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)<>'Q' 
	    
--QSHIFT	
INSERT INTO @ROWDATA (schedule_detail_id,shift_id,shift_name,group_name,position_id,position,day_of_week,total_minutes,timeFlag,completed_date,schedule_date,document_id)
SELECT cpsd.schedule_detail_id, 
       shift.shift_id, 
       CASE 
         WHEN ( shift.end_time - shift.start_time ) < 0 
              AND ( cpsd.schedule_time >= shift.start_time 
                     OR cpsd.schedule_time <= shift.end_time ) THEN 
         shift.shift_name 
         WHEN ( shift.end_time - shift.start_time ) > 0 
              AND ( cpsd.schedule_time >= shift.start_time 
                    AND cpsd.schedule_time <= shift.end_time ) THEN 
         shift.shift_name 
       END                       AS Shift1, 
       shift.group_name, 
       usr.position_id, 
       CASE 
         WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown' 
         ELSE usr.position_description 
       END                       AS position, 
       Datepart(dd, cpsd.shift_date)  AS day_of_week, 
       Isnull(cpsd.task_time, 0) AS total_minutes, 
       2 timeflag, 
       cpsd.completed_date, 
       cpsd.shift_date                AS schedule_date, 
       cpsd.documentation_id 
FROM   #prp_poc_details cpsd 
       INNER JOIN cp_rev_intervention crr WITH (nolock) 
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.#prp_shift_link shift 
               ON cpsd.std_shift_id = shift.shift_id 
       INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock) 
               ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id 
       INNER JOIN dbo.#prp_position_times pt 
               ON pt.position_id = crr.service_tracking_position_id 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       AND cpsd.completed_date IS NOT NULL 
       AND cpsd.strikeout_date IS NULL;  

--NonQshift
INSERT INTO @ROWDATA (schedule_detail_id,shift_id,shift_name,group_name,position_id,position,day_of_week,total_minutes,timeFlag,completed_date,schedule_date,document_id)
SELECT schedule_detail_id, 
       Cast(shift_id AS VARCHAR) + '-' 
       + Cast(shift.flg AS VARCHAR) shift_id, 
       CASE 
         WHEN Substring(schedule_detail_id, Charindex('_', schedule_detail_id) +
                                             1, 1) 
              = 'D' 
              AND ( shift.end_time - shift.start_time ) < 0 
              AND ( cpsd.schedule_time >= shift.start_time 
                     OR cpsd.schedule_time <= shift.end_time ) THEN 
         shift.shift_name 
         WHEN Substring(schedule_detail_id, Charindex('_', schedule_detail_id) +
                                             1, 1) 
              = 'D' 
              AND ( shift.end_time - shift.start_time ) > 0 
              AND ( cpsd.schedule_time >= shift.start_time 
                    AND cpsd.schedule_time <= shift.end_time ) THEN 
         shift.shift_name 
         WHEN Substring(schedule_detail_id, Charindex('_', schedule_detail_id) +
                                             1, 1) 
              <> 'D'THEN shift.shift_name 
       END                          AS Shift, 
       shift.group_name, 
       usr.position_id, 
       CASE 
         WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown' 
         ELSE usr.position_description 
       END                          AS position, 
       Datepart(dd, schedule_date)  AS day_of_week, 
       Isnull(cpsd.task_time, 0)    AS total_minutes, 
       2, 
       completed_date, 
       schedule_date, 
       documentation_id 
FROM   #prp_poc_details cpsd 
       INNER JOIN cp_rev_intervention crr WITH (nolock) 
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.#prp_shifts shift 
               ON 1 = CASE 
                        WHEN Substring(cpsd.schedule_detail_id, 
                             Charindex('_', cpsd.schedule_detail_id) + 1, 
                             1) 
                             = 'D' 
                             AND 
                      crr.service_tracking_position_id = shift.position_id 
                             AND cpsd.std_shift_id IS NULL THEN 1 
                        WHEN Substring(cpsd.schedule_detail_id, 
                             Charindex('_', cpsd.schedule_detail_id) + 1, 
                             1) 
                             IN ( 
                                    'U', 'S' ) 
                             AND 
                      crr.service_tracking_position_id = shift.position_id 
                             AND cpsd.std_shift_id IS NULL 
                             AND 1 = CASE 
                                       WHEN 
                                 ( shift.end_time - shift.start_time ) < 0 
                                 AND 
                        ( 
                          cpsd.schedule_time >= shift.start_time 
                           OR cpsd.schedule_time <= shift.end_time ) THEN 
                          1 
                          WHEN ( shift.end_time - shift.start_time ) > 0 
                               AND ( 
                          cpsd.schedule_time >= shift.start_time 
                          AND cpsd.schedule_time <= shift.end_time ) THEN 
                          1 
                          ELSE 0 
                        END THEN 1 
                        WHEN Substring(cpsd.schedule_detail_id, 
                             Charindex('_', cpsd.schedule_detail_id) + 1, 
                             1) 
                             = 'S' 
                             AND crr.service_tracking_position_id = -1 
                             AND cpsd.std_shift_id IS NULL 
                             AND cpsd.schedule_time >= shift.start_time 
                             AND cpsd.schedule_time <= shift.end_time THEN 1 
                        ELSE 0 
                      END 
       INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock) 
               ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id 
       INNER JOIN dbo.#prp_position_times pt 
               ON pt.position_id = crr.service_tracking_position_id 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       AND cpsd.completed_date IS NOT NULL 
       AND cpsd.std_shift_id IS NULL 
       AND cpsd.strikeout_date IS NULL  ;
	


-- Unschedule
if @vIncludeUnscheduled='Y'
begin
INSERT INTO @ROWDATA (schedule_detail_id,shift_id,shift_name,group_name,position_id,position,day_of_week,total_minutes,timeFlag,completed_date,schedule_date,document_id)
SELECT cpsd.schedule_detail_id, 
       Cast(shift.shift_id AS VARCHAR) + '-' 
       + Cast(shift.flg AS VARCHAR) shift_id, 
       CASE 
         WHEN Substring(cpsd.schedule_detail_id, Charindex('_', cpsd.schedule_detail_id) +
                                             1, 1) 
              = 'D' 
              AND ( shift.end_time - shift.start_time ) < 0 
              AND ( cpsd.schedule_time >= shift.start_time 
                     OR cpsd.schedule_time <= shift.end_time ) THEN 
         shift.shift_name 
         WHEN Substring(cpsd.schedule_detail_id, Charindex('_', cpsd.schedule_detail_id) +
                                             1, 1) 
              = 'D' 
              AND ( shift.end_time - shift.start_time ) > 0 
              AND ( cpsd.schedule_time >= shift.start_time 
                    AND cpsd.schedule_time <= shift.end_time ) THEN 
         shift.shift_name 
         WHEN Substring(cpsd.schedule_detail_id, Charindex('_', cpsd.schedule_detail_id) +
                                             1, 1) 
              <> 'D'THEN shift.shift_name 
       END                          AS Shift, 
       shift.group_name, 
       usr.position_id, 
       CASE 
         WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown' 
         ELSE usr.position_description 
       END                          AS position, 
       Datepart(dd, schedule_date)  AS day_of_week, 
       Isnull(cpsd.task_time, 0)    AS total_minutes, 
       2 timeflag, 
       cpsd.completed_date, 
       cpsd.schedule_date, 
       cpsd.documentation_id 
FROM   #prp_poc_details cpsd 
       INNER JOIN cp_rev_intervention crr 
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       --and cpstdi.require_time_tracking=1 
       INNER JOIN dbo.#prp_shifts shift WITH (nolock) 
               ON 1 = CASE 
                        WHEN Substring(cpsd.schedule_detail_id, 
                             Charindex('_', cpsd.schedule_detail_id) + 1, 
                             1) 
                             = 'D' 
                             AND 
                      crr.service_tracking_position_id = shift.position_id 
                             AND cpsd.std_shift_id IS NULL THEN 1 
                        WHEN Substring(cpsd.schedule_detail_id, 
                             Charindex('_', cpsd.schedule_detail_id) + 1, 
                             1) IN ( 'U', 'S' ) 
                             AND 
                      crr.service_tracking_position_id = shift.position_id 
                             AND cpsd.std_shift_id IS NULL 
                             AND 1 = CASE 
                                       WHEN 
                                 ( shift.end_time - shift.start_time ) < 0 
                                 AND 
                        ( 
                          cpsd.schedule_time >= shift.start_time 
                           OR cpsd.schedule_time <= shift.end_time ) THEN 
                          1 
                          WHEN ( shift.end_time - shift.start_time ) > 0 
                               AND ( 
                          cpsd.schedule_time >= shift.start_time 
                          AND cpsd.schedule_time <= shift.end_time ) THEN 
                          1 
                          ELSE 0 
                        END THEN 1 
                        WHEN Substring(schedule_detail_id, 
                             Charindex('_', schedule_detail_id) + 1, 
                             1) 
                             = 'S' 
                             AND crr.service_tracking_position_id = -1 
                             AND cpsd.std_shift_id IS NULL 
                             AND cpsd.schedule_time >= shift.start_time 
                             AND cpsd.schedule_time <= shift.end_time THEN 1 
                        ELSE 0 
                      END 
       INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock) 
               ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id 
       INNER JOIN dbo.#prp_position_times pt 
               ON pt.position_id = crr.service_tracking_position_id 
WHERE  cpsd.schedule_type = 40 
       AND cpsd.schedule_type <> 8 
       AND cpsd.completed_date IS NOT NULL 
       AND cpsd.std_shift_id IS NULL 
       AND cpsd.strikeout_date IS NULL  ;
END	

IF @vIncludePRN='Y'
BEGIN 
	INSERT INTO @ROWDATA (schedule_detail_id,shift_id,shift_name,group_name,position_id,position,day_of_week,total_minutes,timeFlag,completed_date,schedule_date,document_id)
	SELECT cpsd.schedule_detail_id, 
		   shift_id,
		   shift.shift_name as Shift, 
		   shift.group_name, 
		   usr.position_id, 
		   CASE 
			 WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown' 
			 ELSE usr.position_description 
		   END                              AS position, 
		   Datepart(dd, cpsd.schedule_date) AS day_of_week, 
		   Isnull(cpsd.task_time, 0)        AS total_minutes, 
		   2 as timeFlag, 
		   dbo.fn_adjust_time_fac_time_zone(@vFacId, cpsd.completed_date) as completed_date, 
		   dbo.fn_adjust_time_fac_time_zone(@vFacId, cpsd.schedule_date) as schedule_date, 
		   cpsd.documentation_id 
	FROM   #prp_poc_details cpsd 
		   INNER JOIN cp_rev_intervention crr WITH (nolock) 
				   ON crr.clientid = cpsd.client_id 
					  AND crr.current_row = 'Y' 
					  AND crr.gen_intervention_id = cpsd.intervention_id 
					  AND crr.require_time_tracking = 1 
		   LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
				  ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
					 AND cpstdi.poc_flowsheet = 'Y' 
		   INNER JOIN dbo.#prp_shift_link shift 
				   ON shift.shift_id = cpsd.std_shift_id				   
		   INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock) 
				   ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id 
		   INNER JOIN dbo.#prp_position_times pt 
				   ON pt.position_id = crr.service_tracking_position_id 
	WHERE  cpsd.schedule_type = 8 
		   AND completed_date IS NOT NULL  
		   AND cpsd.strikeout_date IS NULL
END

--ADJUST SHIFT NAME BASE OF COMPLETED DATE OR SCHEDULE DATE

--delete from @ROWDATA where sFlag=1 and timeFlag=1;

update a set shift_name=b.shift_name ,shift_id=cast(b.shift_id as varchar)+'-'+cast(b.flg as varchar)
 from @ROWDATA a
 inner join #prp_shifts b on cast(replace(convert(varchar(5),schedule_date,108),':','') as int)>=b.start_time and 
 cast(replace(convert(varchar(5),schedule_date,108),':','') as int)<=b.end_time 
 inner join #PRP_Position_Times c on c.position_id=b.position_id
where a.shift_name is null 



delete from @ROWDATA 
where shift_name is null 
and substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)<>'D' 



--------------- DELETE DUPLICATE

;WITH CTE_1  AS
(
select schedule_detail_id,shift_name,group_name,position_id,position,total_minutes,timeFlag,
case when timeFlag=1 then null else completed_date end completed_date ,
case when timeFlag=1 then null else document_id end document_id,
row_number() over(PARTITION BY schedule_detail_id,shift_name,group_name,position_id,position,total_minutes,timeFlag,case when timeFlag=1 then null else completed_date end, case when timeFlag=1 then null else document_id end
order by schedule_detail_id,shift_name,group_name,position_id,position,total_minutes,timeFlag,case when timeFlag=1 then null else completed_date end, case when timeFlag=1 then null else document_id end) row_id
from @ROWDATA
) 

delete from cte_1 where  row_id>1


--Qshift
update  a set 
  a.completed_date=  dbo.fn_adjust_time_fac_time_zone (@vFacId ,completed_date ) 
from @ROWDATA a
where substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)='Q'  



--NonQshift

     --- Nightshift
    update a SET
    schedule_date=cast(convert(varchar(20),b.day_date,110)
    +' '
    +convert(varchar(5),dbo.fn_adjust_time_fac_time_zone (@vFacId ,schedule_date ),108) as datetime),
    completed_date =cast(convert(varchar(20),c.day_date,110)
    +' '
    +convert(varchar(5),dbo.fn_adjust_time_fac_time_zone (@vFacId ,completed_date ),108) as datetime)

     from @ROWDATA a
     inner join @Dateadjust b on b.std_shift_id=cast(substring(a.shift_id,1,charindex('-',a.shift_id)-1) as int)
     and cast(convert(varchar(20),a.schedule_date,110) as datetime)=cast(convert(varchar(20),b.s_date,110) as datetime)
     left join @Dateadjust c on c.std_shift_id=cast(substring(a.shift_id,1,charindex('-',a.shift_id)-1) as int)
     and cast(convert(varchar(20),a.completed_date,110) as datetime)=cast(convert(varchar(20),c.s_date,110) as datetime)
    where substring(a.schedule_detail_id,charindex('_',a.schedule_detail_id)+1,1)<>'Q'
    and right(a.shift_id,1)=1;
    
    --- DAY AND EVEING 
    update a set 
      a.schedule_date=  dbo.fn_adjust_time_fac_time_zone (@vFacId ,schedule_date ),
      a.completed_date=  dbo.fn_adjust_time_fac_time_zone (@vFacId ,completed_date ) 
     FROM @ROWDATA a
     where 
     substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)<>'Q'  
     and right(shift_id,1)=0;

delete  from @ROWDATA where (schedule_date <@vStartDate or schedule_date>@vEndDate) and  schedule_date is not null


 --------------- SHOWING ACTUAL AND PLAN IN THE SAME DAY


delete  a
from @ROWDATA a 
where a.timeflag=1
and not exists (select 1 from @ROWDATA b where b.schedule_detail_id=a.schedule_detail_id and b.timeFlag=2 and a.document_id=b.document_id)
and substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)='D'


update  a set 
  day_of_week= case 
                when substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1) in ('D') and a.completed_date is not null 
                  then datepart(dd,completed_date)
                when timeflag=1 then datepart(dd,schedule_date)
                when timeflag in (2,3)  and substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1) <>'Q'
                 then datepart(dd,completed_date) else datepart(dd,schedule_date)
                end
from @ROWDATA a  



	----------------------------------------------------------------------

	INSERT INTO #prp_poc_planned 
	select @vFacId,Shift,group_name,position_id,position,'Planned Hours' as hour_type,[1] as day_1,[2] as day_2, [3] as day_3, [4] as day_4, [5] as day_5, [6] as day_6, [7] as day_7,
	[8] as day_8,[9] as day_9,[10] as day_10,[11] as day_11,[12] as day_12,[13] as day_13,[14] as day_14,[15] as day_15,[16] as day_16,[17] as day_17,
	[18] as day_18,[19] as day_19,[20] as day_20,[21] as day_21,[22] as day_22,[23] as day_23,[24] as day_24,[25] as day_25,[26] as day_26,[27] as day_27,
	[28] as day_28,[29] as day_29,[30] as day_30,[31] as day_31, 0 as total, 0 as ordr
	from
	(
	 select schedule_detail_id,shift_name Shift,group_name,position_id,position,day_of_week,total_minutes,timeFlag 
     from @ROWDATA
     where timeFlag=1
	) as rawdata
	PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17],[18],[19],[20],[21],[22],[23],
		[24],[25],[26],[27],[28],[29],[30],[31])) as pivotdata
	ORDER BY 1,2

	INSERT INTO #prp_poc_planned 
	select @vFacId,Shift,group_name,position_id,position,'Actual Hours' as hour_type,[1] as day_1,[2] as day_2, [3] as day_3, [4] as day_4, [5] as day_5, [6] as day_6, [7] as day_7,
	[8] as day_8,[9] as day_9,[10] as day_10,[11] as day_11,[12] as day_12,[13] as day_13,[14] as day_14,[15] as day_15,[16] as day_16,[17] as day_17,
	[18] as day_18,[19] as day_19,[20] as day_20,[21] as day_21,[22] as day_22,[23] as day_23,[24] as day_24,[25] as day_25,[26] as day_26,[27] as day_27,
	[28] as day_28,[29] as day_29,[30] as day_30,[31] as day_31, 0 as total, 1 as ordr
	from
	(
	select schedule_detail_id,shift_name Shift,group_name,position_id,position,day_of_week,total_minutes,timeFlag 
     from @ROWDATA
     where timeFlag=2
	) as rawdata
	PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17],[18],[19],[20],[21],[22],[23],
		[24],[25],[26],[27],[28],[29],[30],[31])) as pivotdata

	

	if @debug_me='Y' select * from #prp_poc_planned

	--insert dummy actual row if the corresponding planned ro has no data
	INSERT INTO #prp_poc_planned

		select @vFacId,planned.Shift,planned.group_name,planned.position_id,planned.position,'Actual Hours' as hour_type,
		0 as day_1, 0 as day_2, 0 as day_3, 0 as day_4, 0 as day_5, 0 as day_6, 0 as day_7,
		0 as day_8, 0 as day_9, 0 as day_10, 0 as day_11, 0 as day_12, 0 as day_13, 0 as day_14, 0 as day_15, 0 as day_16, 0 as day_17,
		0 as day_18, 0 as day_19, 0 as day_20, 0 as day_21, 0 as day_22, 0 as day_23, 0 as day_24, 0 as day_25, 0 as day_26, 0 as day_27,
		0 as day_28, 0 as day_29, 0 as day_30, 0 as day_31, 0 as total, 1 as ordr
		 from #prp_poc_planned planned
		 where  planned.ordr=0
		  and not exists  (select 1 from #prp_poc_planned actual where  actual.ordr=1 and planned.shift=actual.shift and planned.position_id=actual.position_id )	  
		 


insert into #prp_poc_planned_final
	select @vFacId,
	Shift,group_name,position_id,position,hour_type,
	sum(day_1) day_1,sum(day_2) day_2,sum(day_3) day_3,sum(day_4) day_4,sum(day_5) day_5,sum(day_6) day_6,
	sum(day_7) day_7,sum(day_8) day_8,sum(day_9) day_9,sum(day_10) day_10,sum(day_11) day_11,sum(day_12) day_12,
	sum(day_13) day_13,sum(day_14) day_14,sum(day_15) day_15,sum(day_16) day_16,sum(day_17) day_17,sum(day_18) day_18,	
	sum(day_19) day_19,sum(day_20) day_20,sum(day_21) day_21,sum(day_22) day_22,sum(day_23) day_23,sum(day_24) day_24,	
	sum(day_25) day_25,sum(day_26) day_26,sum(day_27) day_27,sum(day_28) day_28,sum(day_29) day_29,sum(day_30) day_30,
	sum(day_31) day_31,sum(total) total,ordr
		from #prp_poc_planned  
		group by Shift,group_name,position_id,position,hour_type,ordr
		order by shift,ordr
		
		

CREATE  CLUSTERED INDEX _temp1_prp_poc_planned_final on #prp_poc_planned_final(Shift,position,ordr)		

INSERT INTO #prp_poc_planned_final
select @vFacId,
	pre.Shift,pre.group_name,pre.position_id,pre.position,'Planned '+CHAR(45)+' Actual = ' as hour_type,
	(isnull(pre.day_1,0)-isnull(nxt.day_1,0)) as day_1,
	(isnull(pre.day_2,0)-isnull(nxt.day_2,0)) as day_2, 
	(isnull(pre.day_3,0)-isnull(nxt.day_3,0)) as day_3, 
	(isnull(pre.day_4,0)-isnull(nxt.day_4,0)) as day_4, 
	(isnull(pre.day_5,0)-isnull(nxt.day_5,0)) as day_5, 
	(isnull(pre.day_6,0)-isnull(nxt.day_6,0)) as day_6, 
	(isnull(pre.day_7,0)-isnull(nxt.day_7,0)) as day_7,
	(isnull(pre.day_8,0)-isnull(nxt.day_8,0)) as day_8,
	(isnull(pre.day_9,0)-isnull(nxt.day_9,0)) as day_9, 
	(isnull(pre.day_10,0)-isnull(nxt.day_10,0)) as day_10, 
	(isnull(pre.day_11,0)-isnull(nxt.day_11,0)) as day_11, 
	(isnull(pre.day_12,0)-isnull(nxt.day_12,0)) as day_12, 
	(isnull(pre.day_13,0)-isnull(nxt.day_13,0)) as day_13, 
	(isnull(pre.day_14,0)-isnull(nxt.day_14,0)) as day_14, 
	(isnull(pre.day_15,0)-isnull(nxt.day_15,0)) as day_15,
	(isnull(pre.day_16,0)-isnull(nxt.day_16,0)) as day_16, 
	(isnull(pre.day_17,0)-isnull(nxt.day_17,0)) as day_17, 
	(isnull(pre.day_18,0)-isnull(nxt.day_18,0)) as day_18, 
	(isnull(pre.day_19,0)-isnull(nxt.day_19,0)) as day_19, 
	(isnull(pre.day_20,0)-isnull(nxt.day_20,0)) as day_20, 
	(isnull(pre.day_21,0)-isnull(nxt.day_21,0)) as day_21, 
	(isnull(pre.day_22,0)-isnull(nxt.day_22,0)) as day_22,
	(isnull(pre.day_23,0)-isnull(nxt.day_23,0)) as day_23, 
	(isnull(pre.day_24,0)-isnull(nxt.day_24,0)) as day_24, 
	(isnull(pre.day_25,0)-isnull(nxt.day_25,0)) as day_25, 
	(isnull(pre.day_26,0)-isnull(nxt.day_26,0)) as day_26, 
	(isnull(pre.day_27,0)-isnull(nxt.day_27,0)) as day_27, 
	(isnull(pre.day_28,0)-isnull(nxt.day_28,0)) as day_28, 
	(isnull(pre.day_29,0)-isnull(nxt.day_29,0)) as day_29, 
	(isnull(pre.day_30,0)-isnull(nxt.day_30,0)) as day_30, 
	(isnull(pre.day_31,0)-isnull(nxt.day_31,0))as day_31,   
	0 as total, 2 as ordr
	from (select Shift
			,group_name
			,position_id 
			,position
			,day_1
			,day_2
			,day_3
			,day_4
			,day_5
			,day_6
			,day_7
			,day_8
			,day_9
			,day_10
			,day_11
			,day_12
			,day_13
			,day_14
			,day_15
			,day_16
			,day_17
			,day_18
			,day_19
			,day_20
			,day_21
			,day_22
			,day_23
			,day_24
			,day_25
			,day_26
			,day_27
			,day_28
			,day_29
			,day_30
			,day_31
		from #prp_poc_planned_final where ordr=0) pre
		join (select Shift
			,group_name
			,position_id 
			,position
			,day_1
			,day_2
			,day_3
			,day_4
			,day_5
			,day_6
			,day_7
			,day_8
			,day_9
			,day_10
			,day_11
			,day_12
			,day_13
			,day_14
			,day_15
			,day_16
			,day_17
			,day_18
			,day_19
			,day_20
			,day_21
			,day_22
			,day_23
			,day_24
			,day_25
			,day_26
			,day_27
			,day_28
			,day_29
			,day_30
			,day_31
		from #prp_poc_planned_final a where ordr=1
		and EXISTS (select 1 from #prp_poc_planned_final b where a.fac_id=b.fac_id and a.shift=b.shift and a.position_id=b.position_id and b.ordr=0)) nxt
		on pre.position=nxt.position
		and pre.shift=nxt.shift;
			

	insert INTO #prp_poc_planned_final
		select pocplan.fac_id,pocplan.Shift,pocplan.group_name,pocplan.position_id, pocplan.position,'Planned FTEs' as hour_type,
			(pocplan.day_1/pt.hours) as day_1,
			(pocplan.day_2/pt.hours) as day_2,
			(pocplan.day_3/pt.hours) as day_3,
			(pocplan.day_4/pt.hours) as day_4,
			(pocplan.day_5/pt.hours) as day_5,
			(pocplan.day_6/pt.hours) as day_6,
			(pocplan.day_7/pt.hours) as day_7,
			(pocplan.day_8/pt.hours) as day_8,
			(pocplan.day_9/pt.hours) as day_9,
			(pocplan.day_10/pt.hours) as day_10,
			(pocplan.day_11/pt.hours) as day_11,
			(pocplan.day_12/pt.hours) as day_12,
			(pocplan.day_13/pt.hours) as day_13,
			(pocplan.day_14/pt.hours) as day_14,
			(pocplan.day_15/pt.hours) as day_15,
			(pocplan.day_16/pt.hours) as day_16,
			(pocplan.day_17/pt.hours) as day_17,
			(pocplan.day_18/pt.hours) as day_18,
			(pocplan.day_19/pt.hours) as day_19,
			(pocplan.day_20/pt.hours) as day_20,
			(pocplan.day_21/pt.hours) as day_21,
			(pocplan.day_22/pt.hours) as day_22,
			(pocplan.day_23/pt.hours) as day_23,
			(pocplan.day_24/pt.hours) as day_24,
			(pocplan.day_25/pt.hours) as day_25,
			(pocplan.day_26/pt.hours) as day_26,
			(pocplan.day_27/pt.hours) as day_27,
			(pocplan.day_28/pt.hours) as day_28,
			(pocplan.day_29/pt.hours) as day_29,
			(pocplan.day_30/pt.hours) as day_30,
			(pocplan.day_31/pt.hours) as day_31,
			0 as Total, 3 as ordr
		from #prp_poc_planned_final pocplan
		inner JOIN #PRP_Position_Times pt on pocplan.position_id=pt.position_id and pocplan.ordr=0


	insert INTO #prp_poc_planned_final
		select pocplan.fac_id,pocplan.Shift,pocplan.group_name,pocplan.position_id, pocplan.position,'Actual FTEs' as hour_type,
			(pocplan.day_1/pt.hours) as day_1,
			(pocplan.day_2/pt.hours) as day_2,
			(pocplan.day_3/pt.hours) as day_3,
			(pocplan.day_4/pt.hours) as day_4,
			(pocplan.day_5/pt.hours) as day_5,
			(pocplan.day_6/pt.hours) as day_6,
			(pocplan.day_7/pt.hours) as day_7,
			(pocplan.day_8/pt.hours) as day_8,
			(pocplan.day_9/pt.hours) as day_9,
			(pocplan.day_10/pt.hours) as day_10,
			(pocplan.day_11/pt.hours) as day_11,
			(pocplan.day_12/pt.hours) as day_12,
			(pocplan.day_13/pt.hours) as day_13,
			(pocplan.day_14/pt.hours) as day_14,
			(pocplan.day_15/pt.hours) as day_15,
			(pocplan.day_16/pt.hours) as day_16,
			(pocplan.day_17/pt.hours) as day_17,
			(pocplan.day_18/pt.hours) as day_18,
			(pocplan.day_19/pt.hours) as day_19,
			(pocplan.day_20/pt.hours) as day_20,
			(pocplan.day_21/pt.hours) as day_21,
			(pocplan.day_22/pt.hours) as day_22,
			(pocplan.day_23/pt.hours) as day_23,
			(pocplan.day_24/pt.hours) as day_24,
			(pocplan.day_25/pt.hours) as day_25,
			(pocplan.day_26/pt.hours) as day_26,
			(pocplan.day_27/pt.hours) as day_27,
			(pocplan.day_28/pt.hours) as day_28,
			(pocplan.day_29/pt.hours) as day_29,
			(pocplan.day_30/pt.hours) as day_30,
			(pocplan.day_31/pt.hours) as day_31,
			0 as Total, 4 as ordr
		from #prp_poc_planned_final pocplan
		inner JOIN #PRP_Position_Times pt on pocplan.position_id=pt.position_id and pocplan.ordr=1
	ORDER BY 1,2


INSERT INTO #prp_poc_planned_final
select @vFacId,
	pre.Shift,pre.group_name,pre.position_id,pre.position,'FTEs: Planned '+CHAR(45)+' Actual = ' as hour_type,
	(isnull(pre.day_1,0)-isnull(nxt.day_1,0)) as day_1,
	(isnull(pre.day_2,0)-isnull(nxt.day_2,0)) as day_2, 
	(isnull(pre.day_3,0)-isnull(nxt.day_3,0)) as day_3, 
	(isnull(pre.day_4,0)-isnull(nxt.day_4,0)) as day_4, 
	(isnull(pre.day_5,0)-isnull(nxt.day_5,0)) as day_5, 
	(isnull(pre.day_6,0)-isnull(nxt.day_6,0)) as day_6, 
	(isnull(pre.day_7,0)-isnull(nxt.day_7,0)) as day_7,
	(isnull(pre.day_8,0)-isnull(nxt.day_8,0)) as day_8,
	(isnull(pre.day_9,0)-isnull(nxt.day_9,0)) as day_9, 
	(isnull(pre.day_10,0)-isnull(nxt.day_10,0)) as day_10, 
	(isnull(pre.day_11,0)-isnull(nxt.day_11,0)) as day_11, 
	(isnull(pre.day_12,0)-isnull(nxt.day_12,0)) as day_12, 
	(isnull(pre.day_13,0)-isnull(nxt.day_13,0)) as day_13, 
	(isnull(pre.day_14,0)-isnull(nxt.day_14,0)) as day_14, 
	(isnull(pre.day_15,0)-isnull(nxt.day_15,0)) as day_15,
	(isnull(pre.day_16,0)-isnull(nxt.day_16,0)) as day_16, 
	(isnull(pre.day_17,0)-isnull(nxt.day_17,0)) as day_17, 
	(isnull(pre.day_18,0)-isnull(nxt.day_18,0)) as day_18, 
	(isnull(pre.day_19,0)-isnull(nxt.day_19,0)) as day_19, 
	(isnull(pre.day_20,0)-isnull(nxt.day_20,0)) as day_20, 
	(isnull(pre.day_21,0)-isnull(nxt.day_21,0)) as day_21, 
	(isnull(pre.day_22,0)-isnull(nxt.day_22,0)) as day_22,
	(isnull(pre.day_23,0)-isnull(nxt.day_23,0)) as day_23, 
	(isnull(pre.day_24,0)-isnull(nxt.day_24,0)) as day_24, 
	(isnull(pre.day_25,0)-isnull(nxt.day_25,0)) as day_25, 
	(isnull(pre.day_26,0)-isnull(nxt.day_26,0)) as day_26, 
	(isnull(pre.day_27,0)-isnull(nxt.day_27,0)) as day_27, 
	(isnull(pre.day_28,0)-isnull(nxt.day_28,0)) as day_28, 
	(isnull(pre.day_29,0)-isnull(nxt.day_29,0)) as day_29, 
	(isnull(pre.day_30,0)-isnull(nxt.day_30,0)) as day_30, 
	(isnull(pre.day_31,0)-isnull(nxt.day_31,0))as day_31,   
	0 as total, 5 as ordr
	from (select Shift
			,group_name
			,position_id 
			,position
			,day_1
			,day_2
			,day_3
			,day_4
			,day_5
			,day_6
			,day_7
			,day_8
			,day_9
			,day_10
			,day_11
			,day_12
			,day_13
			,day_14
			,day_15
			,day_16
			,day_17
			,day_18
			,day_19
			,day_20
			,day_21
			,day_22
			,day_23
			,day_24
			,day_25
			,day_26
			,day_27
			,day_28
			,day_29
			,day_30
			,day_31
		from #prp_poc_planned_final where ordr=3) pre
		join (select Shift
			,group_name
			,position_id 
			,position
			,day_1
			,day_2
			,day_3
			,day_4
			,day_5
			,day_6
			,day_7
			,day_8
			,day_9
			,day_10
			,day_11
			,day_12
			,day_13
			,day_14
			,day_15
			,day_16
			,day_17
			,day_18
			,day_19
			,day_20
			,day_21
			,day_22
			,day_23
			,day_24
			,day_25
			,day_26
			,day_27
			,day_28
			,day_29
			,day_30
			,day_31
		from #prp_poc_planned_final a where ordr=4
		and EXISTS (select 1 from #prp_poc_planned_final b where a.fac_id=b.fac_id and a.shift=b.shift and a.position_id=b.position_id and b.ordr=0)) nxt
		on pre.position=nxt.position
		and pre.shift=nxt.shift;
		


	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	Set @vgs_fill_end_time  = getdate() ; -- fill end time

	select @vStep = 70
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' updating pivoted table ' + convert(varchar(26),getdate(),109)

	update #prp_poc_planned_final SET 
		day_1 = case when hour_type like '%FTEs%' then ISNULL(day_1, 0)/60 else ISNULL(day_1, 0) end 
		,day_2 = case when hour_type like '%FTEs%' then ISNULL(day_2, 0)/60 else ISNULL(day_2, 0) end 
		,day_3 = case when hour_type like '%FTEs%' then ISNULL(day_3, 0)/60 else ISNULL(day_3, 0) end 
		,day_4 = case when hour_type like '%FTEs%' then ISNULL(day_4, 0)/60 else ISNULL(day_4, 0) end 
		,day_5 = case when hour_type like '%FTEs%' then ISNULL(day_5, 0)/60 else ISNULL(day_5, 0) end 
		,day_6 = case when hour_type like '%FTEs%' then ISNULL(day_6, 0)/60 else ISNULL(day_6, 0) end 
		,day_7 = case when hour_type like '%FTEs%' then ISNULL(day_7, 0)/60 else ISNULL(day_7, 0) end 
		,day_8 = case when hour_type like '%FTEs%' then ISNULL(day_8, 0)/60 else ISNULL(day_8, 0) end 
		,day_9 = case when hour_type like '%FTEs%' then ISNULL(day_9, 0)/60 else ISNULL(day_9, 0) end 
		,day_10 = case when hour_type like '%FTEs%' then ISNULL(day_10, 0)/60 else ISNULL(day_10, 0) end 
		,day_11 = case when hour_type like '%FTEs%' then ISNULL(day_11, 0)/60 else ISNULL(day_11, 0) end 
		,day_12 = case when hour_type like '%FTEs%' then ISNULL(day_12, 0)/60 else ISNULL(day_12, 0) end 
		,day_13 = case when hour_type like '%FTEs%' then ISNULL(day_13, 0)/60 else ISNULL(day_13, 0) end 
		,day_14 = case when hour_type like '%FTEs%' then ISNULL(day_14, 0)/60 else ISNULL(day_14, 0) end 
		,day_15 = case when hour_type like '%FTEs%' then ISNULL(day_15, 0)/60 else ISNULL(day_15, 0) end 
		,day_16 = case when hour_type like '%FTEs%' then ISNULL(day_16, 0)/60 else ISNULL(day_16, 0) end 
		,day_17 = case when hour_type like '%FTEs%' then ISNULL(day_17, 0)/60 else ISNULL(day_17, 0) end 
		,day_18 = case when hour_type like '%FTEs%' then ISNULL(day_18, 0)/60 else ISNULL(day_18, 0) end 
		,day_19 = case when hour_type like '%FTEs%' then ISNULL(day_19, 0)/60 else ISNULL(day_19, 0) end 
		,day_20 = case when hour_type like '%FTEs%' then ISNULL(day_20, 0)/60 else ISNULL(day_20, 0) end 
		,day_21 = case when hour_type like '%FTEs%' then ISNULL(day_21, 0)/60 else ISNULL(day_21, 0) end 
		,day_22 = case when hour_type like '%FTEs%' then ISNULL(day_22, 0)/60 else ISNULL(day_22, 0) end 
		,day_23 = case when hour_type like '%FTEs%' then ISNULL(day_23, 0)/60 else ISNULL(day_23, 0) end 
		,day_24 = case when hour_type like '%FTEs%' then ISNULL(day_24, 0)/60 else ISNULL(day_24, 0) end 
		,day_25 = case when hour_type like '%FTEs%' then ISNULL(day_25, 0)/60 else ISNULL(day_25, 0) end 
		,day_26 = case when hour_type like '%FTEs%' then ISNULL(day_26, 0)/60 else ISNULL(day_26, 0) end 
		,day_27 = case when hour_type like '%FTEs%' then ISNULL(day_27, 0)/60 else ISNULL(day_27, 0) end 
		,day_28 = case when hour_type like '%FTEs%' then ISNULL(day_28, 0)/60 else ISNULL(day_28, 0) end 
		,day_29 = case when hour_type like '%FTEs%' then ISNULL(day_29, 0)/60 else ISNULL(day_29, 0) end 
		,day_30 = case when hour_type like '%FTEs%' then ISNULL(day_30, 0)/60 else ISNULL(day_30, 0) end 
		,day_31 = case when hour_type like '%FTEs%' then ISNULL(day_31, 0)/60 else ISNULL(day_31, 0) end 

	update #prp_poc_planned_final SET total= (day_1 + day_2 + day_3 + day_4 + day_5 + day_6 + day_7 + day_8 + day_9 + day_10 + day_11 + day_12
		+ day_13 + day_14 + day_15 + day_16 + day_17 + day_18 + day_19 + day_20 + day_21 + day_22 + day_23 + day_24 + day_25 + day_26
		+ day_27 + day_28 + day_29 + day_30 + day_31)

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	Set @vgs_fill_end_time  = getdate() ; -- fill end time

	select @vStep = 90
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' returning final result ' + convert(varchar(26),getdate(),109)
	--*********************************************************************************************************
--- final select
delete from #prp_poc_planned_final where position ='Unknown' and ordr in (0,2)
 

	--select fac_id,Shift,Group_name,position as discipline,hour_type
	--,day_1,day_2,day_3,day_4,day_5,day_6,day_7,day_8,day_9,day_10
	--,day_11,day_12,day_13,day_14,day_15,day_16,day_17,day_18,day_19,day_20,day_21,day_22
	--,day_23,day_24,day_25,day_26,day_27,day_28,day_29,day_30,day_31,total,@status_code as status_code, @status_text as status_text
	--from #prp_poc_planned_final
	--order BY shift,position,ordr

	select fac_id,Shift,Group_name,position as discipline,hour_type
	,CASE WHEN sum(day_1) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_1) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_1)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_1)), 0), 114) END as day_1
	,CASE WHEN sum(day_2) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_2) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_2)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_2)), 0), 114) END as day_2
	,CASE WHEN sum(day_3) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_3) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_3)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_3)), 0), 114) END as day_3
	,CASE WHEN sum(day_4) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_4) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_4)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_4)), 0), 114) END as day_4
	,CASE WHEN sum(day_5) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_5) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_5)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_5)), 0), 114) END as day_5
	,CASE WHEN sum(day_6) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_6) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_6)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_6)), 0), 114) END as day_6
	,CASE WHEN sum(day_7) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_7) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_7)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_7)), 0), 114) END as day_7
	,CASE WHEN sum(day_8) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_8) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_8)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_8)), 0), 114) END as day_8
	,CASE WHEN sum(day_9) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_9) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_9)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_9)), 0), 114) END as day_9
	,CASE WHEN sum(day_10) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_10) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_10)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_10)), 0), 114) END as day_10
	,CASE WHEN sum(day_11) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_11) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_11)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_11)), 0), 114) END as day_11
	,CASE WHEN sum(day_12) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_12) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_12)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_12)), 0), 114) END as day_12
	,CASE WHEN sum(day_13) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_13) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_13)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_13)), 0), 114) END as day_13
	,CASE WHEN sum(day_14) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_14) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_14)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_14)), 0), 114) END as day_14
	,CASE WHEN sum(day_15) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_15) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_15)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_15)), 0), 114) END as day_15
	,CASE WHEN sum(day_16) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_16) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_16)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_16)), 0), 114) END as day_16
	,CASE WHEN sum(day_17) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_17) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_17)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_17)), 0), 114) END as day_17
	,CASE WHEN sum(day_18) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_18) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_18)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_18)), 0), 114) END as day_18
	,CASE WHEN sum(day_19) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_19) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_19)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_19)), 0), 114) END as day_19
	,CASE WHEN sum(day_20) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_20) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_20)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_20)), 0), 114) END as day_20
	,CASE WHEN sum(day_21) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_21) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_21)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_21)), 0), 114) END as day_21
	,CASE WHEN sum(day_22) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_22) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_22)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_22)), 0), 114) END as day_22
	,CASE WHEN sum(day_23) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_23) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_23)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_23)), 0), 114) END as day_23
	,CASE WHEN sum(day_24) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_24) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_24)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_24)), 0), 114) END as day_24
	,CASE WHEN sum(day_25) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_25) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_25)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_25)), 0), 114) END as day_25
	,CASE WHEN sum(day_26) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_26) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_26)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_26)), 0), 114) END as day_26
	,CASE WHEN sum(day_27) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_27) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_27)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_27)), 0), 114) END as day_27
	,CASE WHEN sum(day_28) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_28) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_28)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_28)), 0), 114) END as day_28
	,CASE WHEN sum(day_29) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_29) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_29)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_29)), 0), 114) END as day_29
	,CASE WHEN sum(day_30) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_30) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_30)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_30)), 0), 114) END as day_30
	,CASE WHEN sum(day_31) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(day_31) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(day_31)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(day_31)), 0), 114) END as day_31
	,CASE WHEN sum(Total) < 0 THEN '-' ELSE CASE WHEN hour_type like 'Planned - Actual %' AND sum(Total) > 0 THEN '+' ELSE '' END END 
			+ CASE WHEN hour_type like '%FTEs%' THEN CONVERT(varchar(5), sum(Total)) ELSE CONVERT(varchar(5), DATEADD(minute, abs(sum(Total)), 0), 114) END as Total
	, @status_code as status_code, @status_text as status_text	
	from
	#prp_poc_planned_final
	group BY fac_id,Shift,Group_name,position,hour_type,ordr
	order BY shift,position,ordr

	Set @rows_returned = @@ROWCOUNT;

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	if @debug_me='Y' Print 'Successful execution of stored procedure ' + Object_name(@@ProcID) + convert(varchar(26),getdate(),109);

END TRY 

BEGIN CATCH 
	if @status_code = 0 Set @Status_Code = 1 else set @status_code = 2  --- convert 3 to 2
	if @status_code = 1
	BEGIN
		select @Status_Text = Rtrim(Left('Stored Procedure Failed with error Code : ' +   Cast(@@error as Varchar(10)) +  ' Line Number : ' +  Cast(ERROR_LINE() as Varchar(5)) + ' ' +  ERROR_MESSAGE(),3000))

		if @debug_me='Y' Print 'Stored procedure failure in step:'+ convert(varchar(3),@vstep) + '	' + convert(varchar(26),getdate())
		if @debug_me='Y' Print 'Error code: '+convert(varchar(3),@vStep) + '; Error description:	' + @Status_Text
	END 

	Select 
		NULL as fac_id
		, NULL as Shift
		, NULL as Group_name
		, NULL as discipline
		, NULL as hour_type
		, NULL as day_1
		, NULL as day_2
		, NULL as day_3
		, NULL as day_4
		, NULL as day_5
		, NULL as day_6
		, NULL as day_7
		, NULL as day_8
		, NULL as day_9
		, NULL as day_10
		, NULL as day_11
		, NULL as day_12
		, NULL as day_13
		, NULL as day_14
		, NULL as day_15
		, NULL as day_16
		, NULL as day_17
		, NULL as day_18
		, NULL as day_19
		, NULL as day_20
		, NULL as day_21
		, NULL as day_22
		, NULL as day_23
		, NULL as day_24
		, NULL as day_25
		, NULL as day_26
		, NULL as day_27
		, NULL as day_28
		, NULL as day_29
		, NULL as day_30
		, NULL as day_31 
		, NULL as Total
		, @status_code as status_code
		, @status_text as status_text
		
END CATCH 

RETURN 

END
GO
GRANT EXECUTE ON  dbo.sproc_prp_rl_poc_planned_actual_service_time_monthly   to PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_prp_rl_poc_planned_actual_service_time_monthly.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_poc_planned_actual_service_time_monthly.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_poc_planned_actual_service_time_Task_client.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- PCC-55481       :   script to create sproc_prp_rl_poc_planned_actual_service_time_Task_client Procedure  
--						-- 
-- Written By:          Henny Ehghaghi
-- Reviewed By:         
-- 
-- Script Type:         DDL 
-- Target DB Type:      Client
-- Target ENVIRONMENT:  BOTH (US/CA) 
-- 
-- 
-- Re-Runable:          YES 
-- 
-- Description of Script : Create sproc_prp_rl_poc_planned_actual_service_time_Task_client Procedure for Service Tracking reporting
-- 
-- Special Instruction: 

-- 
-- =================================================================================

/***********************************************************************************
Revision History:
2014-03-25  Henny Ehghaghi	PCC-56339	3.7.3.2 
2014-04-07  Henny Ehghaghi	PCC-56251	3.7.4 Assigne Alias name before all column names 
2014-05-20  Henny Ehghaghi  PCC-57972   3.7.4.1 Fixing Shift descreption (when start or end time is zero)
2018-04-30	Rolly Sanchez	CORE-2578	3.7.15.3	Stored Proc throws an error when task description is more than 254 chars

***********************************************************************************/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_prp_rl_poc_planned_actual_service_time_Task_client' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE dbo.sproc_prp_rl_poc_planned_actual_service_time_Task_client
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO



Create Procedure dbo.sproc_prp_rl_poc_planned_actual_service_time_Task_client
 @fac_id int
, @client_id int = -1
, @include_unscheduled char(1) = 'N'
, @include_prn char(1) = 'N'
, @month_week varchar(20)
, @execution_user_login varchar(60)
, @rows_returned int out
, @debug_me char(1)  = 'N'
, @status_code int  out 
, @status_text varchar(3000) out
/********************************************************************************
			   
Declare  @rows_ret int		,@statuscode int		,@statustext varchar(3000)
exec dbo.sproc_prp_rl_poc_planned_actual_service_time_Task_client
@fac_id =  '1'
,@client_id = '-1'
,@include_unscheduled  = 'Y'
, @include_prn = 'Y'
,@month_week='1;2014,2'
,@execution_user_login =  'pcc-moorer'
,@rows_returned = null
,@debug_me = 'N'
,@status_code = null
,@status_text = null

**********************************************************************************/

AS
BEGIN


SET NOCOUNT ON;
--declare Standard local variables required for any store proc
DECLARE @vStep        INT, 
        @vErr         VARCHAR(max), 
        @vdelim       CHAR(1), 
        @vCharNewLine CHAR(2), 
        @vSeparator   CHAR(6), 
        @vSeparator2  CHAR(6), 
        @vReportDate  DATETIME, 
        @vRowCount    INT;

--Facility Related variables, also used in capturing execution Statistics 
DECLARE @vFacIDs VARCHAR(max);
DECLARE @vFacWarningMsg VARCHAR(max); --- to know whether it the returned list is restricted
 

----Local Variables

DECLARE @vFacId              INT, 
        @vFacName            VARCHAR(500), 
        @vFacAddress         VARCHAR(max), 
        @vRegId              INT, 
        @vWeekDate           DATETIME, 
        @vClientId           INT, 
        @vIncludeUnscheduled CHAR(1), 
        @vSortBy             VARCHAR(50), 
        @Vmonth              VARCHAR(20), 
        @vStartDate          DATETIME, 
        @vEndDate            DATETIME, 
        @vshift              INT, 
        @vstatus             INT, 
        @vType               INT,
        @vMonth_Week         VARCHAR(250),
		@vIncludePRN CHAR(1),
		@vIncludePRNbit BIT;  

-----Governor and Statistics Variables 
DECLARE @vgs_program_name    VARCHAR(200), 
        @vgs_start_time      DATETIME, 
        @vgs_execution_user  VARCHAR(60), 
        @vgs_fill_end_time   DATETIME, 
        @vGeneric_statuscode INT, 
        @vGeneric_statustext VARCHAR(3000), 
        @vgsStepStartTime    DATETIME, 
        @vgsStepEndTime      DATETIME  

CREATE TABLE #prp_shifts 
  ( 
     shift_id    INT, 
     shift_name  VARCHAR(50), 
     start_time  INT, 
     end_time    INT, 
     group_name  VARCHAR(15), 
     position_id INT ,
     flg int
  );  
  
CREATE TABLE #prp_shift_link 
  ( 
     shift_id    INT, 
     shift_name  VARCHAR(50), 
     start_time  INT, 
     end_time    INT, 
     group_name  VARCHAR(15), 
     position_id INT 
  ); 

CREATE TABLE #prp_poc_details 
  ( 
     id_key                         VARCHAR(20), 
     first_name                     VARCHAR(50), 
     last_name                      VARCHAR(50), 
     bed_id                         INT, 
     bed_desc                       VARCHAR(30), 
     discharge_date                 DATETIME, 
     client_id_number               VARCHAR(35), 
     photo_small                    VARCHAR(55), 
     room_desc                      VARCHAR(60), 
     unit_id                        INT, 
     unit_desc                      VARCHAR(35), 
     admission_date                 DATETIME, 
     client_id                      INT, 
     effective_date                 DATETIME, 
     ineffective_date               DATETIME, 
     current_row                    VARCHAR(1), 
     intervention_desc              VARCHAR(2000), 
     date_initiated                 DATETIME, 
     std_intervention_id            INT, 
     require_time_tracking          BIT, 
     baseline_time                  SMALLINT, 
     intervention_id                INT, 
     schedule_id                    INT, 
     schedule_type                  INT, 
     std_shift_ids                  VARCHAR(500), 
     start_time                     VARCHAR(4), 
     end_time                       VARCHAR(4), 
     xxminutes                      INT, 
     fac_id                         INT, 
     date_of_month                  INT, 
     schedule_detail_id             VARCHAR(100), 
     std_shift_id                   INT, 
     shift_date                     DATETIME, 
     schedule_date                  DATETIME, 
     schedule_time                  INT, 
     schedule_end_date              DATETIME, 
     documentation_id               VARCHAR(100), 
     completed_date                 DATETIME, 
     strikeout_date                 DATETIME, 
     entered_date                   DATETIME, 
     task_time                      SMALLINT, 
     cp_sec_user_audit_id           INT, 
     struckout_cp_sec_user_audit_id INT 
  ); 

CREATE TABLE #prp_poc_planned_monthly 
  ( 
     fac_id      INT, 
     client_id   INT, 
     client_name VARCHAR(250), 
     shift       VARCHAR(50), 
     group_name  VARCHAR(15),
     position_id INT,
     position    VARCHAR(254), 
     task_id INT, 
     task    VARCHAR(2000), 
     hour_type   VARCHAR (60), 
     day_1       DECIMAL(8, 2) DEFAULT 0, 
     day_2       DECIMAL(8, 2) DEFAULT 0, 
     day_3       DECIMAL(8, 2) DEFAULT 0, 
     day_4       DECIMAL(8, 2) DEFAULT 0, 
     day_5       DECIMAL(8, 2) DEFAULT 0, 
     day_6       DECIMAL(8, 2) DEFAULT 0, 
     day_7       DECIMAL(8, 2) DEFAULT 0, 
     day_8       DECIMAL(8, 2) DEFAULT 0, 
     day_9       DECIMAL(8, 2) DEFAULT 0, 
     day_10      DECIMAL(8, 2) DEFAULT 0, 
     day_11      DECIMAL(8, 2) DEFAULT 0, 
     day_12      DECIMAL(8, 2) DEFAULT 0, 
     day_13      DECIMAL(8, 2) DEFAULT 0, 
     day_14      DECIMAL(8, 2) DEFAULT 0, 
     day_15      DECIMAL(8, 2) DEFAULT 0, 
     day_16      DECIMAL(8, 2) DEFAULT 0, 
     day_17      DECIMAL(8, 2) DEFAULT 0, 
     day_18      DECIMAL(8, 2) DEFAULT 0, 
     day_19      DECIMAL(8, 2) DEFAULT 0, 
     day_20      DECIMAL(8, 2) DEFAULT 0, 
     day_21      DECIMAL(8, 2) DEFAULT 0, 
     day_22      DECIMAL(8, 2) DEFAULT 0, 
     day_23      DECIMAL(8, 2) DEFAULT 0, 
     day_24      DECIMAL(8, 2) DEFAULT 0, 
     day_25      DECIMAL(8, 2) DEFAULT 0, 
     day_26      DECIMAL(8, 2) DEFAULT 0, 
     day_27      DECIMAL(8, 2) DEFAULT 0, 
     day_28      DECIMAL(8, 2) DEFAULT 0, 
     day_29      DECIMAL(8, 2) DEFAULT 0, 
     day_30      DECIMAL(8, 2) DEFAULT 0, 
     day_31      DECIMAL(8, 2) DEFAULT 0, 
     total       DECIMAL(20, 2) DEFAULT 0, 
     ordr        TINYINT 
  ); 

CREATE TABLE #prp_poc_planned_final_monthly 
  ( 
     fac_id      INT, 
     client_id   INT, 
     client_name VARCHAR(250), 
     shift       VARCHAR(50), 
     group_name  VARCHAR(15), 
     position_id INT,
     position varchar(254),
     task_id INT, 
     task    VARCHAR(2000), 
     hour_type   VARCHAR (60), 
     day_1       DECIMAL(8, 2) DEFAULT 0, 
     day_2       DECIMAL(8, 2) DEFAULT 0, 
     day_3       DECIMAL(8, 2) DEFAULT 0, 
     day_4       DECIMAL(8, 2) DEFAULT 0, 
     day_5       DECIMAL(8, 2) DEFAULT 0, 
     day_6       DECIMAL(8, 2) DEFAULT 0, 
     day_7       DECIMAL(8, 2) DEFAULT 0, 
     day_8       DECIMAL(8, 2) DEFAULT 0, 
     day_9       DECIMAL(8, 2) DEFAULT 0, 
     day_10      DECIMAL(8, 2) DEFAULT 0, 
     day_11      DECIMAL(8, 2) DEFAULT 0, 
     day_12      DECIMAL(8, 2) DEFAULT 0, 
     day_13      DECIMAL(8, 2) DEFAULT 0, 
     day_14      DECIMAL(8, 2) DEFAULT 0, 
     day_15      DECIMAL(8, 2) DEFAULT 0, 
     day_16      DECIMAL(8, 2) DEFAULT 0, 
     day_17      DECIMAL(8, 2) DEFAULT 0, 
     day_18      DECIMAL(8, 2) DEFAULT 0, 
     day_19      DECIMAL(8, 2) DEFAULT 0, 
     day_20      DECIMAL(8, 2) DEFAULT 0, 
     day_21      DECIMAL(8, 2) DEFAULT 0, 
     day_22      DECIMAL(8, 2) DEFAULT 0, 
     day_23      DECIMAL(8, 2) DEFAULT 0, 
     day_24      DECIMAL(8, 2) DEFAULT 0, 
     day_25      DECIMAL(8, 2) DEFAULT 0, 
     day_26      DECIMAL(8, 2) DEFAULT 0, 
     day_27      DECIMAL(8, 2) DEFAULT 0, 
     day_28      DECIMAL(8, 2) DEFAULT 0, 
     day_29      DECIMAL(8, 2) DEFAULT 0, 
     day_30      DECIMAL(8, 2) DEFAULT 0, 
     day_31      DECIMAL(8, 2) DEFAULT 0, 
     total       DECIMAL(20, 2) DEFAULT 0, 
     ordr        TINYINT 
  ); 
  
  CREATE TABLE #prp_poc_planned( 
		  fac_id int
		, client_id int
		, client_name varchar(250)
		, shift varchar(50)
		, group_name varchar(15) 
		, position_id int
		, position varchar(254)
		, task_id INT 
        , task    VARCHAR(2000)
		, hour_type varchar (60)
		, sunday decimal(8,2) default 0
		, monday decimal(8,2) default 0
		, tuesday decimal(8,2) default 0
		, wednesday decimal(8,2) default 0
		, thursday decimal(8,2) default 0
		, friday decimal(8,2) default 0
		, saturday decimal(8,2) default 0
		, total decimal(10,2) default 0
		, ordr tinyint
);

CREATE TABLE #prp_poc_planned_final( 
		  fac_id int
		, client_id int
		, client_name varchar(250)
		, shift varchar(50)
		, group_name varchar(15) 
		, position_id int
		, position varchar(254)
		, task_id INT 
        , task    VARCHAR(2000) 
		, hour_type varchar (60)
		, sunday decimal(8,2) default 0
		, monday decimal(8,2) default 0
		, tuesday decimal(8,2) default 0
		, wednesday decimal(8,2) default 0
		, thursday decimal(8,2) default 0
		, friday decimal(8,2) default 0
		, saturday decimal(8,2) default 0
		, total decimal(10,2) default 0
		, ordr tinyint
);

CREATE TABLE #rowdata  
  ( 
     id_key                       INT IDENTITY(1,1),
     schedule_detail_id           VARCHAR(250), 
     client_id                    INT, 
     client_name                  VARCHAR(max), 
     shift_id                     INT, 
     shift                        VARCHAR(max), 
     group_name                   VARCHAR(max), 
     service_tracking_position_id INT, 
     position_id                  INT, 
     position                     VARCHAR(max), 
     day_of_week                  INT, 
     total_minutes                INT, 
     timeflag                     INT, 
     completed_date               DATETIME, 
     schedule_date                DATETIME  ,
     std_intervention_id          INT,
     intervention_desc            VARCHAR(max) ,
     document_id                  VARCHAR(250),
     sFlag                        INT
     PRIMARY KEY (schedule_detail_id, timeflag, shift_id,id_key),
     UNIQUE CLUSTERED (schedule_date,completed_date,id_key) 
  ); 
  

DECLARE @day_week TABLE 
  ( 
     dw       INT IDENTITY(1, 1), 
     date_day DATETIME, 
     day_num  INT 
  );  
   
DECLARE @daylightStart DATETIME, 
        @daylightEnd   DATETIME  ;
        
BEGIN TRY

	Set @status_code = 0   ---- Status Code 0 = Success, 1 = Exception
	set @status_text = null;
	set @rows_returned = 0;
	Set @vgs_program_name  = Object_name(@@ProcID);  ---Current Store Proc Name
	Set @vgs_start_time = getdate();
	Set @vgs_execution_user = @execution_user_login;

	select @vStep = 0
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Executing store proc :  ' + @vgs_program_name  + convert(varchar(26),getdate(),109)

	--set Standard variables
	set @vdelim = ';'
	set @vCharNewLine  = char(10);
	set @vSeparator = 'ZYXWVU';
	set @vSeparator2 = 'UVWXYZ';

	----Parameter Sniffing - use local variables when they are used in a where clause
	SET @vFacID			        = @fac_id;
    SET @vMonth_Week            = @month_week;
    SET @vType                  = LEFT(@month_week,1);
    
    IF @vType=1 --Monthly
     BEGIN
      SET @Vmonth      = substring(@vMonth_Week,charindex(';',@vMonth_Week)+1,len(@vMonth_Week)) ;
      SET @vStartDate  = CAST(SUBSTRING(@Vmonth,1,CHARINDEX(',',@Vmonth)-1)+'-'+
                              SUBSTRING(@Vmonth,CHARINDEX(',',@Vmonth)+1,LEN(@Vmonth))+'-01' AS DATETIME);
      SET @vEndDate    =  CAST(CONVERT(VARCHAR(10),DATEADD(s,-1,DATEADD(mm, DATEDIFF(m,0,@vStartDate)+1,0)),12) AS DATETIME);
 	  SET @vEndDate	   = (select convert(datetime, convert(varchar(4), datepart(yyyy, @vEndDate))
							+ '-' + convert(varchar(2), datepart(MM, @vEndDate))
							+ '-' + convert(varchar(2), datepart(dd, @vEndDate))
							+ ' 23:59:59'));
							
	  SELECT @daylightStart=start_date,@daylightEnd=end_date
	  FROM day_light_savings_dates
	  WHERE datepart(yyyy,start_date )=left(@Vmonth,4);
    --select 11,@vPositionTimes
     END
    ELSE IF @vType=2 --Weekly
     BEGIN
      SET @vWeekDate	= substring(@vMonth_Week,charindex(';',@vMonth_Week)+1,len(@vMonth_Week)) ;
      SET @vStartDate	= @vWeekDate
	  SET @vEndDate		= dateadd(dd,6,@vStartDate)
	  SET @vEndDate		= (select convert(datetime, convert(varchar(4), datepart(yyyy, @vEndDate))
									+ '-' + convert(varchar(2), datepart(MM, @vEndDate))
									+ '-' + convert(varchar(2), datepart(dd, @vEndDate))
									+ ' 23:59:59'));
	  SELECT @daylightStart=start_date,@daylightEnd=end_date
	  FROM day_light_savings_dates
	  WHERE datepart(yyyy,start_date )=datepart(yyyy,@vWeekDate );
	  
	  
	   INSERT INTO @day_week 
        SELECT day_date, 
               day_num 
        FROM   date_dim 
        WHERE  day_date >= @vStartDate 
               AND day_date <= @vEndDate;  
	  
     END
     
	SET @vClientId				= @client_id;
	SET @vIncludeUnscheduled	= @include_unscheduled;
	SET @vIncludePRN	= ISNULL(@include_prn, 'N');
	SELECT @vIncludePRNbit = IIF(@vIncludePRN = 'N', 0, 1);
   	

   
    
     if @debug_me='Y' select @vStartDate startDate,@vEndDate endDate,DATEADD(dd,-(DAY(DATEADD(mm,1,@vEndDate))-1),DATEADD(mm,1,@vEndDate))

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep = 10
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Validating Input Parameters  ' +  convert(varchar(26),getdate(),109)

	----Validate all input parameters
	if (
		@fac_id is NULL 
		or @execution_user_login is null
		or @vMonth_Week is null
		)
	begin
		set @vErr = 'One or more of the following input parameters is invalid... '
					+ ' @fac_id=' + isnull(convert(varchar(10),@fac_id),'null/empty')
					+ ' @vMonth_Week=' + isnull(@Vmonth,'null/empty')
					+ ', @execution_user_login=' + isnull(@execution_user_login,'null/empty')
	
		RAISERROR (@vErr -- Message text
					   ,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
					   ,1 -- State
						);
	end

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	Select @vStep = 20;
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Getting user access fac list ' + convert(varchar(26),getdate(),109);

	Select @vFacIds = fac_id
		  ,@vFacWarningMsg = msg
	From  dbo.fn_prp_get_facility_access_list_delim(@vFacId ,@vgs_execution_user); ---filter the fac list with user access

	--facilities warnings
	if @vFacWarningMsg is NOT NULL --- NOT NULL stands for restricted facilities access warning message
	Begin
		Set @status_code = 2 ; ----Set it warning
		Set @status_text = isnull(@status_text,'') + @vFacWarningMsg ;
	End 

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	-------------------------------------------------------------
	-- Inserting records in temp table.
	-------------------------------------------------------------
	select @vStep = 30
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' getting raw data ' + convert(varchar(26),getdate(),109)

		insert INTO  #prp_poc_details 
		( id_key
		, first_name
		, last_name
		, bed_id
		, bed_desc
		, discharge_date
		, client_id_number
		, photo_small
		, room_desc
		, unit_id
		, unit_desc
		, admission_date
		, client_id
		, effective_date  
		, ineffective_date  
		, current_row
		, intervention_desc
		, date_initiated
		, std_intervention_id
		, require_time_tracking
		, baseline_time
		, intervention_id
		, schedule_id
		, schedule_type
		, std_shift_ids
		, start_time 
		, end_time 
		, xxminutes
		, fac_id
		, date_of_month 
		, schedule_detail_id
		, std_shift_id
		, shift_date 
		, schedule_date
		, schedule_end_date
		, documentation_id
		, completed_date
		, strikeout_date
		, entered_date
		, task_time
		, cp_sec_user_audit_id
		, struckout_cp_sec_user_audit_id
		)
	exec dbo.sproc_prp_pcc_poc_getScheduleDetails
	@vFacId,
	-1,--@vShiftId,--@shiftID_param int,
	-1,--@myPositionID_param int,
	-1,--@assignmentID_param int,
	-1,--@unitID_param int,
	-1,--@selectedPositionID_param int,
	@vStartDate,--'2014-01-26 00:00:00',--@shiftStartTime_param datetime,
	@vEndDate,--'2014-02-01 23:59:59'--@shiftEndTime_param datetime,
	NULL,--'7445,7455,7465',--@stdInts_param varchar(8000),
	@vClientId,--@clientID_param int,
	@vStartDate,--'2014-01-26 00:00:00',--@localStartTime_param datetime,
	@vEndDate,--'2014-02-01 23:59:59'--@localEndTime_param datetime,
	Null,--@max_details_param int = 2147483647,
	@vIncludePRNbit,--@include_prn_param bit = 1,
	'N',--@debug				char(1)  = 'N',
	Null,--@status_code		int	out,
	Null--@status_text		varchar(3000) out
	
	set @vRowCount = @@rowcount
		if  (@vRowCount = 0)
	begin
	 Set @status_code = 2
	 Set @status_text = isnull(@status_text,'') + 'No Data Found' ;
	 Raiserror( 'sproc_prp_pcc_poc_getScheduleDetails returned 0 rows.', 10, 1 );
	 
	 end
	 

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep = 31
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' DAY LIGHT SAVING DATE PROCESS ' + convert(varchar(26),getdate(),109)
-- DAY LIGHT SAVING DATE 
        update  a set
            schedule_date=case 
              when schedule_date= dateadd(hh,1,@daylightStart) then @daylightStart
              when schedule_date= dateadd(hh,-1,@daylightEnd) then @daylightEnd
             end   ,
            completed_date=case 
              when completed_date= dateadd(hh,1,@daylightStart) then  @daylightStart
              when completed_date= dateadd(hh,-1,@daylightEnd) then  @daylightEnd
              end 
        from #prp_poc_details a
         where schedule_date= dateadd(hh,1,@daylightStart) or schedule_date= dateadd(hh,-1,@daylightEnd)
         or completed_date= dateadd(hh,1,@daylightStart) or completed_date= dateadd(hh,-1,@daylightEnd)


	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	
 select @vStep = 32
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Filling Schedule Time  ' + convert(varchar(26),getdate(),109)

	update #prp_poc_details 
	        set schedule_time= case 
	                        when substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)='D'  and completed_date is not null THEN
	                        cast(replace(convert(varchar(5),dbo.fn_adjust_time_fac_time_zone(@vFacId,completed_date),108),':','') as int)
	                        else cast(replace(convert(varchar(5),dbo.fn_adjust_time_fac_time_zone (@vFacId ,schedule_date),108),':','') as int) end
		        ,
	        schedule_date =case 
	                        when substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)='D'  and completed_date is not null THEN
	                            completed_date
	                        else schedule_date end ;
	
	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
  select @vStep = 34
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' DELETING EXTRA SCHEDULE DATA BASE OF INEFFECTIVE DATE ' + convert(varchar(26),getdate(),109)
	
 	delete					        
    from #prp_poc_details
    where ineffective_date is not null
    and schedule_date>ineffective_date;


    delete from #prp_poc_details
    where ineffective_date is  null
    and schedule_date<effective_date;

 
 	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	CREATE  CLUSTERED INDEX _temp1_prppocdetails on #prp_poc_details(id_key,client_id,intervention_id,std_intervention_id,schedule_time)


--It's using for QSHIFT
select @vStep = 35
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' PREPARE SHIFT DATA  ' + convert(varchar(26),getdate(),109)


INSERT INTO #prp_shift_link( shift_id , shift_name , start_time , end_time , group_name , position_id )
	select distinct shift.std_shift_id,shift.description,
	shift.start_time,shift.end_time,'',0
	from dbo.cp_std_shift shift WITH (NOLOCK)
	WHERE
	shift.deleted='N' and (shift.fac_id=@vFacId or shift.fac_id=-1)


--It's using for Non-QSHIFT

INSERT INTO #prp_shifts (shift_id , shift_name, start_time , end_time , group_name, position_id , flg) 
	select distinct shift.std_shift_id,
	
		shift.description+' ('+
		case when left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end)) ='' then '0' ELSE

left((
		case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		,(case when LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2 <0 then 00 ELSE
LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2  end))
end 
		+':'+right(cast(start_time as int),2)+(case when cast(start_time as int)>1200 THEN ' PM' ELSE ' AM' END) 
		+' - ' +
		case when rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end))))='' then '0'
		else
		rtrim(ltrim(left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		,(case when LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 <0 then 00
		else LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2 end)))) end 
		+':'+right(cast(end_time as int),2)+(case when cast(end_time as int)>1200 THEN ' PM' ELSE ' AM' END) +')' shift_name,
		--shift.description+' ('+left((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END)
		--,(LEN((case when cast(start_time as int)>1200 THEN cast(start_time as int)-1200 ELSE cast(start_time as int) END))-2))
		--+':'+right(cast(start_time as int),2)+(case when cast(start_time as int)>1200 THEN ' PM' ELSE ' AM' END) +
		--' - ' +left((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END)
		--,(LEN((case when cast(end_time as int)>1200 THEN cast(end_time as int)-1200 ELSE cast(end_time as int) END))-2))
		--+':'+right(cast(end_time as int),2)+(case when cast(end_time as int)>1200 THEN ' PM' ELSE ' AM' END) +')' shift_name,
	shift.start_time,cast(shift.end_time as int) end_time,'' group_name, 0 position_id,
	case when shift.start_time - ( cast(shift.end_time as int)-1 )>0 then 1 else 0 end
	from  dbo.cp_std_shift shift WITH (NOLOCK) 
	WHERE
	shift.deleted='N' and (shift.fac_id=@vFacId or shift.fac_id=-1)



	CREATE  CLUSTERED INDEX _temp1_prpshifts on #prp_shifts(position_id,start_time,end_time)

	--if @debug_me='Y' select * from #prp_shifts order BY shift_name
		set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	select @vStep =40
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' loading and calculating pivoted table ' + convert(varchar(26),getdate(),109)

-------------------------------------------------------------
-- Row data for Planned Hours
-------------------------------------------------------------
--Qshift
INSERT INTO #rowdata 
            (schedule_detail_id, 
             client_id, 
             client_name,
             shift_id, 
             shift, 
             group_name, 
             position_id, 
             position, 
             day_of_week, 
             total_minutes, 
             timeflag, 
             completed_date,
             schedule_date,std_intervention_id , intervention_desc,document_id,sFlag) 
SELECT cpsd.schedule_detail_id, 
       cpsd.client_id, 
       cpsd.last_name + ', ' + cpsd.first_name + ' (' 
       + cpsd.client_id_number + ')'                      AS client_name,shift_id, 
       'Scheduled'                                        AS Shift, 
       ''                                                 AS group_name, 
       crr.service_tracking_position_id                AS position_id, 
       cc.item_description                                AS position, 
       Datepart(dd, cpsd.shift_date)                        AS day_of_week, 
       COALESCE(cpsd.baseline_time, cpstdi.baseline_time) AS total_minutes, 
       1, 
       cpsd.completed_date ,cpsd.shift_date as schedule_date,cpsd.std_intervention_id , cpsd.intervention_desc,cpsd.documentation_id,
       case when cpsd.strikeout_date is not null then 1 else 0 end sFlag
FROM   #prp_poc_details cpsd 
       inner join dbo.cp_rev_intervention crr  WITH (nolock) 
	   on crr.clientid=cpsd.client_id
       and crr.current_row='Y'
       and crr.gen_intervention_id=cpsd.intervention_id
       and crr.require_time_tracking = 1
       left JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
               ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                  AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.common_code cc WITH (nolock) 
               ON crr.service_tracking_position_id = cc.item_id 
       INNER JOIN #prp_shift_link shift WITH (nolock) 
               ON cpsd.std_shift_id = shift.shift_id 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       ;
	
	------------
	--Non-Qshift
INSERT INTO #rowdata 
            (schedule_detail_id, 
             client_id, 
             client_name,shift_id, 
             shift, 
             group_name, 
             position_id, 
             position, 
             day_of_week, 
             total_minutes, 
             timeflag, 
             completed_date,schedule_date,std_intervention_id , intervention_desc,document_id,sFlag) 
SELECT cpsd.schedule_detail_id, 
       cpsd.client_id, 
       cpsd.last_name + ', ' + cpsd.first_name + ' (' 
       + cpsd.client_id_number + ')'                      AS client_name,shift_id, 
       'Scheduled'                                        AS Shift, 
       ''                                                 AS group_name,
       case when isnull(cpstdi.require_time_tracking,0) = 1  then crr.service_tracking_position_id 
       when  isnull(cpstdi.require_time_tracking,0)=0 and isnull(crr.require_time_tracking,0)=1 then crr.service_tracking_position_id
       end  AS position_id,
 
       cc.item_description                                AS position, 
       Datepart(dd, cpsd.schedule_date)                        AS day_of_week, 
       COALESCE(cpsd.baseline_time, cpstdi.baseline_time) AS total_minutes, 
       1, 
       cpsd.completed_date,cpsd.schedule_date ,cpsd.std_intervention_id , cpsd.intervention_desc,cpsd.documentation_id,
       case when cpsd.strikeout_date is not null then 1 else 0 end sFlag
FROM   #prp_poc_details cpsd 
       inner join dbo.cp_rev_intervention crr  WITH (nolock) 
	   on crr.clientid=cpsd.client_id
       and crr.current_row='Y'
       and crr.gen_intervention_id=cpsd.intervention_id
       and crr.require_time_tracking = 1
       left JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
               ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                  AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN dbo.common_code cc WITH (nolock) 
               ON   cc.item_id = crr.service_tracking_position_id

       INNER JOIN #prp_shifts shift WITH (nolock) 
               ON 1 = CASE 
                        WHEN Substring(cpsd.schedule_detail_id,Charindex('_', cpsd.schedule_detail_id) + 1,1)  = 'D' 
                             AND cpsd.std_shift_id IS NULL THEN 1 
                        WHEN Substring(cpsd.schedule_detail_id,Charindex('_', cpsd.schedule_detail_id) + 1,1)= 'S' 
                             AND cpsd.std_shift_id IS NULL 
                             
                             THEN 1 
                          
                        ELSE 0 
                      END 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       AND cpsd.std_shift_id IS NULL 
      ; 
-------------------------------------------------------------
-- Row data for Actual Hours
-------------------------------------------------------------
update #prp_poc_details 
	    set schedule_time=replace(convert(varchar(5),dbo.fn_adjust_time_fac_time_zone (@vFacId ,completed_date),108),':','')
 where completed_date is not null 
  and substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)<>'Q' 
  
INSERT INTO #rowdata --Qshift
            (schedule_detail_id, 
             client_id, 
             client_name,shift_id, 
             shift, 
             group_name,
             service_tracking_position_id, 
             position_id, 
             position, 
             day_of_week, 
             total_minutes, 
             timeflag, 
             completed_date,schedule_date,std_intervention_id , intervention_desc,document_id) 
SELECT cpsd.schedule_detail_id, 
       cpsd.client_id, 
       cpsd.last_name + ', ' + cpsd.first_name + ' (' 
       + cpsd.client_id_number + ')' AS client_name, 
       shift.shift_id, 
       'Scheduled'                   AS Shift, 
       ''                            AS group_name, 
       crr.service_tracking_position_id, 
       usr.position_id, 
       CASE 
         WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown' 
         ELSE usr.position_description 
       END                           AS position, 
       Datepart(dd, cpsd.shift_date)      AS day_of_week, 
       Isnull(cpsd.task_time, 0)     AS total_minutes, 
       2, 
       cpsd.completed_date, 
       cpsd.shift_date               AS schedule_date, 
       cpsd.std_intervention_id, 
       cpsd.intervention_desc, 
       cpsd.documentation_id 
FROM   #prp_poc_details cpsd 
       INNER JOIN dbo.cp_rev_intervention crr  WITH (nolock)
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN #prp_shift_link shift WITH (nolock) 
               ON cpsd.std_shift_id = shift.shift_id 
       INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock) 
               ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       AND cpsd.completed_date IS NOT NULL 
       AND cpsd.strikeout_date IS NULL;  
       
       
INSERT INTO #rowdata --Non-Qshift
            (schedule_detail_id, 
             client_id, 
             client_name,shift_id, 
             shift, 
             group_name, 
             service_tracking_position_id,
             position_id, 
             position, 
             day_of_week, 
             total_minutes, 
             timeflag, 
             completed_date,schedule_date,std_intervention_id , intervention_desc,document_id) 
        SELECT cpsd.schedule_detail_id, 
       cpsd.client_id, 
       cpsd.last_name + ', ' + cpsd.first_name + ' (' 
       + cpsd.client_id_number + ')' AS client_name, 
       shift.shift_id, 
       'Scheduled'                   AS Shift, 
       ''                            AS group_name, 
       CASE 
         WHEN Isnull(cpstdi.require_time_tracking, 0) = 1 THEN 
         crr.service_tracking_position_id 
         WHEN Isnull(cpstdi.require_time_tracking, 0) = 0 
              AND Isnull(crr.require_time_tracking, 0) = 1 THEN 
         crr.service_tracking_position_id 
       END                           AS position_id, 
       usr.position_id, 
       CASE 
         WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown' 
         ELSE usr.position_description 
       END                           AS position, 
       Datepart(dd, schedule_date)   AS day_of_week, 
       Isnull(cpsd.task_time, 0)     AS total_minutes, 
       2, 
       cpsd.completed_date, 
       cpsd.schedule_date, 
       cpsd.std_intervention_id, 
       cpsd.intervention_desc, 
       cpsd.documentation_id 
FROM   #prp_poc_details cpsd 
       INNER JOIN dbo.cp_rev_intervention crr  WITH (nolock)
               ON crr.clientid = cpsd.client_id 
                  AND crr.current_row = 'Y' 
                  AND crr.gen_intervention_id = cpsd.intervention_id 
                  AND crr.require_time_tracking = 1 
       LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
              ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
                 AND cpstdi.poc_flowsheet = 'Y' 
       INNER JOIN #prp_shifts shift WITH (nolock) 
               ON 1 = CASE 
                        WHEN 
                      Substring(cpsd.schedule_detail_id, 
                      Charindex('_', cpsd.schedule_detail_id) + 1, 1) = 'D' 
                      AND cpsd.std_shift_id IS NULL THEN 1 
                        WHEN 
                      Substring(cpsd.schedule_detail_id, 
                      Charindex('_', cpsd.schedule_detail_id) + 1, 1) IN ( 'U', 
                      'S' ) 
                      AND cpsd.std_shift_id IS NULL THEN 1 
                        ELSE 0 
                      END 
       INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock) 
               ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id 
WHERE  cpsd.schedule_type <> 40 
       AND cpsd.schedule_type <> 8 
       AND completed_date IS NOT NULL 
       AND cpsd.std_shift_id IS NULL 
       AND cpsd.strikeout_date IS NULL;  
       
       
IF @vIncludeUnscheduled = 'Y'

    BEGIN
        INSERT INTO #rowdata 
            (schedule_detail_id, 
             client_id, 
             client_name,
             shift_id, 
             shift, 
             group_name, 
             position_id, 
             position, 
             day_of_week, 
             total_minutes, 
             timeflag, 
             completed_date,schedule_date,std_intervention_id , intervention_desc,document_id) 
        select cpsd.schedule_detail_id,cpsd.client_id,
        cpsd.last_name +', '+cpsd.first_name +' ('+cpsd.client_id_number +')' as client_name,shift.shift_id, 
        'Unscheduled' as Shift,'' as group_name,usr.position_id, 
		        case 
		        when isnull(usr.position_description,'')='' THEN 'Unknown' 
		        else usr.position_description end as position, 
	    DATEPART(dd, cpsd.schedule_date) as day_of_week,isnull(cpsd.task_time,0) as total_minutes,
		3,cpsd.completed_date,cpsd.schedule_date,cpsd.std_intervention_id , cpsd.intervention_desc,cpsd.documentation_id
		        from #prp_poc_details cpsd
	 inner join dbo.cp_rev_intervention crr  WITH (nolock) 
	 on crr.clientid=cpsd.client_id
       and crr.current_row='Y'
       and crr.gen_intervention_id=cpsd.intervention_id
       and crr.require_time_tracking = 1
	left JOIN dbo.cp_std_intervention cpstdi WITH (NOLOCK) on 
	    cpsd.std_intervention_id=cpstdi.std_intervention_id 
	    AND cpstdi.poc_flowsheet='Y'
	INNER JOIN #prp_shifts shift WITH (NOLOCK) ON 
	1= case 
	     when substring(cpsd.schedule_detail_id,charindex('_',cpsd.schedule_detail_id)+1,1)='D' 
	         and cpsd.std_shift_id IS Null  then 1
	     when  substring(cpsd.schedule_detail_id,charindex('_',cpsd.schedule_detail_id)+1,1) in ('U','S'  )
	         and cpsd.std_shift_id IS Null  
	          
	         then 1 
	     else 0 end
	INNER JOIN dbo.cp_sec_user_audit usr WITH (NOLOCK) ON cpsd.cp_sec_user_audit_id=usr.cp_sec_user_audit_id
		        WHERE cpsd.schedule_type=40 AND cpsd.completed_date is not null and  cpsd.strikeout_date is null;
    END

IF @vIncludePRN = 'Y'
BEGIN
	INSERT INTO #rowdata
				(schedule_detail_id, 
				 client_id, 
				 client_name,shift_id, 
				 shift, 
				 group_name,
				 position_id, 
				 position, 
				 day_of_week, 
				 total_minutes, 
				 timeflag, 
				 completed_date,schedule_date,std_intervention_id , intervention_desc,document_id) 
			SELECT cpsd.schedule_detail_id, 
		   cpsd.client_id, 
		   cpsd.last_name + ', ' + cpsd.first_name + ' (' 
		   + cpsd.client_id_number + ')' AS client_name, 
		   shift.std_shift_id as shift_id, 
		   'PRN'                   AS Shift, 
		   ''                            AS group_name, 
		   usr.position_id, 
		   CASE 
			 WHEN Isnull(usr.position_description, '') = '' THEN 'Unknown' 
			 ELSE usr.position_description 
		   END                           AS position, 
		   Datepart(dd, schedule_date)   AS day_of_week, 
		   Isnull(cpsd.task_time, 0)     AS total_minutes, 
		   4, 
		   cpsd.completed_date, 
		   cpsd.schedule_date, 
		   cpsd.std_intervention_id, 
		   cpsd.intervention_desc, 
		   cpsd.documentation_id 
	FROM   #prp_poc_details cpsd 
		   INNER JOIN dbo.cp_rev_intervention crr  WITH (nolock)
				   ON crr.clientid = cpsd.client_id 
					  AND crr.current_row = 'Y' 
					  AND crr.gen_intervention_id = cpsd.intervention_id 
					  AND crr.require_time_tracking = 1 
		   LEFT JOIN dbo.cp_std_intervention cpstdi WITH (nolock) 
				  ON cpsd.std_intervention_id = cpstdi.std_intervention_id 
					 AND cpstdi.poc_flowsheet = 'Y' 
		   INNER JOIN dbo.cp_std_shift shift WITH (NOLOCK) 
					 ON shift.std_shift_id = cpsd.std_shift_id
		   INNER JOIN dbo.cp_sec_user_audit usr WITH (nolock) 
				   ON cpsd.cp_sec_user_audit_id = usr.cp_sec_user_audit_id 
	WHERE  cpsd.schedule_type = 8 
		   AND completed_date IS NOT NULL 
		   AND cpsd.strikeout_date IS NULL;
END

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
--------------- Delete duplicate
select @vStep = 41
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' DELETEING DUPLICATE ROW ' + convert(varchar(26),getdate(),109)

--DELETE from #rowdata where sFlag=1 and timeFlag=1;


;WITH CTE_1  AS
(
select  schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,
  position ,total_minutes,timeFlag ,case when timeFlag=1 then null else completed_date end completed_date ,std_intervention_id , intervention_desc,case when timeFlag=1 then null else document_id end document_id,
row_number() over(PARTITION BY  schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,
  position ,total_minutes,timeFlag ,case when timeFlag=1 then null else completed_date end ,std_intervention_id , intervention_desc ,case when timeFlag=1 then null else document_id end
order by  schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,
  position ,total_minutes,timeFlag ,case when timeFlag=1 then null else completed_date end,std_intervention_id , intervention_desc,case when timeFlag=1 then null else document_id end  ) row_id
from #rowdata
) 

delete from cte_1 where  row_id>1
	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
-------------------------------------------------------------------
select @vStep = 42
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' UPDATING SCHEDULE/COMPLETED DATE BASE OF TZ ' + convert(varchar(26),getdate(),109)


update  a set 
  a.schedule_date=   case when substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)<>'Q' 
   then dbo.fn_adjust_time_fac_time_zone (@vFacId ,schedule_date ) else schedule_date end,
  a.completed_date=  dbo.fn_adjust_time_fac_time_zone (@vFacId ,completed_date ) 
from #rowdata a

----------------- showing actual and plan in the same day
	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'select @vStep = 43
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + 'DELETE DURATIONS TASK THAT NOT COMPLETED' + convert(varchar(26),getdate(),109)

delete  from #rowdata where (schedule_date <@vStartDate or schedule_date>@vEndDate) and  schedule_date is not null

delete  a
from #rowdata a 
where a.timeflag=1
and not exists (select 1 from #rowdata b where b.schedule_detail_id=a.schedule_detail_id and b.timeFlag=2  and a.document_id=b.document_id)
and substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)='D'


update  a set 
  day_of_week= case 
                when substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1) in ('D') and a.completed_date is not null 
                  then datepart(dd,completed_date)
                when timeflag=1 then datepart(dd,schedule_date)
                when timeflag in (2,3,4) and substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)<>'Q'
                 then datepart(dd,completed_date) else datepart(dd,schedule_date)
                end
from #rowdata a  

IF @vType=2
update a set day_of_week=dw.dw
from #rowdata  a
INNER JOIN @day_week dw on dw.date_day=
 case 
  when substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1) in ('D') and a.completed_date is not null  
    then cast(convert(varchar(10),completed_date, 120)  as datetime)
  when timeflag=1 then cast(convert(varchar(10),schedule_date, 120)  as datetime) 
  when timeflag in (3,2,4) and substring(schedule_detail_id,charindex('_',schedule_detail_id)+1,1)<>'Q' 
   then cast(convert(varchar(10),completed_date, 120)  as datetime)
   else cast(convert(varchar(10),schedule_date, 120)  as datetime) 
  end
--cast(convert(varchar(10),schedule_date, 120)  as datetime) 

 	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

if @debug_me='Y' SELECT '#rowdata', * FROM #rowdata;

  ----------------------------------------------

IF @vType= 1
 BEGIN
 select @vStep = 44
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + 'SHOWING MONTHLY DATA ' + convert(varchar(26),getdate(),109)

  INSERT INTO #prp_poc_planned_monthly
  (fac_id ,client_id   , client_name , shift  , group_name  ,position_id ,position    , task_id , task    , hour_type   , 
day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
day_31, total , ordr ) 
	select @vFacId,client_id,client_name,Shift,group_name,position_id,position,task_id,task,'Planned' as hour_type,
	isnull([1],0) as day_1,isnull([2],0) as day_2, isnull([3],0) as day_3, isnull([4],0) as day_4, isnull([5],0) as day_5,
	isnull([6],0) as day_6, isnull([7],0) as day_7,	isnull([8],0) as day_8,isnull([9],0) as day_9,isnull([10],0) as day_10,
	isnull([11],0) as day_11,isnull([12],0) as day_12,isnull([13],0) as day_13,isnull([14],0) as day_14,isnull([15],0) as day_15,
	isnull([16],0) as day_16,isnull([17],0) as day_17,isnull([18],0) as day_18,isnull([19],0) as day_19,isnull([20],0) as day_20,
	isnull([21],0) as day_21,isnull([22],0) as day_22,isnull([23],0) as day_23,isnull([24],0) as day_24,isnull([25],0) as day_25,
	isnull([26],0) as day_26,isnull([27],0) as day_27,isnull([28],0) as day_28,isnull([29],0) as day_29,isnull([30],0) as day_30,
	isnull([31],0) as day_31, 0 as total,  0 as ordr
	from
	(select schedule_detail_id ,client_id,client_name ,shift ,group_name,position_id,position,std_intervention_id task_id,
  intervention_desc task ,day_of_week ,total_minutes,timeFlag ,completed_date  from #rowdata where timeFlag=1
	) as rawdata
	PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17],[18],[19],[20],[21],[22],[23],
		[24],[25],[26],[27],[28],[29],[30],[31])) as pivotdata



	INSERT INTO #prp_poc_planned_monthly
	(fac_id ,client_id   , client_name , shift  , group_name  ,position_id ,position    , task_id , task    , hour_type   , 
day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
day_31, total , ordr )  
	select @vFacId,client_id,client_name,Shift,group_name,position_id,position,task_id,task,'Actual' as hour_type,
	isnull([1],0) as day_1,isnull([2],0) as day_2, isnull([3],0) as day_3, isnull([4],0) as day_4, isnull([5],0) as day_5,
	isnull([6],0) as day_6, isnull([7],0) as day_7,	isnull([8],0) as day_8,isnull([9],0) as day_9,isnull([10],0) as day_10,
	isnull([11],0) as day_11,isnull([12],0) as day_12,isnull([13],0) as day_13,isnull([14],0) as day_14,isnull([15],0) as day_15,
	isnull([16],0) as day_16,isnull([17],0) as day_17,isnull([18],0) as day_18,isnull([19],0) as day_19,isnull([20],0) as day_20,
	isnull([21],0) as day_21,isnull([22],0) as day_22,isnull([23],0) as day_23,isnull([24],0) as day_24,isnull([25],0) as day_25,
	isnull([26],0) as day_26,isnull([27],0) as day_27,isnull([28],0) as day_28,isnull([29],0) as day_29,isnull([30],0) as day_30,
	isnull([31],0) as day_31, 0 as total, 
	1 as ordr
	from
	(select schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,std_intervention_id task_id,position_id,position,
  intervention_desc task ,day_of_week ,total_minutes,timeFlag ,completed_date  from #rowdata where timeFlag=2
	) as rawdata
	PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17],[18],[19],[20],[21],[22],[23],
		[24],[25],[26],[27],[28],[29],[30],[31])) as pivotdata

	IF @vIncludeUnscheduled = 'Y'
	
		INSERT INTO #prp_poc_planned_monthly 
		(fac_id ,client_id   , client_name , shift  , group_name  ,position_id ,position    , task_id , task    , hour_type   , 
        day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
        day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
        day_31, total , ordr )
		select @vFacId,client_id,client_name,Shift,group_name,position_id,position,task_id,task,'Actual' as hour_type,
		isnull([1],0) as day_1,isnull([2],0) as day_2, isnull([3],0) as day_3, isnull([4],0) as day_4, isnull([5],0) as day_5,
	isnull([6],0) as day_6, isnull([7],0) as day_7,	isnull([8],0) as day_8,isnull([9],0) as day_9,isnull([10],0) as day_10,
	isnull([11],0) as day_11,isnull([12],0) as day_12,isnull([13],0) as day_13,isnull([14],0) as day_14,isnull([15],0) as day_15,
	isnull([16],0) as day_16,isnull([17],0) as day_17,isnull([18],0) as day_18,isnull([19],0) as day_19,isnull([20],0) as day_20,
	isnull([21],0) as day_21,isnull([22],0) as day_22,isnull([23],0) as day_23,isnull([24],0) as day_24,isnull([25],0) as day_25,
	isnull([26],0) as day_26,isnull([27],0) as day_27,isnull([28],0) as day_28,isnull([29],0) as day_29,isnull([30],0) as day_30,
	isnull([31],0) as day_31, 0 as total,  10 as ordr
		from
		(select schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,position,std_intervention_id task_id, intervention_desc task ,day_of_week ,total_minutes,timeFlag ,completed_date  
		from #rowdata where timeFlag=3
		) as rawdata
		PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17],[18],[19],[20],[21],[22],[23],
		[24],[25],[26],[27],[28],[29],[30],[31])) as pivotdata

	IF @vIncludePRN = 'Y'
	BEGIN
		INSERT INTO #prp_poc_planned_monthly 
		(fac_id ,client_id   , client_name , shift  , group_name  ,position_id ,position    , task_id , task    , hour_type   , 
        day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
        day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
        day_31, total , ordr )
		select @vFacId,client_id,client_name,Shift,group_name,position_id,position,task_id,task,'Actual' as hour_type,
		isnull([1],0) as day_1,isnull([2],0) as day_2, isnull([3],0) as day_3, isnull([4],0) as day_4, isnull([5],0) as day_5,
	isnull([6],0) as day_6, isnull([7],0) as day_7,	isnull([8],0) as day_8,isnull([9],0) as day_9,isnull([10],0) as day_10,
	isnull([11],0) as day_11,isnull([12],0) as day_12,isnull([13],0) as day_13,isnull([14],0) as day_14,isnull([15],0) as day_15,
	isnull([16],0) as day_16,isnull([17],0) as day_17,isnull([18],0) as day_18,isnull([19],0) as day_19,isnull([20],0) as day_20,
	isnull([21],0) as day_21,isnull([22],0) as day_22,isnull([23],0) as day_23,isnull([24],0) as day_24,isnull([25],0) as day_25,
	isnull([26],0) as day_26,isnull([27],0) as day_27,isnull([28],0) as day_28,isnull([29],0) as day_29,isnull([30],0) as day_30,
	isnull([31],0) as day_31, 0 as total,  20 as ordr
		from
		(select schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,position,std_intervention_id task_id, intervention_desc task ,day_of_week ,total_minutes,timeFlag ,completed_date  
		from #rowdata where timeFlag=4
		) as rawdata
		PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17],[18],[19],[20],[21],[22],[23],
		[24],[25],[26],[27],[28],[29],[30],[31])) as pivotdata

		INSERT INTO #prp_poc_planned_monthly
		(fac_id ,client_id   , client_name , shift  , group_name  , task_id , task    , hour_type   , 
		day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
		day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
		day_31, total , ordr ) 
		select fac_id,client_id,client_name,Shift,group_name,0,'ZZZZ','' as hour_type,sum(day_1) as day_1,sum(day_2) as day_2, sum(day_3) as day_3, 
			sum(day_4) as day_4, sum(day_5) as day_5, sum(day_6) as day_6, sum(day_7) as day_7,sum(day_8) as day_8,sum(day_9) as day_9, sum(day_10) as day_10, 
			sum(day_11) as day_11, sum(day_12) as day_12, sum(day_13) as day_13, sum(day_14) as day_14,sum(day_15) as day_15,sum(day_16) as day_16, sum(day_17) as day_17, 
			sum(day_18) as day_18, sum(day_19) as day_19, sum(day_20) as day_20, sum(day_21) as day_21,sum(day_22) as day_22,sum(day_23) as day_23, sum(day_24) as day_24, 
			sum(day_25) as day_25, sum(day_26) as day_26, sum(day_27) as day_27, sum(day_28) as day_28,sum(day_29) as day_29,sum(day_30) as day_30, sum(day_31) as day_31, 
			sum(total) as total, 21 as ordr
		from #prp_poc_planned_monthly
		where ordr = 20
		group BY fac_id,client_id,client_name,Shift,group_name

		--insert dummy actual row if the corresponding planned ro has no data
		INSERT INTO #prp_poc_planned_monthly
		(fac_id ,client_id   , client_name , shift  , group_name  , task_id , task    , hour_type   , 
		day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
		day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
		day_31, total , ordr ) 
		select distinct planned.fac_id,planned.client_id,planned.client_name,'No PRN Tasks Documented' as Shift,'' as group_name, 0 as position_id,'ZZZZ' as position,'Actual' as hour_type,
			0 as day_1, 0 as day_2, 0 as day_3, 0 as day_4, 0 as day_5, 0 as day_6, 0 as day_7,
			0 as day_8, 0 as day_9, 0 as day_10, 0 as day_11, 0 as day_12, 0 as day_13, 0 as day_14, 0 as day_15, 0 as day_16, 0 as day_17,
			0 as day_18, 0 as day_19, 0 as day_20, 0 as day_21, 0 as day_22, 0 as day_23, 0 as day_24, 0 as day_25, 0 as day_26, 0 as day_27,
			0 as day_28, 0 as day_29, 0 as day_30, 0 as day_31,  0 as total, 20 as ordr
		from #prp_poc_planned_monthly planned WITH (NOLOCK) 
		left JOIN (select client_id from #prp_poc_planned_monthly WITH (NOLOCK) where ordr=20 group by client_id) clients 
			ON planned.client_id = clients.client_id and planned.ordr=0
		where planned.ordr=0 and clients.client_id is null


	END
	
INSERT INTO #prp_poc_planned_monthly
	(fac_id ,client_id   , client_name , shift  , group_name  ,position_id ,position    , task_id , task    , hour_type   , 
    day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
    day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
    day_31, total , ordr )
	select @vFacId,planned.client_id,planned.client_name,planned.Shift,planned.group_name,planned.position_id,planned.position,planned.task_id,planned.task,'Actual' as hour_type,
		0 as day_1, 0 as day_2, 0 as day_3, 0 as day_4, 0 as day_5, 0 as day_6, 0 as day_7,
		0 as day_8, 0 as day_9, 0 as day_10, 0 as day_11, 0 as day_12, 0 as day_13, 0 as day_14, 0 as day_15, 0 as day_16, 0 as day_17,
		0 as day_18, 0 as day_19, 0 as day_20, 0 as day_21, 0 as day_22, 0 as day_23, 0 as day_24, 0 as day_25, 0 as day_26, 0 as day_27,
		0 as day_28, 0 as day_29, 0 as day_30, 0 as day_31, 0 as total, 1 as ordr
	from #prp_poc_planned_monthly planned
		 where  planned.ordr=0
		  and not exists  (select 1 from #prp_poc_planned_monthly actual where  actual.ordr=1 and planned.shift=actual.shift and planned.position_id=actual.position_id and actual.client_id=planned.client_id and planned.task_id=actual.task_id )
	
		  
	

	IF @vIncludeUnscheduled = 'Y'
	begin
	
	
		INSERT INTO #prp_poc_planned_monthly
		(fac_id ,client_id   , client_name , shift  , group_name  , task_id , task    , hour_type   , 
day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
day_31, total , ordr ) 
		select fac_id,client_id,client_name,Shift,group_name,0,'ZZZZ','' as hour_type,sum(day_1) as day_1,sum(day_2) as day_2, sum(day_3) as day_3, 
			sum(day_4) as day_4, sum(day_5) as day_5, sum(day_6) as day_6, sum(day_7) as day_7,sum(day_8) as day_8,sum(day_9) as day_9, sum(day_10) as day_10, 
			sum(day_11) as day_11, sum(day_12) as day_12, sum(day_13) as day_13, sum(day_14) as day_14,sum(day_15) as day_15,sum(day_16) as day_16, sum(day_17) as day_17, 
			sum(day_18) as day_18, sum(day_19) as day_19, sum(day_20) as day_20, sum(day_21) as day_21,sum(day_22) as day_22,sum(day_23) as day_23, sum(day_24) as day_24, 
			sum(day_25) as day_25, sum(day_26) as day_26, sum(day_27) as day_27, sum(day_28) as day_28,sum(day_29) as day_29,sum(day_30) as day_30, sum(day_31) as day_31, 
			sum(total) as total, 11 as ordr
		from #prp_poc_planned_monthly
		where ordr = 10
		group BY fac_id,client_id,client_name,Shift,group_name
		
		

		--insert dummy actual row if the corresponding planned ro has no data
		INSERT INTO #prp_poc_planned_monthly
		(fac_id ,client_id   , client_name , shift  , group_name  , task_id , task    , hour_type   , 
day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
day_31, total , ordr ) 
		select distinct planned.fac_id,planned.client_id,planned.client_name,'No Unscheduled Tasks Documented' as Shift,'' as group_name, 0 as position_id,'ZZZZ' as position,'Actual' as hour_type,
			0 as day_1, 0 as day_2, 0 as day_3, 0 as day_4, 0 as day_5, 0 as day_6, 0 as day_7,
			0 as day_8, 0 as day_9, 0 as day_10, 0 as day_11, 0 as day_12, 0 as day_13, 0 as day_14, 0 as day_15, 0 as day_16, 0 as day_17,
			0 as day_18, 0 as day_19, 0 as day_20, 0 as day_21, 0 as day_22, 0 as day_23, 0 as day_24, 0 as day_25, 0 as day_26, 0 as day_27,
			0 as day_28, 0 as day_29, 0 as day_30, 0 as day_31,  0 as total, 10 as ordr
		from #prp_poc_planned_monthly planned WITH (NOLOCK) 
		left JOIN (select client_id from #prp_poc_planned_monthly WITH (NOLOCK) where ordr=10 group by client_id) clients 
			ON planned.client_id = clients.client_id and planned.ordr=0
		where planned.ordr=0 and clients.client_id is null

	end
	

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	Set @vgs_fill_end_time  = getdate() ; -- fill end time

	select @vStep = 70
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' updating pivoted table ' + convert(varchar(26),getdate(),109)

	if @debug_me='Y' select '#prp_poc_planned_monthly', * from #prp_poc_planned_monthly;


insert into #prp_poc_planned_final_monthly
(fac_id ,client_id   , client_name , shift  , group_name   , task_id , task    , hour_type   , 
day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
day_31, total , ordr ) 
	select  @vFacId,
	planned.client_id,planned.client_name,planned.Shift,planned.group_name,planned.task_id,planned.task,hour_type,
	sum(day_1) day_1,sum(day_2) day_2,sum(day_3) day_3,sum(day_4) day_4,sum(day_5) day_5,sum(day_6) day_6,
	sum(day_7) day_7,sum(day_8) day_8,sum(day_9) day_9,sum(day_10) day_10,sum(day_11) day_11,sum(day_12) day_12,
	sum(day_13) day_13,sum(day_14) day_14,sum(day_15) day_15,sum(day_16) day_16,sum(day_17) day_17,sum(day_18) day_18,	
	sum(day_19) day_19,sum(day_20) day_20,sum(day_21) day_21,sum(day_22) day_22,sum(day_23) day_23,sum(day_24) day_24,	
	sum(day_25) day_25,sum(day_26) day_26,sum(day_27) day_27,sum(day_28) day_28,sum(day_29) day_29,sum(day_30) day_30,
	sum(day_31) day_31,sum(total) total,ordr
		from #prp_poc_planned_monthly  planned
		group by planned.client_id,planned.client_name,planned.Shift,planned.group_name,planned.task_id,planned.task,ordr,hour_type
		
		
	update #prp_poc_planned_final_monthly SET 
		day_1 = ISNULL(day_1, 0) 
		,day_2 = ISNULL(day_2, 0)
		,day_3 = ISNULL(day_3, 0)
		,day_4 = ISNULL(day_4, 0)
		,day_5 = ISNULL(day_5, 0)
		,day_6 = ISNULL(day_6, 0)
		,day_7 = ISNULL(day_7, 0)
		,day_8 = ISNULL(day_8, 0)
		,day_9 = ISNULL(day_9, 0)
		,day_10 = ISNULL(day_10, 0)
		,day_11 = ISNULL(day_11, 0)
		,day_12 = ISNULL(day_12, 0)
		,day_13 = ISNULL(day_13, 0)
		,day_14 = ISNULL(day_14, 0)
		,day_15 = ISNULL(day_15, 0)
		,day_16 = ISNULL(day_16, 0)
		,day_17 = ISNULL(day_17, 0)
		,day_18 = ISNULL(day_18, 0)
		,day_19 = ISNULL(day_19, 0)
		,day_20 = ISNULL(day_20, 0)
		,day_21 = ISNULL(day_21, 0)
		,day_22 = ISNULL(day_22, 0)
		,day_23 = ISNULL(day_23, 0)
		,day_24 = ISNULL(day_24, 0)
		,day_25 = ISNULL(day_25, 0)
		,day_26 = ISNULL(day_26, 0)
		,day_27 = ISNULL(day_27, 0)
		,day_28 = ISNULL(day_28, 0)
		,day_29 = ISNULL(day_29, 0)
		,day_30 = ISNULL(day_30, 0)
		,day_31 = ISNULL(day_31, 0)

		

	INSERT INTO #prp_poc_planned_final_monthly
	(fac_id ,client_id   , client_name , shift  , group_name   , task_id , task    , hour_type   , 
day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
day_31, total , ordr ) 
	select @vFacId,pre.client_id,pre.client_name,pre.Shift,pre.group_name,pre.task_id,pre.task,'Planned '+CHAR(45)+' Actual = ' as hour_type,
	(isnull(pre.day_1,0)-isnull(nxt.day_1,0)) as day_1,
	(isnull(pre.day_2,0)-isnull(nxt.day_2,0)) as day_2, 
	(isnull(pre.day_3,0)-isnull(nxt.day_3,0)) as day_3, 
	(isnull(pre.day_4,0)-isnull(nxt.day_4,0)) as day_4, 
	(isnull(pre.day_5,0)-isnull(nxt.day_5,0)) as day_5, 
	(isnull(pre.day_6,0)-isnull(nxt.day_6,0)) as day_6, 
	(isnull(pre.day_7,0)-isnull(nxt.day_7,0)) as day_7,
	(isnull(pre.day_8,0)-isnull(nxt.day_8,0)) as day_8,
	(isnull(pre.day_9,0)-isnull(nxt.day_9,0)) as day_9, 
	(isnull(pre.day_10,0)-isnull(nxt.day_10,0)) as day_10, 
	(isnull(pre.day_11,0)-isnull(nxt.day_11,0)) as day_11, 
	(isnull(pre.day_12,0)-isnull(nxt.day_12,0)) as day_12, 
	(isnull(pre.day_13,0)-isnull(nxt.day_13,0)) as day_13, 
	(isnull(pre.day_14,0)-isnull(nxt.day_14,0)) as day_14, 
	(isnull(pre.day_15,0)-isnull(nxt.day_15,0)) as day_15,
	(isnull(pre.day_16,0)-isnull(nxt.day_16,0)) as day_16, 
	(isnull(pre.day_17,0)-isnull(nxt.day_17,0)) as day_17, 
	(isnull(pre.day_18,0)-isnull(nxt.day_18,0)) as day_18, 
	(isnull(pre.day_19,0)-isnull(nxt.day_19,0)) as day_19, 
	(isnull(pre.day_20,0)-isnull(nxt.day_20,0)) as day_20, 
	(isnull(pre.day_21,0)-isnull(nxt.day_21,0)) as day_21, 
	(isnull(pre.day_22,0)-isnull(nxt.day_22,0)) as day_22,
	(isnull(pre.day_23,0)-isnull(nxt.day_23,0)) as day_23, 
	(isnull(pre.day_24,0)-isnull(nxt.day_24,0)) as day_24, 
	(isnull(pre.day_25,0)-isnull(nxt.day_25,0)) as day_25, 
	(isnull(pre.day_26,0)-isnull(nxt.day_26,0)) as day_26, 
	(isnull(pre.day_27,0)-isnull(nxt.day_27,0)) as day_27, 
	(isnull(pre.day_28,0)-isnull(nxt.day_28,0)) as day_28, 
	(isnull(pre.day_29,0)-isnull(nxt.day_29,0)) as day_29, 
	(isnull(pre.day_30,0)-isnull(nxt.day_30,0)) as day_30, 
	(isnull(pre.day_31,0)-isnull(nxt.day_31,0))as day_31,   
	0 as total, 2 as ordr
	from (select client_id
			,client_name
			,Shift
			,group_name
			,task_id 
			,task
			,day_1
			,day_2
			,day_3
			,day_4
			,day_5
			,day_6
			,day_7
			,day_8
			,day_9
			,day_10
			,day_11
			,day_12
			,day_13
			,day_14
			,day_15
			,day_16
			,day_17
			,day_18
			,day_19
			,day_20
			,day_21
			,day_22
			,day_23
			,day_24
			,day_25
			,day_26
			,day_27
			,day_28
			,day_29
			,day_30
			,day_31
			,ROW_NUMBER() OVER ( PARTITION BY client_id--,position
				order by  client_id,task) as rwnum
		from #prp_poc_planned_final_monthly where ordr=0 ) pre
		join (select client_id
			,client_name
			,Shift
			,group_name
			,task_id 
			,task
			,day_1
			,day_2
			,day_3
			,day_4
			,day_5
			,day_6
			,day_7
			,day_8
			,day_9
			,day_10
			,day_11
			,day_12
			,day_13
			,day_14
			,day_15
			,day_16
			,day_17
			,day_18
			,day_19
			,day_20
			,day_21
			,day_22
			,day_23
			,day_24
			,day_25
			,day_26
			,day_27
			,day_28
			,day_29
			,day_30
			,day_31
			,ROW_NUMBER() OVER ( PARTITION BY client_id--,position 
				order by  client_id,task) as rwnum
		from #prp_poc_planned_final_monthly a where ordr=1
		and EXISTS (select 1 from #prp_poc_planned_final_monthly b where a.fac_id=b.fac_id and a.shift=b.shift and a.task_id=b.task_id and b.ordr=0)) nxt
		on pre.client_id=nxt.client_id and pre.task=nxt.task and pre.rwnum=nxt.rwnum


	update #prp_poc_planned_final_monthly SET total= (day_1 + day_2 + day_3 + day_4 + day_5 + day_6 + day_7 + day_8 + day_9 + day_10 + day_11 + day_12
		+ day_13 + day_14 + day_15 + day_16 + day_17 + day_18 + day_19 + day_20 + day_21 + day_22 + day_23 + day_24 + day_25 + day_26
		+ day_27 + day_28 + day_29 + day_30 + day_31)



	INSERT INTO #prp_poc_planned_final_monthly
	(fac_id ,client_id   , client_name , shift  , group_name   , task_id , task    , hour_type   , 
day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
day_31, total , ordr ) 
	select fac_id,client_id,client_name,Shift,group_name,0,'ZZZZ','Planned' as hour_type,sum(day_1) as day_1,sum(day_2) as day_2, sum(day_3) as day_3, 
			sum(day_4) as day_4, sum(day_5) as day_5, sum(day_6) as day_6, sum(day_7) as day_7,sum(day_8) as day_8,sum(day_9) as day_9, sum(day_10) as day_10, 
			sum(day_11) as day_11, sum(day_12) as day_12, sum(day_13) as day_13, sum(day_14) as day_14,sum(day_15) as day_15,sum(day_16) as day_16, sum(day_17) as day_17, 
			sum(day_18) as day_18, sum(day_19) as day_19, sum(day_20) as day_20, sum(day_21) as day_21,sum(day_22) as day_22,sum(day_23) as day_23, sum(day_24) as day_24, 
			sum(day_25) as day_25, sum(day_26) as day_26, sum(day_27) as day_27, sum(day_28) as day_28,sum(day_29) as day_29,sum(day_30) as day_30, sum(day_31) as day_31,  
			sum(total) as total, 4 as ordr
	from #prp_poc_planned_final_monthly
	where ordr = 0
	group BY fac_id,client_id,client_name,Shift,group_name


	INSERT INTO #prp_poc_planned_final_monthly
	(fac_id ,client_id   , client_name , shift  , group_name   , task_id , task    , hour_type   , 
day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
day_31, total , ordr ) 
	select fac_id,client_id,client_name,Shift,group_name,0,'ZZZZ','Actual' as hour_type,sum(day_1) as day_1,sum(day_2) as day_2, sum(day_3) as day_3, 
			sum(day_4) as day_4, sum(day_5) as day_5, sum(day_6) as day_6, sum(day_7) as day_7,sum(day_8) as day_8,sum(day_9) as day_9, sum(day_10) as day_10, 
			sum(day_11) as day_11, sum(day_12) as day_12, sum(day_13) as day_13, sum(day_14) as day_14,sum(day_15) as day_15,sum(day_16) as day_16, sum(day_17) as day_17, 
			sum(day_18) as day_18, sum(day_19) as day_19, sum(day_20) as day_20, sum(day_21) as day_21,sum(day_22) as day_22,sum(day_23) as day_23, sum(day_24) as day_24, 
			sum(day_25) as day_25, sum(day_26) as day_26, sum(day_27) as day_27, sum(day_28) as day_28,sum(day_29) as day_29,sum(day_30) as day_30, sum(day_31) as day_31, 
			sum(total) as total, 5 as ordr
	from #prp_poc_planned_final_monthly
	where ordr = 1 or ordr = 3
	group BY fac_id,client_id,client_name,Shift,group_name



INSERT INTO #prp_poc_planned_final_monthly
(fac_id ,client_id   , client_name , shift  , group_name   , task_id , task    , hour_type   , 
day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
day_31, total , ordr ) 
	select @vFacId,pre.client_id,pre.client_name,pre.Shift,pre.group_name,0,'ZZZZ','Planned '+CHAR(45)+' Actual = ' as hour_type,
	(isnull(pre.day_1,0)-isnull(nxt.day_1,0)) as day_1,
	(isnull(pre.day_2,0)-isnull(nxt.day_2,0)) as day_2, 
	(isnull(pre.day_3,0)-isnull(nxt.day_3,0)) as day_3, 
	(isnull(pre.day_4,0)-isnull(nxt.day_4,0)) as day_4, 
	(isnull(pre.day_5,0)-isnull(nxt.day_5,0)) as day_5, 
	(isnull(pre.day_6,0)-isnull(nxt.day_6,0)) as day_6, 
	(isnull(pre.day_7,0)-isnull(nxt.day_7,0)) as day_7,
	(isnull(pre.day_8,0)-isnull(nxt.day_8,0)) as day_8,
	(isnull(pre.day_9,0)-isnull(nxt.day_9,0)) as day_9, 
	(isnull(pre.day_10,0)-isnull(nxt.day_10,0)) as day_10, 
	(isnull(pre.day_11,0)-isnull(nxt.day_11,0)) as day_11, 
	(isnull(pre.day_12,0)-isnull(nxt.day_12,0)) as day_12, 
	(isnull(pre.day_13,0)-isnull(nxt.day_13,0)) as day_13, 
	(isnull(pre.day_14,0)-isnull(nxt.day_14,0)) as day_14, 
	(isnull(pre.day_15,0)-isnull(nxt.day_15,0)) as day_15,
	(isnull(pre.day_16,0)-isnull(nxt.day_16,0)) as day_16, 
	(isnull(pre.day_17,0)-isnull(nxt.day_17,0)) as day_17, 
	(isnull(pre.day_18,0)-isnull(nxt.day_18,0)) as day_18, 
	(isnull(pre.day_19,0)-isnull(nxt.day_19,0)) as day_19, 
	(isnull(pre.day_20,0)-isnull(nxt.day_20,0)) as day_20, 
	(isnull(pre.day_21,0)-isnull(nxt.day_21,0)) as day_21, 
	(isnull(pre.day_22,0)-isnull(nxt.day_22,0)) as day_22,
	(isnull(pre.day_23,0)-isnull(nxt.day_23,0)) as day_23, 
	(isnull(pre.day_24,0)-isnull(nxt.day_24,0)) as day_24, 
	(isnull(pre.day_25,0)-isnull(nxt.day_25,0)) as day_25, 
	(isnull(pre.day_26,0)-isnull(nxt.day_26,0)) as day_26, 
	(isnull(pre.day_27,0)-isnull(nxt.day_27,0)) as day_27, 
	(isnull(pre.day_28,0)-isnull(nxt.day_28,0)) as day_28, 
	(isnull(pre.day_29,0)-isnull(nxt.day_29,0)) as day_29, 
	(isnull(pre.day_30,0)-isnull(nxt.day_30,0)) as day_30, 
	(isnull(pre.day_31,0)-isnull(nxt.day_31,0))as day_31,   
	0 as total,  6 as ordr
	from (select client_id
			,client_name
			,Shift
			,group_name
			,task_id 
			,task
			,day_1
			,day_2
			,day_3
			,day_4
			,day_5
			,day_6
			,day_7
			,day_8
			,day_9
			,day_10
			,day_11
			,day_12
			,day_13
			,day_14
			,day_15
			,day_16
			,day_17
			,day_18
			,day_19
			,day_20
			,day_21
			,day_22
			,day_23
			,day_24
			,day_25
			,day_26
			,day_27
			,day_28
			,day_29
			,day_30
			,day_31
			,ROW_NUMBER() OVER ( PARTITION BY client_id--,position
				order by  client_id,task) as rwnum
		from #prp_poc_planned_final_monthly where ordr=4) pre
		join (select client_id
			,client_name
			,Shift
			,group_name
			,task_id 
			,task
			,day_1
			,day_2
			,day_3
			,day_4
			,day_5
			,day_6
			,day_7
			,day_8
			,day_9
			,day_10
			,day_11
			,day_12
			,day_13
			,day_14
			,day_15
			,day_16
			,day_17
			,day_18
			,day_19
			,day_20
			,day_21
			,day_22
			,day_23
			,day_24
			,day_25
			,day_26
			,day_27
			,day_28
			,day_29
			,day_30
			,day_31
			,ROW_NUMBER() OVER ( PARTITION BY client_id--,position 
				order by  client_id,task) as rwnum
		from #prp_poc_planned_final_monthly a where ordr=5
		and EXISTS (select 1 from #prp_poc_planned_final_monthly b where a.fac_id=b.fac_id and a.shift=b.shift and a.task_id=b.task_id and b.ordr=4)) nxt
		on pre.client_id=nxt.client_id and pre.task=nxt.task and pre.rwnum=nxt.rwnum

--Insert summary data. Need to provide output only if either PRN or Unscheduled tasks were checked off

	IF (@vIncludeUnscheduled = 'Y' OR @vIncludePRN = 'Y')
	BEGIN

		INSERT INTO #prp_poc_planned_final_monthly
		(fac_id ,client_id   , client_name , shift  , group_name   , task_id , task    , hour_type   , 
		day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
		day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
		day_31, total , ordr ) 
		select fac_id,client_id,client_name,'Summary' as Shift,group_name,0,'','Planned' as hour_type,
			day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
			day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
			day_31, total, 30 as ordr
		from #prp_poc_planned_final_monthly
		where ordr = 4

		INSERT INTO #prp_poc_planned_final_monthly
		(fac_id ,client_id   , client_name , shift  , group_name   , task_id , task    , hour_type   , 
		day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
		day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
		day_31, total , ordr ) 
		select fac_id,client_id,client_name,'Summary' as Shift,'',0,'','Actual *' as hour_type,sum(day_1) as day_1,sum(day_2) as day_2, sum(day_3) as day_3, 
				sum(day_4) as day_4, sum(day_5) as day_5, sum(day_6) as day_6, sum(day_7) as day_7,sum(day_8) as day_8,sum(day_9) as day_9, sum(day_10) as day_10, 
				sum(day_11) as day_11, sum(day_12) as day_12, sum(day_13) as day_13, sum(day_14) as day_14,sum(day_15) as day_15,sum(day_16) as day_16, sum(day_17) as day_17, 
				sum(day_18) as day_18, sum(day_19) as day_19, sum(day_20) as day_20, sum(day_21) as day_21,sum(day_22) as day_22,sum(day_23) as day_23, sum(day_24) as day_24, 
				sum(day_25) as day_25, sum(day_26) as day_26, sum(day_27) as day_27, sum(day_28) as day_28,sum(day_29) as day_29,sum(day_30) as day_30, sum(day_31) as day_31,  
				sum(total) as total, 31 as ordr
		from #prp_poc_planned_final_monthly
		where ordr = 5 or ordr = 21 or ordr = 11
		group BY fac_id,client_id,client_name

		INSERT INTO #prp_poc_planned_final_monthly
		(fac_id ,client_id   , client_name , shift  , group_name   , task_id , task    , hour_type   , 
		day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
		day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
		day_31, total , ordr ) 
			select @vFacId,pre.client_id,pre.client_name,pre.Shift,pre.group_name,0,'','Planned '+CHAR(45)+' Actual = ' as hour_type,
			(isnull(pre.day_1,0)-isnull(nxt.day_1,0)) as day_1,
			(isnull(pre.day_2,0)-isnull(nxt.day_2,0)) as day_2, 
			(isnull(pre.day_3,0)-isnull(nxt.day_3,0)) as day_3, 
			(isnull(pre.day_4,0)-isnull(nxt.day_4,0)) as day_4, 
			(isnull(pre.day_5,0)-isnull(nxt.day_5,0)) as day_5, 
			(isnull(pre.day_6,0)-isnull(nxt.day_6,0)) as day_6, 
			(isnull(pre.day_7,0)-isnull(nxt.day_7,0)) as day_7,
			(isnull(pre.day_8,0)-isnull(nxt.day_8,0)) as day_8,
			(isnull(pre.day_9,0)-isnull(nxt.day_9,0)) as day_9, 
			(isnull(pre.day_10,0)-isnull(nxt.day_10,0)) as day_10, 
			(isnull(pre.day_11,0)-isnull(nxt.day_11,0)) as day_11, 
			(isnull(pre.day_12,0)-isnull(nxt.day_12,0)) as day_12, 
			(isnull(pre.day_13,0)-isnull(nxt.day_13,0)) as day_13, 
			(isnull(pre.day_14,0)-isnull(nxt.day_14,0)) as day_14, 
			(isnull(pre.day_15,0)-isnull(nxt.day_15,0)) as day_15,
			(isnull(pre.day_16,0)-isnull(nxt.day_16,0)) as day_16, 
			(isnull(pre.day_17,0)-isnull(nxt.day_17,0)) as day_17, 
			(isnull(pre.day_18,0)-isnull(nxt.day_18,0)) as day_18, 
			(isnull(pre.day_19,0)-isnull(nxt.day_19,0)) as day_19, 
			(isnull(pre.day_20,0)-isnull(nxt.day_20,0)) as day_20, 
			(isnull(pre.day_21,0)-isnull(nxt.day_21,0)) as day_21, 
			(isnull(pre.day_22,0)-isnull(nxt.day_22,0)) as day_22,
			(isnull(pre.day_23,0)-isnull(nxt.day_23,0)) as day_23, 
			(isnull(pre.day_24,0)-isnull(nxt.day_24,0)) as day_24, 
			(isnull(pre.day_25,0)-isnull(nxt.day_25,0)) as day_25, 
			(isnull(pre.day_26,0)-isnull(nxt.day_26,0)) as day_26, 
			(isnull(pre.day_27,0)-isnull(nxt.day_27,0)) as day_27, 
			(isnull(pre.day_28,0)-isnull(nxt.day_28,0)) as day_28, 
			(isnull(pre.day_29,0)-isnull(nxt.day_29,0)) as day_29, 
			(isnull(pre.day_30,0)-isnull(nxt.day_30,0)) as day_30, 
			(isnull(pre.day_31,0)-isnull(nxt.day_31,0))as day_31,   
			0 as total,  32 as ordr
			from (select client_id
					,client_name
					,Shift
					,group_name
					,task_id 
					,task
					,day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
					day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
					day_31
				from #prp_poc_planned_final_monthly where ordr=30) pre
				join (select client_id
					,client_name
					,Shift
					,group_name
					,task_id 
					,task
					,day_1 ,day_2 , day_3 , day_4 , day_5 , day_6 , day_7 , day_8 , day_9 , day_10, day_11, day_12, day_13, day_14, day_15, 
					day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24, day_25, day_26, day_27, day_28, day_29, day_30, 
					day_31
				from #prp_poc_planned_final_monthly a where ordr=31) nxt
				on pre.client_id=nxt.client_id and pre.Shift=nxt.Shift		

	END

	if @debug_me='Y' select '#prp_poc_planned_final_monthly', * from #prp_poc_planned_final_monthly;

    update #prp_poc_planned_final_monthly 
       SET total= (day_1 + day_2 + day_3 + day_4 + day_5 + day_6 + day_7 + day_8 + day_9 + day_10 + day_11 + day_12
		    + day_13 + day_14 + day_15 + day_16 + day_17 + day_18 + day_19 + day_20 + day_21 + day_22 + day_23 + day_24 + day_25 + day_26
		    + day_27 + day_28 + day_29 + day_30 + day_31)
	
		Set @vgs_fill_end_time  = getdate() ; -- fill end time

	select @vStep = 50
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' returning final result ' + convert(varchar(26),getdate(),109)

	select 
		fac_id,client_name,Shift,Group_name,case when task='ZZZZ' then 'Total' else task end as discipline,hour_type
	    ,CASE WHEN sum(day_1) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_1) > 0 THEN '+' ELSE '' END END 
	        + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_1)), 0), 114) as day_1
		,CASE WHEN sum(day_2) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_2) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_2)), 0), 114) as day_2
		,CASE WHEN sum(day_3) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_3) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_3)), 0), 114) as day_3
		,CASE WHEN sum(day_4) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_4) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_4)), 0), 114) as day_4 
		,CASE WHEN sum(day_5) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_5) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_5)), 0), 114) as day_5  
		,CASE WHEN sum(day_6) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_6) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_6)), 0), 114) as day_6  
		,CASE WHEN sum(day_7) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_7) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_7)), 0), 114) as day_7  
		,CASE WHEN sum(day_8) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_8) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_8)), 0), 114) as day_8 
		,CASE WHEN sum(day_9) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_9) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_9)), 0), 114) as day_9 
		,CASE WHEN sum(day_10) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_10) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_10)), 0), 114) as day_10 
		,CASE WHEN sum(day_11) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_11) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_11)), 0), 114) as day_11 
		,CASE WHEN sum(day_12) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_12) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_12)), 0), 114) as day_12 
		,CASE WHEN sum(day_13) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_13) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_13)), 0), 114) as day_13 
		,CASE WHEN sum(day_14) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_14) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_14)), 0), 114) as day_14 
		,CASE WHEN sum(day_15) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_15) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_15)), 0), 114) as day_15 
		,CASE WHEN sum(day_16) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_16) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_16)), 0), 114) as day_16 
		,CASE WHEN sum(day_17) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_17) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_17)), 0), 114) as day_17 
		,CASE WHEN sum(day_18) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_18) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_18)), 0), 114) as day_18 
		,CASE WHEN sum(day_19) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_19) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_19)), 0), 114) as day_19 
		,CASE WHEN sum(day_20) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_20) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_20)), 0), 114) as day_20 
		,CASE WHEN sum(day_21) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_21) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_21)), 0), 114) as day_21 
		,CASE WHEN sum(day_22) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_22) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_22)), 0), 114) as day_22 
		,CASE WHEN sum(day_23) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_23) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_23)), 0), 114) as day_23 
		,CASE WHEN sum(day_24) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_24) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_24)), 0), 114) as day_24 
		,CASE WHEN sum(day_25) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_25) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_25)), 0), 114) as day_25 
		,CASE WHEN sum(day_26) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_26) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_26)), 0), 114) as day_26 
		,CASE WHEN sum(day_27) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_27) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_27)), 0), 114) as day_27 
		,CASE WHEN sum(day_28) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_28) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_28)), 0), 114) as day_28 
		,CASE WHEN sum(day_29) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_29) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_29)), 0), 114) as day_29 
		,CASE WHEN sum(day_30) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_30) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_30)), 0), 114) as day_30 
		,CASE WHEN sum(day_31) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(day_31) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(day_31)), 0), 114) as day_31 
		,CASE WHEN sum(Total) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Total) > 0 THEN '+' ELSE '' END END 
		    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Total)), 0), 114) as Total 
		, @status_code as status_code, @status_text as status_text	
	from
	#prp_poc_planned_final_monthly
	group BY fac_id,client_name,Shift,Group_name,task,hour_type,ordr
	order BY 
	client_name,
	case Shift when 'Scheduled' then 1
		when 'PRN' then 2
		when 'No PRN Tasks Documented' then 2
		when 'Unscheduled' then 3
		when 'No Unscheduled Tasks Documented' then 3
		when 'Summary' then 4
	else 5
	end,task,ordr
 
 END
ELSE IF @vType= 2
 BEGIN
 select @vStep = 45
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + 'SHOWING WEEKLY DATA ' + convert(varchar(26),getdate(),109)

  INSERT INTO #prp_poc_planned 
  (fac_id ,client_id   , client_name , shift  , group_name  ,position_id ,position , task_id , task , hour_type   , 
sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)
	select @vFacId,client_id,client_name,Shift,group_name,position_id,position,task_id,task,'Planned' as hour_type,
	isnull([1],0) as Sunday,isnull([2],0) as Monday, isnull([3],0) as Tuesday, isnull([4],0) as Wednesday,
	 isnull([5],0) as Thursday, isnull([6],0) as Friday, isnull([7],0) as Saturday, 0 as total, 0 as ordr
	from
	(select schedule_detail_id ,client_id,client_name ,shift ,group_name,position_id,
  position ,std_intervention_id task_id, intervention_desc task,day_of_week ,total_minutes,timeFlag ,completed_date  from #rowdata where timeFlag=1
	) as rawdata
	PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7])) as pivotdata


	INSERT INTO #prp_poc_planned  (fac_id ,client_id   , client_name , shift  , group_name  ,position_id ,position , task_id , task , hour_type   , 
sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)
	select @vFacId,client_id,client_name,Shift,group_name,position_id,position,task_id,task,'Actual' as hour_type,
	isnull([1],0) as Sunday,isnull([2],0) as Monday, isnull([3],0) as Tuesday, isnull([4],0) as Wednesday,
	 isnull([5],0) as Thursday, isnull([6],0) as Friday, isnull([7],0) as Saturday, 0 as total, 
		  1 ordr
	from
	(select schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,
  position ,std_intervention_id task_id, intervention_desc task,day_of_week ,total_minutes,timeFlag ,completed_date  from #rowdata where timeFlag=2
	) as rawdata
	PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7])) as pivotdata
	
	IF @vIncludeUnscheduled = 'Y'

	INSERT INTO #prp_poc_planned 
	 (fac_id ,client_id   , client_name , shift  , group_name  ,position_id ,position , task_id , task , hour_type   , 
sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)
	select @vFacId,client_id,client_name,Shift,group_name,position_id,position,task_id,task,'Actual' as hour_type,
	[1] as Sunday,[2] as Monday, [3] as Tuesday, [4] as Wednesday, [5] as Thursday, [6] as Friday, 
		[7] as Saturday, 0 as total, 
		  10  as ordr
	from
	(select schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,
  position ,std_intervention_id task_id, intervention_desc task,day_of_week ,total_minutes,timeFlag ,completed_date  from #rowdata where timeFlag=3
	) as rawdata
	PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7])) as pivotdata


	IF @vIncludePRN = 'Y'
	BEGIN
		INSERT INTO #prp_poc_planned 
		 (fac_id ,client_id   , client_name , shift  , group_name  ,position_id ,position , task_id , task , hour_type   , 
		sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)
		select @vFacId,client_id,client_name,Shift,group_name,position_id,position,task_id,task,'Actual' as hour_type,
		[1] as Sunday,[2] as Monday, [3] as Tuesday, [4] as Wednesday, [5] as Thursday, [6] as Friday, 
			[7] as Saturday, 0 as total, 
			  20  as ordr
		from
		(select schedule_detail_id ,client_id,client_name ,shift ,group_name,service_tracking_position_id,position_id,
	  position ,std_intervention_id task_id, intervention_desc task,day_of_week ,total_minutes,timeFlag ,completed_date  from #rowdata where timeFlag=4
		) as rawdata
		PIVOT (SUM(total_minutes) for day_of_week in([1],[2],[3],[4],[5],[6],[7])) as pivotdata

		INSERT INTO #prp_poc_planned (fac_id ,client_id   , client_name , shift  , group_name  , task_id , task , hour_type   , 
		sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)
		select fac_id,client_id,client_name,Shift,group_name,0,'ZZZZ','' as hour_type,sum(Sunday) as Sunday,sum(Monday) as Monday, sum(Tuesday) as Tuesday, 
			sum(Wednesday) as Wednesday, sum(Thursday) as Thursday, sum(Friday) as Friday, sum(Saturday) as Saturday, sum(total) as total, 21 as ordr
		from #prp_poc_planned
		where ordr = 20
		group BY fac_id,client_id,client_name,Shift,group_name

		--insert dummy actual row if the corresponding planned ro has no data
		INSERT INTO #prp_poc_planned
		(fac_id ,client_id   , client_name , shift  , group_name  , task_id , task , hour_type   , 
		sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)
		select distinct planned.fac_id,planned.client_id,planned.client_name,'No PRN Tasks Documented' as Shift,'' as group_name, 0 as position_id,'ZZZZ' as position,'Actual' as hour_type,
			0 as Sunday, 0 as Monday, 0 as Tuesday, 0 as Wednesday, 0 as Thursday, 0 as Friday, 0 as Saturday, 0 as total, 20 as ordr
		from #prp_poc_planned planned WITH (NOLOCK) 
		left JOIN (select client_id from #prp_poc_planned WITH (NOLOCK) where ordr=20 group by client_id) clients 
			ON planned.client_id = clients.client_id and planned.ordr=0
		where planned.ordr=0 and clients.client_id is null

	END

---------------------------------------------------------------------------	
	--insert dummy actual row if the corresponding planned ro has no data
---------------------------------------------------------------------------

		
	INSERT INTO #prp_poc_planned
	(fac_id ,client_id   , client_name , shift  , group_name  ,position_id ,position , task_id , task , hour_type   , 
sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)
	select @vFacId,planned.client_id,planned.client_name,planned.Shift,planned.group_name,planned.position_id,planned.position,planned.task_id,planned.task,'Actual' as hour_type,
		0 as Sunday, 0 as Monday, 0 as Tuesday, 0 as Wednesday, 0 as Thursday, 0 as Friday, 0 as Saturday, 0 as total, 1 as ordr
		from #prp_poc_planned planned
		 where  planned.ordr=0
		  and not exists  (select 1 from #prp_poc_planned actual where  actual.ordr=1 and planned.shift=actual.shift and planned.position_id=actual.position_id and planned.task_id=actual.task_id )
	
	IF @vIncludeUnscheduled = 'Y'
	begin
		
		INSERT INTO #prp_poc_planned (fac_id ,client_id   , client_name , shift  , group_name  , task_id , task , hour_type   , 
sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)
		select fac_id,client_id,client_name,Shift,group_name,0,'ZZZZ','' as hour_type,sum(Sunday) as Sunday,sum(Monday) as Monday, sum(Tuesday) as Tuesday, 
			sum(Wednesday) as Wednesday, sum(Thursday) as Thursday, sum(Friday) as Friday, sum(Saturday) as Saturday, sum(total) as total, 11 as ordr
		from #prp_poc_planned
		where ordr = 10
		group BY fac_id,client_id,client_name,Shift,group_name

		--insert dummy actual row if the corresponding planned ro has no data
		INSERT INTO #prp_poc_planned
		(fac_id ,client_id   , client_name , shift  , group_name  , task_id , task , hour_type   , 
sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)
		select distinct planned.fac_id,planned.client_id,planned.client_name,'No Unscheduled Tasks Documented' as Shift,'' as group_name, 0 as position_id,'ZZZZ' as position,'Actual' as hour_type,
			0 as Sunday, 0 as Monday, 0 as Tuesday, 0 as Wednesday, 0 as Thursday, 0 as Friday, 0 as Saturday, 0 as total, 10 as ordr
		from #prp_poc_planned planned WITH (NOLOCK) 
		left JOIN (select client_id from #prp_poc_planned WITH (NOLOCK) where ordr=10 group by client_id) clients 
			ON planned.client_id = clients.client_id and planned.ordr=0
		where planned.ordr=0 and clients.client_id is null


	end



	--if @debug_me='Y' select * from #prp_poc_planned
	
	update #prp_poc_planned SET total= (isnull(Sunday,0) + isnull(Monday,0) + isnull(Tuesday,0) + isnull(Wednesday,0) + isnull(Thursday,0) + isnull(Friday,0) + isnull(Saturday,0))

	insert into #prp_poc_planned_final
	(fac_id ,client_id   , client_name , shift  , group_name  , task_id , task , hour_type   , 
sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)
select 
@vFacId , client_id , client_name , shift , group_name , task_id , task , hour_type ,
	sum(Sunday) Sunday,sum(Monday) Monday,sum(Tuesday) Tuesday,sum(Wednesday) Wednesday,sum(Thursday) Thursday,
	sum(Friday) Friday,sum(Saturday),sum(total) total,ordr
	from #prp_poc_planned  
		group by client_id , client_name , shift , group_name , task_id , task , hour_type ,ordr
		
		
CREATE  CLUSTERED INDEX _temp1_prp_poc_planned_final on #prp_poc_planned_final(Shift,position,ordr)	

update #prp_poc_planned_final 
 SET total= (isnull(Sunday,0) + isnull(Monday,0) + isnull(Tuesday,0) + isnull(Wednesday,0) + isnull(Thursday,0) + isnull(Friday,0) + isnull(Saturday,0))

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	Set @vgs_fill_end_time  = getdate() ; -- fill end time

	
	update #prp_poc_planned_final SET 
		Sunday = ISNULL(Sunday, 0)
		,Monday = ISNULL(Monday, 0)
		,Tuesday = ISNULL(Tuesday, 0)
		,Wednesday = ISNULL(Wednesday, 0)
		,Thursday = ISNULL(Thursday, 0)
		,Friday = ISNULL(Friday, 0)
		,Saturday = ISNULL(Saturday, 0)



	INSERT INTO #prp_poc_planned_final
	(fac_id ,client_id   , client_name , shift  , group_name  , task_id , task , hour_type   , 
sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)

	select @vFacId,pre.client_id,pre.client_name,pre.Shift,pre.group_name,pre.task_id,pre.task,'Planned '+CHAR(45)+' Actual = ' as hour_type,
	(isnull(pre.Sunday,0)-isnull(nxt.Sunday,0)) as Sunday,
	(isnull(pre.Monday,0)-isnull(nxt.Monday,0)) as Monday, 
	(isnull(pre.Tuesday,0)-isnull(nxt.Tuesday,0)) as Tuesday, 
	(isnull(pre.Wednesday,0)-isnull(nxt.Wednesday,0)) as Wednesday, 
	(isnull(pre.Thursday,0)-isnull(nxt.Thursday,0)) as Thursday, 
	(isnull(pre.Friday,0)-isnull(nxt.Friday,0)) as Friday, 
	(isnull(pre.Saturday,0)-isnull(nxt.Saturday,0)) as Saturday,
	0 as total, 2 as ordr
	from (select client_id
			,client_name
			,Shift
			,group_name
			,task_id 
			,task
			,Sunday
			,Monday
			,Tuesday
			,Wednesday
			,Thursday
			,Friday
			,Saturday
			,ROW_NUMBER() OVER ( PARTITION BY client_id--,position
				order by  client_id,task) as rwnum
		from #prp_poc_planned_final where ordr=0) pre
		join (select client_id
			,client_name
			,Shift
			,group_name
			,task_id 
			,task
			,Sunday
			,Monday
			,Tuesday
			,Wednesday
			,Thursday
			,Friday
			,Saturday
			,ROW_NUMBER() OVER ( PARTITION BY client_id--,position 
				order by  client_id,task) as rwnum
		from #prp_poc_planned_final a where ordr=1
		and EXISTS (select 1 from #prp_poc_planned_final b where a.fac_id=b.fac_id and a.shift=b.shift and a.task_id=b.task_id and b.ordr=0)) nxt
		on pre.client_id=nxt.client_id and pre.task=nxt.task and pre.rwnum=nxt.rwnum

	update #prp_poc_planned_final SET total= (Sunday + Monday + Tuesday + Wednesday + Thursday + Friday + Saturday)

	INSERT INTO #prp_poc_planned_final
	(fac_id ,client_id   , client_name , shift  , group_name  , task_id , task , hour_type   , 
sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)
	select fac_id,client_id,client_name,Shift,group_name,0,'ZZZZ','Planned' as hour_type,sum(Sunday) as Sunday,sum(Monday) as Monday, sum(Tuesday) as Tuesday, 
		sum(Wednesday) as Wednesday, sum(Thursday) as Thursday, sum(Friday) as Friday, sum(Saturday) as Saturday, sum(total) as total, 4 as ordr
	from #prp_poc_planned_final
	where ordr = 0
	group BY fac_id,client_id,client_name,Shift,group_name

	INSERT INTO #prp_poc_planned_final
	(fac_id ,client_id   , client_name , shift  , group_name  , task_id , task , hour_type   , 
sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)
	select fac_id,client_id,client_name,Shift,group_name,0,'ZZZZ','Actual' as hour_type,sum(Sunday) as Sunday,sum(Monday) as Monday, sum(Tuesday) as Tuesday, 
		sum(Wednesday) as Wednesday, sum(Thursday) as Thursday, sum(Friday) as Friday, sum(Saturday) as Saturday, sum(total) as total, 5 as ordr
	from #prp_poc_planned_final
	where ordr = 1 or ordr = 3
	group BY fac_id,client_id,client_name,Shift,group_name



	INSERT INTO #prp_poc_planned_final
	(fac_id ,client_id   , client_name , shift  , group_name  , task_id , task , hour_type   , 
sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)

	select @vFacId,pre.client_id,pre.client_name,pre.Shift,pre.group_name,pre.task_id,pre.task,'Planned '+CHAR(45)+' Actual = ' as hour_type,
	(isnull(pre.Sunday,0)-isnull(nxt.Sunday,0)) as Sunday,
	(isnull(pre.Monday,0)-isnull(nxt.Monday,0)) as Monday, 
	(isnull(pre.Tuesday,0)-isnull(nxt.Tuesday,0)) as Tuesday, 
	(isnull(pre.Wednesday,0)-isnull(nxt.Wednesday,0)) as Wednesday, 
	(isnull(pre.Thursday,0)-isnull(nxt.Thursday,0)) as Thursday, 
	(isnull(pre.Friday,0)-isnull(nxt.Friday,0)) as Friday, 
	(isnull(pre.Saturday,0)-isnull(nxt.Saturday,0)) as Saturday,  
	0 as total, 6 as ordr
	from (select client_id
			,client_name
			,Shift
			,group_name
			,task_id 
			,task
			,Sunday
			,Monday
			,Tuesday
			,Wednesday
			,Thursday
			,Friday
			,Saturday
			,ROW_NUMBER() OVER ( PARTITION BY client_id--,position
				order by  client_id,task) as rwnum
		from #prp_poc_planned_final where ordr=4) pre
		join (select client_id
			,client_name
			,Shift
			,group_name
			,task_id 
			,task
			,Sunday
			,Monday
			,Tuesday
			,Wednesday
			,Thursday
			,Friday
			,Saturday
			,ROW_NUMBER() OVER ( PARTITION BY client_id--,position 
				order by  client_id,task) as rwnum
		from #prp_poc_planned_final a where ordr=5
		and EXISTS (select 1 from #prp_poc_planned_final b where a.fac_id=b.fac_id and a.shift=b.shift and a.task_id=b.task_id and b.ordr=4)) nxt
		on pre.client_id=nxt.client_id and pre.task=nxt.task and pre.rwnum=nxt.rwnum


--Insert summary data. Need to provide output only if either PRN or Unscheduled tasks were checked off

IF (@vIncludeUnscheduled = 'Y' OR @vIncludePRN = 'Y')
BEGIN
		INSERT INTO #prp_poc_planned_final
		(fac_id ,client_id   , client_name , shift  , group_name  , task_id , task , hour_type   , 
		sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)
		select fac_id,client_id,client_name,'Summary' as Shift,group_name,0,'','Planned' as hour_type,
			sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , 30 as ordr
		from #prp_poc_planned_final
		where ordr = 4

		INSERT INTO #prp_poc_planned_final
		(fac_id ,client_id   , client_name , shift  , group_name  , task_id , task , hour_type   , 
		sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)
		select fac_id,client_id,client_name,'Summary' as Shift,'' as group_name,0,'','Actual *' as hour_type,
			sum(Sunday) as Sunday,sum(Monday) as Monday, sum(Tuesday) as Tuesday, 
			sum(Wednesday) as Wednesday, sum(Thursday) as Thursday, sum(Friday) as Friday, sum(Saturday) as Saturday, sum(total) as total, 31 as ordr
		from #prp_poc_planned_final
		where ordr = 5 or ordr = 21 or ordr = 11
		group BY fac_id,client_id,client_name
		
		
		INSERT INTO #prp_poc_planned_final
		(fac_id ,client_id   , client_name , shift  , group_name  , task_id , task , hour_type   , 
		sunday , monday , tuesday , wednesday , thursday , friday , saturday , total , ordr)

		select @vFacId,pre.client_id,pre.client_name,pre.Shift,pre.group_name,pre.task_id,pre.task,'Planned '+CHAR(45)+' Actual = ' as hour_type,
		(isnull(pre.Sunday,0)-isnull(nxt.Sunday,0)) as Sunday,
		(isnull(pre.Monday,0)-isnull(nxt.Monday,0)) as Monday, 
		(isnull(pre.Tuesday,0)-isnull(nxt.Tuesday,0)) as Tuesday, 
		(isnull(pre.Wednesday,0)-isnull(nxt.Wednesday,0)) as Wednesday, 
		(isnull(pre.Thursday,0)-isnull(nxt.Thursday,0)) as Thursday, 
		(isnull(pre.Friday,0)-isnull(nxt.Friday,0)) as Friday, 
		(isnull(pre.Saturday,0)-isnull(nxt.Saturday,0)) as Saturday,  
		0 as total, 32 as ordr
		from (select client_id
				,client_name
				,Shift
				,group_name
				,task_id 
				,task
				,Sunday
				,Monday
				,Tuesday
				,Wednesday
				,Thursday
				,Friday
				,Saturday
			from #prp_poc_planned_final where ordr=30) pre
			join (select client_id
				,client_name
				,Shift
				,group_name
				,task_id 
				,task
				,Sunday
				,Monday
				,Tuesday
				,Wednesday
				,Thursday
				,Friday
				,Saturday
			from #prp_poc_planned_final a where ordr=31) nxt
			on pre.client_id=nxt.client_id and pre.Shift=nxt.Shift

END
	
		update #prp_poc_planned_final 
		SET total= (isnull(Sunday,0) + isnull(Monday,0) + isnull(Tuesday,0) + isnull(Wednesday,0) + isnull(Thursday,0) + isnull(Friday,0) + isnull(Saturday,0))

	Set @vgs_fill_end_time  = getdate() ; -- fill end time

	select @vStep = 50
	set @vgsStepStartTime = GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' returning final result ' + convert(varchar(26),getdate(),109)

	
	select fac_id,client_name,Shift,Group_name,case when task='ZZZZ' then 'Total' else task end as discipline,hour_type
	,CASE WHEN sum(Sunday) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Sunday) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Sunday)), 0), 114) as Sunday
	,CASE WHEN sum(Monday) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Monday) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Monday)), 0), 114) as Monday
	,CASE WHEN sum(Tuesday) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Tuesday) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Tuesday)), 0), 114) as Tuesday
	,CASE WHEN sum(Wednesday) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Wednesday) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Wednesday)), 0), 114) as Wednesday
	,CASE WHEN sum(Thursday) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Thursday) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Thursday)), 0), 114) as Thursday
	,CASE WHEN sum(Friday) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Friday) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Friday)), 0), 114) as Friday
	,CASE WHEN sum(Saturday) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Saturday) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Saturday)), 0), 114) as Saturday
	,CASE WHEN sum(Total) < 0 THEN '-' ELSE CASE WHEN hour_type = 'Planned - Actual = ' AND sum(Total) > 0 THEN '+' ELSE '' END END 
	    + CONVERT(varchar(5), DATEADD(minute, abs(sum(Total)), 0), 114) as Total
	, @status_code as status_code, @status_text as status_text	
	from
	#prp_poc_planned_final
	group BY fac_id,client_name,Shift,Group_name,task,hour_type,ordr
	order BY 
	client_name,
	case Shift when 'Scheduled' then 1
		when 'PRN' then 2
		when 'No PRN Tasks Documented' then 2
		when 'Unscheduled' then 3
		when 'No Unscheduled Tasks Documented' then 3
		when 'Summary' then 4
	else 5
	end,task,ordr


	Set @rows_returned = @@ROWCOUNT;


 END

             
	
		
	select @vStep = 90	
	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	
	--*********************************************************************************************************


	

	Set @rows_returned = @@ROWCOUNT;

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	if @debug_me='Y' Print 'Successful execution of stored procedure ' + Object_name(@@ProcID) + convert(varchar(26),getdate(),109);

END TRY 

BEGIN CATCH 
	if @status_code = 0 Set @Status_Code = 1 else set @status_code = 2  --- convert 3 to 2
	if @status_code = 1
	BEGIN
		select @Status_Text = Rtrim(Left('Stored Procedure Failed with error Code : ' +   Cast(@@error as Varchar(10)) +  ' Line Number : ' +  Cast(ERROR_LINE() as Varchar(5)) + ' ' +  ERROR_MESSAGE(),3000))

		if @debug_me='Y' Print 'Stored procedure failure in step:'+ convert(varchar(3),@vstep) + '	' + convert(varchar(26),getdate())
		if @debug_me='Y' Print 'Error code: '+convert(varchar(3),@vStep) + '; Error description:	' + @Status_Text
	END 
 if @vtype=1
	Select 
		  NULL as fac_id
		, NULL as client_name
		, NULL as Shift
		, NULL as Group_name
		, NULL as discipline
		, NULL as hour_type
		, NULL as day_1
		, NULL as day_2
		, NULL as day_3
		, NULL as day_4
		, NULL as day_5
		, NULL as day_6
		, NULL as day_7
		, NULL as day_8
		, NULL as day_9
		, NULL as day_10
		, NULL as day_11
		, NULL as day_12
		, NULL as day_13
		, NULL as day_14
		, NULL as day_15
		, NULL as day_16
		, NULL as day_17
		, NULL as day_18
		, NULL as day_19
		, NULL as day_20
		, NULL as day_21
		, NULL as day_22
		, NULL as day_23
		, NULL as day_24
		, NULL as day_25
		, NULL as day_26
		, NULL as day_27
		, NULL as day_28
		, NULL as day_29
		, NULL as day_30
		, NULL as day_31 
		, NULL as Total
		, @status_code as status_code
		, @status_text as status_text
 ELSE
		Select 
		NULL as fac_id
		, NULL as client_name
		, NULL as Shift
		, NULL as Group_name
		, NULL as discipline
		, NULL as hour_type
		, NULL as task
		, NULL as Sunday
		, NULL as Monday
		, NULL as Tuesday
		, NULL as Wednesday
		, NULL as Thursday 
		, NULL as Friday
		, NULL as Saturday
		, NULL as Total
		, @status_code as status_code
		, @status_text as status_text
END CATCH 

RETURN 

END
GO
GRANT EXECUTE ON  dbo.sproc_prp_rl_poc_planned_actual_service_time_Task_client   to PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_prp_rl_poc_planned_actual_service_time_Task_client.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_poc_planned_actual_service_time_Task_client.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_rent_roll_report3.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*
===================================================================================================== 
PCC-54915:             Script to create [sproc_prp_rl_rent_roll_report3] Procedure  in Client Database

Written By:            Dominic Christie
Reviewed By:         
 
PCC-96830:             Migrate Stored Procedures
Revision By:           Thomas Kim
Reviewed By:    

Script Type:           DDL 
Target DB Type:        Client Database
Target ENVIRONMENT:    BOTH
 
Re-Runable:            YES
 
Description of Script: Display rent charges for beds in all rooms.
 
Special Instruction:  
=====================================================================================================
*/

IF EXISTS ( SELECT   ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_prp_rl_rent_roll_report3' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE dbo.sproc_prp_rl_rent_roll_report3
END
GO

CREATE Procedure dbo.sproc_prp_rl_rent_roll_report3  
	  @fac_id INT
	, @room_status VARCHAR(2500)
	, @show_empty_companion_beds BIT
	, @show_occupied_companion_beds BIT
	, @living_unit_id INT
	, @effective_date DATETIME
	, @execution_user_login VARCHAR(60)
	, @enforce_max_weight_flag BIT
	, @order_by INT = 0					-- 0(default) - by room, 1 - by last name, 2 - by first name
	, @report_format_type VARCHAR(3)	-- pdf or csv
	, @emc_flag BIT = 0
	, @rows_returned INT OUT
	, @debug_me CHAR(1) = 'N'
	, @status_code INT  OUT
	, @status_text VARCHAR(3000) OUT
  
/****************************************************************************************************  
--SAMPLE EXECUTION SCRIPT  
  
DECLARE @rows_ret int, @statuscode int, @statustext VARCHAR(3000);
EXEC dbo.sproc_prp_rl_rent_roll_report3
	@fac_id = 1,
	@room_status = '-1',
	@show_empty_companion_beds = 1,
	@show_occupied_companion_beds = 1,
	@living_unit_id = -1,
	@effective_date = '2020-07-30',
	@execution_user_login = 'pcc-parras',	-- use your pcc login here or script won't return any results
	@enforce_max_weight_flag = 1,
	@order_by = 0,							-- 0(default) - by room, 1 - by last name, 2 - by first name
	@report_format_type = 'pdf',			-- if not pdf, then csv
	@emc_flag = 0,
	@rows_returned = 0,
	@debug_me = 'Y',
	@status_code = null,
	@status_text = null;
SELECT @rows_ret, @statuscode int, @statustext;
*****************************************************************************************************/  

AS
BEGIN

SET NOCOUNT ON;  

--DECLARE Standard local variables required for any store proc  
DECLARE @vStep INT  
	,@vErr VARCHAR(MAX)  
	,@vRowCount INT  
	,@vLivingUnitID INT  
	,@vEffectiveDate DATETIME = CONVERT(DATE, @effective_date)	 -- truncate time
	,@vFirstDay DATETIME  
	,@vEndOfMonth DATETIME  
	,@vRoomStatus VARCHAR(2500)   
	,@vTotalDaysInMonth INT
	,@Today DATETIME = CONVERT(DATE, GETDATE())
	;
----Local Variables  
DECLARE @vFacId int  
	,@vReportId int  
	,@vCHARNewLine  CHAR(2)  
	,@vdelim CHAR(1)  
	,@visemc BIT  
	,@vselected_parameters VARCHAR(4000)
	,@vDefaultPayerID INT
	,@vDefaultEmptyBedScheduleID INT
	,@vZeroWeightRateId INT
	,@vDefaultSecurityDepositPayerId INT
;  
  
DECLARE @vFacIDs VARCHAR(max);
DECLARE @PRP_FacList as table(FacId int);
DECLARE @vFacWarningMsg VARCHAR(max);
DECLARE @vOrderBy INT = @order_by;
  
-----Governor and Statistics Variables   
DECLARE
	 @vgs_program_name VARCHAR(200) = Object_name(@@ProcID)  ---Current Store Proc Name  
	,@vgs_executiON_user VARCHAR(60)  
	,@vgs_fill_END_time DATETIME  
	,@vGeneric_statuscode int   
	,@vGeneric_statustext VARCHAR(3000)  
	,@vgsStepStartTime DATETIME  
	,@vgsTotalStartTime DATETIME  
	,@vgsFacID VARCHAR(max)		
	,@vgsParamName1 VARCHAR(12) 
	,@vgsParamValue1 VARCHAR(2500) 
	,@vgsParamName2 VARCHAR(19) 
	,@vgsParamValue2 VARCHAR(254) 
	,@vgsParamName3 VARCHAR(25)
	,@vgsParamValue3 VARCHAR(17)
	;

DECLARE 
	  @exclStatusType       CHAR (1)    = 'V'
	, @exclActionDischarge  VARCHAR(10) = 'Discharge'
	, @exclActionDeath		VARCHAR(10) = 'Death'
	;

BEGIN TRY

	SET @vStep = 1;
	SET @vgsStepStartTime = GETDATE();
	SET @vgsTotalStartTime = @vgsStepStartTime;
	IF @debug_me='Y'
	BEGIN
		IF @vgs_program_name IS NULL
			SET @vgs_program_name = 'SprocCodeTest'

		PRINT 'Executing store proc :  ' + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Set vars and Getting Parameter Details for Statistics Logging and Report Selection Header :  ' + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);
	END

	IF (@fac_id IS NULL  
		OR @execution_user_login IS NULL
		OR @living_unit_id IS NULL
		OR @effective_date IS NULL
		OR @room_status IS NULL
		)
	BEGIN
		SET @vErr = 'One or more of the following input parameters is invalid... '  
			+ ' @fac_id=' + isNULL(CONVERT(VARCHAR(10),@fac_id),'NULL/empty')  
			+ ', @execution_user_login=' + isNULL(@execution_user_login,'NULL/empty')  
			+ ', @living_unit_id=' + isNULL(CONVERT(VARCHAR(10),@living_unit_id),'NULL/empty')  
			+ ', @effective_date=' + isNULL(CONVERT(VARCHAR(26),@effective_date,109),'NULL/empty')  
			+ ', @room_status=' + isNULL(@room_status,'NULL/empty');
  
		RAISERROR (@vErr -- Message text  
					,11 -- Severity (RAISERROR with severity 11-19 will cause executiON to jump to the CATCH block)  
					,1 -- State  
			);  
	END  
  
	--SET Standard variables
	SET @status_code = 0;   ---- Status Code 0 = Success, 1 = Exception  
	SET @status_text = NULL;  
	SET @rows_returned = 0;  
	SET @vgs_execution_user = @execution_user_login; 
	SET @vdelim = ','
	SET @vCHARNewLine  = CHAR(13) + CHAR(10); 

	----Parameter Sniffing - use local variables when they are used in a where clause  
	SET @vFacID = @fac_id;
	SET @vLivingUnitID = @living_unit_id;  
	SET @vRoomStatus = @room_status;
	SET @vFirstDay = DATEADD(DAY, 1, EOMONTH(@vEffectiveDate, -1));
	SET @vEndOfMonth = DATEADD(DAY, 1, EOMONTH(@vEffectiveDate));
	SET @vEndOfMonth = DATEADD(SECOND, -1, @vEndOfMonth);

	SET @vTotalDaysInMonth = DAY(EOMONTH(@vEffectiveDate));
	-- set all the parameter name for statistics logging and for the Report Selection Header

	IF (@debug_me = 'Y')
		SELECT '@vEndOfMonth', @vEndOfMonth;

	SET @vgsParamName1  = 'Status';
	SET @vgsParamValue1 = IIF(@vRoomStatus = '-1', 'All', @vRoomStatus);

	SELECT @vgsParamName2 = term_room + ' Type'	
	FROM [dbo].fn_prp_get_terminology(@vFacID, @emc_flag) 
	WHERE fac_id=@vFacID 

	SELECT @vgsParamName3 = 'Show Companion ' + term_beds
	FROM [dbo].fn_prp_get_terminology(@vFacID, @emc_flag) 
	WHERE fac_id = @vFacID;

	SET @vgsParamValue3 =	CASE
								WHEN @show_empty_companion_beds = 1 AND @show_occupied_companion_beds = 1 
									THEN 'All'
								WHEN @show_empty_companion_beds = 1 OR @show_occupied_companion_beds = 1 
									THEN IIF(@show_empty_companion_beds = 1, 'Empty', 'Occupied')
								ELSE 'None'
							END;

	--Get default private payer for the facility
	SET @vDefaultPayerID = (
		SELECT TOP(1) default_payer_id
		FROM ar_configuration
		WHERE (fac_id = @fac_Id	OR fac_id = -1)
			AND default_payer_id IS NOT NULL
	);

	IF @debug_me = 'Y'
		SELECT '@vDefaultPayerID', @vDefaultPayerID

	SET @vDefaultSecurityDepositPayerId = (
		SELECT TOP(1) default_security_deposit_payer_id
		FROM ar_configuration
		WHERE (fac_id = @fac_Id	OR fac_id = -1)
			AND default_security_deposit_payer_id IS NOT NULL
	);
	IF @vLivingUnitID=-1
		SELECT @vgsParamValue2 = 'All';
	ELSE 
		SELECT @vgsParamValue2 = item_Description
		FROM common_code
		WHERE item_code='rtype'
			AND deleted='N'
			AND item_id=@vLivingUnitID

	SELECT @vselected_parameters = '    ' + @vgsParamName2 + ': ' + @vgsParamValue2 
		+ '    ' + @vgsParamName1 + ': ' +  @vgsParamValue1
		+ '    ' + @vgsParamName3 + ': ' +  @vgsParamValue3

	IF @debug_me='Y'
	BEGIN
		PRINT 'selected_parameters:' + @vselected_parameters;
		PRINT 'STEP ' +  CONVERT(VARCHAR(20), @vStep) + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';
	END;


	SET @vStep = 2; 
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep)
			+ ' Getting user access fac list '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);
  
	 SELECT  @vFacIds = fac_id, @vFacWarningMsg = msg
	 FROM  dbo.fn_prp_get_facility_access_list_delim(@fac_id,@vgs_execution_user); ---filter the fac list with user access  

	 IF @debug_me='Y'
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep)
			+ ' Facilities returned=[' + isNULL(@vFacIds,'NULL') + '] Facility access warning message=[' + isNULL(@vFacWarningMsg,'') + '] ' + CONVERT(VARCHAR(26),getdate(),109);
  
	 --facilities warnings  
	 IF @vFacWarningMsg is NOT NULL --- NOT NULL means restricted facilities access warning message  
	 BEGIN  
	  SET @status_code = 2; ----Set it to warning status  
	  SET @status_text = isNULL(@status_text,'') + @vFacWarningMsg;  
	 END   
  
	--fill facids into @PRP_FacList   
	 SELECT  @vFacId = Cast(items as int)
	 FROM dbo.Split(@vFacIds,@vDelim);  ----ONly ONe FacId is expected at a time

	 IF @@ROWCOUNT = 0  ---- only if there is any FacCount proceed further  
	 BEGIN  
	  IF @status_code = 0 
		SET @status_code = 3; --Set it to error status  
	  RAISERROR( @status_text,11,1);  
	 END   
  
	if @debug_me='Y' Print 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: ' + LTRIM(RTRIM(STR(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';
  
  
	SET @vStep = 3;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y'
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep)
			+ ' Creating Temp Tables and Table Variables Required for The Proc '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

	DECLARE @room_sum_for_jrxml TABLE
		(room_id					INT
		,total_market_rate			MONEY
		,total_actual_rate			MONEY
		,total_discount				MONEY
		,total_deposit_received		MONEY
		,bed_count					INT
		,total_occupied_weight		FLOAT
		);

	DECLARE @availableOccupiedDays TABLE (
		  bed_id         INT
		, occupied_days  INT
		, available_days INT
	);

	CREATE TABLE #RentRollData
		(fac_id INT  
		,room_id INT  
		,bed_id INT
		,client_id INT
		,room_desc VARCHAR(60)  
		,bed_desc VARCHAR(30)  
		,room_type  VARCHAR(250)  
		,sq_footage INT  
		,market_rate  MONEY
		,actual_rate  MONEY
		,room_rate VARCHAR(50)   
		,rate_type_id INT
		,weight float
		,primary_payer_name VARCHAR(50)
		,discount MONEY
		,deposit_required BIT
		,deposit_amount MONEY
		,deposit_received MONEY  
		,lease_start_date DATETIME   
		,lease_end_date DATETIME 
		,estimated_move_out DATETIME
		,occupied_days INT DEFAULT(0)
		,vacant_days INT DEFAULT(0)
		,bed_status  VARCHAR(250) 
		,bed_status_id CHAR(1) DEFAULT(0) 
		,room_status  VARCHAR(250)
		,bed_count INT 
		,inactive_no_show BIT
		,inactive_Days SMALLINT
		-----------These Columns are added to facilitate the summary calculation in JRXML
		,is_unit_occupied INT  
		,is_bed_occupied INT 
		,occupied_market_rate MONEY
		,occupied_actual_rate MONEY
		,occupied_discount MONEY
		,occupied_sq_footage  INT
		,occupied_bed_id INT
		,occupied_room_id INT
		,total_deposit_required  MONEY  
		,Status_type VARCHAR(150)
		,is_bed_addnl_bed BIT 
		,is_bed_addnl_row_UPT BIT
		,is_rv_weight_1  CHAR(1)   DEFAULT(0) 
		,is_market_rate BIT
		,is_companion BIT
		,anniversary_date DATETIME
		,is_incomplete_census BIT
		);  
  
	IF @debug_me='Y'
		PRINT 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';
  
  
	SET @vStep = 4;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep)
			+ ' Getting Default Rates and Dates for Rooms '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

	--Get standard schedule ID

	SELECT @vDefaultEmptyBedScheduleID = (
		SELECT TOP 1 alrs.schedule_id 
		FROM dbo.ar_lib_rate_schedule alrs WITH (NOLOCK)
			JOIN ar_rate_schedule ars WITH (NOLOCK)
				ON ars.schedule_id = alrs.schedule_id
					AND ars.fac_id = @vFacID
			JOIN ar_rate_status arss WITH (NOLOCK)
				ON arss.payer_id = @vDefaultPayerID
					AND arss.fac_id = ars.fac_id
					AND arss.schedule_id = ars.schedule_id
		WHERE alrs.deleted = 'N' 
			AND ((alrs.reg_id IS NULL AND (alrs.fac_id = '-1' OR alrs.fac_id = @vFacID)) OR (alrs.reg_id IS NOT NULL))
			AND alrs.description LIKE 'Standard%' 
		ORDER BY alrs.schedule_id
	);

	IF @vDefaultEmptyBedScheduleID IS NULL
	BEGIN
		SELECT @vDefaultEmptyBedScheduleID = (
			SELECT TOP 1 alrs.schedule_id 
			FROM dbo.ar_lib_rate_schedule alrs WITH (NOLOCK)
				JOIN ar_rate_schedule ars WITH (NOLOCK)
					ON ars.schedule_id = alrs.schedule_id
						AND ars.fac_id = @vFacID
				JOIN ar_rate_status arss WITH (NOLOCK)
					ON arss.payer_id = @vDefaultPayerID
						AND arss.fac_id = ars.fac_id
						AND arss.schedule_id = ars.schedule_id
			WHERE alrs.deleted = 'N' 
				AND ((alrs.reg_id IS NULL AND (alrs.fac_id = '-1' OR alrs.fac_id = @vFacID)) OR (alrs.reg_id IS NOT NULL))
			ORDER BY alrs.schedule_id
			);
	END;

	IF @debug_me = 'Y'
		SELECT '@vDefaultEmptyBedScheduleID', @vDefaultEmptyBedScheduleID;

	SELECT TOP (1) @vZeroWeightRateId = r.rate_type_Id
	FROM ar_rate_type_category c
		JOIN  ar_lib_rate_type l
			ON l.category_id = c.category_id
				AND l.deleted = 'N'
		JOIN ar_rate_type r
			ON r.rate_type_id = l.rate_type_id
				AND r.fac_id = @vFacId
	WHERE c.weight = 0
		AND c.deleted = 'N'
	ORDER BY r.rate_type_Id
	;

	IF @debug_me = 'Y'
		SELECT '@vZeroWeightRateId', @vZeroWeightRateId;

	IF @debug_me = 'Y'
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms ';


	SET @vStep = 5;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y'
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Handling the Inactive Beds '  + @vgs_program_name  + CONVERT(VARCHAR(26),GETDATE(),109);

	SELECT bed_id
		, inactive_days = DATEDIFF(dd, IIF(@vFirstDay > startdate, @vFirstDay, startdate), IIF(enddate IS NULL OR enddate > @vEffectiveDate , @vEffectiveDate, enddate)) + 1
	INTO #InactiveBeds
	FROM dbo.bed_state WITH (NOLOCK)
	WHERE deleted = 'N'
		AND startdate <= @vEffectiveDate
		AND (enddate IS NULL OR enddate > @vFirstDay)
		AND fac_id = @vFacID
	;

	SELECT bed_id
		, inactive_days = SUM(inactive_days)
	INTO #InactiveBedDays
	FROM #InactiveBeds
	GROUP BY bed_id
	;

	IF @debug_me = 'Y'
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms ';


	SET @vStep = 6;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Getting the Details for OCCUPIED Beds/Clients Rate '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

	SELECT room.fac_id
		, room.room_id
		, room.room_desc
		, bed.bed_id
		, bed.bed_Desc
		, roomtype.item_description
		, room.square_footage
		, rdr.deposit_required
		, rdr.deposit_amount
		, rdr.rate_type_id
		, total_deposit_required = IIF(rdr.deposit_required = 0, NULL, rdr.deposit_amount)
		, ib.inactive_days
	INTO #RoomBed
	FROM dbo.room WITH (NOLOCK)
		JOIN dbo.bed WITH (NOLOCK)
			ON bed.room_id = room.room_id
				AND bed.fac_id = room.fac_id
				AND bed.deleted = 'N'
				AND (bed.retired_date IS NULL OR bed.retired_date > @vEffectiveDate)
		JOIN dbo.room_date_range rdr WITH (NOLOCK)
			ON rdr.room_id = room.room_id
				AND rdr.deleted = 'N'
				AND rdr.effective_Date <= @vEffectiveDate
				AND (rdr.ineffective_date IS NULL OR rdr.ineffective_Date >= @vEffectiveDate)
		LEFT JOIN dbo.common_code roomtype WITH (NOLOCK)
			ON rdr.accommodation_id = roomtype.item_id
				AND roomtype.deleted='N'
				AND item_code = 'rtype'
		LEFT JOIN #InactiveBedDays ib
			ON ib.bed_id = bed.bed_id
				AND ib.inactive_days >= @vTotalDaysInMonth
	WHERE (@vLivingUnitID = -1 OR roomtype.item_id = @vLivingUnitID) --either ALL or specIFic
		AND room.fac_id = @vFacID
		AND room.deleted = 'N'
		AND ib.bed_id IS NULL
	;

	IF (@debug_me = 'Y')
		SELECT '#RoomBed', * 
		FROM #RoomBed
		ORDER BY room_id, bed_id;

	SELECT crpair.client_id
		, crpair.c_census_id
		, r_census_id = IIF(c.incomplete = 'Y', NULL, crpair.r_census_id)
		, c.status_code_id
		, c.action_code_id
		, c.bed_id
		, status_type = statusCode.action_type
		, actCode.action_type
		, r.actual_accomm_id
		, r.eff_schedule_id
		, c.primary_payer_id
		, primary_payer_name = lpay.description
		, ars.schedule_id
		, r.rugs_code
		, r.alternate_care_level
		, c_effective_date = c.effective_date
		, c_ineffective_date = c.ineffective_date
		, c.incomplete
	    , r_effective_date = r.effective_date
	INTO #CensusDetails
	FROM dbo.fn_census_flattenedFacilitySummary(@vFacID, @vEndOfMonth) crpair
		JOIN census_item c WITH (NOLOCK)
			ON c.census_id = crpair.c_census_id
				AND c.status_code_id NOT IN (-1, 17)
				AND c.effective_date <= @vEndOfMonth
				AND c.deleted = 'N'
		JOIN census_codes statusCode WITH (NOLOCK)
			ON statusCode.item_id = c.status_code_id 
				AND statusCode.deleted = 'N'
				AND statusCode.action_type <> @exclStatusType
		JOIN census_codes actCode WITH (NOLOCK)
			ON actCode.item_id = c.action_code_id 
				AND actCode.deleted = 'N'
				AND (actCode.action_type IS NULL OR actCode.action_type NOT IN (@exclActionDischarge, @exclActionDeath))
		LEFT JOIN census_item r WITH (NOLOCK)
			ON r.census_id = crpair.r_census_id
				AND r.deleted = 'N'
		LEFT JOIN ar_lib_payers lpay WITH (NOLOCK)
			ON lpay.payer_id = c.primary_payer_id
				AND lpay.deleted = 'N'
		LEFT JOIN dbo.ar_rate_status ars WITH (NOLOCK)
			ON ars.status_id = c.status_code_id
				AND ars.fac_id = c.fac_id
				AND ars.payer_id = c.primary_payer_id
	WHERE crpair.stop_billing_flag = 0
	;

	IF (@debug_me = 'Y')
		SELECT '#CensusDetails', * 
		FROM #CensusDetails
		ORDER BY client_id, c_census_id, bed_id;

	SELECT flat.client_id
		, flat.c_census_id
		, flat.r_census_id
		, flat.status_code_id
		, flat.action_code_id
		, flat.status_type
		, flat.action_type
		, flat.bed_id
		, flat.actual_accomm_id
		, flat.eff_schedule_id
		, flat.primary_payer_id
		, flat.primary_payer_name
		, flat.schedule_id
		, flat.rugs_code
		, flat.alternate_care_level
		, flat.c_effective_date
		, flat.c_ineffective_date
		, is_secondary_bed = 0
		, flat.incomplete
	    , flat.r_effective_date
	INTO #CensusPrimarySecondaryBeds
	FROM #CensusDetails flat
	UNION ALL
	SELECT flat.client_id
		, flat.c_census_id
		, flat.r_census_id
		, flat.status_code_id
		, flat.action_code_id
		, flat.status_type
		, flat.action_type
		, secc.bed_id
		, secr.actual_accomm_id
		, secr.eff_schedule_id
		, flat.primary_payer_id
		, flat.primary_payer_name
		, flat.schedule_id
		, flat.rugs_code
		, flat.alternate_care_level
		, flat.c_effective_date
		, flat.c_ineffective_date
		, is_secondary_bed = 1
		, flat.incomplete
	    , flat.r_effective_date
	FROM #CensusDetails flat
		JOIN census_item_secondary_bed secc WITH (NOLOCK)
			ON secc.census_id = flat.c_census_id
		LEFT JOIN census_item_secondary_rate secr WITH (NOLOCK)
			ON secr.census_id = flat.r_census_id
	;

	SELECT psbed.client_id
		, psbed.c_census_id
		, psbed.r_census_id
		, psbed.c_effective_date
		, psbed.c_ineffective_date
		, psbed.status_type
		, psbed.action_type
		, psbed.actual_accomm_id
		, psbed.eff_schedule_id
		, psbed.is_secondary_bed
		, psbed.primary_payer_id
		, psbed.primary_payer_name
		, psbed.schedule_id
		, psbed.rugs_code
		, psbed.alternate_care_level
		, psbed.bed_id
		, bed.room_id
		, rtc.weight
		, lrt.rate_type_id
		, rate_type_description = lrt.long_description
		, bed_row_num = ROW_NUMBER() OVER (PARTITION BY psbed.bed_id ORDER BY psbed.c_effective_date DESC) -- latest client in count, others ignored
		, psbed.incomplete
	    , psbed.r_effective_date
	INTO #CensusBedWeightFiltered
	FROM #CensusPrimarySecondaryBeds psbed
		JOIN #RoomBed bed
			ON bed.bed_id = psbed.bed_id
		LEFT JOIN ar_lib_rate_type lrt WITH (NOLOCK)
			ON lrt.rate_type_id = psbed.actual_accomm_id
				AND lrt.deleted = 'N' 
				AND lrt.version_flag = 1
		LEFT JOIN ar_rate_type_category rtc WITH (NOLOCK)
			ON rtc.category_id = lrt.category_id
				AND rtc.deleted = 'N'
	;

	SELECT cbed.bed_id
		, monthly_reimb_rate = 
			dbo.fn_ar_getCensusMonthlyPayRate
				( cbed.r_census_id
				, cbed.eff_schedule_id
				, cbed.rugs_code
				, cbed.alternate_care_level
				, cbed.is_secondary_bed
				)
		, monthly_pay_rate = 
			CASE
			WHEN effrs.is_market_rate = 1 THEN 
				Round(( effrs.percentage_of_market_rates * mr.monthly_rate ) / 100, 2)
			ELSE
				dbo.fn_ar_getCensusMonthlyRate
					( cbed.r_census_id
					, cbed.eff_schedule_id
					, cbed.rugs_code
					, cbed.alternate_care_level
					, cbed.is_secondary_bed
					)
			END
		, daily_reimb_rate = 
			dbo.fn_ar_getCensusDailyPayRate
				( cbed.r_census_id
				, cbed.eff_schedule_id
				, cbed.rugs_code
				, cbed.alternate_care_level
				, cbed.is_secondary_bed
				)
		, daily_pay_rate = 
			CASE
			WHEN effrs.is_market_rate = 1 THEN 
				Round(( effrs.percentage_of_market_rates * mr.daily_rate ) / 100, 2)
			ELSE
				dbo.fn_ar_getCensusDailyRate
					( cbed.r_census_id
					, cbed.eff_schedule_id
					, cbed.rugs_code
					, cbed.alternate_care_level
					, cbed.is_secondary_bed
					)
			END
		, cbed.client_id
		, rate_type = cbed.rate_type_description
		, rate_type_id = cbed.rate_type_id
		, is_market_rate = ISNULL(effrs.is_market_rate, 0)
		, cbed.eff_schedule_id
	INTO #CensusRateAmount
	FROM #CensusBedWeightFiltered cbed
		LEFT JOIN ar_eff_rate_schedule effrs WITH (NOLOCK)
			ON effrs.eff_schedule_id = cbed.eff_schedule_id
				AND effrs.schedule_id = cbed.schedule_id
				AND effrs.fac_id = @vFacID
				AND effrs.is_market_rate = 1
	    LEFT JOIN ar_date_range effdr WITH (NOLOCK)
	        ON effrs.eff_date_range_id = effdr.eff_date_range_id
		LEFT JOIN ar_market_rates mr WITH (NOLOCK)
		    ON mr.room_id = cbed.room_id
		        AND mr.rate_type_id = effrs.market_rate_type_id
		        AND mr.deleted = 'N'
		JOIN ar_date_range_market_rates mrd WITH (NOLOCK)
		    ON mrd.eff_date_range_id = mr.eff_date_range_id
		        AND mrd.fac_id = effrs.fac_id
		        AND mrd.deleted = 'N'
		        AND mrd.applied = 1
		        AND mrd.eff_date_from <= COALESCE(effdr.eff_date_from, cbed.r_effective_date)
		        AND (mrd.eff_date_to IS NULL
		                OR COALESCE(effdr.eff_date_from, cbed.r_effective_date) <= mrd.eff_date_to)
	WHERE cbed.r_census_id IS NOT NULL
		AND cbed.bed_row_num = 1
	;

	SELECT cbed.status_type
		, cbed.action_type
		, a.rate_type_id
		, a.rate_type room_rate
		, market_rate =	COALESCE(a.monthly_pay_rate  , a.daily_pay_rate * @vTotalDaysInMonth  , a.monthly_reimb_rate, a.daily_reimb_rate * @vTotalDaysInMonth)
		, actual_rate =	COALESCE(a.monthly_reimb_rate, a.daily_reimb_rate * @vTotalDaysInMonth, a.monthly_pay_rate  , a.daily_pay_rate * @vTotalDaysInMonth)
		, cbed.bed_id
		, cbed.room_id
		, cbed.weight
		, cbed.primary_payer_name
		, cbed.client_id
		, a.is_market_rate
		, bed_row_num = ROW_NUMBER() OVER (PARTITION BY cbed.bed_id ORDER BY cbed.c_effective_date DESC) -- latest client in count, others ignored
	INTO #ActualAndMarketRates
	FROM #CensusBedWeightFiltered cbed
		LEFT JOIN #CensusRateAmount a
			ON a.client_id = cbed.client_id
				AND a.bed_id = cbed.bed_id
	;

	SELECT DISTINCT client_id
	INTO #Clients
	FROM #CensusDetails
	;

	SELECT tr.client_id
		, deposit_received = SUM(tr.amount)
	INTO #DepositReceived
	FROM #Clients cl
		JOIN dbo.ar_transactions tr WITH (NOLOCK)
			ON tr.client_id = cl.client_id
				AND tr.payer_id = @vDefaultSecurityDepositPayerId
				AND tr.fac_id = @vFacId
				AND tr.transaction_type = 'C'
				AND tr.is_posted = 1
				AND tr.deleted = 'N'
	GROUP BY tr.client_id
	;

	SELECT a.client_id
		, rla.lease_start_date
		, rla.lease_end_date
		, rla.anniversary_date
		, lease_row_num = ROW_NUMBER() OVER (PARTITION BY a.client_id ORDER BY rla.lease_start_date desc)
	INTO #RentrollLeaseAgreement
	FROM #Clients a
		JOIN dbo.rentroll_lease_agreement rla WITH (NOLOCK)
			ON rla.client_id = a.client_id
				AND rla.lease_start_date <= @vEffectiveDate 
		JOIN  dbo.rentroll_agreement_type agrtype WITH (NOLOCK)
			ON agrtype.agreement_type_id = rla.agreement_type_id 
				AND agrtype.agreement_type IN ('lease','Rent') 
				AND agrtype.active = 1
	;

	INSERT INTO #RentRollData
		( fac_id
		, room_id
		, room_desc
		, bed_id
		, bed_desc
		, client_id
		, room_type
		, sq_footage
		, market_rate
		, actual_rate
		, room_rate
		, rate_type_id
		, weight
		, primary_payer_name
		, discount
		, deposit_required
		, deposit_amount
		, deposit_received
		, bed_status_id
		, is_bed_occupied
		, occupied_market_rate
		, occupied_actual_rate
		, occupied_discount
		, occupied_sq_footage
		, occupied_bed_id
		, occupied_room_id
		, total_deposit_required
		, status_type
		, lease_start_date
		, lease_end_date
		, inactive_no_show
		, inactive_Days
		, is_bed_addnl_bed
		, is_market_rate
		, is_companion
		, anniversary_date
		, is_incomplete_census
		)
	SELECT @vFacId
		, roombed.room_id
		, roombed.room_desc
		, roombed.bed_id
		, roombed.bed_Desc
		, rate.client_id
		, roombed.item_description
		, roombed.square_footage
		, rate.market_rate
		, rate.actual_rate
		, room_rate = IIF(rate.bed_id IS NULL OR rate.client_id IS NULL, censusbed.rate_type_description, rate.room_rate)
		, rate_type_id = COALESCE(rate.rate_type_id, roombed.rate_type_id)
		, weight = rate.weight
		, rate.primary_payer_name
		, discount = rate.market_rate - rate.actual_rate
		, roombed.deposit_required
		, deposit_amount = IIF(roombed.deposit_required = 0, NULL, IIF(rate.bed_id IS NULL, NULL, roombed.deposit_amount * rate.weight))
		, deposit_received = dr.deposit_received * (-1) ----as per the logic for transaction
		, bed_status_id = CASE
			WHEN rate.bed_id IS NULL THEN IIF(ISNULL(roombed.inactive_days, 0) > 0, 5, 4)
			ELSE
				CASE
					WHEN rate.status_type=@exclStatusType THEN 4
					WHEN ((rate.action_type = 'Room Reserve' AND rate.status_type <> @exclStatusType) OR rate.status_type = 'N' ) THEN 2
					ELSE 1
				END
			END
		, is_bed_occupied = CASE WHEN rate.bed_id IS NULL THEN 0 ELSE 1 END
		, occupied_market_rate = rate.market_rate
		, occupied_actual_rate = rate.actual_rate
		, occupied_discount = rate.market_rate - rate.actual_rate
		, occupied_sq_footage = CASE WHEN rate.bed_id IS NULL THEN NULL ELSE roombed.square_footage END
		, occupied_bed_id = rate.bed_id
		, occupied_room_id = rate.room_id
		, total_deposit_required = IIF(roombed.deposit_required = 0, NULL, roombed.deposit_amount)
		, rate.action_type
		, lease_start_date
		, lease_end_date
		, inactive_no_show = IIF(roombed.inactive_days IS NOT NULL AND roombed.inactive_days > 0, 1, 0)
		, roombed.inactive_days
		, is_bed_addnl_bed = ISNULL(censusbed.is_secondary_bed, 0)
		, rate.is_market_rate
		, is_companion = IIF(rate.weight = 0 AND rate.bed_id IS NOT NULL, 1, NULL)
		, rla.anniversary_date
		, is_incomplete_census = IIF(censusbed.incomplete = 'Y', 1, 0)
	FROM #RoomBed roombed
		LEFT JOIN #ActualAndMarketRates rate
			ON rate.bed_id = roombed.bed_id
				AND rate.bed_row_num = 1
		LEFT JOIN #CensusBedWeightFiltered censusbed
			ON censusbed.bed_id = roombed.bed_id
				AND censusbed.bed_row_num = 1
		LEFT JOIN #RentrollLeaseAgreement rla
			ON rla.client_id = rate.client_id 
				AND lease_row_num = 1
		LEFT JOIN #DepositReceived dr
			ON dr.client_id = rate.client_id
				AND ISNULL(censusbed.is_secondary_bed, 0) = 0
	;

	IF @debug_me='Y'
		SELECT '#RentRollData1', * 
		FROM #RentRollData
		ORDER BY room_id, bed_id, client_id;

	IF @debug_me='Y'
		PRINT 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' (OCCUPIED) complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';


	SET @vStep = 7;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Getting the Details for EMPTY Beds'  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

	SELECT s.schedule_id
		, s.eff_date_range_id
		, s.fac_id
		, s.eff_schedule_id
		, s.rate_type_id
		, s.is_manual_rate
		, s.is_manual_pay_rate
		, care_level_code = cti.care_level_code
		, s.is_custom_rate
		, alt.is_alt
		, s.is_market_rate
		, care_level_template_id = cti.care_level_template_id
		, s.rate_template_id
		, adr.eff_date_from
		, s.pay_rate_template_id
		, s.rate_template_pct
		, s.pay_rate_template_pct
	INTO #ScheduleDetails
	FROM ar_eff_rate_schedule s
		JOIN ar_date_range adr
			ON adr.eff_date_range_id = s.eff_date_range_id
				AND adr.fac_id = s.fac_id
				AND adr.deleted = 'N'
				AND adr.eff_date_from <= @vEffectiveDate
				AND (adr.eff_date_to >= @vEffectiveDate OR adr.eff_date_to IS NULL)
				AND adr.payer_id = @vDefaultPayerID
		CROSS JOIN (
				SELECT 0 AS is_alt
				UNION ALL
				SELECT 1
			) alt
		LEFT JOIN dbo.ar_lib_care_level_template_item cti WITH (NOLOCK)
			ON ((alt.is_alt = 1 AND adr.alt_care_level_template_id = cti.care_level_template_id)
					OR (alt.is_alt = 0 AND adr.care_level_template_id = cti.care_level_template_id))
				AND cti.effective_date <= adr.eff_date_from
				AND (cti.ineffective_date >= adr.eff_date_from OR cti.ineffective_date IS NULL)
				AND cti.deleted = 'N'
	WHERE s.schedule_id = @vDefaultEmptyBedScheduleID
	;

	SELECT aers.schedule_id
		, aers.eff_date_range_id
		, aers.fac_id
		, aers.eff_schedule_id
		, aers.rate_type_id
		, amr.room_id
		, monthly_rate = ROUND(( aers.percentage_of_market_rates * amr.monthly_rate ) / 100, 2)
		, daily_rate = ROUND(( aers.percentage_of_market_rates * amr.daily_rate ) / 100, 2)
	INTO #MarketRates
	FROM ar_eff_rate_schedule aers
		JOIN dbo.ar_market_rates amr
			ON aers.is_market_rate = 1
				AND amr.eff_date_range_id = aers.market_date_range_id
				AND amr.deleted = 'N'
				AND amr.rate_type_id = aers.market_rate_type_id
		JOIN ar_date_range_market_rates adrmr
			ON adrmr.eff_date_range_id = aers.market_date_range_id
				AND adrmr.fac_id = aers.fac_id
				AND adrmr.deleted = 'N'
				AND adrmr.eff_date_from <= @vEffectiveDate
				AND (adrmr.eff_date_to >= @vEffectiveDate OR adrmr.eff_date_to IS NULL)
				AND adrmr.applied = 1
	WHERE aers.fac_id = @vFacId
		AND aers.is_market_rate = 1
		AND aers.schedule_id = @vDefaultEmptyBedScheduleID
	;

	SELECT s.schedule_id
		, s.eff_date_range_id
		, s.fac_id
		, s.eff_schedule_id
		, s.rate_type_id
		, r.monthly_rate
		, r.daily_rate
		, sequence_no = cti.sequence_no
		, care_level_id = cti.care_level_id
	INTO #ManualRates
	FROM #ScheduleDetails s
		JOIN dbo.ar_rate_detail r WITH (NOLOCK) -- Manual rate.
			ON r.eff_schedule_id = s.eff_schedule_id
				AND(s.is_manual_rate = 1 OR s.is_manual_pay_rate = 1)
				AND s.is_alt = 0
				AND (r.care_level = s.care_level_code OR s.is_custom_rate = 1)
				AND r.fac_id = @vFacId
		LEFT JOIN ar_eff_rate_schedule ers
			ON ers.eff_schedule_id = r.eff_schedule_id
		LEFT JOIN ar_date_range adr
			ON adr.eff_date_range_id = ers.eff_date_range_id
				AND adr.deleted = 'N'
		LEFT JOIN ar_lib_care_level_template_item cti
			ON cti.care_level_template_id = adr.care_level_template_id
				AND cti.care_level_code = r.care_level
				AND cti.deleted = 'N'
	WHERE s.fac_id = @vFacId
		AND s.is_manual_rate = 1
	;

	SELECT t.rate_template_id,
		   t.care_level_template_id,
		   i.effective_date,
		   i.ineffective_date,
		   c.care_level_id,
		   c.care_level_code,
		   c.sequence_no as care_level_sequence_no,
		   r.daily_rate,
		   r.monthly_rate
	INTO #RateTemplate
	FROM ar_lib_rate_template t
		JOIN ar_lib_care_level_template ct 
			ON t.care_level_template_id = ct.care_level_template_id
		JOIN ar_lib_rate_template_info i 
			ON t.rate_template_id = i.rate_template_id
				AND i.is_accepted = 1
		JOIN ar_lib_care_level_template_item c 
			ON t.care_level_template_id = c.care_level_template_id
				AND i.effective_date >= c.effective_date 
				AND (i.effective_date <= c.ineffective_date OR c.ineffective_date IS NULL)
		LEFT JOIN ar_lib_rate_template_rate r 
			ON r.rate_template_info_id = i.rate_template_info_id
				AND r.care_level_id = c.care_level_id
	;

	SELECT s.schedule_id
		, s.eff_date_range_id
		, s.fac_id
		, s.eff_schedule_id
		, s.rate_type_id
		, monthly_rate = rt.monthly_rate * (s.rate_template_pct / 100)
		, daily_rate = rt.daily_rate * (s.rate_template_pct / 100)
		, s.is_alt
		, rt.care_level_sequence_no
		, rt.care_level_id
	INTO #TemplateRates
	FROM #ScheduleDetails s
		-- JOIN to templates to get the rate if we are not using a manual rate.
		LEFT JOIN #RateTemplate rt -- Standard template
			ON s.rate_template_id = rt.rate_template_id
				AND s.care_level_template_id = rt.care_level_template_id
				AND s.care_level_code = rt.care_level_code
				AND s.eff_date_from >= rt.effective_date
				AND (s.eff_date_from < rt.ineffective_date OR rt.ineffective_date is NULL)
		LEFT JOIN #RateTemplate pt -- Reimbursement Template
			ON 	s.pay_rate_template_id = pt.rate_template_id
				AND s.is_manual_pay_rate = 0
				AND s.care_level_template_id = pt.care_level_template_id
				AND s.care_level_code = pt.care_level_code
				AND s.eff_date_from >= pt.effective_date
				AND (s.eff_date_from < pt.ineffective_date OR pt.ineffective_date is NULL)
	WHERE s.fac_id = @vFacId
		AND s.is_manual_rate = 0
		AND s.is_market_rate = 0
	;

	SELECT mkt.schedule_id
		, mkt.eff_date_range_id
		, mkt.fac_id
		, mkt.eff_schedule_id
		, mkt.rate_type_id
		, mkt.room_id
		, mkt.monthly_rate
		, mkt.daily_rate
	INTO #AllRateTypes
	FROM #MarketRates mkt
	UNION
	SELECT m.schedule_id
		, m.eff_date_range_id
		, m.fac_id
		, m.eff_schedule_id
		, m.rate_type_id
		, room_id = NULL
		, m.monthly_rate
		, m.daily_rate
	FROM #ManualRates m
	UNION
	SELECT t.schedule_id
		, t.eff_date_range_id
		, t.fac_id
		, t.eff_schedule_id
		, t.rate_type_id
		, room_id = NULL
		, t.monthly_rate
		, t.daily_rate
	FROM #TemplateRates t
	;

	SELECT room_id
		, beds_count = COUNT(*)
	INTO #RoomCapacity
	FROM #RentRollData
	GROUP BY room_id
	;

	SELECT room_id
		, clients_count = COUNT(*)
	INTO #ClientInRoomCount
	FROM #RentRollData
	WHERE is_bed_occupied = 1 
		AND is_incomplete_census = 0
	GROUP BY room_id
	;

	SELECT 
		c.room_id
		, c.clients_count
		, r.beds_count
	INTO #PartiallyOccupiedRoom
	FROM #ClientInRoomCount c
	JOIN #RoomCapacity r
		ON r.room_id = c.room_id
			AND c.clients_count < r.beds_count
	;

	SELECT rc.room_id
	INTO #FullyAvailableRooms
	FROM #RoomCapacity rc
	LEFT JOIN #ClientInRoomCount c
		ON c.room_id = rc.room_id
	WHERE c.room_id IS NULL
	;

	SELECT 
		o.room_id
		, o.bed_id
		, o.is_incomplete_census
	INTO #FullyAvailableRoomBeds
	FROM #RentRollData o
	JOIN #FullyAvailableRooms f
		ON f.room_id = o.room_id
	;

	SELECT DISTINCT 
		rdr.room_id
		, rdr.rate_type_id
		, artc.weight
	INTO #DefaultRoomRateForEmptyBeds
	FROM #RentRollData o
		JOIN dbo.room_date_range rdr
			ON rdr.room_id = o.room_id
				AND rdr.deleted = 'N'
				AND rdr.effective_Date <= @vEffectiveDate
				AND (rdr.ineffective_date IS NULL OR rdr.ineffective_Date >= @vEffectiveDate)
		JOIN ar_lib_rate_type alrt
			ON alrt.rate_type_id = rdr.rate_type_id
				AND alrt.deleted = 'N'
		JOIN ar_rate_type_category artc
			ON artc.category_id = alrt.category_id
				AND artc.deleted = 'N'
	WHERE is_bed_occupied = 0
		OR is_incomplete_census = 1
	;

	SELECT
		rb.room_id 
		, rb.bed_Id
		, cumulative_weight = ROW_NUMBER() OVER (PARTITION BY rb.room_id ORDER BY IIF(rb.is_incomplete_census = 1, 1, 0) DESC, rb.bed_id) * d.weight
	INTO #CumulativeWeightForEmptyRoomBeds
	FROM #FullyAvailableRoomBeds rb
		JOIN #DefaultRoomRateForEmptyBeds d
			ON d.room_id = rb.room_id
	;

	SELECT
		c.room_id 
		, c.bed_Id
		, rate_type_id = Iif(c.cumulative_weight <= 1, d.rate_type_id, NULL)
		, weight = iif(c.cumulative_weight <= 1, d.weight, 0)
		, companion_flag = IIF(c.cumulative_weight > 1, 1, 0)
	INTO #EmptyRoomBedsRateTypes
	FROM #FullyAvailableRoomBeds a
		JOIN #CumulativeWeightForEmptyRoomBeds c
			ON c.room_id = a.room_id
				AND a.bed_id = c.bed_id
		JOIN #DefaultRoomRateForEmptyBeds d
			ON d.room_id = c.room_id
	;

	SELECT 
		room_id
		, weight_sum = SUM(weight)
	INTO #PartiallyOccupiedWeightSum
	FROM #RentRollData
	WHERE weight IS NOT NULL
	GROUP BY room_id
	;

	SELECT 
		s.room_id
		, r.beds_count
		, r.clients_count
		, occupied_weight_sum = s.weight_sum
		, remaining_weight = (1 - s.weight_sum)
	INTO #PartiallyOccupiedWeight
	FROM #PartiallyOccupiedWeightSum s
		JOIN #PartiallyOccupiedRoom r
			ON r.room_id = s.room_id
	;

	SELECT 
		w.room_id
		, category_weight = artc.weight
		, has_remainder = 
			CASE
				WHEN w.remaining_weight = 0 OR artc.weight = 0 THEN 0
				ELSE IIF(CAST(w.remaining_weight AS DECIMAL(5,2)) % CAST(artc.weight AS DECIMAL(5,2)) <= 0.02, 0, 1)
			END
		, beds_covered_by_rate_weight = 
			CASE
				WHEN w.remaining_weight = 0 OR artc.weight = 0 THEN 0
				ELSE CAST(IIF(w.remaining_weight / artc.weight > (w.beds_count - w.clients_count), w.beds_count - w.clients_count, w.remaining_weight / artc.weight) AS INT)
			END
		, art.rate_type_id
		, w.remaining_weight
	INTO #PartiallyOccupiedRateWeightAssignment
	FROM #PartiallyOccupiedWeight w
		JOIN ar_rate_type_category artc 
			ON artc.weight <= w.remaining_weight
				AND artc.deleted = 'N'
		JOIN ar_lib_rate_type alrt
			ON alrt.category_id = artc.category_id
				AND alrt.deleted = 'N'
		JOIN ar_rate_type art
			ON art.rate_type_id = alrt.rate_type_id
				AND art.fac_id = @vFacId
	UNION ALL
	SELECT
		w.room_id
		, 0
		, 0
		, 0
		, NULL
		, w.remaining_weight
	FROM #PartiallyOccupiedWeight w
	;

	SELECT 
		room_id
		, category_weight
		, beds_covered_by_rate_weight
		, rate_type_id
		, rate_type_rank = RANK() OVER (PARTITION BY room_id ORDER BY beds_covered_by_rate_weight DESC, category_weight DESC)
	INTO #PartiallyOccupiedWeightPriority
	FROM #PartiallyOccupiedRateWeightAssignment
	;

	SELECT 
		p.room_id
		, f.bed_id
		, p.category_weight
		, p.beds_covered_by_rate_weight
		, p.rate_type_id
		, empty_bed_rank = DENSE_RANK() OVER (PARTITION BY r.room_id ORDER BY IIF(f.is_incomplete_census = 1, 1, 0) DESC, f.bed_id)
	INTO #PartiallyOccupiedEmptyBedOrder
	FROM #PartiallyOccupiedRoom r
		JOIN #PartiallyOccupiedWeightPriority p
			ON p.room_id = r.room_id
				AND rate_type_rank = 1
		JOIN #RentRollData f
			ON f.room_id = r.room_id
				AND (f.is_bed_occupied = 0 OR f.is_incomplete_census = 1)
	;

	SELECT 
		r.room_id
		, r.bed_id
		, rate_type_id = IIF(r.empty_bed_rank <= r.beds_covered_by_rate_weight, r.rate_type_id, NULL)
		, weight = IIF(r.empty_bed_rank <= r.beds_covered_by_rate_weight, r.category_weight, 0)
		, companion_flag = IIF(r.empty_bed_rank <= r.beds_covered_by_rate_weight, 0, 1)
	INTO #PartiallyOccupiedRoomBedWeights
	FROM #PartiallyOccupiedEmptyBedOrder r
	;

	SELECT 
		e.room_id
		, e.bed_id
		, e.rate_type_id
		, e.weight
		, e.companion_flag
	INTO #EmptyBedRateTypes
	FROM #EmptyRoomBedsRateTypes e
	UNION
	SELECT 
		po.room_id
		, po.bed_id
		, po.rate_type_id
		, po.weight
		, po.companion_flag
	FROM #PartiallyOccupiedRoomBedWeights po
	;

	SELECT DISTINCT
		e.room_id
		, e.bed_id
		, rate_type_id = COALESCE(r.rate_type_id, @vZeroWeightRateId)
		, e.weight
		, e.companion_flag
	INTO #EmptyBedCompanionRateTypes
	FROM #EmptyBedRateTypes e
		LEFT JOIN ar_rate_type_category c
			ON c.weight = e.weight
				AND c.deleted = 'N'
		LEFT JOIN ar_lib_rate_type lib
			ON lib.category_id = c.category_id
				AND lib.deleted = 'N'	
		LEFT JOIN ar_rate_type r
			ON r.rate_type_id = lib.rate_type_id
				AND r.fac_id = @vFacId
	WHERE e.weight = 0
	;

	SELECT 
		e.room_id
		, e.bed_id
		, e.rate_type_id
		, e.weight
		, e.companion_flag
	INTO #EmptyBedAllRateTypes
	FROM #EmptyBedRateTypes e
	WHERE e.weight <> 0
	UNION
	SELECT 
		c.room_id
		, c.bed_id
		, c.rate_type_id
		, c.weight
		, c.companion_flag
	FROM #EmptyBedCompanionRateTypes c
	;

	SELECT m.schedule_id
		, m.eff_date_range_id
		, m.fac_id
		, m.eff_schedule_id
		, m.rate_type_id
		, o.room_id
		, o.bed_id
		, m.monthly_rate
		, m.daily_rate
	INTO #MarketRatesForEmptyBeds
	FROM #EmptyBedAllRateTypes o
		JOIN #MarketRates m
			ON m.rate_type_id = o.rate_type_id
				AND m.room_id = o.room_id
	;

	SELECT m.schedule_id
		, m.eff_date_range_id
		, m.fac_id
		, m.eff_schedule_id
		, m.rate_type_id
		, o.room_id
		, o.bed_id
		, m.monthly_rate
		, m.daily_rate
		, room_care_level_row_num = ROW_NUMBER() OVER(PARTITION BY o.room_id, o.bed_id ORDER BY IIF(m.monthly_rate IS NULL AND m.daily_rate IS NULL, 0, 1) DESC, m.sequence_no, m.care_level_id, m.rate_type_id)
	INTO #ManualRatesForEmptyBedsPrioritized
	FROM #EmptyBedAllRateTypes o
		JOIN #ManualRates m
			ON m.rate_type_id = o.rate_type_id
	;

	SELECT 
		mr.room_id
		, mr.bed_id
		, mr.monthly_rate
		, mr.daily_rate
		, mr.rate_type_id
	INTO #ManualRatesForEmptyBeds
	FROM #ManualRatesForEmptyBedsPrioritized mr
	WHERE mr.room_care_level_row_num = 1
	;

	SELECT t.schedule_id
		, t.eff_date_range_id
		, t.fac_id
		, t.eff_schedule_id
		, t.rate_type_id
		, o.room_id
		, t.monthly_rate
		, t.daily_rate
		, t.is_alt
		, room_care_level_row_num = ROW_NUMBER() OVER(PARTITION BY o.room_id ORDER BY t.is_alt, t.care_level_sequence_no, t.care_level_id)
	INTO #TemplateRatesForEmptyRooms
	FROM #EmptyBedAllRateTypes o
		JOIN #TemplateRates t
			ON t.rate_type_id = o.rate_type_id
	;

	SELECT t.schedule_id
		, t.eff_date_range_id
		, t.fac_id
		, t.eff_schedule_id
		, t.rate_type_id
		, o.room_id
		, o.bed_id
		, t.monthly_rate
		, t.daily_rate
		, t.is_alt
	INTO #TemplateRateForEmptyRoomBeds
	FROM #EmptyBedAllRateTypes o
		JOIN #TemplateRatesForEmptyRooms t
			ON t.room_id = o.room_id
				AND t.room_care_level_row_num = 1
	;

	SELECT
		o.room_id
		, o.bed_id   
		, market_rate = COALESCE(mr.monthly_rate, mkt.monthly_rate, t.monthly_rate, @vTotalDaysInMonth * COALESCE(mr.daily_rate, mkt.daily_rate, t.daily_rate))
		, o.rate_type_id 
		, o.weight
		, room_bed_row_num = ROW_NUMBER() OVER(PARTITION BY o.room_id, o.bed_id ORDER BY IIF((COALESCE(mr.monthly_rate, mkt.monthly_rate, t.monthly_rate, @vTotalDaysInMonth * COALESCE(mr.daily_rate, mkt.daily_rate, t.daily_rate))) IS NULL, 0, 1) DESC)
	INTO #EmptyBedsFinalPrioritized
	FROM #EmptyBedAllRateTypes o
		LEFT JOIN #ManualRatesForEmptyBeds mr
			ON mr.bed_id = o.bed_id
				AND mr.rate_type_id = o.rate_type_id
		LEFT JOIN #MarketRatesForEmptyBeds mkt
			ON mkt.bed_id = o.bed_id
				AND mkt.rate_type_id = o.rate_type_id
		LEFT JOIN #TemplateRateForEmptyRoomBeds t
			ON t.bed_id = o.bed_id
				AND t.rate_type_id = o.rate_type_id
	;

	SELECT
		e.room_id
		, e.bed_id
		, e.market_rate
		, rate_type_id = COALESCE(ebr.rate_type_id, e.rate_type_id)
		, is_companion = CONVERT(BIT, IIF(e.weight = 0, 1, 0))
		, e.weight
	INTO #EmptyBedsWithCompanion
	FROM #EmptyBedsFinalPrioritized e
		LEFT JOIN #EmptyBedAllRateTypes ebr
			ON ebr.bed_id = e.bed_id
				AND ebr.rate_type_id = e.rate_type_id
	WHERE e.room_bed_row_num = 1
	;

	UPDATE rrd
	SET
		market_rate = IIF(rrd.is_incomplete_census = 0, e.market_rate, NULL)
		, rate_type_id = e.rate_type_id
		, room_rate = IIF(rrd.is_incomplete_census = 0, alrt.long_description, NULL)
		, is_companion = e.is_companion
		, weight = e.weight
		, deposit_amount = IIF(rrd.deposit_required = 1, e.weight * rrd.total_deposit_required, NULL)
	FROM #RentRollData rrd
		JOIN #EmptyBedsWithCompanion e
			ON e.bed_id = rrd.bed_id
		LEFT JOIN ar_lib_rate_type alrt
			ON alrt.rate_type_id = e.rate_type_id
				AND alrt.deleted = 'N'
	WHERE rrd.is_bed_occupied = 0
		OR is_incomplete_census = 1;

	IF @debug_me='Y'
		select '#RentRollData2', * 
		from #RentRollData
		order by room_id, bed_id

	IF @debug_me='Y' PRINT 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' (EMPTY) complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';


	SET @vStep = 8;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Preparing SUM for Jrxml and Internal Calculation '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109) ;

	INSERT INTO @room_sum_for_jrxml 
		( room_id
		, total_market_rate
		, total_actual_rate
		, total_discount
		, total_deposit_received
		, bed_count
		)
	SELECT room_id
		, total_market_rate = SUM(market_rate)
		, total_actual_rate = SUM(actual_rate)
		, total_discount = SUM(discount)
		, total_deposit_received = SUM(deposit_received)
		, bed_count = SUM(is_bed_occupied)
	FROM #RentRollData rrd
	WHERE (rrd.is_bed_occupied = 0 AND (@show_empty_companion_beds = 1 OR ISNULL(rrd.is_companion, 0) = 0))
		OR (rrd.is_bed_occupied = 1 AND (@show_occupied_companion_beds = 1 OR ISNULL(rrd.is_companion, 0) = 0))
	GROUP BY room_id;

	WITH OccupiedRoomWeights AS (
		SELECT j.room_id
			, weight = ISNULL(SUM(rrd.weight), 0)
		FROM @room_sum_for_jrxml j
			JOIN #RentRollData rrd
				ON rrd.room_id = j.room_id
		WHERE is_bed_occupied = 1
		GROUP BY j.room_id
	)
	UPDATE j
	SET total_occupied_weight = ISNULL(o.weight, 0)
	FROM @room_sum_for_jrxml j
	JOIN OccupiedRoomWeights o
		ON o.room_id = j.room_id;

	IF @debug_me='Y' Print 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';
 
	IF (@debug_me='Y'  or @debug_me='weight')
		SELECT '@room_sum_for_jrxml',* FROM @room_sum_for_jrxml;


	SET @vStep = 9;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Handling the Future Dated Move Out Dates and the Bed Status based on the Dates for Client '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

	UPDATE rent
	SET estimated_move_out = COALESCE(cl.discharge_date, cl.estimated_discharge_date)
		, bed_status_id = IIF(rent.bed_status_id IN (1, 2) AND (cl.discharge_date IS NOT NULL OR cl.estimated_discharge_date IS NOT NULL), 3, rent.bed_status_id)
	FROM #RentRollData rent 
		JOIN clients cl WITH (NOLOCK)
			ON cl.client_id = rent.client_id
				AND cl.deleted = 'N'
	;

	IF @debug_me='Y' 
		PRINT 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';


	SET @vStep = 10;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Setting Occupied/Available Days for each bed '  + @vgs_program_name + ' ' + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

	IF NOT (@report_format_type = 'pdf' AND @emc_flag = 1)
	BEGIN
		INSERT INTO @availableOccupiedDays
		EXEC sproc_prp_rl_rent_roll_report_occ_avail 
				  @vFacId
				, @vFirstDay
				, @debug_me
				, @status_code
				, @status_text;

		UPDATE rrd
		SET occupied_days = IIF(aod.occupied_days IS NULL AND aod.available_days IS NULL, 0, aod.occupied_days)
			, vacant_days = IIF(aod.occupied_days IS NULL AND aod.available_days IS NULL, @vTotalDaysInMonth, aod.available_days)
		FROM #RentRollData rrd
			LEFT JOIN @availableOccupiedDays aod
				ON aod.bed_id = rrd.bed_id
	END

	IF @debug_me='Y' 
		PRINT 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';


	SET @vStep = 11;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Deriving the Bed Staus based on Weight and Move out Dates '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

	UPDATE r
	SET is_rv_weight_1 = 
		CASE 
			WHEN r.room_id = rj.room_id AND rj.total_occupied_weight > 0.98 AND bed_status_id = 4 THEN 1 
			ELSE is_rv_weight_1 
		END
	FROM #RentRollData r 
		INNER JOIN @room_sum_for_jrxml rj 
			ON rj.room_id=r.room_id;

	IF (@enforce_max_weight_flag = 1)
	BEGIN
		UPDATE r
		----this bit column is used to calculate the the Rented and Vacant occupied days that emerged as the Rented and Vacant due to weight 1
		SET bed_status_id = IIF(r.room_id = rj.room_id AND rj.total_occupied_weight > 0.98 AND rj.bed_count > 0 AND bed_status_id = 4, 2, bed_status_id)
		FROM #RentRollData r 
			INNER JOIN @room_sum_for_jrxml rj 
				ON rj.room_id = r.room_id
		WHERE r.is_bed_occupied = 0
		;
	END

	if @debug_me='Y' Print 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';
 
	IF (@debug_me='Y'  OR @debug_me='rate')---using rate to debug only the ouput for rate related data
		SELECT 'bed status #RentRollData',* 
		FROM #RentRollData
		ORDER BY room_id, bed_id;


	SET @vStep = 12;
	SET @vgsStepStartTime = GETDATE();
	IF @debug_me='Y' 
		PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
			+ ' Deriving Status For the Bed '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

	----No room and Bed Status are stored in table hence these section updates the room status on the fly based on the various combination of the bed status
	---Again the Bed Status are also calculated on the fly...

	UPDATE rrd
	SET room_status = 
		CASE
			WHEN countid = 2 THEN 
				CASE dco.bed_status_id
					WHEN 12 THEN 'Fully Occupied'
					WHEN 13 THEN 'Occupied with planned move out'
					WHEN 14 THEN 'Partially Occupied'
					WHEN 15 THEN 'Fully Occupied'
					WHEN 23 THEN 'Occupied with planned move out'
					WHEN 24 THEN 'Partially Occupied'
					WHEN 25 THEN 'Fully Rented & Vacant'
					WHEN 34 THEN 'Partially Occupied with planned move out'
					WHEN 35 THEN 'Occupied with planned move out'
					WHEN 45 THEN 'Fully Available'
				END
			WHEN countid = 1 THEN 
				CASE rrd.bed_status_id
					WHEN 1 THEN 'Fully Occupied'
					WHEN 2 THEN 'Fully Rented & Vacant'
					WHEN 3 THEN 'Occupied with planned move out'
					WHEN 4 THEN 'Fully Available'
					WHEN 5 THEN 'Fully Inactive'
				END
			ELSE
				CASE
					WHEN CHARINDEX('4', dco.bed_status_id) > 0 THEN 
						CASE 
							WHEN CHARINDEX('3', dco.bed_status_id)>0 THEN 'Partially Occupied with planned move out'
							ELSE 'Partially Occupied'
						END
					ELSE 
						CASE 
							WHEN CHARINDEX('3', dco.bed_status_id)>0 THEN 'Occupied with planned move out'
							ELSE 'Fully Occupied'
						END
				END
		END
	FROM #RentRollData rrd 
		INNER JOIN (
				SELECT count(DISTINCT bed_status_id )countid,room_id 
				FROM #RentRollData 
				GROUP BY room_id
			) co
			ON co.room_id=rrd.room_id
		INNER JOIN (
				SELECT room_id
					, REPLACE(ISNULL([1],'')+ISNULL([2],'')+ISNULL([3],'')+ISNULL([4],'')+ISNULL([5],''),' ', '' ) AS bed_status_id
				FROM (
						SELECT room_id
							, bed_status_id
						FROM #RentRollData
					) ps
					PIVOT (MAX(bed_status_id) FOR bed_status_id in ([1],[2],[3],[4],[5])) AS pvt
			) dco
			ON dco.room_id = rrd.room_id
	;

	IF @debug_me='Y' Print 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';


	IF (@debug_me='Y'  OR @debug_me='rate')---using rate to debug only the ouput for rate related data
		SELECT 'rooms status #RentRollData',* 
		FROM #RentRollData
		ORDER BY room_id, bed_id;


	SELECT @rows_returned = Count(*) 
	FROM #RentRollData 
	WHERE (@vRoomStatus='-1' OR room_status=@vRoomStatus);

	IF @rows_returned < 1 AND @emc_flag = 0
	BEGIN
		SELECT NULL fac_id
			,NULL fac_name
			,NULL fac_code
			,NULL room_id 
			,NULL room_desc
			,NULL unit_desc
			,NULL floor_desc
			,NULL room_desc_original
			,NULL bed_id
			,NULL bed_desc
			,NULL client_id
			,NULL client_name
			,NULL first_name
			,NULL last_name
			,NULL client_id_number
			,NULL sex
			,NULL primary_payer_name
			,NULL room_type
			,NULL sq_footage   
			,NULL market_rate 
			,NULL actual_rate  
			,NULL room_rate   
			,NULL discount
			,NULL deposit_required   
			,NULL deposit_received   
			,NULL lease_start
			,NULL lease_end
			,NULL resident_status
			,NULL move_in   
			,NULL estimated_move_out
			,NULL stay_days
			,NULL bed_status 
			,NULL room_status  
			,NULL is_unit_occupied
			,NULL occupied_bed_id
			,NULL occupied_room_id
			,NULL occupied_market_rate
			,NULL occupied_actual_rate
			,NULL occupied_discount
			,NULL occupied_sq_footage
			,NULL total_deposit_required   
			,NULL total_deposit_received   
			,NULL total_market_rate 
			,NULL total_actual_rate 
			,NULL total_discount 
			,NULL inactive_bed_status
			,NULL occupied_days
			,NULL vacant_days
			,NULL is_bed_addnl_bed
			,NULL potential_occupancy
			,NULL row_num
			,NULL ordering_row_num
			,0 status_code  
			,NULL status_text 
			,@vselected_parameters as selected_parameters
			,@effective_date effective_date;
	END
	ELSE
	BEGIN;

		SET @vStep = 13;
		SET @vgsStepStartTime = GETDATE();
		IF @debug_me='Y' 
			PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
				+ ' Vacant / Move In details For the Bed '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

		WITH BedsByRoom_CTE AS (
			SELECT room_id
				, potential_occupancy = COUNT(*) 
			FROM bed 
			WHERE deleted = 'N'
				AND (retired_date IS NULL OR retired_date > @vEffectiveDate)
			GROUP BY room_id
		),
		FinalOutput_CTE AS (
			SELECT rd.fac_id
				, rd.room_id
				, rd.bed_id
				, rd.bed_desc
				, rd.client_id
				, rd.room_type
				, rd.sq_footage
				, rd.market_rate
				, rd.actual_rate
				, rd.room_rate
				, rd.discount
				, deposit_required = rd.deposit_amount
				, rd.deposit_received
				, rd.lease_start_date lease_start
				, rd.lease_end_date lease_end
				, rd.estimated_move_out
				, rd.occupied_days
				, rd.vacant_days
				, rd.room_status
				, is_unit_occupied = IIF(rj.bed_count = 0, 0, 1)
				, rd.occupied_bed_id
				, rd.occupied_room_id
				, rd.occupied_market_rate
				, rd.occupied_actual_rate
				, rd.occupied_discount
				, rd.occupied_sq_footage
				, total_deposit_required = rd.total_deposit_required
				, total_deposit_received = rj.total_deposit_received
				, rj.total_market_rate
				, rj.total_actual_rate
				, total_discount = IIF(rj.bed_count = 0, NULL, rj.total_discount)
				, status_code = 0
				, status_text = NULL
				, selected_parameters = @vselected_parameters
				, rd.bed_status_id
				, rd.inactive_Days
				, rd.weight
				, rd.primary_payer_name
				, rd.is_bed_addnl_bed
				, bedsByRoom.potential_occupancy
				, is_companion = ISNULL(rd.is_companion, 0)
				, rd.is_bed_occupied
				, rd.anniversary_date
			FROM #RentRollData rd 
				JOIN @room_sum_for_jrxml rj
					ON rj.room_id = rd.room_id
				LEFT JOIN BedsByRoom_CTE bedsByRoom
					ON bedsByRoom.room_id = rd.room_id
			WHERE (@vRoomStatus = '-1' OR rd.room_status = @vRoomStatus)
				AND rd.inactive_no_show = 0
		),
		OccupiedRooms_CTE AS (
			SELECT DISTINCT 
				  room_id
				, bed_id
				, lease_start
				, lease_end
			FROM FinalOutput_CTE
			WHERE weight > 0.98
				AND bed_status_id IN (1, 3)
		)
		SELECT 
			  f.fac_id
			, facility.name AS fac_name
			, facility.facility_code AS fac_code
			, f.room_id
			, room_desc = unit.unit_desc + '-' + flr.floor_desc + '-' + room.room_desc
			, unit.unit_desc
			, flr.floor_desc
			, room_desc_original = room.room_desc
			, f.bed_id
			, f.bed_desc 
			, f.client_id
			, client_name = 
				CASE 
					WHEN @vOrderBy = 0 AND COALESCE(m.last_name, m.first_name, cl.client_id_number, '') = '' THEN 'None'
					WHEN @vOrderBy <> 0 AND COALESCE(m.last_name, m.first_name, cl.client_id_number, '') = '' THEN ''
					ELSE ltrim(rtrim(isNULL(m.last_name,''))) + ', ' + ltrim(rtrim(isNULL(m.first_name,''))) + ' (' + ltrim(rtrim(isNULL(cl.client_id_number,'')))+ ')'
				END
			, m.first_name
			, m.last_name
			, cl.client_id_number
			, m.sex
			, f.primary_payer_name
			, f.room_type
			, f.sq_footage   
			, f.market_rate  
			, f.actual_rate
			, f.room_rate   
			, f.discount
			, f.deposit_required   
			, f.deposit_received
			, lease_start   = COALESCE(occ.lease_start  , f.lease_start)
			, lease_end     = COALESCE(occ.lease_end    , f.lease_end)
			, resident_status = IIF(f.client_id IS NULL, NULL, 'Active')
			, move_in       = cl.admission_date
			, f.estimated_move_out
			, stay_days     = IIF(cl.admission_date <= @Today, DATEDIFF(dd, cl.admission_date, @Today) + 1, NULL)
			, f.occupied_days
			, f.vacant_days
			, bed_status = 
				CASE f.bed_status_id
					WHEN 1 THEN 'Occupied'
					WHEN 2 THEN 'Rented & Vacant' 
					WHEN 3 THEN 'Occupied with planned move out' 
					WHEN 4 THEN 'Available' 
					WHEN 5 THEN 'Inactive' 
				END
			, f.room_status
			, f.is_unit_occupied
			, f.occupied_bed_id
			, f.occupied_room_id
			, f.occupied_market_rate
			, f.occupied_actual_rate
			, f.occupied_discount
			, f.occupied_sq_footage
			, f.total_deposit_required
			, f.total_deposit_received
			, f.total_market_rate
			, f.total_actual_rate
			, f.total_discount
			, inactive_bed_Status = IIF(f.bed_status_id = 5, 1, 0)
			, f.is_bed_addnl_bed
			, f.potential_occupancy
			, f.status_code
			, f.status_text  
			, f.selected_parameters
			, effective_date = @vEffectiveDate
			, f.is_companion
			, f.anniversary_date
			, row_num = DENSE_RANK() OVER (ORDER BY unit.unit_desc, flr.floor_desc, room.room_desc)
		INTO #RentRollResult
		FROM FinalOutput_CTE f
			LEFT JOIN OccupiedRooms_CTE occ
				ON occ.room_id = f.room_id 
					AND occ.bed_id = f.bed_id 
					AND f.bed_status_id = 2
			JOIN dbo.room room WITH (NOLOCK) 
				ON f.room_id = room.room_id
					AND room.deleted = 'N'
			JOIN dbo.[floor] flr WITH (NOLOCK) 
				ON room.floor_id = flr.floor_id
					AND flr.deleted = 'N'
			JOIN dbo.unit unit WITH (NOLOCK) 
				ON room.unit_id = unit.unit_id
					AND unit.deleted = 'N'
			LEFT JOIN dbo.clients cl WITH (NOLOCK)
				ON cl.client_id = f.client_id 
					AND cl.fac_id = f.fac_id
					AND cl.deleted = 'N'
			LEFT JOIN dbo.mpi m WITH (NOLOCK) 
				ON m.mpi_id = cl.mpi_id
					AND m.deleted = 'N'
			JOIN facility ON facility.fac_id = f.fac_id
		WHERE (f.is_bed_occupied = 0 AND (@show_empty_companion_beds = 1 OR f.is_companion = 0))
			OR (f.is_bed_occupied = 1 AND (@show_occupied_companion_beds = 1 OR f.is_companion = 0))
		;

		IF @debug_me='Y'
			PRINT 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';


		SET @vStep = 14;
		SET @vgsStepStartTime = GETDATE();
		IF @debug_me='Y' 
			PRINT 'STEP ' + CONVERT(VARCHAR(20), @vStep) 
				+ ' Ordering Result '  + @vgs_program_name  + CONVERT(VARCHAR(26), @vgsStepStartTime, 109);

		IF @vOrderBy = 1		-- last name
			WITH RowNum_CTE AS (
				SELECT *
					, ordering_row_num = DENSE_RANK() OVER (ORDER BY last_name, first_name, client_id_number, unit_desc, floor_desc, room_desc, bed_desc)
				FROM #RentRollResult 
			)
			SELECT *
			FROM RowNum_CTE
			ORDER BY ordering_row_num, unit_desc, floor_desc, room_desc, bed_desc
			;
		ELSE IF @vOrderBy = 2	-- first name
			WITH RowNum_CTE AS (
				SELECT *
					, ordering_row_num = DENSE_RANK() OVER (ORDER BY first_name, last_name, client_id_number, unit_desc, floor_desc, room_desc, bed_desc)
				FROM #RentRollResult
			)
			SELECT *
			FROM RowNum_CTE
			ORDER BY ordering_row_num, unit_desc, floor_desc, room_desc, bed_desc
			;
		ELSE					-- @vOrderBy = 0	-- room
			WITH RowNum_CTE AS (
				SELECT *
					, ordering_row_num = DENSE_RANK() OVER (ORDER BY unit_desc, floor_desc, room_desc)
				FROM #RentRollResult
			)
			SELECT *
			FROM RowNum_CTE
			ORDER BY ordering_row_num, bed_desc, room_type, client_name
			;

		IF @debug_me='Y'
			PRINT 'STEP ' +  CONVERT(VARCHAR(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms, @vgsStepStartTime, GETDATE()))))+ ' ms';

	END

	IF @debug_me='Y' Print 'Total execution time: ' + LTRIM(RTRIM(STR(DATEDIFF(ms, @vgsTotalStartTime, GETDATE()))))+ ' ms';

END TRY
  
BEGIN CATCH  
	SET @Status_Code = IIF(@status_code = 0, 1, 2);  --- convert 3 to 2

	IF @status_code = 1  
		SELECT @status_text = rtrim( LEFT( 'Stored Procedure failed WITH Error Code : ' + CAST(ERROR_NUMBER() AS VARCHAR(10)) +  ', Line Number : ' + CAST(ERROR_LINE() AS VARCHAR(10)) + ', Description : ' +  ERROR_MESSAGE(), 3000 ) );

	IF @emc_flag = 0
	BEGIN
		SELECT NULL fac_id
   			,NULL fac_name
   			,NULL fac_code
   			,NULL room_id 
   			,NULL room_desc   
   			,NULL unit_desc
   			,NULL floor_desc
   			,NULL room_desc_original
   			,NULL bed_id
   			,NULL bed_desc
   			,NULL client_id
   			,NULL client_name
   			,NULL first_name
   			,NULL last_name
   			,NULL client_id_number
   			,NULL sex
   			,NULL primary_payer_name
   			,NULL room_type
   			,NULL sq_footage   
   			,NULL market_rate 
   			,NULL actual_rate  
   			,NULL room_rate   
   			,NULL discount
   			,NULL deposit_required   
   			,NULL deposit_received   
   			,NULL lease_start 
   			,NULL lease_end
			,NULL resident_status
   			,NULL move_in 
   			,NULL estimated_move_out
   			,NULL stay_days
   			,NULL bed_status  
   			,NULL room_status 
   			,NULL is_unit_occupied
   			,NULL occupied_bed_id
   			,NULL occupied_room_id
   			,NULL occupied_market_rate
   			,NULL occupied_actual_rate
   			,NULL occupied_discount
   			,NULL occupied_sq_footage
   			,NULL total_deposit_required   
   			,NULL total_deposit_received   
   			,NULL total_market_rate 
   			,NULL total_actual_rate 
   			,NULL total_discount 
   			,NULL inactive_bed_status
   			,NULL occupied_days
   			,NULL vacant_days
   			,@status_code status_code  
   			,@status_text status_text   
   			,@vselected_parameters selected_parameters
   			,NULL effective_date
   			,NULL is_companion
   			,NULL anniversary_date
   			,NULL row_num
   			,NULL ordering_row_num;
	END
  
	IF @debug_me='Y'
	BEGIN
		Print 'Stored procedure failure in step: '+ convert(varchar(3),@vStep) + '     ' + convert(varchar(26), getdate());
		Print 'Error code: '+convert(varchar(3),@vStep) + '; Error description:      ' + @Status_Text;
	END
END CATCH  

IF OBJECT_ID('tempdb..#RentRollData') IS NOT NULL
BEGIN
	DROP TABLE #RentRollData;
END

IF OBJECT_ID('tempdb..#RentRollResult') IS NOT NULL
BEGIN
	DROP TABLE #RentRollResult;
END

RETURN;

END


GO
GRANT EXECUTE ON sproc_prp_rl_rent_roll_report3 TO PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_prp_rl_rent_roll_report3.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_rent_roll_report3.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_statements.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ================================================================================= 
-- PCC-117622       :   script to create sproc_prp_rl_statements Procedure  
--						-- 
-- Written By:          Ritch Moore
-- Reviewed By:         
-- 
-- Script Type:         DDL 
-- Target DB Type:      Client
-- Target ENVIRONMENT:  BOTH (US/CA) 
-- 
-- 
-- Re-Runable:          YES 
-- 
-- Description of Script : Create sproc_prp_rl_statements 
-- 
-- Special Instruction: 

-- 
-- =================================================================================

/***********************************************************************************
Revision History:
2017-06-23  Ritch Moore		PCC-117622	Initial creation of this stored proc - based on sproc_prp_rl_consolidated_statement with transaction logic from sproc_prp_rl_transaction_report
2017-06-23  Ritch Moore		PCC-117714	Resident Filter Logic + input param cleanup
2017-07-05  Ritch Moore		PCC-117677	Combine consecutive room charges if the rate has not changed (step 50)
2017-07-05  Ritch Moore		PCC-118468	Append date range at the end of the description when grouping by charge code or charge code category
2017-07-18  Ritch Moore		PCC-118334	Add order by functionality including reprint from
2017-07-26	Ritch Moore		PCC-118334	Accept new "Order By" parameter to statement stored proc
2017-07-26	Ritch Moore		PCC-118679	Add Room Location to Room Charges
2017-07-31	Ritch Moore		PCC-119896	Change sorting in the room combine logic
2017-07-31	Ritch Moore		PCC-119178	Other payer statement logic
2017-08-03	Ritch Moore		PCC-118977	Read checks payable to from the statement config table
2017-08-03	Ritch Moore		PCC-119183	Add resident status as an input parameter
2017-08-16	Ritch Moore		PCC-119293	Add additional values to informational payer data
2017-08-17	Ritch Moore		PCC-118699	Transaction sorting option
2017-08-17	Ritch Moore		PCC-120524	Suppress Net Zeros Transactions
2017-08-18	Ritch Moore		PCC-118685	Add Resident Trust data
2017-08-18	Ritch Moore		PCC-120217	Add EFT bank message
2017-08-21	Ritch Moore		PCC-120087	Reintroduce the Statement Date in configuration
2017-08-23	Ritch Moore		PCC-120806	Summarize Ancillary Charge's child transaction as the parent
2017-08-23	Ritch Moore		PCC-119715	Add additional Show Comments Options
2017-08-23	Ritch Moore		PCC-120749	Add Aging for Other Private statement payers
2017-08-30	Ritch Moore		PCC-121158	Summarize Other Co-insurance items
2017-08-30	Ritch Moore		PCC-121198	Remove Transaction Type Description from Description
2017-09-01	Ritch Moore		PCC-121288	Add Contact Country to output
2017-09-05	Ritch Moore		PCC-121242	Add GST/HST Registration #'s (for CDN statements)
2017-09-06	Ritch Moore		PCC-121426	Add case statement around appending the care level to transaction descriptions.
2017-09-06	Ritch Moore		PCC-121509	Address other payer aging/balance due mismatches
2017-09-08	Ritch Moore		PCC-121456	Conditional EFT statement message logic
2017-09-12	Ritch Moore		PCC-121797	Add if statements around transaction grouping (private and other payers separate
2017-09-13	Ritch Moore		PCC-121523	Payment Reversals will be enclosed by double asterisks
2017-09-20	Ritch Moore		PCC-122170	Wrap child transaction combining in statement type "if" statements
2017-09-22	Ritch Moore		PCC-122292	Keep Facility Group Addresses when run from EMC- no payer overrides
2017-09-26	Ritch Moore		PCC-122303	Add resident number after the resident name in payment coupon - limit to 2
2017-10-04	Ritch Moore		CORE-4190	Replace isnumeric function with try_convert as isnumeric returns true when commas exist (bed description 1,2,3 for instance)
2017-10-18	Ritch Moore		CORE-4612	Adjust invoice gathering joins for Canadian performance (ext)
2017-10-30	Ritch Moore		CORE-5462	Trust balance should not show on Statement when show balance on statement is set to No in the trust client configuration
2017-10-30	Ritch Moore		CORE-772	Support passing of invoice_id's for statement print link and trial billing
2017-11-20	Ritch Moore		CORE-7167	Include billed transactions in other invoices on the trial statement for the same billing date and generated date
2017-11-30	Ritch Moore		CORE-7473	Still generating consolidated statements in Statement when consolidate statement is not checked
2017-12-06	Ritch Moore		CORE-8101	Resolve issue with not pulling Resident Insurance Address into the statement
2017-12-19	Ritch Moore		CORE-7803	Return address needs to display facility/facility group address
2017-12-19	Ritch Moore		CORE-7953	Remove batch number and entry number on transaction description
2017-12-20	Ritch Moore		CORE-7957	Show Reversal transaction at top of each sorting group
2018-01-02	Ritch Moore		CORE-8776	Statement Message needs to be a sticky setting
2018-01-03	Ritch Moore		CORE-7950	Display Transaction Warning Message on the Statement *NEW*
2018-01-04	Ritch Moore		CORE-7975	In EMC, each facility/campus selected will generate statements using their own assigned template
2018-01-04	Ritch Moore		CORE-9169	Update to the source of checks payable to
2018-01-08	Ritch Moore		CORE-8365	Join update for other aging for performance
2018-02-05	Ritch Moore		CORE-10900	Performance tuning for Statement
2018-02-08	Ritch Moore		CORE-10905	Support for Portal Export format
2018-03-19	Ritch Moore		CORE-11907	Configurable Export Specification Updates
2018-04-02	Ritch Moore		CORE-14099	Configurable Export Payer Export filter
2018-04-04	Ritch Moore		CORE-14518	Consecutive room related transactions do not roll up in specific scenario with multiple contacts
2018-04-06	Ritch Moore		CORE-10718	New Identifier on new statement for Payment Portal
2018-04-30	Ritch Moore		CORE-15273	Replace payer temp table with ar_lib_payers with the export condition - performance
2018-06-18	Ritch Moore		CORE-17401	Update to include configurable account number option
2018-06-27	Ritch Moore		CORE-17930	Add the account number label to the Configurable export
2018-06-27	Ritch Moore		CORE-17932	Add the account number option to the Configurable export
2018-07-05	Ritch Moore		CORE-17759	Add distinct to temp invoice table load, when invoice_ids passed
2018-07-16	Ritch Moore		CORE-19445	Replace distinct added in CORE-17759 with Exists - as per DM
2018-08-01	Ritch Moore		CORE-19440	Only show informational payer balance when the balance greater than $0
2018-08-01	Ritch Moore		CORE-15744	New Statement should not consolidate Resident statements by all facility group types
2018-08-01	Ritch Moore		CORE-15353	Duplicate entries for residents in EMC when there are client records for the same resident within the billing office - rechecked in for snrzt issue
***********************************************************************************/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_prp_rl_statements' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE dbo.sproc_prp_rl_statements
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO


Create Procedure dbo.sproc_prp_rl_statements

  @export_mode bit = 0
, @template_id int = 0
, @fac_id varchar(max) = Null
, @include_inactive_fac_ids bit = 0
, @is_contact bit = 1
, @receiver_ids varchar(max)  = '-1'
, @client_status smallint = -1 --0=current, 1=discharged, -1=all
, @payer_id_list varchar(max) = '0'
, @invoice_id_list varchar(max) = Null
, @last_statement bit = 1
, @statement_start_date datetime = Null
, @statement_end_date datetime = Null
, @show_results varchar(2) = 'D' --D = Detail, C = Summarize by Charge Code, CC = Summarize by Charge Code Category, A = Summarize all Ancillary Charges
, @combine_children tinyint = 0 -- 0 = all transactions, 1 = combine all children, 2 = reimbursement rate (combine CA and CR with parent)
, @billing_group varchar(max) = Null
, @display_admit_date bit = 0
, @display_discharge_date bit = 0
, @reprint_from varchar(20)
, @show_aging bit = 0
, @cash_receipt_comments bit = 0
, @ancillary_comments bit = 0
, @adjustment_comments bit = 0
, @statement_message varchar(254) = ''
, @is_emc  bit = '0'
, @export_resend_flag bit = 0
, @include_prefix_facility_code bit ='0'
, @minimum_balance money = Null
, @use_effective_date_as_bill_date bit = 0
, @sort_by bit = 0 --0='Name', 1='location'
, @transaction_order char(1) = 'P' --'P' = transaction type/date, 'D' = date/trnsaction_type
, @is_new_eft char(1) = 'Y' -- 'N' = Old Canadian method, 'Y' = New method
, @account_number_source char(1) = 'C' -- 'C' = Contact Number, 'R' = Resident Number
, @combine_ancillary_flag bit = 0
, @execution_user_login varchar(60)
, @debug_me char(1)  = 'N'
, @rows_returned int = 0 out
, @status_code int = 0 out 
, @status_text varchar(3000) = Null out


/********************************************************************************

exec dbo.sproc_prp_rl_statements
  @export_mode = 0
, @template_id = 1
, @fac_id = '10'--'35,36,37'--1 --'8'
, @include_inactive_fac_ids = '0'
, @is_contact = 0
, @receiver_ids = '-1'
, @client_status = -1
, @payer_id_list = '0'
, @invoice_id_list = '1762871,1762864,1762872'
, @last_statement = '0'--'0'
, @statement_start_date = '1/1/2018'
, @statement_end_date = '3/31/2018'
, @show_results = 'D'
, @combine_children = 0
, @billing_group = Null--'363'
, @display_admit_date = '0'
, @display_discharge_date = '0'
, @reprint_from = ''
, @show_aging = '0'
, @cash_receipt_comments = 1
, @ancillary_comments = 1
, @adjustment_comments = 1
, @statement_message = ''
, @is_emc = 0
, @export_resend_flag = 1
, @include_prefix_facility_code  ='1'
, @minimum_balance = Null
, @use_effective_date_as_bill_date = 0
, @sort_by = 0
, @transaction_order = 'D'
, @is_new_eft = 'Y'
, @account_number_source = 'C'
, @execution_user_login = 'PCC-adhikj'
, @debug_me  = 'N'
, @rows_returned = 0
, @status_code = ''
, @status_text = ''     

**********************************************************************************/

as
Begin

SET NOCOUNT ON;

	DECLARE @sprocExecId bigint 
	DECLARE @startTime DATETIME = GETDATE()
	DECLARE @endTime DATETIME
	Declare @sprocParamLogEnable int = 0
	select @sprocParamLogEnable = count(1) from configuration_parameter
	where name = 'enable_ar_sproc_param_log' and value = 'Y'
	
	if @sprocParamLogEnable > 0
	BEGIN
		Begin try

			declare @params varchar(max)
			declare @proc_name nvarchar(128) = object_name(@@procid)
			select @params = '@export_mode=' + case when @export_mode is null then 'NULL' else cast(@export_mode as VARCHAR) end 
			+ ',@template_id=' + case when @template_id is null then 'NULL' else cast(@template_id as VARCHAR) end
			+ ',@fac_id=' + case when @fac_id is null then 'NULL' ELSE '''' + @fac_id + '''' end 
			+ ',@include_inactive_fac_ids=' + case when @include_inactive_fac_ids is null then 'NULL' else cast(@include_inactive_fac_ids as VARCHAR) end
			+ ',@is_contact=' + case when @is_contact is null then 'NULL' else cast(@is_contact as VARCHAR) end
			+ ',@receiver_ids=' + case when @receiver_ids is null then 'NULL' ELSE '''' + @receiver_ids + '''' end 
			+ ',@client_status=' + case when @client_status is null then 'NULL' else cast(@client_status as VARCHAR) end
			+ ',@payer_id_list=' + case when @payer_id_list is null then 'NULL' ELSE '''' + @payer_id_list + '''' end 
			+ ',@invoice_id_list=' + case when @invoice_id_list is null then 'NULL' ELSE '''' + @invoice_id_list + '''' end 
			+ ',@last_statement=' + case when @last_statement is null then 'NULL' else cast(@last_statement as VARCHAR) end
			+ ',@statement_start_date=' + case when @statement_start_date is null then 'NULL' else ''''+ convert(VARCHAR, @statement_start_date, 121) + '''' end
			+ ',@statement_end_date=' + case when @statement_end_date is null then 'NULL' else ''''+ convert(VARCHAR, @statement_end_date, 121) + '''' end
			+ ',@show_results=' + case when @show_results is null then 'NULL' ELSE '''' + @show_results + '''' end
			+ ',@combine_children=' + case when @combine_children is null then 'NULL' else cast(@combine_children as VARCHAR) end
			+ ',@billing_group=' + case when @billing_group is null then 'NULL' ELSE '''' + @billing_group + '''' end
			+ ',@display_admit_date=' + case when @display_admit_date is null then 'NULL' else cast(@display_admit_date as VARCHAR) end
			+ ',@display_discharge_date=' + case when @display_discharge_date is null then 'NULL' else cast(@display_discharge_date as VARCHAR) end
			+ ',@reprint_from=' + case when @reprint_from is null then 'NULL' ELSE '''' + @reprint_from + '''' end
			+ ',@show_aging=' + case when @show_aging is null then 'NULL' else cast(@show_aging as VARCHAR) end
			+ ',@cash_receipt_comments=' + case when @cash_receipt_comments is null then 'NULL' else cast(@cash_receipt_comments as VARCHAR) end
			+ ',@ancillary_comments=' + case when @ancillary_comments is null then 'NULL' else cast(@ancillary_comments as VARCHAR) end
			+ ',@adjustment_comments=' + case when @adjustment_comments is null then 'NULL' else cast(@adjustment_comments as VARCHAR) end
			+ ',@statement_message=' + case when @statement_message is null then 'NULL' ELSE '''' + @statement_message + '''' end
			+ ',@is_emc=' + case when @is_emc is null then 'NULL' else cast(@is_emc as VARCHAR) end
			+ ',@export_resend_flag=' + case when @export_resend_flag is null then 'NULL' else cast(@export_resend_flag as VARCHAR) end
			+ ',@include_prefix_facility_code=' + case when @include_prefix_facility_code is null then 'NULL' else cast(@include_prefix_facility_code as VARCHAR) end
			+ ',@minimum_balance=' + case when @minimum_balance is null then 'NULL' else cast(@minimum_balance as VARCHAR) end
			+ ',@use_effective_date_as_bill_date=' + case when @use_effective_date_as_bill_date is null then 'NULL' else cast(@use_effective_date_as_bill_date as VARCHAR) end
			+ ',@sort_by=' + case when @sort_by is null then 'NULL' else cast(@sort_by as VARCHAR) end
			+ ',@transaction_order=' + case when @transaction_order is null then 'NULL' ELSE '''' + @transaction_order + '''' end
			+ ',@is_new_eft=' + case when @is_new_eft is null then 'NULL' ELSE '''' + @is_new_eft + '''' end
			+ ',@account_number_source=' + case when @account_number_source is null then 'NULL' ELSE '''' + @account_number_source + '''' end
			+ ',@combine_ancillary_flag=' + case when @combine_ancillary_flag is null then 'NULL' else cast(@combine_ancillary_flag as VARCHAR) end
			+ ',@execution_user_login=' + case when @execution_user_login is null then 'NULL' ELSE '''' + @execution_user_login + '''' end 
			+ ',@debug_me=' + case when @debug_me is null then 'NULL' ELSE '''' + @debug_me + '''' end 
			+ ',@rows_returned=' + case when @rows_returned is null then 'NULL' else cast(@rows_returned as VARCHAR) end 
			+ ',@status_code=' + case when @status_code is null then 'NULL' else cast(@status_code as VARCHAR) end
			+ ',@status_text=' + case when @status_text is null then 'NULL' ELSE '''' + @status_text + '''' end 
						
			insert into ar_sproc_params_log (sproc_name, params,start_time)
			SELECT @proc_name, @params, @startTime

			set @sprocExecId = @@identity
		END TRY
		BEGIN CATCH
			set @sprocExecId = -1
		END CATCH
	END

--declare Standard local variables required for any store proc
DECLARE   @vStep int
		, @vErr varchar(max)
		, @vdelim char(1)
		, @vReportDate datetime
		, @vRowCount int
		, @vCflr varchar(10)
		, @vTermClient VARCHAR(50)
		, @vTermFacility VARCHAR(50)
		, @vTermAdmission VARCHAR(50)
		, @vTermDischarge VARCHAR(50)
		, @vTermRoom VARCHAR(50)

--Facility Related variables, also used in capturing execution Statistics 
Declare @vFacIDs varchar(max)		
Declare @PRP_FacList as table(FacId int)
Declare @vFacWarningMsg varchar(max) --- to know whether it the returned list is restricted

----Local Variables
DECLARE @vFacId varchar(max)
	, @vTemplateId varchar(max)
	, @vIncludeInactiveFacIds bit 
	, @vIsContact bit
	, @vReceiverIds varchar(max)
	, @vClientStatus smallint
	, @vPayerIdList varchar(max)
	, @vInvoiceIdList varchar(max)
	, @vLastStatement	bit
	, @vStatementStartDate datetime
	, @vLastInvoiceDate datetime
	, @vStatementEndDate datetime
	, @vSummarizeReversals bit
	, @vShowResults varchar(2)
	, @vCombineChildren tinyint
	, @vSuppress0value bit
	, @vBillingGroup varchar(max)
	, @vDisplayAdmitDate bit
	, @vDisplayDischargeDate bit
	, @vReprintFrom varchar(20)
	, @vIncludeResidentMessage bit
	, @vShowAging bit
	, @vOtherPayerSummary bit
	, @vCashReceiptComments bit
	, @vAncillaryComments bit
	, @vAdjustmentComments bit
	, @vStatementMessage varchar(500)
	, @vShowPaymentDueDate bit
    , @vFacIdListNotInGroup varchar(max)
	, @vIsEmc  bit
	, @vIncludeNonContacts  bit
--	, @vNonContactStatementStartDate datetime
    , @vIncludePrefixFacilityCode  bit
	, @vMinimumBalance money
	, @vUseEffectiveDateAsBillDate bit
	, @vChecksPayableTo	varchar(100)
	, @vPrivateStatementsIncluded bit
	, @vOtherStatementsIncluded bit
	, @vSortBy bit
	, @vTransactionOrder char(1)
	, @vIsNewEft char(1)
	, @vIsTrial bit
	, @vExportMode bit
	, @vExportResendFlag bit
	, @vShowInvoiceNumber bit
	, @vShowLocation bit 
	, @vShowResidentNumber bit 
	, @vShowTransactionWarningMessage bit 
	, @vTransactionWarningMessage varchar(200) 
	, @vDisplayUnitAndAmountFlag bit
	, @vPaymentInstructions varchar(1000)
	, @vShowOnlineID bit
	, @vAccountNumberLabel varchar(15)
	, @vAccountNumberSource char(1)
	, @vCombineRecurringAncillary bit
	, @vCombineCouncilPayerContribution bit

create table #client_ids_table
		(
			client_id int
		  );

create table #receiver_ids_table 
		 (
			contact_id numeric(18,1),
			consolidate_statement tinyint
		  );

create table #payer_ids_table 
		 (
			fac_id int,
			payer_id int, 
			bill_payer_id int,
			client_id int,
			statement_date datetime,
			generated_date datetime,
			trial_flag varchar(1)
		  );

create table #invoice_ids_table 
		 (
			invoice_id int,
			client_id int,
			payer_id int,
			statement_date datetime,
			generated_date datetime,
			trial_flag varchar(1)
		  );

create table #billing_group_table
		(
			 group_id int
		);

create table #contact_union_table 
		(
			  contact_id numeric(18,1)
			 ,contact_num int
			 ,payer_id int
			 ,client_id int
			 ,bill_date datetime
			 ,inv_created_date datetime
			 ,generated_date datetime
			 ,row_num int
		);

-----Governor and Statistics Variables 
Declare  @vgs_program_name varchar(200)
		 ,@vgs_start_time datetime
		 ,@vgs_execution_user varchar(60)
		 ,@vgs_fill_end_time datetime
		 ,@vgsStepStartTime datetime
		 ,@vgsStepEndTime datetime

----client Access Varaibles
Declare @vCheckClientId varchar(max)
Declare @vClientIDs varchar(max)		
Declare @vClientWarningMsg varchar(max)--- to know whether it the returned list is restricted

BEGIN TRY

Set @status_code = 0   ---- Status Code 0 = Success, 1 = Exception
set @status_text = null;
set @rows_returned = 0;
Set @vgs_program_name  = Object_name(@@ProcID);  ---Current Store Proc Name
Set @vgs_start_time = getdate();
Set @vgs_execution_user = @execution_user_login;
set @vdelim = ','
set @vCflr = Char(13)
set @vReportDate = getdate();
set @vIsTrial = 0
set @vStep = 0
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Executing store proc :  ' + @vgs_program_name  + convert(varchar(26),getdate(),109)

----Parameter Sniffing - use local variables when they are used in a where clause
SET @vFacID							= @fac_id;
SET @vTemplateId					= @template_id;
SET @vIncludeInactiveFacIds			= @include_inactive_fac_ids; 
SET @vIsContact						= @is_contact;
SET @vReceiverIds					= @receiver_ids;
SET @vClientStatus					= @client_status
SET @vPayerIdList					= @payer_id_list;
SET @vInvoiceIdList					= @invoice_id_list;
SET @vLastStatement					= @last_statement;
SET @vStatementStartDate			= convert(datetime, convert(varchar(10),@statement_start_date , 101) + ' 00:00:00');
SET @vStatementEndDate				= convert(datetime, convert(varchar(10),@statement_end_date , 101) + ' 23:59:59');
SET @vSummarizeReversals			= 1;
SET @vShowResults					= @show_results;
SET @vCombineChildren				= @combine_children;
SET @vBillingGroup					= isnull(@billing_group,'-1');
SET @vDisplayAdmitDate				= @display_admit_date;
SET @vDisplayDischargeDate			= @display_discharge_date;
SET @vReprintFrom					= @reprint_from; --case when @reprint_from is not null then @reprint_from+'%' else null end;
SET @vIncludeResidentMessage		= 1;
SET @vShowAging						= @show_aging;
SET @vCashReceiptComments			= @cash_receipt_comments;
SET @vAncillaryComments				= @ancillary_comments;
SET @vAdjustmentComments			= @adjustment_comments;
SET @vStatementMessage				= @statement_message;
SET @vShowPaymentDueDate			= 0;
SET @vIsEmc							= @is_emc;
SET @vIncludePrefixFacilityCode		= @include_prefix_facility_code;
SET @vIncludeNonContacts			= 0;
SET @vMinimumBalance				= @minimum_balance;
SET @vUseEffectiveDateAsBillDate	= @use_effective_date_as_bill_date;
SET @vSortBy						= @sort_by;
SET @vTransactionOrder				= @transaction_order;
SET @vIsNewEft						= @is_new_eft;
SET @vSuppress0value				= 1;
SET @vExportMode					= @export_mode;
SET @vExportResendFlag				= @export_resend_flag;

SET @vOtherPayerSummary				= 1;
SET @vShowOnlineID					= 1;
SET @vAccountNumberSource			= @account_number_source;
SET @vCombineRecurringAncillary		= @combine_ancillary_flag;
SET @vCombineCouncilPayerContribution = (select top 1 isnull(cp.value,0)
										from configuration_parameter cp 
										where name = 'combine_council_payer_contribution' and fac_id = -1);


--If @vReceiverIds = '-1' and (@vIsContact = 0 or @vPayerIdList = '0') --for all we want to pull as contacts, but only when private/outpatient is selected alone - other payers need the resident.
--	set @vIsContact = 1

--set hard coded export conditions
if @vExportMode = 1
	begin
		SET @vShowAging				= 0;
		SET @vOtherPayerSummary		= 0;
	end
	
If  @vReceiverIds = '-1'
	set @vIncludeNonContacts = 1
else
	set @vIncludeNonContacts = 0

If  @vReceiverIds <> '-1' and @vIsContact = 0
	begin
		INSERT into #client_ids_table select Cast(items as int) from dbo.Split(@vReceiverIds,@vdelim)
	end
	
If  @vReceiverIds <> '-1' and @vIsContact = 1
	begin
		INSERT into #receiver_ids_table select Cast(items as int), 2 from dbo.Split(@vReceiverIds,@vdelim)
	end
--else
--	begin

--	end

create table #contact_clients
	(
		  fac_id							int
		, contact_id						numeric(18,1) 
		, consolidate_statement				bit
		, client_id							int
		, invoice_id						int
		, statement_invoice_number			int
		, payer_id							int
		, payer								varchar(50)
		, inv_effective_date				datetime
		, inv_eff_date_from					datetime
		, inv_eff_date_to					datetime
		, remit_to_name						varchar(375)
		, remit_to_address1					varchar(70)
		, remit_to_address2					varchar(70)
		, remit_to_address3					varchar(70)
		, remit_to_city						varchar(75)
		, remit_to_county					varchar(75)
		, remit_to_prov_state				varchar(75)
		, remit_to_country					varchar(75)
		, remit_to_postal_zip_code			varchar(75)
		, remit_to_phone					varchar(35)
		, contact_title						varchar(30)
		, contact_first_name				varchar(120)
		, contact_last_name					varchar(50)
		, contact_address1					varchar(105)
		, contact_address2					varchar(120)
		, contact_address3					varchar(120)
		, contact_city						varchar(75)
		, contact_county					varchar(75)
		, contact_prov_state				varchar(75)
		, contact_postal_zip_code			varchar(75)
		, contact_country					varchar(75)
		, contact_email						varchar(75)
		, account_number					varchar(12)
		, generated_date					datetime
		, bill_date							datetime
		, aging_date						datetime
		, payment_due_date					datetime
		, pre_consolidated_payment_due_date	datetime
		, statement_through_date			datetime
		, amount_due						money
		, eft_message						varchar(500)
		, client_message					varchar(500)
		, group_message						varchar(max)
		, global_message					varchar(500)
		, previous_balance_due				money
		, payments							money
		, summary_fac_id					int
		, summary_charge_center				varchar(75)
		, summary_charge_center_code		varchar(5)
		, summary_charge_client_first_name	varchar(50)
		, summary_charge_client_last_name	varchar(50)
		, summary_charge_client_name		varchar(120)
		, summary_charge_client_number		varchar(35)
		, summary_charge_client_location	varchar(100)
		, summary_charge_client_dob			datetime
		, summary_charge_client_admission	datetime
		, summary_charge_client_discharge	datetime
		, summary_current_balance			money
		, summary_previous_balance_due		money
		, summary_payments					money
		, summary_late_fees					money
		, summary_client_balance_due		money
		, private_bills_to					varchar(2)
		, amount_past_due_yn				char(1)
		, term_used_for_client				varchar(25)
		, client_admit_date					datetime
		, client_discharge_date				datetime
		, client_mrn						varchar(25)
		, client_first_name					varchar(50)
		, client_last_name					varchar(50)
		, client_unit						varchar(50)
		, unit_order						numeric
		, client_room						varchar(50)
		, room_order						numeric
		, client_bed						varchar(50)
		, bed_order							numeric
		, patient_specific_message			varchar(500)
		, contact_num						int
		, non_consolidated_contact_num		int
		, client_list						varchar(500)
		, main_location						bit
		, consolidated_location_order		smallint
		, sort_location						varchar(100)
		);

CREATE CLUSTERED INDEX _tmp_idx_contact_clients on #contact_clients(contact_id,client_id,invoice_id);

create table #contact_return_to
	(
		  contact_num						int 
		, return_to_group_number			varchar(50)
		, return_to_name					varchar(375)
		, return_to_address1				varchar(70)
		, return_to_address2				varchar(70)
		, return_to_address3				varchar(70)
		, return_to_city					varchar(75)
		, return_to_county					varchar(75)
		, return_to_prov_state				varchar(75)
		, return_to_country					varchar(75)
		, return_to_postal_zip_code			varchar(75)
		, return_to_phone					varchar(35)
		);

CREATE CLUSTERED INDEX _tmp_idx_contact_payment_to on #contact_return_to(contact_num);

create table #local_transactions
	(
		  invoice_id					int
		, contact_id					numeric(18,1) 
		, batch_id						int
		, entry_number					int
		, client_id						int
		, auto_generated				varchar(1)
		, transaction_id				int
		, reversing_tx_id				int
		, distribution_tx_id			int
		, applied_payment_id			int
		, payer_id						int
		, parent_payer_id				int
		, days_account_id				int
		, dollars_account_id			int
		, fac_id						int
		, is_billed						bit
		, transaction_type				varchar(2)
		, parent_tx_type				varchar(2)
		, [description]					varchar(100)
		, alt_description				varchar(100)
		, cheque_number					varchar(50)
		, effective_date				datetime
		, transaction_date				datetime
		, bill_date						datetime
		, applied_date					datetime
		, generated_date				datetime
		, days_amount					int
		, daily_rate					money
		, monthly_rate					money
		, amount						money
		, care_level					varchar(5)
		, revenue_code					varchar(5)
		, hcpcs_code					varchar(5)
		, item_type_id					int
		, comment						varchar(200)
		, rate_type_id					int
		, rugs_modifier					varchar(2)
		, medicare_day					int
		, mppr_flag						bit
		, mark_as_billed_by				varchar(60)
		, mark_as_billed_date			datetime
		, mark_as_billed_comment		varchar(256)
		, transaction_type_group		tinyint
		, skip_bit						tinyint
	);

CREATE CLUSTERED INDEX _tmp_idx_local_transactions on #local_transactions(invoice_id,transaction_type,distribution_tx_id,reversing_tx_id);

create table #child_transactions
	(
		  distribution_tx_id			int
		, transaction_type				varchar(2)
		, parent_tx_type				varchar(2)
		, contact_id					numeric(18,1) 
		, invoice_id					int
		, payer_id						int
		, days_amount					int
		, daily_rate					money
		, monthly_rate					money
		, amount						money
		, bill_date						datetime
		, generated_date				datetime
		, skip_bit						bit

	);

create table #transactions

	(
		  invoice_id					int
		, fac_id						int
		, contact_id					numeric(18,1) 
		, contact_num					int
		, client_id						int
		, payer_id						int
		, payer							varchar(100)
		, payer_type					varchar(20)
		, batch_id						int
		, entry_number					int
		, distribution_tx_id			bigint
		, transaction_id				bigint
		, reversing_tx_id				bigint
		, auto_generated				varchar(1)
		, bill_date						datetime
		, posting_date					datetime
		, effective_date				datetime
		, effective_from_date			datetime
		, effective_thru_date			datetime
		, generated_date				datetime
		, charge_code					varchar(12)
		, frequency						varchar(1)
		, revenue_code					varchar(5)
		, hcpcs_code					varchar(5)
		, mppr_flag						bit
		, tx_description				varchar(200)
		, care_level					varchar(5)
		, benefit_days					varchar(10)
		, parent_tx_type				varchar(2)
		, transaction_type				varchar(2)
		, unit_amount					money
		, units							int
		, amount						money
		, gl_account					varchar(75)
		, days_account					varchar(75)
		, billed						varchar(5)
		, comment						varchar(200)
		, cheque_number					varchar(50)
		, adjusted_tx_type				varchar(10)
		, recurring_tx					bit
		, reversed						bit
		, transaction_type_group		tinyint
		, ancillary_year				smallint
		, ancillary_month				tinyint
		, balance_due					money
		, other_payer					tinyint
		, aging_total					money
		, aging_current_label			varchar(10)
		, aging_current_amount			money
		, aging_30_label				varchar(10)
		, aging_30_amount				money
		, aging_60_label				varchar(10)
		, aging_60_amount				money
		, aging_90_label				varchar(10)
		, aging_90_amount				money
		, aging_120_label				varchar(10)
		, aging_120_amount				money
		, aging_150_label				varchar(10)
		, aging_150_amount				money
		, aging_180_label				varchar(10)
		, aging_180_amount				money
		, aging_210_label				varchar(10)
		, aging_210_amount				money
		, detail_order					int

	);

CREATE CLUSTERED INDEX _tmp_idx_consolidated_statement_detail on #transactions(contact_id,client_id,invoice_id);

create table #facilty_group_info
	(
		  facility_group_id				int
		, fac_id						int
		, remit_to_group_number			varchar(50)
		, remit_to_name					varchar(100)
		, remit_to_address1				varchar(120)
		, remit_to_address2				varchar(120)
		, remit_to_address3				varchar(120)
		, remit_to_city					varchar(120)
		, remit_to_county				varchar(120)
		, remit_to_prov_state			varchar(120)
		, remit_to_country				varchar(120)
		, remit_to_postal_zip_code		varchar(120)
		, remit_to_phone				varchar(35)
		, facility_group_number			varchar(50)
		, facility_group_name			varchar(100)
		, facility_group_address1		varchar(75)
		, facility_group_address2		varchar(75)
		, facility_group_address3		varchar(75)
		, facility_group_city			varchar(75)
		, facility_group_county			varchar(75)
		, facility_group_prov_state		varchar(75)
		, facility_group_country			varchar(75)
		, facility_group_postal_zip_code	varchar(75)
		, facility_group_phone				varchar(75)
		, facility_group_fax				varchar(75)
			
	);

create table #balance_forward_union
	(	 contact_id		numeric(18,1) --int
		,contact_num	int
		,client_id		int 
		,payer_id		int
		,invoice_date	datetime
		,payer_type		varchar(20)
		,amount			money 
	);

create table #balance_forward_amount
	(	 contact_id		numeric(18,1) --int
		,contact_num	int
		,client_id		int 
		,payer_id		int 
		,invoice_date	datetime
		,payer_type		varchar(20)
		,amount			money 
	);


create table #facility_list 
		 (
			  fac_id int
			, cheques_payable_to varchar(max)
			, gst_hst varchar(3)
			, gst_number varchar(15)
			, show_payment_due_date bit
			, country varchar(75)
			);

create table #invoices
	(
		  fac_id						int
		, client_id						int
		, invoice_id					int
		, created_date					datetime
		, statement_invoice_number		int
		, payer_id						int
		, effective_date				datetime
		, eff_date_from					datetime
		, eff_date_to					datetime
		, generated_date				datetime
		, payment_due_date				datetime
		, statement_through_date		datetime
		, trial_flag					char(1)
		);

CREATE CLUSTERED INDEX _tmp_idx_invoices on #invoices(client_id);

create table #cfilter (receiver_id int)

create table #subclass (subclass_id int)
create table #relationship (item_id int)
			
set @vgsStepEndTime=GETDATE();
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
			
select @vStep = 10
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Validating Input Parameters  ' +  convert(varchar(26),getdate(),109)

----Validate all input parameters
if (
		@execution_user_login is null
	)
	begin
		set @vErr = 'One or more of the following input parameters is invalid... '
					+ ', @execution_user_login=' + isnull(@execution_user_login,'null/empty')
		
		RAISERROR (@vErr -- Message text
						,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
						,1 -- State
						);
	end

set @vgsStepEndTime=GETDATE();
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

Select @vStep = 20;
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Loading temp tables ' + convert(varchar(26),getdate(),109);

--CORE-85860 performance tuning: existing logic does not check for deleted column, we're not changing this logic for now
insert into #subclass select item_id from dbo.common_code where item_description = 'Resident'
CREATE CLUSTERED INDEX _tmp_idx_subclass on #subclass(subclass_id);

insert into #relationship select item_id from dbo.common_code where item_description = 'Self'
CREATE CLUSTERED INDEX _tmp_idx_relationship on #relationship(item_id);

INSERT into #facility_list select Cast(items as int) fac_id,'', Null, Null, 0, '' from dbo.Split(@vFacId,@vdelim)

update fac set fac.gst_hst = (case when config.gst_hst = 0 then 'GST' when config.gst_hst = 1 then 'HST' else Null end), fac.gst_number = config.gst_number 
from #facility_list fac
inner join dbo.ar_configuration config with (nolock) on fac.fac_id = config.fac_id
inner join dbo.configuration_parameter parm with (nolock) on fac.fac_id = parm.fac_id and parm.name = 'show_gst' and parm.value = 'Y'

update fl set fl.cheques_payable_to = (case when sct.cheques_payable_to_option = 0 then fac.name when sct.cheques_payable_to_option = 1 
	then grp.name else sct.cheques_payable_to end), fl.show_payment_due_date = (Case when config.show_payment_due_date = 'Y' then 1 else 0 end),
	fl.country = (Case when cntry.item_id is null then '' else cntry.item_description end)
from #facility_list fl
inner join dbo.facility fac with (nolock) on fl.fac_id = fac.fac_id
inner join dbo.view_ar_statement_configuration_template_facility_mapping map with (nolock) on map.fac_id = fac.fac_id
inner join dbo.ar_statement_configuration_template sct with (nolock) on map.template_id = sct.template_id
inner join dbo.ar_configuration config with (nolock) on fl.fac_id = config.fac_id
left join dbo.facility_group_mapping fgm with (nolock) on fac.fac_id = fgm.fac_id
left join dbo.facility_group grp with (nolock) on fgm.facility_group_id = grp.facility_group_id and grp.[type_id] = 1
left join dbo.common_code cntry with (nolock) on fac.country_id = cntry.item_id
--select * from #facility_list
--select * from facility where fac_id in(80,81,82,83)
--print '@vBillingGroup = ' +@vBillingGroup
IF @vBillingGroup <> '-1' --and @vBillingGroup <> '0'
	begin
		insert INTO #billing_group_table select Cast(items as int) from dbo.Split(@vBillingGroup,@vdelim)
	end

declare @vBillingGroupIncludesMissing bit
	
select @vBillingGroupIncludesMissing = count(1) from #billing_group_table where group_id = 0
--select * from #billing_group_table
SET @vPrivateStatementsIncluded = 0
SET @vOtherStatementsIncluded = 0

INSERT into #payer_ids_table (payer_id, bill_payer_id) select Cast(items as int), Cast(items as int) from dbo.Split(@vPayerIdList,@vdelim)

if (select count(*) from #payer_ids_table where payer_id = 0) > 0
	begin
		if @vExportMode = 0
			INSERT into #payer_ids_table 
			select distinct pyr.fac_id,libpayer.payer_id, 0, Null, Null, Null, 'N'
			from dbo.ar_lib_payers libpayer with (nolock)
			inner join dbo.ar_payers pyr with (nolock) on libpayer.payer_id = pyr.payer_id
			inner join #facility_list pf on pyr.fac_id = pf.fac_id
			where libpayer.deleted='N' and 
			--(libpayer.payer_type  = 'Private' OR libpayer.payer_type  = 'Outpatient') and libpayer.bill_form = 'private' --old statment filter method.
			((libpayer.payer_type = 'Private' and libpayer.bill_form = 'private') or (libpayer.payer_type = 'Outpatient' and libpayer.outpatient_payer_type = 'Private'))
		else
			INSERT into #payer_ids_table 
			select distinct pyr.fac_id,libpayer.payer_id, 0, Null, Null, Null, 'N'
			from dbo.ar_lib_payers libpayer with (nolock)
			inner join dbo.ar_payers pyr with (nolock) on libpayer.payer_id = pyr.payer_id
			inner join #facility_list pf on pyr.fac_id = pf.fac_id
			where libpayer.deleted='N' and pyr.export_ps_flag = 'Y' and 
			--(libpayer.payer_type  = 'Private' OR libpayer.payer_type  = 'Outpatient') and libpayer.bill_form = 'private' --old statment filter method.
			((libpayer.payer_type = 'Private' and libpayer.bill_form = 'private') or (libpayer.payer_type = 'Outpatient' and libpayer.outpatient_payer_type = 'Private'))


		delete from #payer_ids_table where payer_id = 0 and bill_payer_id = 0

		SET @vPrivateStatementsIncluded = 1

	end

if (select count(*) from #payer_ids_table where bill_payer_id > 0) > 0
	SET @vOtherStatementsIncluded = 1

if (select count(*) from #payer_ids_table where bill_payer_id > 0) > 0
	begin
		SET @vOtherStatementsIncluded = 1
		if @vInvoiceIdList is null 
			begin

				insert into #payer_ids_table
				select pyr.fac_id, pyr.payer_id, pyr.payer_id, lpyr.client_id, lpyr.statement_date, lpyr.generated_date, 'N'
				from
				#payer_ids_table lpyr
				inner join dbo.ar_payers pyr on lpyr.payer_id = pyr.payer_id
				inner join #facility_list pf on pyr.fac_id = pf.fac_id
				where lpyr.bill_payer_id > 0

				delete from #payer_ids_table where fac_id is null

			end
	end

if @vInvoiceIdList is not null
	begin
		INSERT into #invoice_ids_table (invoice_id) select Cast(items as int) from dbo.Split(@vInvoiceIdList,@vdelim)

		update prntinv set prntinv.client_id = inv.client_id, prntinv.payer_id = inv.payer_id, prntinv.statement_date = inv.effective_date, prntinv.generated_date = invstat.generated_date,
			prntinv.trial_flag = inv.trial_flag
		from
		#invoice_ids_table prntinv
		inner join dbo.ar_invoice inv on prntinv.invoice_id = inv.invoice_id
		left join dbo.ar_invoice_statement invstat on inv.invoice_id = invstat.invoice_id

		update pyr set pyr.statement_date = prntinv.statement_date, pyr.generated_date = prntinv.generated_date, pyr.trial_flag = prntinv.trial_flag
		from
		#payer_ids_table pyr
		inner join #invoice_ids_table prntinv on pyr.payer_id = prntinv.payer_id

		insert into #payer_ids_table
		select pyr.fac_id, pyr.payer_id, pyr.bill_payer_id, prntinv.client_id, prntinv.statement_date, prntinv.generated_date, prntinv.trial_flag
		from
		#payer_ids_table pyr
		inner join #invoice_ids_table prntinv on pyr.payer_id = prntinv.payer_id

		delete pyr
		from
		#payer_ids_table pyr
		inner join #payer_ids_table dpyr on pyr.payer_id = dpyr.payer_id and pyr.statement_date = dpyr.statement_date and pyr.generated_date = dpyr.generated_date
		where pyr.client_id is null and dpyr.client_id is not null

		insert into #payer_ids_table
		select pyr.fac_id, pyr.payer_id, pyr.bill_payer_id, dpyr.client_id, dpyr.statement_date, dpyr.generated_date, dpyr.trial_flag
		from
		#payer_ids_table pyr
		left join #payer_ids_table dpyr on pyr.bill_payer_id = dpyr.bill_payer_id 
		where pyr.client_id is null and dpyr.client_id is not null
	
		delete from #payer_ids_table where client_id is null;

		with dups 
			as
			(select fac_id, payer_id, bill_payer_id, client_id, statement_date, generated_date, trial_flag,
				row_number() OVER ( PARTITION BY fac_id, payer_id, bill_payer_id, client_id, statement_date, generated_date, trial_flag ORDER BY fac_id, payer_id, bill_payer_id, client_id, statement_date, generated_date, trial_flag ) AS rwnum
				from #payer_ids_table
			)

		delete from dups where rwnum > 1
		
		IF (select COUNT(1) from #invoice_ids_table where trial_flag = 'Y') > 0
		begin
			set @vIsTrial=1
			set @vShowAging = 0 --aging won't include the trial bill transactions and will appear off
		end
	end

if isnull(@vReceiverIds, '-1') <> '-1' 
	insert into #cfilter select Cast(items as int) from dbo.Split(@vReceiverIds,@vdelim)

if @debug_me = 'Y' select * from #receiver_ids_table
if @debug_me = 'Y' select * from #payer_ids_table

--gather export variables

if @vExportMode = 1
	begin

		--select @vTemplateId = facmap.template_id from view_ar_statement_configuration_template_facility_mapping facmap where fac_id = @vFacId
		set @vTemplateId = (select top 1 facmap.template_id 
			from view_ar_statement_configuration_template_facility_mapping facmap 
			inner join #facility_list fl on facmap.fac_id = fl.fac_id order by facmap.fac_id)

		

		select 
			 @vDisplayAdmitDate = cfg.display_admit_date_flag,
			 @vDisplayDischargeDate = cfg.display_discharge_date_flag,
			 @vTransactionOrder = cfg.sort_option,
			 @vUseEffectiveDateAsBillDate = cfg.statement_date_option,
			 @vCombineChildren = cfg.transaction_display_option,
			 @vShowResults = cfg.ancillary_display_option,
			 @vCashReceiptComments = cfg.comment_from_cash,
			 @vAncillaryComments = cfg.comment_from_ancillary,
			 @vAdjustmentComments = cfg.comment_from_adjustments,
			 @vShowLocation = cfg.display_location_flag,
			 @vShowResidentNumber = cfg.display_resident_number_flag,
			 @vShowInvoiceNumber = cfg.display_invoice_number_flag,
			 @vShowTransactionWarningMessage = cfg.display_transaction_warning_message,
			 @vTransactionWarningMessage = cfg.transaction_warning_message,
			 @vDisplayUnitAndAmountFlag = cfg.display_unit_and_amount_flag,
			 @vPaymentInstructions = cfg.payment_instructions,
			 @vIncludePrefixFacilityCode = cfg.prefix_facility_code_to_account_number_flag,
			 @vAccountNumberLabel = cfg.account_number_label,
			 @vAccountNumberSource = cfg.account_number_source
		from dbo.ar_statement_configuration_template cfg with (nolock) where template_id = @vTemplateId
--select * from ar_statement_configuration_template
		--set terms
		if @vIsEmc = 1
			Select @vTermClient = term_client
				, @vTermFacility = term_facility
				, @vTermAdmission = term_admission
				, @vTermDischarge = term_discharge
				, @vTermRoom = term_room
			from [dbo].fn_prp_get_terminology(@vFacId,0)
			where fac_id = -1
		else
			Select @vTermClient = term_client
				, @vTermFacility = term_facility
				, @vTermAdmission = term_admission
				, @vTermDischarge = term_discharge
				, @vTermRoom = term_room
			from [dbo].fn_prp_get_terminology(@vFacId,0)
			where fac_id <> -1

	end

--select @vShowPaymentDueDate = cfg.display_payment_due_date from dbo.ar_statement_configuration_template cfg with (nolock) where template_id = @vTemplateId

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

Select @vStep = 30;
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Gathering invoices ' + convert(varchar(26),getdate(),109);

if @vLastStatement = 1 and @vInvoiceIdList is null
	begin

		if @vIsContact = 1
	
			select @vStatementStartDate = max(inv.effective_date)	
			from dbo.ar_invoice inv with (nolock)
				--inner join dbo.ar_invoice_statement invstat with (nolock) on inv.invoice_id = invstat.invoice_id
				inner join #facility_list fl on inv.fac_id = fl.fac_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and inv.trial_flag = 'N' and inv.deleted = 'N' and payer.bill_payer_id = 0
				inner join dbo.clients cl with (nolock) on inv.client_id = cl.client_id and cl.fac_id = inv.fac_id
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id 
				inner join dbo.contact_relationship conr with (nolock) on conr.reference_id = mpi.mpi_id and conr.deleted='N'
				left join #cfilter confilter on conr.contact_id = confilter.receiver_id
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
				left join #billing_group_table bg on grp.group_id = bg.group_id	
				where (@vClientStatus = -1 or (@vClientStatus = 0 and (cl.discharge_date is null or cl.discharge_date > @vReportDate)) or (@vClientStatus = 1 and cl.discharge_date <= @vReportDate)) 
				and (@vReceiverIds = '-1' or confilter.receiver_id is not null)
				and (@vBillingGroup = '-1' or (@vBillingGroup <> '-1' and ((clgrp.group_id is not null and bg.group_id is not null and @vBillingGroup <> '0') 
					or (isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null) )) or @vBillingGroup is null)

		else

			select @vStatementStartDate = max(inv.effective_date)	
			from dbo.ar_invoice inv with (nolock)
				inner join #facility_list fl on inv.fac_id = fl.fac_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and inv.trial_flag = 'N' and inv.deleted = 'N'
				inner join dbo.clients cl with (nolock) on inv.client_id = cl.client_id and cl.fac_id = inv.fac_id 
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id 
				left join #cfilter clfilter on inv.client_id = clfilter.receiver_id
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
				left join #billing_group_table bg on grp.group_id = bg.group_id	
				where (@vClientStatus = -1 or (@vClientStatus = 0 and (cl.discharge_date is null or cl.discharge_date > @vReportDate)) or (@vClientStatus = 1 and cl.discharge_date <= @vReportDate)) 
				and (@vReceiverIds = '-1' or clfilter.receiver_id is not null)
				and (@vBillingGroup = '-1' or (@vBillingGroup <> '-1' and ((clgrp.group_id is not null and bg.group_id is not null and @vBillingGroup <> '0') 
					or (isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null) )) or @vBillingGroup is null)

		SET @vStatementStartDate = convert(datetime, convert(varchar(10),@vStatementStartDate , 101) + ' 00:00:00');
		SET @vStatementEndDate = DATEADD(s,-1,DATEADD(mm, DATEDIFF(m,0,@vStatementStartDate)+1,0));
			
		if @debug_me='Y' print '@vStatementStartDate  ' +  convert(varchar(26),@vStatementStartDate,109)
		if @debug_me='Y' print '@vStatementEndDate  ' +  convert(varchar(26),@vStatementEndDate,109)
	
	end

if @vInvoiceIdList is null
	begin
		insert into #invoices
		select 
			  inv.fac_id
			, inv.client_id
			, inv.invoice_id
			, inv.created_date
			, inv.statement_invoice_number
			, inv.payer_id
			, inv.effective_date
			, inv.eff_date_from
			, inv.eff_date_to
			, invstat.generated_date
			, invstat.payment_due_date
			, invstat.statement_through_date
			, inv.trial_flag
		from dbo.ar_invoice inv with (nolock) 
			inner join #facility_list fac on inv.fac_id = fac.fac_id and inv.trial_flag = 'N' and inv.deleted = 'N'
			inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and inv.effective_date >= @vStatementStartDate and inv.effective_date <= @vStatementEndDate and inv.fac_id = payer.fac_id
			left join dbo.ar_invoice_statement invstat with (nolock) on inv.invoice_id = invstat.invoice_id
		where (@vExportMode = 0 OR inv.date_exported_ps IS NULL OR @vExportResendFlag = 1 )
	end

if @vInvoiceIdList is not null and @vOtherStatementsIncluded = 1
	begin
		insert into #invoices
		select 
			  inv.fac_id
			, inv.client_id
			, inv.invoice_id
			, inv.created_date
			, inv.statement_invoice_number
			, inv.payer_id
			, inv.effective_date
			, inv.eff_date_from
			, inv.eff_date_to
			, invstat.generated_date
			, invstat.payment_due_date
			, invstat.statement_through_date
			, inv.trial_flag
		from dbo.ar_invoice inv with (nolock)
			inner join #facility_list fac on inv.fac_id = fac.fac_id 
			inner join dbo.ar_invoice_statement invstat with (nolock) on inv.invoice_id = invstat.invoice_id --and pyrs.generated_date = invstat.generated_Date
			where exists(select 1 from #payer_ids_table pyrs where pyrs.payer_id = inv.payer_id and pyrs.bill_payer_id <> 0 and 
				inv.deleted='N' and pyrs.statement_date = inv.effective_date)

		set @vRowCount = isnull(@vRowCount,0) + @@rowcount

		if @vRowCount = 0
			set @vOtherStatementsIncluded = 0

	end

if @vInvoiceIdList is not null and @vPrivateStatementsIncluded = 1
	begin
		insert into #invoices
		select 
			  inv.fac_id
			, inv.client_id
			, inv.invoice_id
			, inv.created_date
			, inv.statement_invoice_number
			, inv.payer_id
			, inv.effective_date
			, inv.eff_date_from
			, inv.eff_date_to
			, invstat.generated_date
			, invstat.payment_due_date
			, invstat.statement_through_date
			, inv.trial_flag
		from dbo.ar_invoice inv with (nolock)
			inner join #facility_list fac on inv.fac_id = fac.fac_id 
			inner join dbo.ar_invoice_statement invstat with (nolock) on inv.invoice_id = invstat.invoice_id --and pyrs.generated_date = invstat.generated_Date
			where exists(select 1 from #payer_ids_table pyrs where pyrs.payer_id = inv.payer_id and pyrs.bill_payer_id = 0 and 
				inv.deleted='N' and pyrs.statement_date = inv.effective_date)
	end

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

If @vIsEmc = 1
	begin

		Select @vStep = 40;
		set @vgsStepStartTime = GETDATE()
		if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Getting facility group info ' + convert(varchar(26),getdate(),109);

		insert into #facilty_group_info
		select 
			  grp.facility_group_id
			, f.fac_id
			, grp.facility_group_code as remit_to_group_number
			, grp.name as remit_to_name
			, Case when isnull(grp.use_facility_group_address,0) <> 1 then adr.address1 
--						when fgm.fac_id is not null and grp.remit_to_address_id is not null then adr.address1 
					else grp.address1 end as remit_to_address1 
			, Case when isnull(grp.use_facility_group_address,0) <> 1 then adr.address2
--						when fgm.fac_id is not null and grp.remit_to_address_id is not null then adr.address2  
					else grp.address2 end as remit_to_address2
			, Case when isnull(grp.use_facility_group_address,0) <> 1 then adr.address3 
--						when fgm.fac_id is not null and grp.remit_to_address_id is not null then adr.address3
					else grp.address3 end as remit_to_address3 
			, Case when isnull(grp.use_facility_group_address,0) <> 1 then adr.city 
--						when fgm.fac_id is not null and grp.remit_to_address_id is not null then adr.city   
					else grp.city end as remit_to_city
			, Case when isnull(grp.use_facility_group_address,0) <> 1 then cntygrp.name 
					else cntyadr.name end as remit_to_county
			, Case when isnull(grp.use_facility_group_address,0) <> 1 then adr.prov_state 
--						when fgm.fac_id is not null and grp.remit_to_address_id is not null then adr.prov_state   
					else grp.prov_state end as remit_to_prov_state
			, Case when isnull(grp.use_facility_group_address,0) <> 1 then cntrygrp.item_description 
					else cntryadr.item_description end as remit_to_country
			, Case when isnull(grp.use_facility_group_address,0) <> 1 then adr.postal_zip_code
--						when fgm.fac_id is not null and grp.remit_to_address_id is not null then adr.postal_zip_code    
					else grp.postal_zip_code end as remit_to_postal_zip_code
			, Case when grp.use_facility_group_address <> 1 then grp.telephone2 
					else grp.telephone end as remit_to_phone
			, grp.facility_group_code as facility_group_number
			, grp.name as facility_group_name
			, grp.address1 as facility_group_address1
			, grp.address2 as facility_group_address2
			, grp.address3 as facility_group_address3
			, grp.city as facility_group_city
			, cntyadr.name as facility_group_county
			, grp.prov_state as facility_group_prov_state
			, cntrygrp.item_description as facility_group_country
			, grp.postal_zip_code as facility_group_postal_zip_code
			, grp.telephone as facility_group_phone
			, grp.fax as facility_group_fax

		from #facility_list fl
			inner join facility f with (nolock) on fl.fac_id = f.fac_id
			inner join dbo.facility_group_mapping fgm with (nolock) on f.fac_id = fgm.fac_id
			inner join dbo.facility_group grp with (nolock) on fgm.facility_group_id = grp.facility_group_id and grp.[type_id] = 1
			left join dbo.address adr with (nolock) on grp.remit_to_address_id = adr.address_id
			left join dbo.county cntygrp with (nolock) on adr.county_id = cntygrp.county_id
			left join dbo.county cntyadr with (nolock) on grp.county_id = cntyadr.county_id
			left join dbo.common_code cntrygrp with (nolock) on grp.country_id = cntrygrp.item_id
			left join dbo.common_code cntryadr with (nolock) on adr.country_id = cntryadr.item_id

		set @vgsStepEndTime=GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

	end

if @debug_me='Y' select * from #facilty_group_info
if @debug_me='Y' select * from #facility_list

if @vInvoiceIdList is not null
	begin
	If @vPrivateStatementsIncluded = 1 -- process private statements as they are included
		begin	
			-----getting the list of contacts
			select @vStep = 70
			set @vgsStepStartTime = GETDATE()
			if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' gathering contacts clients and their invoices ' + convert(varchar(26),getdate(),109)
			--*********************************************************************************************************

			insert into #receiver_ids_table
			select distinct
				  conr.contact_id
				, conr.consolidate_statements
			from #invoice_ids_table prntinv
				--inner join dbo.ar_invoice inv with (nolock) on prntinv.invoice_id = inv.invoice_id
				inner join #invoices inv with (nolock) on prntinv.invoice_id = inv.invoice_id
				inner join dbo.clients cl with (nolock) on inv.client_id = cl.client_id 
				inner join  #facility_list fl on cl.fac_id = fl.fac_id 
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id = 0
				inner join dbo.ar_configuration config with (nolock) on fl.fac_id  = config.fac_id
				inner join dbo.contact_type_audit cta with (nolock) on mpi.mpi_id = cta.reference_id  --and (cta.contact_id = @vReceiverIds or @vReceiverIds = -1) 
					and config.contact_type_id = cta.[type_id] and cta.fac_id = inv.fac_id
					and cta.effective_date  <= inv.created_date AND (cta.ineffective_date  >= inv.created_date or cta.ineffective_date is null)
				inner join dbo.contact_relationship conr with (nolock) on conr.contact_id = cta.contact_id and conr.deleted='N' 
					and conr.reference_id = cta.reference_id and conr.subclass_id = cta.subclass_id --and cta.subclass_id = @vSubClassResidentID --9176
				inner join #subclass subc on cta.subclass_id = subc.subclass_id 
				--inner join dbo.common_code cc with (nolock) on cta.subclass_id = cc.item_id and cc.item_description = 'Resident'
				inner join dbo.contact_audit conta with (nolock) on cta.contact_id = conta.contact_id and conta.deleted='N'			
					and conta.effective_date  <= inv.created_date AND (conta.ineffective_date  >= inv.created_date or conta.ineffective_date is null)
				left join dbo.contact_address_audit conadd with (nolock) on cta.contact_id = conadd.contact_id 			
					and conadd.effective_date  <= inv.created_date AND (conadd.ineffective_date  >= inv.created_date or conadd.ineffective_date is null)
				left join dbo.address_audit cadd with (nolock) on conadd.address_id = cadd.address_id			
					and cadd.effective_date  <= inv.created_date AND (cadd.ineffective_date  >= inv.created_date or cadd.ineffective_date is null)	
				left join dbo.county cnty with (nolock) on cadd.county_id = cnty.county_id
				left join common_code country with (nolock) on cadd.country_id = country.item_id
				left join common_code_audit title with (nolock)	on isnull(title.deleted, 'N') = 'N' and conta.title_id = title.item_id 
					and title.effective_date  <= inv.created_date AND (title.ineffective_date  >= inv.created_date or title.ineffective_date is null)

			--resident statemments
			insert into #contact_clients
			select distinct
					fl.fac_id
				, conr.contact_id
				, conr.consolidate_statements as consolidate_statement
				, cl.client_id 
				, inv.invoice_id 
				, inv.statement_invoice_number
				, 0 as payer_id	
				, libpayer.description as payer 
				, inv.effective_date
				, inv.eff_date_from
				, inv.eff_date_to
				, hfac.name as remit_to_name
				, hfac.address1 as remit_to_address1
				, hfac.address2 as remit_to_address2
				, '' as remit_to_address3
				, hfac.city as remit_to_city
				, faccnty.name as remit_to_county
				, hfac.prov as remit_to_prov_state
				, fl.country
				, hfac.pc as remit_to_postal_zip_code
				, hfac.tel as remit_to_phone
				, title.item_description as contact_title
				, conta.first_name as contact_first_name
				, conta.last_name as contact_last_name
				, cadd.address1 as contact_address1
				, cadd.address2 as contact_address2
				, cadd.address3 as contact_address3
				, cadd.city as contact_city
				, cnty.name as contact_county
				, cadd.prov_state as contact_prov_state
				, cadd.postal_zip_code as contact_postal_zip_code
				, country.item_description as contact_country
				, null as contact_email
				, conr.contact_id as account_number
				, convert(varchar(10),isnull(inv.generated_date,'1/1/1900'), 101) as generated_date
				, convert(varchar(10),inv.effective_date, 101) as bill_date
				, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
				, inv.payment_due_date
				, Null as pre_consolidated_payment_due_date
				, inv.statement_through_date	
				, Null as amount_due
				, Null as eft_message
				, Case when @vIncludeResidentMessage = 1 then clcon.invoice_message else Null end as client_message
				, Null as group_message
				, Null as global_message
				, Null as previous_balance_due
				, Null as payments
				, fl.fac_id as summary_fac_id
				, hfac.name as summary_charge_center
				, hfac.facility_code as summary_charge_center_code
				, mpi.first_name as summary_charge_client_first_name
				, mpi.last_name as summary_charge_client_last_name
				, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
				, cl.client_id_number as summary_charge_client_number
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as summary_charge_client_location
				, mpi.date_of_birth as summary_charge_client_dob
				, cl.admission_date as summary_charge_client_admission
				, cl.discharge_date as summary_charge_client_discharge
				, 0.0 as summary_current_balance
				, 0.0 as summary_previous_balance_due
				, 0.0 as summary_payments
				, 0.0 as summary_late_fees
				, 0.0 as summary_client_balance_due	
				, '' as private_bills_to				
				, null as amount_past_due_yn	
				, null as term_used_for_client	
				, null as client_admit_date					
				, null as client_discharge_date				
				, null as client_mrn						
				, null as client_first_name					
				, null as client_last_name					
				, unit.unit_desc as client_unit
				, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
						when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
				, rm.room_desc as client_room
				, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
						when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
				, bd.bed_desc as client_bed
				, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
						when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
				, null as patient_specific_message
				, 0 as  contact_num
				, 0 as non_consolidated_contact_num			
				, '' as client_list
				, Case when relatcc.item_id is not null then 1 else 0 end as main_location
				, 0 as consolidated_location_order
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as sort_location
			from #receiver_ids_table confilter 
				inner join dbo.contact_relationship conr with (nolock) on confilter.contact_id = conr.contact_id and conr.deleted='N' 
				inner join dbo.mpi with (nolock) on conr.reference_id = mpi.mpi_id
					--and conr.reference_id = cta.reference_id and conr.subclass_id = cta.subclass_id 
				inner join dbo.clients cl with (nolock) on mpi.mpi_id = cl.mpi_id
				inner join #facility_list fl on cl.fac_id = fl.fac_id
				--inner join dbo.ar_invoice inv with (nolock) on cl.client_id = inv.client_id and  inv.deleted = 'N'
				inner join #invoices inv with (nolock) on cl.client_id = inv.client_id
				--inner join dbo.ar_payers payr with (nolock) on fl.fac_id = payr.fac_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id = 0 and inv.effective_date = payer.statement_date --and inv.trial_flag = payer.trial_flag and inv.client_id = payer.client_id
				--inner join dbo.ar_payers payr with (nolock) on payer.payer_id = payr.payer_id and payr.fac_id = fl.fac_id
				inner join dbo.ar_configuration config with (nolock) on fl.fac_id  = config.fac_id
				inner join dbo.contact_type_audit cta with (nolock) on  conr.contact_id = cta.contact_id and conr.reference_id = cta.reference_id 
					and config.contact_type_id = cta.[type_id] and cta.fac_id = inv.fac_id and conr.subclass_id = cta.subclass_id --and cta.subclass_id = @vSubClassResidentID --9176
					and cta.effective_date  <= inv.created_date AND (cta.ineffective_date  >= inv.created_date or cta.ineffective_date is null)
				inner join #subclass subc on cta.subclass_id = subc.subclass_id
				--inner join dbo.ar_invoice_statement invstat with (nolock) on inv.invoice_id = invstat.invoice_id and 
				--	convert(varchar(10),payer.generated_date, 101) = convert(varchar(10),invstat.generated_date, 101) 
				inner join dbo.ar_lib_payers libpayer with (nolock) on payer.payer_id = libpayer.payer_id 
				left join #relationship relatcc on conr.relationship_id = relatcc.item_id
				inner join dbo.contact_audit conta with (nolock) on cta.contact_id = conta.contact_id and conta.deleted='N'			
					and conta.effective_date  <= inv.created_date AND (conta.ineffective_date  >= inv.created_date or conta.ineffective_date is null)
				left join dbo.contact_address_audit conadd with (nolock) on cta.contact_id = conadd.contact_id 			
					and conadd.effective_date  <= inv.created_date AND (conadd.ineffective_date  >= inv.created_date or conadd.ineffective_date is null)
				left join dbo.address_audit cadd with (nolock) on conadd.address_id = cadd.address_id			
					and cadd.effective_date  <= inv.created_date AND (cadd.ineffective_date  >= inv.created_date or cadd.ineffective_date is null)	
				left join dbo.county cnty with (nolock) on cadd.county_id = cnty.county_id
				left join common_code country with (nolock) on cadd.country_id = country.item_id
				left join common_code_audit title with (nolock)	on isnull(title.deleted, 'N') = 'N' and conta.title_id = title.item_id 
					and title.effective_date  <= inv.created_date AND (title.ineffective_date  >= inv.created_date or title.ineffective_date is null)
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
				left join dbo.ar_client_configuration clcon with (nolock) on cl.client_id = clcon.client_id and clcon.deleted='N'
				left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
				left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
				left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
				left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
				inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
					and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)	
				left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id
				left join #invoice_ids_table prntinv on cl.client_id = prntinv.client_id
			where (@vIsTrial = 1 or inv.trial_flag = 'N')
				and conr.consolidate_statements = confilter.consolidate_statement and 
				((confilter.consolidate_statement = 0 and prntinv.client_id is not null) or (confilter.consolidate_statement = 1))						

			update con set con.private_bills_to	= payr.private_bills_to
			from #contact_clients con
			inner join dbo.ar_invoice inv with (nolock) on con.invoice_id = inv.invoice_id
			inner join dbo.ar_payers payr with (nolock) on inv.fac_id = payr.fac_id and inv.payer_id = payr.payer_id				

			insert into #contact_clients --residents without contacts
			select distinct
					cl.fac_id
				, 0 as contact_id
				, 0 as consolidate_statement
				, cl.client_id 
				, inv.invoice_id
				, inv.statement_invoice_number
				, 0 as payer_id	
				, libpayer.description as payer 
				, inv.effective_date
				, inv.eff_date_from
				, inv.eff_date_to
				, hfac.name as remit_to_name
				, hfac.address1 as remit_to_address1
				, hfac.address2 as remit_to_address2
				, '' as remit_to_address3
				, hfac.city as remit_to_city
				, faccnty.name as remit_to_county
				, hfac.prov as remit_to_prov_state
				, fl.country
				, hfac.pc as remit_to_postal_zip_code
				, hfac.tel as remit_to_phone
				, Null as contact_title
				, mpi.first_name as contact_first_name
				, mpi.last_name as contact_last_name
				, Null as contact_address1
				, Null as contact_address2
				, Null as contact_address3
				, Null as contact_city
				, Null as contact_county
				, Null as contact_prov_state
				, Null as contact_postal_zip_code
				, Null contact_country
				, Null as contact_email
				, 0 as account_number
				, convert(varchar(10),isnull(inv.generated_date,'1/1/1900'), 101) as generated_date
				, convert(varchar(10),inv.effective_date, 101) as bill_date
				, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
				, inv.payment_due_date
				, Null as pre_consolidated_payment_due_date
				, inv.statement_through_date	
				, Null as amount_due
				, Null as eft_message
				, Case when @vIncludeResidentMessage = 1 then clcon.invoice_message else Null end as client_message
				, Null as group_message
				, Null as global_message
				, Null as previous_balance_due
				, Null as payments
				, cl.fac_id as summary_fac_id
				, hfac.name as summary_charge_center
				, hfac.facility_code as summary_charge_center_code
				, mpi.first_name as summary_charge_client_first_name
				, mpi.last_name as summary_charge_client_last_name
				, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
				, cl.client_id_number as summary_charge_client_number
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as summary_charge_client_location
				, mpi.date_of_birth as summary_charge_client_dob
				, cl.admission_date as summary_charge_client_admission
				, cl.discharge_date as summary_charge_client_discharge
				, 0.0 as summary_current_balance
				, 0.0 as summary_previous_balance_due
				, 0.0 as summary_payments
				, 0.0 as summary_late_fees
				, 0.0 as summary_client_balance_due
				, payr.private_bills_to as private_bills_to			
				, null as amount_past_due_yn	
				, null as term_used_for_client				
				, null as client_admit_date					
				, null as client_discharge_date				
				, null as client_mrn						
				, null as client_first_name					
				, null as client_last_name					
				, unit.unit_desc as client_unit
				, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
						when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
				, rm.room_desc as client_room
				, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
						when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
				, bd.bed_desc as client_bed
				, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
						when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
				, null as patient_specific_message	
				, 0 as  contact_num
				, Dense_rank() over (ORDER BY mpi.last_name, mpi.first_name, cl.client_id, inv.effective_date) non_consolidated_contact_num
				--, 1 as non_consolidated_contact_num			
				, '' as client_list
				, 1 as main_location
				, 0 as consolidated_location_order
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as sort_location
			from #invoice_ids_table prntinv
				inner join dbo.clients cl with (nolock) on prntinv.client_id = cl.client_id
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
				--inner join dbo.ar_invoice inv with (nolock) on prntinv.client_id = inv.client_id and inv.deleted = 'N' --and prntinv.trial_flag = inv.trial_flag
				--and inv.effective_date = prntinv.statement_date
				inner join #invoices inv with (nolock) on prntinv.client_id = inv.client_id --and inv.deleted = 'N' --and prntinv.trial_flag = inv.trial_flag
					and inv.effective_date = prntinv.statement_date
				inner join #facility_list fl on cl.fac_id = fl.fac_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id = 0 and inv.client_id = payer.client_id										
				--inner join dbo.ar_invoice_statement invstat with (nolock) on inv.invoice_id = invstat.invoice_id and 
				--	convert(varchar(10),prntinv.generated_date, 101) = convert(varchar(10),invstat.generated_date, 101)
				inner join dbo.ar_lib_payers libpayer with (nolock) on inv.payer_id = libpayer.payer_id 
				inner join dbo.ar_payers payr with (nolock) on libpayer.payer_id = payr.payer_id and payr.fac_id = cl.fac_id
				inner join dbo.ar_payers_audit payraud with (nolock) on libpayer.payer_id = payraud.payer_id and payraud.fac_id = cl.fac_id
					and payraud.effective_date  <= inv.created_date AND (payraud.ineffective_date  >= inv.created_date or payraud.ineffective_date is null)
				inner join dbo.ar_configuration config with (nolock) on cl.fac_id  = config.fac_id
				left join #contact_clients concl on inv.invoice_id = concl.invoice_id
				--left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = cl.fac_id and grp.deleted='N'
				--left join #billing_group_table bg on grp.group_id = bg.group_id
				left join dbo.ar_client_configuration clcon with (nolock) on cl.client_id = clcon.client_id and clcon.deleted='N'
				left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
				left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
				left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
				left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
				inner join dbo.facility_audit hfac with (nolock) on cl.fac_id = hfac.fac_id
					and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)
				left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id
			where concl.invoice_id is null and (@vIsTrial = 1 or inv.trial_flag = 'N')	

			insert into #contact_clients --we need to check for other multiple contacts that may not have all appropriate invoices assigned
			select distinct
					mycon.fac_id
				, mycon.contact_id
				, mycon.consolidate_statement
				, myadd.client_id 
				, myadd.invoice_id
				, myadd.statement_invoice_number
				, 0 as payer_id	
				, myadd.payer 
				, myadd.inv_effective_date
				, myadd.inv_eff_date_from
				, myadd.inv_eff_date_to
				, mycon.remit_to_name
				, mycon.remit_to_address1
				, mycon.remit_to_address2
				, mycon.remit_to_address3
				, mycon.remit_to_city
				, mycon.remit_to_county
				, mycon.remit_to_prov_state
				, mycon.remit_to_country
				, mycon.remit_to_postal_zip_code
				, mycon.remit_to_phone
				, mycon.contact_title
				, mycon.contact_first_name
				, mycon.contact_last_name
				, mycon.contact_address1
				, mycon.contact_address2
				, mycon.contact_address3
				, mycon.contact_city
				, mycon.contact_county
				, mycon.contact_prov_state
				, mycon.contact_postal_zip_code
				, mycon.contact_country
				, mycon.contact_email
				, mycon.account_number
				, myadd.generated_date
				, myadd.bill_date
				, myadd.aging_date
				, myadd.payment_due_date
				, myadd.pre_consolidated_payment_due_date
				, myadd.statement_through_date	
				, myadd.amount_due
				, myadd.eft_message
				, myadd.client_message
				, myadd.group_message
				, myadd.global_message
				, myadd.previous_balance_due
				, myadd.payments
				, myadd.summary_fac_id
				, myadd.summary_charge_center
				, myadd.summary_charge_center_code
				, myadd.summary_charge_client_first_name
				, myadd.summary_charge_client_last_name
				, myadd.summary_charge_client_name
				, myadd.summary_charge_client_number
				, myadd.summary_charge_client_location
				, myadd.summary_charge_client_dob
				, myadd.summary_charge_client_admission
				, myadd.summary_charge_client_discharge
				, 0.0 as summary_current_balance
				, 0.0 as summary_previous_balance_due
				, 0.0 as summary_payments
				, 0.0 as summary_late_fees
				, 0.0 as summary_client_balance_due
				, myadd.private_bills_to				
				, null as amount_past_due_yn	
				, null as term_used_for_client				
				, null as client_admit_date					
				, null as client_discharge_date				
				, null as client_mrn						
				, null as client_first_name					
				, null as client_last_name					
				, myadd.client_unit	
				, myadd.unit_order					
				, myadd.client_room	
				, myadd.room_order					
				, myadd.client_bed
				, myadd.bed_order
				, null as patient_specific_message	
				, mycon.contact_num
				, mycon.non_consolidated_contact_num		
				, '' as client_list
				, myadd.main_location
				, myadd.consolidated_location_order	
				, myadd.sort_location
			from #contact_clients mycon
				inner join (SELECT b.contact_id,a.client_id, a.invoice_id, a.bill_date
					FROM(
						SELECT DISTINCT client_id , invoice_id, bill_date FROM #contact_clients where contact_id > 0) A
						INNER JOIN (
						SELECT DISTINCT contact_id, client_id FROM #contact_clients where contact_id > 0) B
						ON a.client_id = b.client_id 
						EXCEPT
						SELECT contact_id,client_id, invoice_id, bill_date FROM #contact_clients where contact_id > 0
						) toget
						on mycon.contact_id = toget.contact_id and mycon.client_id = toget.client_id and mycon.bill_date = toget.bill_date
				inner join #contact_clients myadd on toget.invoice_id = myadd.invoice_id

		end

		set @vgsStepEndTime=GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

		------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		-- other payer loading here
		if @vOtherStatementsIncluded = 1

		begin

		-----getting the list of contacts
		select @vStep = 80
		set @vgsStepStartTime = GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' gathering other payer invoices ' + convert(varchar(26),getdate(),109)

		insert into #contact_clients
			select distinct
					fl.fac_id
				, Case when payraud.private_bills_to = 'G'  then  -1 * isnull(CAST(conta.contact_id AS NUMERIC(18,1)),3.1) else -2.1 end  as contact_id  --AMRO
				, 0 as consolidate_statement
				, cl.client_id 
				, inv.invoice_id 
				, inv.statement_invoice_number
				, libpayer.payer_id	
				, libpayer.description as payer 
				, inv.effective_date
				, inv.eff_date_from
				, inv.eff_date_to
				, case when fgi.fac_id is null then hfac.name else fgi.remit_to_name end as remit_to_name
				, case when fgi.fac_id is null then hfac.address1 else fgi.remit_to_address1 end as remit_to_address1
				, case when fgi.fac_id is null then hfac.address2 else fgi.remit_to_address2 end as remit_to_address2
				, case when fgi.fac_id is null then '' else fgi.remit_to_address3 end as remit_to_address3
				, case when fgi.fac_id is null then hfac.city else fgi.remit_to_city end as remit_to_city
				, case when fgi.fac_id is null then faccnty.name else fgi.remit_to_county end as remit_to_county
				, case when fgi.fac_id is null then hfac.prov else fgi.remit_to_prov_state end as remit_to_prov_state
				, case when fgi.fac_id is null then fl.country else fgi.remit_to_country end as remit_to_country
				, case when fgi.fac_id is null then hfac.pc else fgi.remit_to_postal_zip_code end as remit_to_postal_zip_code
				, case when fgi.fac_id is null then hfac.tel else fgi.remit_to_phone end as remit_to_phone
				, Case when payraud.private_bills_to = 'G' then title.item_description else '' end as contact_title
				, Case when payraud.private_bills_to = 'G' and isnull(conta.first_name,'') <> '' then conta.first_name
					when payraud.private_bills_to = 'G' and isnull(conta.first_name,'') = '' then 'No Data Found'
					when payraud.private_bills_to <> 'G' and isnull(insco.description,'') = '' then 'No Data Found' else insco.description end as contact_first_name 
				, Case when payraud.private_bills_to = 'G' then conta.last_name else '' end as contact_last_name
				, Case when payraud.private_bills_to = 'G' and isnull(cadd.address1,'') = '' and  isnull(cadd.address2,'') = '' then 'No Address Found' 
					when payraud.private_bills_to = 'G' and isnull(cadd.address1,'') <> '' then cadd.address1		
					when payraud.private_bills_to <> 'G' and isnull(inscoadd.address1,'') = '' and isnull(inscoadd.address2,'') = '' then 'No Address Found' 
					else inscoadd.address1 end as contact_address1
				, Case when payraud.private_bills_to = 'G' then cadd.address2 else inscoadd.address2 end as contact_address2
				, Case when payraud.private_bills_to = 'G' then cadd.address3 else inscoadd.address3 end as contact_address3
				, Case when payraud.private_bills_to = 'G' then cadd.city else inscoadd.city end as contact_city
				, Case when payraud.private_bills_to = 'G' then ccnty.name else cnty.name end as contact_county
				, Case when payraud.private_bills_to = 'G' then cadd.prov_state else inscoadd.prov_state end as contact_prov_state
				, Case when payraud.private_bills_to = 'G' then cadd.postal_zip_code else inscoadd.postal_zip_code end as contact_postal_zip_code
				, Case when payraud.private_bills_to = 'G' then ccountry.item_description else country.item_description end as contact_country
				, null as contact_email
				, Case when payraud.private_bills_to = 'G' then conr.contact_id else '' end as account_number
				, '1/1/1900' as generated_date
				, convert(varchar(10),inv.effective_date, 101) as bill_date
				, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
				, inv.payment_due_date
				, Null as pre_consolidated_payment_due_date
				, inv.statement_through_date	
				, Null as amount_due
				, Null as eft_message
				, '' as client_message
				, Null as group_message
				, Null as global_message
				, Null as previous_balance_due
				, Null as payments
				, fl.fac_id as summary_fac_id
				, hfac.name as summary_charge_center
				, hfac.facility_code as summary_charge_center_code
				, mpi.first_name as summary_charge_client_first_name
				, mpi.last_name as summary_charge_client_last_name
				, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
				, cl.client_id_number as summary_charge_client_number
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as summary_charge_client_location
				, mpi.date_of_birth as summary_charge_client_dob
				, cl.admission_date as summary_charge_client_admission
				, cl.discharge_date as summary_charge_client_discharge
				, 0.0 as summary_current_balance
				, 0.0 as summary_previous_balance_due
				, 0.0 as summary_payments
				, 0.0 as summary_late_fees
				, 0.0 as summary_client_balance_due	
				, payr.private_bills_to as private_bills_to				
				, null as amount_past_due_yn	
				, null as term_used_for_client	
				, null as client_admit_date					
				, null as client_discharge_date				
				, null as client_mrn						
				, null as client_first_name					
				, null as client_last_name					
				, unit.unit_desc as client_unit
				, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
						when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
				, rm.room_desc as client_room
				, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
						when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
				, bd.bed_desc as client_bed
				, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
						when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
				, null as patient_specific_message
				, 0 as  contact_num
				, 0 as non_consolidated_contact_num			
				, '' as client_list
				, 1 as main_location
				, 0 as consolidated_location_order
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as sort_location
			--select flinv.*
			from #invoice_ids_table flinv
				inner join #invoices inv with (nolock) on flinv.invoice_id = inv.invoice_id
				inner join #facility_list fl on inv.fac_id = fl.fac_id
				inner join dbo.clients cl with (nolock) on inv.client_id = cl.client_id
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id > 0
				inner join dbo.ar_lib_payers libpayer with (nolock) on inv.payer_id = libpayer.payer_id 
				inner join dbo.ar_payers payr with (nolock) on libpayer.payer_id = payr.payer_id and payr.fac_id = fl.fac_id
				inner join dbo.ar_payers_audit payraud with (nolock) on libpayer.payer_id = payraud.payer_id and payraud.fac_id = fl.fac_id
				and payraud.effective_date  <= inv.created_date AND (payraud.ineffective_date  >= inv.created_date or payraud.ineffective_date is null)
				inner join dbo.ar_configuration config with (nolock) on fl.fac_id  = config.fac_id
				left join dbo.ar_client_payer_info policy with (nolock) on cl.client_id = policy.client_id and inv.payer_id = policy.payer_id
				left join dbo.client_ids clid with (nolock) on inv.client_id = clid.client_id and policy.policy_no_id = clid.id_type_id
				left join dbo.ar_payer_addresses_audit payradd with (nolock) on payraud.fac_id = payradd.fac_id and payraud.payer_id = payradd.payer_id and payraud.default_address_id = payradd.address_id and
					payradd.effective_date  <= inv.created_date AND (payradd.ineffective_date  >= inv.created_date or payradd.ineffective_date is null)
				left join dbo.ar_lib_insurance_companies_audit insco with (nolock) on payradd.insurance_id = insco.insurance_id and
					insco.effective_date  <= inv.created_date AND (insco.ineffective_date  >= inv.created_date or insco.ineffective_date is null)
				left join dbo.ar_insurance_addresses_audit inscoadd with (nolock) on payradd.address_id = inscoadd.address_id and
					inscoadd.effective_date  <= inv.created_date AND (inscoadd.ineffective_date  >= inv.created_date or inscoadd.ineffective_date is null)
				left join dbo.ar_provider_numbers provnum with (nolock) on inscoadd.address_id = provnum.address_id and fl.fac_id = provnum.fac_id
				left join dbo.county cnty with (nolock) on inscoadd.county_id = cnty.county_id
				left join common_code country with (nolock) on inscoadd.country_id = country.item_id
				left join #client_ids_table clfilter on inv.client_id = clfilter.client_id
				left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
				left join #billing_group_table bg on grp.group_id = bg.group_id
				left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
				left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
				left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
				left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
				inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
					and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)	
				left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id
						left join dbo.contact_type_audit cta with (nolock) on mpi.mpi_id = cta.reference_id  --and (cta.contact_id = @vReceiverIds or @vReceiverIds = -1) 
					and config.contact_type_id = cta.[type_id] and cta.fac_id = inv.fac_id
					and cta.effective_date  <= inv.created_date AND (cta.ineffective_date  >= inv.created_date or cta.ineffective_date is null)
				left join dbo.contact_relationship conr with (nolock) on conr.contact_id = cta.contact_id and conr.deleted='N' 
					and conr.reference_id = cta.reference_id and conr.subclass_id = cta.subclass_id --and cta.subclass_id = @vSubClassResidentID 
				left join #subclass subc on cta.subclass_id = subc.subclass_id
				left join #relationship relatcc on conr.relationship_id = relatcc.item_id
				left join dbo.contact_audit conta with (nolock) on cta.contact_id = conta.contact_id and conta.deleted='N'			
					and conta.effective_date  <= inv.created_date AND (conta.ineffective_date  >= inv.created_date or conta.ineffective_date is null)
				left join dbo.contact_address_audit conadd with (nolock) on cta.contact_id = conadd.contact_id 			
					and conadd.effective_date  <= inv.created_date AND (conadd.ineffective_date  >= inv.created_date or conadd.ineffective_date is null)
				left join dbo.address_audit cadd with (nolock) on conadd.address_id = cadd.address_id			
					and cadd.effective_date  <= inv.created_date AND (cadd.ineffective_date  >= inv.created_date or cadd.ineffective_date is null)	
				left join dbo.county ccnty with (nolock) on cadd.county_id = cnty.county_id
				left join common_code ccountry with (nolock) on cadd.country_id = ccountry.item_id
				left join common_code_audit title with (nolock)	on isnull(title.deleted, 'N') = 'N' and conta.title_id = title.item_id 
					and title.effective_date  <= inv.created_date AND (title.ineffective_date  >= inv.created_date or title.ineffective_date is null)		
			where payraud.private_bills_to <> 'I'

		set @vRowCount = @@rowcount

		insert into #contact_clients
			select distinct
					fl.fac_id
				, -2.1  as contact_id
				, 0 as consolidate_statement
				, cl.client_id 
				, inv.invoice_id 
				, inv.statement_invoice_number
				, libpayer.payer_id	
				, libpayer.description as payer 
				, inv.effective_date
				, inv.eff_date_from
				, inv.eff_date_to
				, case when fgi.fac_id is null then hfac.name else fgi.remit_to_name end as remit_to_name
				, case when fgi.fac_id is null then hfac.address1 else fgi.remit_to_address1 end as remit_to_address1
				, case when fgi.fac_id is null then hfac.address2 else fgi.remit_to_address2 end as remit_to_address2
				, case when fgi.fac_id is null then '' else fgi.remit_to_address3 end as remit_to_address3
				, case when fgi.fac_id is null then hfac.city else fgi.remit_to_city end as remit_to_city
				, case when fgi.fac_id is null then faccnty.name else fgi.remit_to_county end as remit_to_county
				, case when fgi.fac_id is null then hfac.prov else fgi.remit_to_prov_state end as remit_to_prov_state
				, case when fgi.fac_id is null then fl.country else fgi.remit_to_country end as remit_to_country
				, case when fgi.fac_id is null then hfac.pc else fgi.remit_to_postal_zip_code end as remit_to_postal_zip_code
				, case when fgi.fac_id is null then hfac.tel else fgi.remit_to_phone end as remit_to_phone
				, '' as contact_title
				, Case when isnull(insco.description,'') = '' then libpayer.description else insco.description end as contact_first_name 
				, '' as contact_last_name
				, Case when isnull(inscoadd.address1,'') = '' and isnull(inscoadd.address2,'') = '' then 'No Address Found' 
					else inscoadd.address1 end as contact_address1
				, inscoadd.address2 as contact_address2
				, inscoadd.address3 as contact_address3
				, inscoadd.city as contact_city
				, cnty.name as contact_county
				, inscoadd.prov_state as contact_prov_state
				, inscoadd.postal_zip_code as contact_postal_zip_code
				, country.item_description as contact_country
				, null as contact_email
				, '' as account_number
				, '1/1/1900' as generated_date
				, convert(varchar(10),inv.effective_date, 101) as bill_date
				, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
				, inv.payment_due_date
				, Null as pre_consolidated_payment_due_date
				, inv.statement_through_date	
				, null as amount_due
				, Null as eft_message
				, '' as client_message
				, Null as group_message
				, null as global_message
				, null as previous_balance_due
				, null as payments
				, fl.fac_id as summary_fac_id
				, hfac.name as summary_charge_center
				, hfac.facility_code as summary_charge_center_code
				, mpi.first_name as summary_charge_client_first_name
				, mpi.last_name as summary_charge_client_last_name
				, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
				, cl.client_id_number as summary_charge_client_number
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as summary_charge_client_location
				, mpi.date_of_birth as summary_charge_client_dob
				, cl.admission_date as summary_charge_client_admission
				, cl.discharge_date as summary_charge_client_discharge
				, 0.0 as summary_current_balance
				, 0.0 as summary_previous_balance_due
				, 0.0 as summary_payments
				, 0.0 as summary_late_fees
				, 0.0 as summary_client_balance_due	
				, payr.private_bills_to as private_bills_to				
				, null as amount_past_due_yn	
				, null as term_used_for_client	
				, null as client_admit_date					
				, null as client_discharge_date				
				, null as client_mrn						
				, null as client_first_name					
				, null as client_last_name					
				, unit.unit_desc as client_unit
				, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
						when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
				, rm.room_desc as client_room
				, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
						when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
				, bd.bed_desc as client_bed
				, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
						when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
				, null as patient_specific_message
				, 0 as  contact_num
				, 0 as non_consolidated_contact_num			
				, '' as client_list
				, 1 as main_location
				, 0 as consolidated_location_order
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as sort_location
			from #invoice_ids_table flinv
				inner join #invoices inv with (nolock) on flinv.invoice_id = inv.invoice_id
				inner join #facility_list fl on inv.fac_id = fl.fac_id
				inner join dbo.clients cl with (nolock) on inv.client_id = cl.client_id
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id > 0
				inner join dbo.ar_lib_payers libpayer with (nolock) on inv.payer_id = libpayer.payer_id 
				inner join dbo.ar_payers payr with (nolock) on libpayer.payer_id = payr.payer_id and payr.fac_id = fl.fac_id
				inner join dbo.ar_payers_audit payraud with (nolock) on libpayer.payer_id = payraud.payer_id and payraud.fac_id = fl.fac_id
				and payraud.effective_date  <= inv.created_date AND (payraud.ineffective_date  >= inv.created_date or payraud.ineffective_date is null)
				left join dbo.ar_client_payer_info cpiaud with (nolock) on cl.client_id = cpiaud.client_id and payraud.payer_id = cpiaud.payer_id and payraud.fac_id = cpiaud.fac_id and cpiaud.deleted = 'N'
					and cpiaud.effective_date  <= inv.effective_date AND (cpiaud.ineffective_date  >= inv.effective_date or cpiaud.ineffective_date is null) 
				left join dbo.ar_insurance_addresses_audit inscoadd with (nolock) on cpiaud.payer_address_id = inscoadd.address_id and
					inscoadd.effective_date  <= inv.created_date AND (inscoadd.ineffective_date  >= inv.created_date or inscoadd.ineffective_date is null)
				left join dbo.ar_lib_insurance_companies_audit insco with (nolock) on inscoadd.insurance_id = insco.insurance_id and
					insco.effective_date  <= inv.created_date AND (insco.ineffective_date  >= inv.created_date or insco.ineffective_date is null)
				left join dbo.ar_provider_numbers provnum with (nolock) on inscoadd.address_id = provnum.address_id and fl.fac_id = provnum.fac_id
				left join dbo.county cnty with (nolock) on inscoadd.county_id = cnty.county_id
				left join common_code country with (nolock) on inscoadd.country_id = country.item_id
				left join #client_ids_table clfilter on inv.client_id = clfilter.client_id
				left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
				left join #billing_group_table bg on grp.group_id = bg.group_id
				left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
				left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
				left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
				left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
				inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
					and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)	
				left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id							
			where payraud.private_bills_to = 'I'		

		set @vRowCount = isnull(@vRowCount,0) + @@rowcount

		if @vRowCount = 0
			set @vOtherStatementsIncluded = 0

		set @vgsStepEndTime=GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

		end

	end

else
	begin
		-----getting the list of contacts
		select @vStep = 70
		set @vgsStepStartTime = GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' gathering contacts clients and their invoices ' + convert(varchar(26),getdate(),109)
		--*********************************************************************************************************
		If @vPrivateStatementsIncluded = 1 -- process private statements as they are included
		begin	
			if @vIsContact = 0 and @vReceiverIds <> '-1' --get contacts for selected residents.  All clients will be treated as all contacts
				begin
					insert into #receiver_ids_table
					select distinct
						  conr.contact_id
						, conr.consolidate_statements
					from #client_ids_table clfilter
						inner join dbo.clients cl with (nolock) on clfilter.client_id = cl.client_id 
						inner join  #facility_list fl on cl.fac_id = fl.fac_id 
						inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
						inner join #invoices inv with (nolock) on cl.client_id = inv.client_id
						inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id = 0
						inner join dbo.ar_configuration config with (nolock) on fl.fac_id  = config.fac_id
						inner join dbo.contact_type_audit cta with (nolock) on mpi.mpi_id = cta.reference_id
							and config.contact_type_id = cta.[type_id] and cta.fac_id = inv.fac_id
							and cta.effective_date  <= inv.created_date AND (cta.ineffective_date  >= inv.created_date or cta.ineffective_date is null)
						inner join dbo.contact_relationship conr with (nolock) on conr.contact_id = cta.contact_id and conr.deleted='N' 
							and conr.reference_id = cta.reference_id and conr.subclass_id = cta.subclass_id
						inner join #subclass subc on cta.subclass_id = subc.subclass_id
						inner join dbo.contact_audit conta with (nolock) on cta.contact_id = conta.contact_id and conta.deleted='N'			
							and conta.effective_date  <= inv.created_date AND (conta.ineffective_date  >= inv.created_date or conta.ineffective_date is null)
						left join dbo.contact_address_audit conadd with (nolock) on cta.contact_id = conadd.contact_id 			
							and conadd.effective_date  <= inv.created_date AND (conadd.ineffective_date  >= inv.created_date or conadd.ineffective_date is null)
						left join dbo.address_audit cadd with (nolock) on conadd.address_id = cadd.address_id			
							and cadd.effective_date  <= inv.created_date AND (cadd.ineffective_date  >= inv.created_date or cadd.ineffective_date is null)	
						left join dbo.county cnty with (nolock) on cadd.county_id = cnty.county_id
						left join common_code country with (nolock) on cadd.country_id = country.item_id
						left join common_code_audit title with (nolock)	on isnull(title.deleted, 'N') = 'N' and conta.title_id = title.item_id 
							and title.effective_date  <= inv.created_date AND (title.ineffective_date  >= inv.created_date or title.ineffective_date is null)
						left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
						left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
						left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
						left join #billing_group_table bg on grp.group_id = bg.group_id
						left join dbo.ar_client_configuration clcon with (nolock) on cl.client_id = clcon.client_id and clcon.deleted='N'
						inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
							and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)	
						left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id					
					where (@vClientStatus = -1 or (@vClientStatus = 0 and (cl.discharge_date is null or cl.discharge_date > @vReportDate)) or (@vClientStatus = 1 and cl.discharge_date <= @vReportDate)) 
					and (@vBillingGroup = '-1' --or (@vBillingGroup <> '-1' and isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null )
					or (@vBillingGroup <> '-1' and ((clgrp.group_id is not null and bg.group_id is not null and @vBillingGroup <> '0') or (isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null) ))
					or @vBillingGroup is null)

				end

			--resident statemments
			insert into #contact_clients
			select distinct
					fl.fac_id
				, conr.contact_id
				, conr.consolidate_statements as consolidate_statement
				, cl.client_id 
				, inv.invoice_id 
				, inv.statement_invoice_number
				, 0 as payer_id	
				, libpayer.description as payer 
				, inv.effective_date
				, inv.eff_date_from
				, inv.eff_date_to
				, case when fgi.fac_id is null then hfac.name else fgi.remit_to_name end as remit_to_name
				, case when fgi.fac_id is null then hfac.address1 else fgi.remit_to_address1 end as remit_to_address1
				, case when fgi.fac_id is null then hfac.address2 else fgi.remit_to_address2 end as remit_to_address2
				, case when fgi.fac_id is null then '' else fgi.remit_to_address3 end as remit_to_address3
				, case when fgi.fac_id is null then hfac.city else fgi.remit_to_city end as remit_to_city
				, case when fgi.fac_id is null then faccnty.name else fgi.remit_to_county end as remit_to_county
				, case when fgi.fac_id is null then hfac.prov else fgi.remit_to_prov_state end as remit_to_prov_state
				, case when fgi.fac_id is null then fl.country else fgi.remit_to_country end as remit_to_country
				, case when fgi.fac_id is null then hfac.pc else fgi.remit_to_postal_zip_code end as remit_to_postal_zip_code
				, case when fgi.fac_id is null then hfac.tel else fgi.remit_to_phone end as remit_to_phone
				, title.item_description as contact_title
				, conta.first_name as contact_first_name
				, conta.last_name as contact_last_name
				, cadd.address1 as contact_address1
				, cadd.address2 as contact_address2
				, cadd.address3 as contact_address3
				, cadd.city as contact_city
				, cnty.name as contact_county
				, cadd.prov_state as contact_prov_state
				, cadd.postal_zip_code as contact_postal_zip_code
				, country.item_description as contact_country
				, null as contact_email
				, conr.contact_id as account_number
				, convert(varchar(10),isnull(inv.generated_date,'1/1/1900'), 101) as generated_date
				, convert(varchar(10),inv.effective_date, 101) as bill_date
				, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
				, inv.payment_due_date
				, Null as pre_consolidated_payment_due_date
				, inv.statement_through_date	
				, Null as amount_due
				, Null as eft_message
				, Case when @vIncludeResidentMessage = 1 then clcon.invoice_message else Null end as client_message
				, Null as group_message
				, Null as global_message
				, Null as previous_balance_due
				, Null as payments
				, fl.fac_id as summary_fac_id
				, hfac.name as summary_charge_center
				, hfac.facility_code as summary_charge_center_code
				, mpi.first_name as summary_charge_client_first_name
				, mpi.last_name as summary_charge_client_last_name
				, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
				, cl.client_id_number as summary_charge_client_number
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as summary_charge_client_location
				, mpi.date_of_birth as summary_charge_client_dob
				, cl.admission_date as summary_charge_client_admission
				, cl.discharge_date as summary_charge_client_discharge
				, 0.0 as summary_current_balance
				, 0.0 as summary_previous_balance_due
				, 0.0 as summary_payments
				, 0.0 as summary_late_fees
				, 0.0 as summary_client_balance_due	
				, payr.private_bills_to as private_bills_to					
				, null as amount_past_due_yn	
				, null as term_used_for_client	
				, null as client_admit_date					
				, null as client_discharge_date				
				, null as client_mrn						
				, null as client_first_name					
				, null as client_last_name					
				, unit.unit_desc as client_unit
				, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
						when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
				, rm.room_desc as client_room
				, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
						when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
				, bd.bed_desc as client_bed
				, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
						when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
				, null as patient_specific_message
				, 0 as  contact_num
				, 0 as non_consolidated_contact_num			
				, '' as client_list
				, Case when relatcc.item_id is not null then 1 else 0 end as main_location
				, 0 as consolidated_location_order
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as sort_location
			from #facility_list fl
				inner join dbo.clients cl with (nolock) on fl.fac_id = cl.fac_id
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
				inner join #invoices inv with (nolock) on cl.client_id = inv.client_id and fl.fac_id = inv.fac_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id = 0
				inner join dbo.ar_lib_payers libpayer with (nolock) on inv.payer_id = libpayer.payer_id 
				inner join dbo.ar_payers payr with (nolock) on libpayer.payer_id = payr.payer_id and payr.fac_id = fl.fac_id
				inner join dbo.ar_payers_audit payraud with (nolock) on libpayer.payer_id = payraud.payer_id and payraud.fac_id = fl.fac_id
					and payraud.effective_date  <= inv.created_date AND (payraud.ineffective_date  >= inv.created_date or payraud.ineffective_date is null)
				inner join dbo.ar_configuration config with (nolock) on fl.fac_id  = config.fac_id
				inner join dbo.contact_type_audit cta with (nolock) on mpi.mpi_id = cta.reference_id 
					and config.contact_type_id = cta.[type_id] and cta.fac_id = inv.fac_id
					and cta.effective_date  <= inv.created_date AND (cta.ineffective_date  >= inv.created_date or cta.ineffective_date is null)
				left join #receiver_ids_table confilter on cta.contact_id = confilter.contact_id
				inner join dbo.contact_relationship conr with (nolock) on conr.contact_id = cta.contact_id and conr.deleted='N' 
					and conr.reference_id = cta.reference_id and conr.subclass_id = cta.subclass_id 
				inner join #subclass subc on cta.subclass_id = subc.subclass_id
				left join #relationship relatcc on conr.relationship_id = relatcc.item_id				
				inner join dbo.contact_audit conta with (nolock) on cta.contact_id = conta.contact_id and conta.deleted='N'			
					and conta.effective_date  <= inv.created_date AND (conta.ineffective_date  >= inv.created_date or conta.ineffective_date is null)
				left join dbo.contact_address_audit conadd with (nolock) on cta.contact_id = conadd.contact_id 			
					and conadd.effective_date  <= inv.created_date AND (conadd.ineffective_date  >= inv.created_date or conadd.ineffective_date is null)
				left join dbo.address_audit cadd with (nolock) on conadd.address_id = cadd.address_id			
					and cadd.effective_date  <= inv.created_date AND (cadd.ineffective_date  >= inv.created_date or cadd.ineffective_date is null)	
				left join dbo.county cnty with (nolock) on cadd.county_id = cnty.county_id
				left join common_code country with (nolock) on cadd.country_id = country.item_id
				left join common_code_audit title with (nolock)	on isnull(title.deleted, 'N') = 'N' and conta.title_id = title.item_id 
					and title.effective_date  <= inv.created_date AND (title.ineffective_date  >= inv.created_date or title.ineffective_date is null)
				left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
				left join #billing_group_table bg on grp.group_id = bg.group_id
				left join dbo.ar_client_configuration clcon with (nolock) on cl.client_id = clcon.client_id and clcon.deleted='N'
				left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
				left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
				left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
				left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
				inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
					and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)	
				left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id
				left join #client_ids_table clids on cl.client_id = clids.client_id						
			where 
			(@vClientStatus = -1 or (@vClientStatus = 0 and (cl.discharge_date is null or cl.discharge_date > @vReportDate)) or (@vClientStatus = 1 and cl.discharge_date <= @vReportDate)) 
			and (@vReceiverIds = '-1' or confilter.contact_id is not null)
			and ((@vReceiverIds <> '-1' and @vIsContact = 0 and conr.consolidate_statements = confilter.consolidate_statement and 
				((confilter.consolidate_statement = 0 and clids.client_id is not null) or (confilter.consolidate_statement = 1))) or @vReceiverIds = '-1' or @vIsContact = 1)
			and (@vBillingGroup = '-1' --or (@vBillingGroup <> '-1' and isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null )
			or (@vBillingGroup <> '-1' and ((clgrp.group_id is not null and bg.group_id is not null and @vBillingGroup <> '0') or (isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null) ))
			or @vBillingGroup is null)

			if @vReceiverIds = '-1'
				begin
					insert into #contact_clients --residents without contacts
					select distinct
							fl.fac_id
						, 0 as contact_id
						, 0 as consolidate_statement
						, cl.client_id 
						, inv.invoice_id
						, inv.statement_invoice_number
						, 0 as payer_id	
						, libpayer.description as payer 
						, inv.effective_date
						, inv.eff_date_from
						, inv.eff_date_to
						, case when fgi.fac_id is null then hfac.name else fgi.remit_to_name end as remit_to_name
						, case when fgi.fac_id is null then hfac.address1 else fgi.remit_to_address1 end as remit_to_address1
						, case when fgi.fac_id is null then hfac.address2 else fgi.remit_to_address2 end as remit_to_address2
						, case when fgi.fac_id is null then '' else fgi.remit_to_address3 end as remit_to_address3
						, case when fgi.fac_id is null then hfac.city else fgi.remit_to_city end as remit_to_city
						, case when fgi.fac_id is null then faccnty.name else fgi.remit_to_county end as remit_to_county
						, case when fgi.fac_id is null then hfac.prov else fgi.remit_to_prov_state end as remit_to_prov_state
						, case when fgi.fac_id is null then fl.country else fgi.remit_to_country end as remit_to_country
						, case when fgi.fac_id is null then hfac.pc else fgi.remit_to_postal_zip_code end as remit_to_postal_zip_code
						, case when fgi.fac_id is null then hfac.tel else fgi.remit_to_phone end as remit_to_phone
						, Null as contact_title
						, mpi.first_name as contact_first_name
						, mpi.last_name as contact_last_name
						, Null as contact_address1
						, Null as contact_address2
						, Null as contact_address3
						, Null as contact_city
						, Null as contact_county
						, Null as contact_prov_state
						, Null as contact_postal_zip_code
						, Null contact_country
						, Null as contact_email
						, 0 as account_number
						, convert(varchar(10),isnull(inv.generated_date,'1/1/1900'), 101) as generated_date
						, convert(varchar(10),inv.effective_date, 101) as bill_date
						, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
						, inv.payment_due_date
						, Null as pre_consolidated_payment_due_date
						, inv.statement_through_date	
						, Null as amount_due
						, Null as eft_message
						, Case when @vIncludeResidentMessage = 1 then clcon.invoice_message else Null end as client_message
						, null as group_message
						, null as global_message
						, null as previous_balance_due
						, null as payments
						, fl.fac_id as summary_fac_id
						, hfac.name as summary_charge_center
						, hfac.facility_code as summary_charge_center_code
						, mpi.first_name as summary_charge_client_first_name
						, mpi.last_name as summary_charge_client_last_name
						, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
						, cl.client_id_number as summary_charge_client_number
						, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
							when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
							else '' end)) as summary_charge_client_location
						, mpi.date_of_birth as summary_charge_client_dob
						, cl.admission_date as summary_charge_client_admission
						, cl.discharge_date as summary_charge_client_discharge
						, 0.0 as summary_current_balance
						, 0.0 as summary_previous_balance_due
						, 0.0 as summary_payments
						, 0.0 as summary_late_fees
						, 0.0 as summary_client_balance_due
						, payr.private_bills_to as private_bills_to				
						, null as amount_past_due_yn	
						, null as term_used_for_client				
						, null as client_admit_date					
						, null as client_discharge_date				
						, null as client_mrn						
						, null as client_first_name					
						, null as client_last_name					
						, unit.unit_desc as client_unit
						, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
								when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
						, rm.room_desc as client_room
						, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
								when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
						, bd.bed_desc as client_bed
						, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
								when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
						, null as patient_specific_message	
						, 0 as  contact_num
						, Dense_rank() over (ORDER BY mpi.last_name, mpi.first_name, cl.client_id, inv.effective_date) non_consolidated_contact_num
						--, 0 as non_consolidated_contact_num			
						, '' as client_list
						, 1 as main_location
						, 0 as consolidated_location_order
						, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
							when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
							else '' end)) as sort_location
					from #facility_list fl
						inner join #invoices inv with (nolock) on fl.fac_id = inv.fac_id
						inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id = 0											
						inner join dbo.ar_lib_payers libpayer with (nolock) on inv.payer_id = libpayer.payer_id
						inner join dbo.ar_payers payr with (nolock) on libpayer.payer_id = payr.payer_id and payr.fac_id = fl.fac_id 
						inner join dbo.ar_payers_audit payraud with (nolock) on libpayer.payer_id = payraud.payer_id and payraud.fac_id = fl.fac_id
							and payraud.effective_date  <= inv.created_date AND (payraud.ineffective_date  >= inv.created_date or payraud.ineffective_date is null)
						inner join dbo.ar_configuration config with (nolock) on fl.fac_id  = config.fac_id
						inner join dbo.clients cl with (nolock) on inv.client_id = cl.client_id
						inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
						left join #contact_clients concl on inv.invoice_id = concl.invoice_id
						left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
						left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
						left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
						left join #billing_group_table bg on grp.group_id = bg.group_id
						left join dbo.ar_client_configuration clcon with (nolock) on cl.client_id = clcon.client_id and clcon.deleted='N'
						left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
						left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
						left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
						left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
						inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
							and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)
						left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id	
					where --payraud.private_bills_to = 'G' and 
					concl.invoice_id is null and (@vClientStatus = -1 or (@vClientStatus = 0 and (cl.discharge_date is null or cl.discharge_date > @vReportDate)) or (@vClientStatus = 1 and cl.discharge_date <= @vReportDate)) 
					and (@vBillingGroup = '-1' or (@vBillingGroup <> '-1' and isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null )
					or (@vBillingGroup <> '-1' and clgrp.group_id is not null and bg.group_id is not null and isnull(@vBillingGroupIncludesMissing,0) = 0 )
					or @vBillingGroup is null)

				end

			if @vReceiverIds <> '-1'  and  @vIsContact = 0
				begin
					insert into #contact_clients --residents without contacts
					select distinct
							fl.fac_id
						, 0 as contact_id
						, 0 as consolidate_statement
						, cl.client_id 
						, inv.invoice_id
						, inv.statement_invoice_number
						, 0 as payer_id	
						, libpayer.description as payer 
						, inv.effective_date
						, inv.eff_date_from
						, inv.eff_date_to
						, case when fgi.fac_id is null then hfac.name else fgi.remit_to_name end as remit_to_name
						, case when fgi.fac_id is null then hfac.address1 else fgi.remit_to_address1 end as remit_to_address1
						, case when fgi.fac_id is null then hfac.address2 else fgi.remit_to_address2 end as remit_to_address2
						, case when fgi.fac_id is null then '' else fgi.remit_to_address3 end as remit_to_address3
						, case when fgi.fac_id is null then hfac.city else fgi.remit_to_city end as remit_to_city
						, case when fgi.fac_id is null then faccnty.name else fgi.remit_to_county end as remit_to_county
						, case when fgi.fac_id is null then hfac.prov else fgi.remit_to_prov_state end as remit_to_prov_state
						, case when fgi.fac_id is null then fl.country else fgi.remit_to_country end as remit_to_country
						, case when fgi.fac_id is null then hfac.pc else fgi.remit_to_postal_zip_code end as remit_to_postal_zip_code
						, case when fgi.fac_id is null then hfac.tel else fgi.remit_to_phone end as remit_to_phone
						, Null as contact_title
						, mpi.first_name as contact_first_name
						, mpi.last_name as contact_last_name
						, Null as contact_address1
						, Null as contact_address2
						, Null as contact_address3
						, Null as contact_city
						, Null as contact_county
						, Null as contact_prov_state
						, Null as contact_postal_zip_code
						, Null contact_country
						, Null as contact_email
						, 0 as account_number
						, convert(varchar(10),isnull(inv.generated_date,'1/1/1900'), 101) as generated_date
						, convert(varchar(10),inv.effective_date, 101) as bill_date
						, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
						, inv.payment_due_date
						, Null as pre_consolidated_payment_due_date
						, inv.statement_through_date	
						, Null as amount_due
						, Null as eft_message
						, Case when @vIncludeResidentMessage = 1 then clcon.invoice_message else Null end as client_message
						, null as group_message
						, null as global_message
						, null as previous_balance_due
						, null as payments
						, fl.fac_id as summary_fac_id
						, hfac.name as summary_charge_center
						, hfac.facility_code as summary_charge_center_code
						, mpi.first_name as summary_charge_client_first_name
						, mpi.last_name as summary_charge_client_last_name
						, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
						, cl.client_id_number as summary_charge_client_number
						, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
							when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
							else '' end)) as summary_charge_client_location
						, mpi.date_of_birth as summary_charge_client_dob
						, cl.admission_date as summary_charge_client_admission
						, cl.discharge_date as summary_charge_client_discharge
						, 0.0 as summary_current_balance
						, 0.0 as summary_previous_balance_due
						, 0.0 as summary_payments
						, 0.0 as summary_late_fees
						, 0.0 as summary_client_balance_due
						, payr.private_bills_to as private_bills_to					
						, null as amount_past_due_yn	
						, null as term_used_for_client				
						, null as client_admit_date					
						, null as client_discharge_date				
						, null as client_mrn						
						, null as client_first_name					
						, null as client_last_name					
						, unit.unit_desc as client_unit
						, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
								when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
						, rm.room_desc as client_room
						, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
								when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
						, bd.bed_desc as client_bed
						, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
								when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
						, null as patient_specific_message	
						, 0 as  contact_num
						, Dense_rank() over (ORDER BY mpi.last_name, mpi.first_name, cl.client_id, inv.effective_date) non_consolidated_contact_num
						--, 1 as non_consolidated_contact_num			
						, '' as client_list
						, 1 as main_location
						, 0 as consolidated_location_order
						, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
							when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
							else '' end)) as sort_location
					from #facility_list fl
						inner join dbo.clients cl with (nolock) on fl.fac_id = cl.fac_id
						inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
						inner join #invoices inv with (nolock) on cl.client_id = inv.client_id
						inner join #client_ids_table clfilter on inv.client_id = clfilter.client_id
						inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id = 0											
						inner join dbo.ar_lib_payers libpayer with (nolock) on inv.payer_id = libpayer.payer_id 
						inner join dbo.ar_payers payr with (nolock) on libpayer.payer_id = payr.payer_id and payr.fac_id = fl.fac_id
						inner join dbo.ar_payers_audit payraud with (nolock) on libpayer.payer_id = payraud.payer_id and payraud.fac_id = fl.fac_id
							and payraud.effective_date  <= inv.created_date AND (payraud.ineffective_date  >= inv.created_date or payraud.ineffective_date is null)
						inner join dbo.ar_configuration config with (nolock) on fl.fac_id  = config.fac_id
						left join #contact_clients concl on inv.invoice_id = concl.invoice_id
						left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
						left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
						left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
						left join #billing_group_table bg on grp.group_id = bg.group_id
						left join dbo.ar_client_configuration clcon with (nolock) on cl.client_id = clcon.client_id and clcon.deleted='N'
						left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
						left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
						left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
						left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
						inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
							and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)
						left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id	
					where --payraud.private_bills_to = 'G' and 
					concl.invoice_id is null and (@vClientStatus = -1 or (@vClientStatus = 0 and (cl.discharge_date is null or cl.discharge_date > @vReportDate)) or (@vClientStatus = 1 and cl.discharge_date <= @vReportDate)) 
					and (@vBillingGroup = '-1' --or (@vBillingGroup <> '-1' and isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null )
					or (@vBillingGroup <> '-1' and ((clgrp.group_id is not null and bg.group_id is not null and @vBillingGroup <> '0') or (isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null) ))
					or @vBillingGroup is null)
				end

			if @vReceiverIds = '-1'  or (@vReceiverIds <> '-1'  and  @vIsContact = 0)
				begin
					insert into #contact_clients --we need to check for other multiple contacts that may not have all appropriate invoices assigned
					select distinct
							mycon.fac_id
						, mycon.contact_id
						, mycon.consolidate_statement
						, myadd.client_id 
						, myadd.invoice_id
						, myadd.statement_invoice_number
						, 0 as payer_id	
						, myadd.payer 
						, myadd.inv_effective_date
						, myadd.inv_eff_date_from
						, myadd.inv_eff_date_to
						, mycon.remit_to_name
						, mycon.remit_to_address1
						, mycon.remit_to_address2
						, mycon.remit_to_address3
						, mycon.remit_to_city
						, mycon.remit_to_county
						, mycon.remit_to_prov_state
						, mycon.remit_to_country
						, mycon.remit_to_postal_zip_code
						, mycon.remit_to_phone
						, mycon.contact_title
						, mycon.contact_first_name
						, mycon.contact_last_name
						, mycon.contact_address1
						, mycon.contact_address2
						, mycon.contact_address3
						, mycon.contact_city
						, mycon.contact_county
						, mycon.contact_prov_state
						, mycon.contact_postal_zip_code
						, mycon.contact_country
						, mycon.contact_email
						, mycon.account_number
						, myadd.generated_date
						, myadd.bill_date
						, myadd.aging_date
						, myadd.payment_due_date
						, myadd.pre_consolidated_payment_due_date
						, myadd.statement_through_date	
						, myadd.amount_due
						, myadd.eft_message
						, myadd.client_message
						, myadd.group_message
						, myadd.global_message
						, myadd.previous_balance_due
						, myadd.payments
						, myadd.summary_fac_id
						, myadd.summary_charge_center
						, myadd.summary_charge_center_code
						, myadd.summary_charge_client_first_name
						, myadd.summary_charge_client_last_name
						, myadd.summary_charge_client_name
						, myadd.summary_charge_client_number
						, myadd.summary_charge_client_location
						, myadd.summary_charge_client_dob
						, myadd.summary_charge_client_admission
						, myadd.summary_charge_client_discharge
						, 0.0 as summary_current_balance
						, 0.0 as summary_previous_balance_due
						, 0.0 as summary_payments
						, 0.0 as summary_late_fees
						, 0.0 as summary_client_balance_due
						, myadd.private_bills_to				
						, null as amount_past_due_yn	
						, null as term_used_for_client				
						, null as client_admit_date					
						, null as client_discharge_date				
						, null as client_mrn						
						, null as client_first_name					
						, null as client_last_name					
						, myadd.client_unit	
						, myadd.unit_order					
						, myadd.client_room	
						, myadd.room_order					
						, myadd.client_bed
						, myadd.bed_order
						, null as patient_specific_message	
						, mycon.contact_num
						, mycon.non_consolidated_contact_num		
						, '' as client_list
						, myadd.main_location
						, myadd.consolidated_location_order	
						, myadd.sort_location
					from #contact_clients mycon
						inner join (SELECT b.contact_id,a.client_id, a.invoice_id, a.bill_date
							FROM(
								SELECT DISTINCT client_id , invoice_id, bill_date FROM #contact_clients where contact_id > 0) A
								INNER JOIN (
								SELECT DISTINCT contact_id, client_id FROM #contact_clients where contact_id > 0) B
								ON a.client_id = b.client_id 
								EXCEPT
								SELECT contact_id,client_id, invoice_id, bill_date FROM #contact_clients where contact_id > 0
								) toget
								on mycon.contact_id = toget.contact_id and mycon.client_id = toget.client_id and mycon.bill_date = toget.bill_date
						inner join #contact_clients myadd on toget.invoice_id = myadd.invoice_id

				end
		end

		set @vgsStepEndTime=GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

		-- other payer loading here
		if @vOtherStatementsIncluded = 1

		begin		
		-----getting the list of contacts
		select @vStep = 80
		set @vgsStepStartTime = GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' gathering other payer invoices ' + convert(varchar(26),getdate(),109)
		------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

		insert into #contact_clients
			select distinct
					fl.fac_id
				, Case when payraud.private_bills_to = 'G'  then  -1 * isnull(CAST(conta.contact_id AS NUMERIC(18,1)),3.1) else -2.1 end  as contact_id  --AMRO
				, 0 as consolidate_statement
				, cl.client_id 
				, inv.invoice_id 
				, inv.statement_invoice_number
				, libpayer.payer_id	
				, libpayer.description as payer 
				, inv.effective_date
				, inv.eff_date_from
				, inv.eff_date_to
				, case when fgi.fac_id is null then hfac.name else fgi.remit_to_name end as remit_to_name
				, case when fgi.fac_id is null then hfac.address1 else fgi.remit_to_address1 end as remit_to_address1
				, case when fgi.fac_id is null then hfac.address2 else fgi.remit_to_address2 end as remit_to_address2
				, case when fgi.fac_id is null then '' else fgi.remit_to_address3 end as remit_to_address3
				, case when fgi.fac_id is null then hfac.city else fgi.remit_to_city end as remit_to_city
				, case when fgi.fac_id is null then faccnty.name else fgi.remit_to_county end as remit_to_county
				, case when fgi.fac_id is null then hfac.prov else fgi.remit_to_prov_state end as remit_to_prov_state
				, case when fgi.fac_id is null then fl.country else fgi.remit_to_country end as remit_to_country
				, case when fgi.fac_id is null then hfac.pc else fgi.remit_to_postal_zip_code end as remit_to_postal_zip_code
				, case when fgi.fac_id is null then hfac.tel else fgi.remit_to_phone end as remit_to_phone
				, Case when payraud.private_bills_to = 'G' then title.item_description else '' end as contact_title
				, Case when payraud.private_bills_to = 'G' and isnull(conta.first_name,'') <> '' then conta.first_name
					when payraud.private_bills_to = 'G' and isnull(conta.first_name,'') = '' then 'No Data Found'
					when payraud.private_bills_to <> 'G' and isnull(insco.description,'') = '' then 'No Data Found' else insco.description end as contact_first_name 
				, Case when payraud.private_bills_to = 'G' then conta.last_name else '' end as contact_last_name
				, Case when payraud.private_bills_to = 'G' and isnull(cadd.address1,'') = '' and  isnull(cadd.address2,'') = '' then 'No Address Found' 
					when payraud.private_bills_to = 'G' and isnull(cadd.address1,'') <> '' then cadd.address1		
					when payraud.private_bills_to <> 'G' and isnull(inscoadd.address1,'') = '' and isnull(inscoadd.address2,'') = '' then 'No Address Found' 
					else inscoadd.address1 end as contact_address1
				, Case when payraud.private_bills_to = 'G' then cadd.address2 else inscoadd.address2 end as contact_address2
				, Case when payraud.private_bills_to = 'G' then cadd.address3 else inscoadd.address3 end as contact_address3
				, Case when payraud.private_bills_to = 'G' then cadd.city else inscoadd.city end as contact_city
				, Case when payraud.private_bills_to = 'G' then ccnty.name else cnty.name end as contact_county
				, Case when payraud.private_bills_to = 'G' then cadd.prov_state else inscoadd.prov_state end as contact_prov_state
				, Case when payraud.private_bills_to = 'G' then cadd.postal_zip_code else inscoadd.postal_zip_code end as contact_postal_zip_code
				, Case when payraud.private_bills_to = 'G' then ccountry.item_description else country.item_description end as contact_country
				, null as contact_email
				, Case when payraud.private_bills_to = 'G' then conr.contact_id else '' end as account_number
				, '1/1/1900' as generated_date
				, convert(varchar(10),inv.effective_date, 101) as bill_date
				, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
				, inv.payment_due_date
				, Null as pre_consolidated_payment_due_date
				, inv.statement_through_date		
				, Null as amount_due
				, Null as eft_message
				, '' as client_message
				, Null as group_message
				, Null as global_message
				, Null as previous_balance_due
				, Null as payments
				, fl.fac_id as summary_fac_id
				, hfac.name as summary_charge_center
				, hfac.facility_code as summary_charge_center_code
				, mpi.first_name as summary_charge_client_first_name
				, mpi.last_name as summary_charge_client_last_name
				, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
				, cl.client_id_number as summary_charge_client_number
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as summary_charge_client_location
				, mpi.date_of_birth as summary_charge_client_dob
				, cl.admission_date as summary_charge_client_admission
				, cl.discharge_date as summary_charge_client_discharge
				, 0.0 as summary_current_balance
				, 0.0 as summary_previous_balance_due
				, 0.0 as summary_payments
				, 0.0 as summary_late_fees
				, 0.0 as summary_client_balance_due	
				, payr.private_bills_to as private_bills_to					
				, null as amount_past_due_yn	
				, null as term_used_for_client	
				, null as client_admit_date					
				, null as client_discharge_date				
				, null as client_mrn						
				, null as client_first_name					
				, null as client_last_name					
				, unit.unit_desc as client_unit
				, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
						when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
				, rm.room_desc as client_room
				, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
						when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
				, bd.bed_desc as client_bed
				, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
						when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
				, null as patient_specific_message
				, 0 as  contact_num
				, 0 as non_consolidated_contact_num			
				, '' as client_list
				, 1 as main_location
				, 0 as consolidated_location_order
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as sort_location
			from #facility_list fl
				inner join dbo.clients cl with (nolock) on fl.fac_id = cl.fac_id
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
				inner join #invoices inv with (nolock) on cl.client_id = inv.client_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id > 0
				inner join dbo.ar_lib_payers libpayer with (nolock) on inv.payer_id = libpayer.payer_id 
				inner join dbo.ar_payers payr with (nolock) on libpayer.payer_id = payr.payer_id and payr.fac_id = fl.fac_id
				inner join dbo.ar_payers_audit payraud with (nolock) on libpayer.payer_id = payraud.payer_id and payraud.fac_id = fl.fac_id
				and payraud.effective_date  <= inv.created_date AND (payraud.ineffective_date  >= inv.created_date or payraud.ineffective_date is null)
				inner join dbo.ar_configuration config with (nolock) on fl.fac_id  = config.fac_id
				left join dbo.ar_client_payer_info policy with (nolock) on cl.client_id = policy.client_id and inv.payer_id = policy.payer_id
				left join dbo.client_ids clid with (nolock) on inv.client_id = clid.client_id and policy.policy_no_id = clid.id_type_id
				left join dbo.ar_payer_addresses_audit payradd with (nolock) on payraud.fac_id = payradd.fac_id and payraud.payer_id = payradd.payer_id and payraud.default_address_id = payradd.address_id and
					payradd.effective_date  <= inv.created_date AND (payradd.ineffective_date  >= inv.created_date or payradd.ineffective_date is null)
				left join dbo.ar_lib_insurance_companies_audit insco with (nolock) on payradd.insurance_id = insco.insurance_id and
					insco.effective_date  <= inv.created_date AND (insco.ineffective_date  >= inv.created_date or insco.ineffective_date is null)
				left join dbo.ar_insurance_addresses_audit inscoadd with (nolock) on payradd.address_id = inscoadd.address_id and
					inscoadd.effective_date  <= inv.created_date AND (inscoadd.ineffective_date  >= inv.created_date or inscoadd.ineffective_date is null)
				left join dbo.ar_provider_numbers provnum with (nolock) on inscoadd.address_id = provnum.address_id and fl.fac_id = provnum.fac_id
				left join dbo.county cnty with (nolock) on inscoadd.county_id = cnty.county_id
				left join common_code country with (nolock) on inscoadd.country_id = country.item_id
				left join #client_ids_table clfilter on inv.client_id = clfilter.client_id
				left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
				left join #billing_group_table bg on grp.group_id = bg.group_id
				left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
				left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
				left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
				left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
				inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
					and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)	
				left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id
						left join dbo.contact_type_audit cta with (nolock) on mpi.mpi_id = cta.reference_id 
					and config.contact_type_id = cta.[type_id] and cta.fac_id = inv.fac_id
					and cta.effective_date  <= inv.created_date AND (cta.ineffective_date  >= inv.created_date or cta.ineffective_date is null)
				left join dbo.contact_relationship conr with (nolock) on conr.contact_id = cta.contact_id and conr.deleted='N' 
					and conr.reference_id = cta.reference_id and conr.subclass_id = cta.subclass_id 
				left join #relationship relatcc on conr.relationship_id = relatcc.item_id
				left join dbo.contact_audit conta with (nolock) on cta.contact_id = conta.contact_id and conta.deleted='N'			
					and conta.effective_date  <= inv.created_date AND (conta.ineffective_date  >= inv.created_date or conta.ineffective_date is null)
				left join dbo.contact_address_audit conadd with (nolock) on cta.contact_id = conadd.contact_id 			
					and conadd.effective_date  <= inv.created_date AND (conadd.ineffective_date  >= inv.created_date or conadd.ineffective_date is null)
				left join dbo.address_audit cadd with (nolock) on conadd.address_id = cadd.address_id			
					and cadd.effective_date  <= inv.created_date AND (cadd.ineffective_date  >= inv.created_date or cadd.ineffective_date is null)	
				left join dbo.county ccnty with (nolock) on cadd.county_id = cnty.county_id
				left join common_code ccountry with (nolock) on cadd.country_id = ccountry.item_id
				left join common_code_audit title with (nolock)	on isnull(title.deleted, 'N') = 'N' and conta.title_id = title.item_id 
					and title.effective_date  <= inv.created_date AND (title.ineffective_date  >= inv.created_date or title.ineffective_date is null)				
			where payraud.private_bills_to <> 'I' and (@vClientStatus = -1 or (@vClientStatus = 0 and (cl.discharge_date is null or cl.discharge_date > @vReportDate)) or (@vClientStatus = 1 and cl.discharge_date is not null and cl.discharge_date <= @vReportDate)) 
			and (@vReceiverIds = '-1' or clfilter.client_id is not null)
			and (@vBillingGroup = '-1' --or (@vBillingGroup <> '-1' and isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null )
			or (@vBillingGroup <> '-1' and ((clgrp.group_id is not null and bg.group_id is not null and @vBillingGroup <> '0') or (isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null) ))
			or @vBillingGroup is null)

		set @vRowCount = @@rowcount

		insert into #contact_clients
			select distinct
					fl.fac_id
				, -2.1  as contact_id
				, 0 as consolidate_statement
				, cl.client_id 
				, inv.invoice_id 
				, inv.statement_invoice_number
				, libpayer.payer_id	
				, libpayer.description as payer 
				, inv.effective_date
				, inv.eff_date_from
				, inv.eff_date_to
				, case when fgi.fac_id is null then hfac.name else fgi.remit_to_name end as remit_to_name
				, case when fgi.fac_id is null then hfac.address1 else fgi.remit_to_address1 end as remit_to_address1
				, case when fgi.fac_id is null then hfac.address2 else fgi.remit_to_address2 end as remit_to_address2
				, case when fgi.fac_id is null then '' else fgi.remit_to_address3 end as remit_to_address3
				, case when fgi.fac_id is null then hfac.city else fgi.remit_to_city end as remit_to_city
				, case when fgi.fac_id is null then faccnty.name else fgi.remit_to_county end as remit_to_county
				, case when fgi.fac_id is null then hfac.prov else fgi.remit_to_prov_state end as remit_to_prov_state
				, case when fgi.fac_id is null then fl.country else fgi.remit_to_country end as remit_to_country
				, case when fgi.fac_id is null then hfac.pc else fgi.remit_to_postal_zip_code end as remit_to_postal_zip_code
				, case when fgi.fac_id is null then hfac.tel else fgi.remit_to_phone end as remit_to_phone
				, '' as contact_title
				, Case when isnull(insco.description,'') = '' then libpayer.description else insco.description end as contact_first_name 
				, '' as contact_last_name
				, Case when isnull(inscoadd.address1,'') = '' and isnull(inscoadd.address2,'') = '' then 'No Address Found' 
					else inscoadd.address1 end as contact_address1
				, inscoadd.address2 as contact_address2
				, inscoadd.address3 as contact_address3
				, inscoadd.city as contact_city
				, cnty.name as contact_county
				, inscoadd.prov_state as contact_prov_state
				, inscoadd.postal_zip_code as contact_postal_zip_code
				,  country.item_description as contact_country
				, null as contact_email
				, '' as account_number
				, '1/1/1900' as generated_date
				, convert(varchar(10),inv.effective_date, 101) as bill_date
				, dateadd(mm, datediff(mm, 0, inv.effective_date) + 1, 0) as aging_date
				, inv.payment_due_date
				, Null as pre_consolidated_payment_due_date
				, inv.statement_through_date	
				, Null as amount_due
				, Null as eft_message
				, '' as client_message
				, Null as group_message
				, Null as global_message
				, Null as previous_balance_due
				, Null as payments
				, fl.fac_id as summary_fac_id
				, hfac.name as summary_charge_center
				, hfac.facility_code as summary_charge_center_code
				, mpi.first_name as summary_charge_client_first_name
				, mpi.last_name as summary_charge_client_last_name
				, mpi.last_name + ', ' + mpi.first_name as summary_charge_client_name
				, cl.client_id_number as summary_charge_client_number
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as summary_charge_client_location
				, mpi.date_of_birth as summary_charge_client_dob
				, cl.admission_date as summary_charge_client_admission
				, cl.discharge_date as summary_charge_client_discharge
				, 0.0 as summary_current_balance
				, 0.0 as summary_previous_balance_due
				, 0.0 as summary_payments
				, 0.0 as summary_late_fees
				, 0.0 as summary_client_balance_due	
				, payr.private_bills_to as private_bills_to						
				, null as amount_past_due_yn	
				, null as term_used_for_client	
				, null as client_admit_date					
				, null as client_discharge_date				
				, null as client_mrn						
				, null as client_first_name					
				, null as client_last_name					
				, unit.unit_desc as client_unit
				, case when TRY_CONVERT(numeric,unit.unit_desc) is not null then convert(numeric, unit.unit_desc)
						when TRY_CONVERT(numeric,left(unit.unit_desc,1)) is not null  then convert(numeric,(left(unit.unit_desc,PATINDEX('%[^0-9]%',unit.unit_desc)-1))) else 9999999 end as unit_order						
				, rm.room_desc as client_room
				, case when TRY_CONVERT(numeric,rm.room_desc) is not null  then convert(numeric, rm.room_desc)
						when TRY_CONVERT(numeric,left(rm.room_desc,1)) is not null  then convert(numeric,(left(rm.room_desc,PATINDEX('%[^0-9]%',rm.room_desc)-1))) else 9999999 end as room_order						
				, bd.bed_desc as client_bed
				, case when TRY_CONVERT(numeric,bd.bed_desc) is not null  then convert(numeric, bd.bed_desc)
						when TRY_CONVERT(numeric,left(bd.bed_desc,1)) is not null  then convert(numeric,(left(bd.bed_desc,PATINDEX('%[^0-9]%',bd.bed_desc)-1))) else 9999999 end as bed_order	
				, null as patient_specific_message
				, 0 as  contact_num
				, 0 as non_consolidated_contact_num			
				, '' as client_list
				, 1 as main_location
				, 0 as consolidated_location_order
				, ltrim(rtrim(case when bd.bed_id is not null and isnull(bd.bed_desc,'') <> '' then unit.unit_desc + ' ' +rm.room_desc + '-' + bd.bed_desc 
					when bd.bed_id is not null and isnull(bd.bed_desc,'') = '' then unit.unit_desc + ' ' +rm.room_desc
					else '' end)) as sort_location
			from #facility_list fl
				inner join dbo.clients cl with (nolock) on fl.fac_id = cl.fac_id
				inner join dbo.mpi with (nolock) on cl.mpi_id = mpi.mpi_id
				inner join #invoices inv with (nolock) on cl.client_id = inv.client_id
				inner join #payer_ids_table payer on inv.payer_id = payer.payer_id and payer.bill_payer_id > 0
				inner join dbo.ar_lib_payers libpayer with (nolock) on inv.payer_id = libpayer.payer_id 
				inner join dbo.ar_payers payr with (nolock) on libpayer.payer_id = payr.payer_id and payr.fac_id = fl.fac_id
				inner join dbo.ar_payers_audit payraud with (nolock) on libpayer.payer_id = payraud.payer_id and payraud.fac_id = fl.fac_id
				and payraud.effective_date  <= inv.created_date AND (payraud.ineffective_date  >= inv.created_date or payraud.ineffective_date is null)
				left join dbo.ar_client_payer_info cpiaud with (nolock) on cl.client_id = cpiaud.client_id and payraud.payer_id = cpiaud.payer_id and payraud.fac_id = cpiaud.fac_id and cpiaud.deleted = 'N'
					and cpiaud.effective_date  <= inv.effective_date AND (cpiaud.ineffective_date  >= inv.effective_date or cpiaud.ineffective_date is null) 
				left join dbo.ar_insurance_addresses_audit inscoadd with (nolock) on cpiaud.payer_address_id = inscoadd.address_id and
					inscoadd.effective_date  <= inv.created_date AND (inscoadd.ineffective_date  >= inv.created_date or inscoadd.ineffective_date is null)
				left join dbo.ar_lib_insurance_companies_audit insco with (nolock) on inscoadd.insurance_id = insco.insurance_id and
					insco.effective_date  <= inv.created_date AND (insco.ineffective_date  >= inv.created_date or insco.ineffective_date is null)
				left join dbo.ar_provider_numbers provnum with (nolock) on inscoadd.address_id = provnum.address_id and fl.fac_id = provnum.fac_id
				left join dbo.county cnty with (nolock) on inscoadd.county_id = cnty.county_id
				left join common_code country with (nolock) on inscoadd.country_id = country.item_id
				left join #client_ids_table clfilter on inv.client_id = clfilter.client_id
				left join #facilty_group_info fgi on fl.fac_id = fgi.fac_id
				left join dbo.ar_client_group clgrp with (nolock) on cl.client_id = clgrp.client_id
				left join dbo.ar_group grp with (nolock) on clgrp.group_id = grp.group_id and grp.fac_id = fl.fac_id and grp.deleted='N'
				left join #billing_group_table bg on grp.group_id = bg.group_id
				left join dbo.census_item ci with (nolock) on cl.current_census_id = ci.census_id
				left join dbo.bed bd with (nolock) on ci.bed_id = bd.bed_id
				left join dbo.room rm with (nolock) on bd.room_id = rm.room_id
				left join dbo.unit unit with (nolock) on rm.unit_id = unit.unit_id
				inner join dbo.facility_audit hfac with (nolock) on fl.fac_id = hfac.fac_id
					and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)	
				left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id							
			where payraud.private_bills_to = 'I' and (@vClientStatus = -1 or (@vClientStatus = 0 and (cl.discharge_date is null or cl.discharge_date > @vReportDate)) or (@vClientStatus = 1 and cl.discharge_date is not null and cl.discharge_date <= @vReportDate)) 
			and (@vReceiverIds = '-1' or clfilter.client_id is not null)
			and (@vBillingGroup = '-1' --or (@vBillingGroup <> '-1' and isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null )
			or (@vBillingGroup <> '-1' and ((clgrp.group_id is not null and bg.group_id is not null and @vBillingGroup <> '0') or (isnull(@vBillingGroupIncludesMissing,0) = 1 and clgrp.group_id is null) ))
			or @vBillingGroup is null)

		set @vRowCount = isnull(@vRowCount,0) + @@rowcount

		if @vRowCount = 0
			set @vOtherStatementsIncluded = 0

		set @vgsStepEndTime=GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

		end

	end

select @vStep = 85
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' grouping invoices ' + convert(varchar(26),getdate(),109)

--break by generated date
--select contact_num,* from #contact_clients order by 1
if @vSortBy = 1

	begin
		update con set 
				 con.client_unit = main.client_unit
				,con.unit_order = main.unit_order						
				,con.client_room = main.client_room
				,con.room_order = main.room_order						
				,con.client_bed = main.client_bed
				,con.bed_order = main.bed_order
				,con.sort_location = main.sort_location	
		from #contact_clients con
		inner join #contact_clients main on con.contact_id = main.contact_id and con.non_consolidated_contact_num = main.non_consolidated_contact_num
			and con.bill_date = main.bill_date and con.payer_id = main.payer_id and con.consolidate_statement = 1 and main.consolidate_statement = 1
			and con.main_location = 0 and main.main_location = 1

		--when there isn't a "main resident" in a multi resident statement, set it to the first location
		update con set 
				 con.client_unit = sortby.client_unit
				,con.unit_order = sortby.unit_order						
				,con.client_room = sortby.client_room
				,con.room_order = sortby.room_order						
				,con.client_bed = sortby.client_bed
				,con.bed_order = sortby.bed_order
				,con.sort_location = sortby.sort_location	
		from #contact_clients con
		inner join(
					select mincon.contact_id,mincon.bill_date,mincon.payer_id,mincon.generated_date,
					min(mincon.client_unit) as client_unit,min(mincon.unit_order) as unit_order,min(mincon.client_room) as client_room,min(mincon.room_order) as room_order,
					min(mincon.client_bed) as client_bed,min(mincon.bed_order) bed_order,min(mincon.sort_location) as sort_location
					from #contact_clients mincon
					inner join(
								select contact_id,non_consolidated_contact_num,bill_date,contact_last_name, contact_first_name,payer_id, generated_date
								from #contact_clients where main_location = 0 
								group by contact_id,non_consolidated_contact_num,bill_date,contact_last_name, contact_first_name,payer_id, generated_date
								having count(1) > 1
								) nomain on mincon.contact_id = nomain.contact_id and mincon.bill_date = nomain.bill_date and mincon.payer_id = nomain.payer_id and mincon.generated_date = nomain.generated_date
								group by  mincon.contact_id,mincon.bill_date,mincon.payer_id,mincon.generated_date
				) sortby on con.contact_id = sortby.contact_id and con.bill_date = sortby.bill_date and con.payer_id = sortby.payer_id and con.generated_date = sortby.generated_date

		update  con set con.contact_num = rnk.contact_num
		from #contact_clients con
		left join #facilty_group_info fg on con.fac_id = fg.fac_id
		inner join (select contact_id,non_consolidated_contact_num,bill_date,payer_id, generated_date, consolidate_statement, 
				case when fgi.fac_id is null then #contact_clients.fac_id else fgi.facility_group_id end as grp,
				invoice_id, 
			Dense_rank()  over (ORDER BY unit_order, client_unit, room_order, client_room, bed_order, client_bed, inv_effective_date, generated_date,(case when contact_id < 0 then invoice_id else 0 end) ,
				contact_last_name, contact_first_name, contact_id, consolidate_statement, 
				(case when fgi.fac_id is null then #contact_clients.fac_id else fgi.facility_group_id end),
				(case when consolidate_statement = 0 then client_id else 0 end)
				) contact_num from #contact_clients
				left join #facilty_group_info fgi on #contact_clients.fac_id = fgi.fac_id
				) rnk
			on con.contact_id= rnk.contact_id and con.bill_date= rnk.bill_date and con.payer_id= rnk.payer_id and con.non_consolidated_contact_num= rnk.non_consolidated_contact_num 
				and con.generated_date =  rnk.generated_date and con.consolidate_statement =  rnk.consolidate_statement and ((fg.fac_id is null and rnk.grp = con.fac_id) or (fg.fac_id is not null and rnk.grp = fg.facility_group_id))
			where (con.invoice_id = rnk.invoice_id)
	end
else
	If @vIsContact = 0
		begin
			update con set con.sort_location = con.summary_charge_client_name
			from #contact_clients con

			update con set con.sort_location = main.summary_charge_client_name
			from #contact_clients con
			inner join #contact_clients main on con.contact_id = main.contact_id and con.non_consolidated_contact_num = main.non_consolidated_contact_num
				and con.bill_date = main.bill_date and con.payer_id = main.payer_id and con.consolidate_statement = 1 and main.consolidate_statement = 1
				and con.main_location = 0 and main.main_location = 1
			
			--when there isn't a "main resident" in a multi resident statement, set it to the first resident alphabetically
			update con set con.sort_location = sortby.summary_charge_client_name
			from #contact_clients con
			inner join(
						select mincon.contact_id,mincon.bill_date,mincon.payer_id,mincon.generated_date,min(mincon.summary_charge_client_name) as summary_charge_client_name
						from #contact_clients mincon
						inner join(
									select contact_id,non_consolidated_contact_num,bill_date,contact_last_name, contact_first_name,payer_id, generated_date
									from #contact_clients where main_location = 0 
									group by contact_id,non_consolidated_contact_num,bill_date,contact_last_name, contact_first_name,payer_id, generated_date
									having count(1) > 1
								 ) nomain on mincon.contact_id = nomain.contact_id and mincon.bill_date = nomain.bill_date and mincon.payer_id = nomain.payer_id and mincon.generated_date = nomain.generated_date
									group by mincon.contact_id,mincon.bill_date,mincon.payer_id,mincon.generated_date
					) sortby on con.contact_id = sortby.contact_id and con.bill_date = sortby.bill_date and con.payer_id = sortby.payer_id and con.generated_date = sortby.generated_date

			update  con set con.contact_num = rnk.contact_num
			from #contact_clients con
			left join #facilty_group_info fg on con.fac_id = fg.fac_id
			inner join (select distinct contact_id,non_consolidated_contact_num,bill_date,payer_id, generated_date, consolidate_statement, 
					case when fgi.fac_id is null then #contact_clients.fac_id else fgi.facility_group_id end as grp,
					invoice_id, 
				Dense_rank()  over (ORDER BY sort_location ,inv_effective_date, generated_date, (case when consolidate_statement = 1 then '0' else sort_location end), case when contact_id < 0 then invoice_id else 0 end, 
					contact_last_name, contact_first_name, contact_id, (case when contact_id < 0 then invoice_id else 0 end), consolidate_statement, 
					(case when fgi.fac_id is null then #contact_clients.fac_id else fgi.facility_group_id end),
					(case when consolidate_statement = 0 then client_id else 0 end) 
					) contact_num from #contact_clients
					left join #facilty_group_info fgi on #contact_clients.fac_id = fgi.fac_id
					) rnk
				on con.contact_id= rnk.contact_id and con.bill_date= rnk.bill_date and con.payer_id= rnk.payer_id and con.non_consolidated_contact_num= rnk.non_consolidated_contact_num 
					and con.generated_date =  rnk.generated_date and con.consolidate_statement =  rnk.consolidate_statement and ((fg.fac_id is null and rnk.grp = con.fac_id) or (fg.fac_id is not null and rnk.grp = fg.facility_group_id))
			where (con.invoice_id = rnk.invoice_id)

		end
	else
		begin
			update  con set con.contact_num = rnk.contact_num
			from #contact_clients con
			left join #facilty_group_info fg on con.fac_id = fg.fac_id
			inner join (select contact_id,non_consolidated_contact_num,bill_date,contact_last_name, contact_first_name,payer_id, generated_date, consolidate_statement, 
					case when fgi.fac_id is null then #contact_clients.fac_id else fgi.facility_group_id end as grp,
					invoice_id, Dense_rank() over 
				(ORDER BY contact_last_name, contact_first_name, contact_id,payer_id
						, consolidate_statement, inv_effective_date, generated_date,(case when contact_id < 0 then invoice_id else 0 end), 
						(case when fgi.fac_id is null then #contact_clients.fac_id else fgi.facility_group_id end),
						(case when consolidate_statement = 0 then client_id else 0 end)  ) contact_num from #contact_clients
						left join #facilty_group_info fgi on #contact_clients.fac_id = fgi.fac_id 
						) rnk
				on con.contact_id= rnk.contact_id and con.bill_date= rnk.bill_date and con.payer_id= rnk.payer_id and con.non_consolidated_contact_num= rnk.non_consolidated_contact_num
				and con.generated_date =  rnk.generated_date and con.consolidate_statement =  rnk.consolidate_statement 
				and con.contact_last_name = rnk.contact_last_name and con.contact_first_name = rnk.contact_first_name and ((fg.fac_id is null and rnk.grp = con.fac_id) or (fg.fac_id is not null and rnk.grp = fg.facility_group_id))
				where (con.invoice_id = rnk.invoice_id)

		end

If @vIsContact = 0 and @vIsEmc = 1 and isnull(@vReceiverIds,'-1') <> '-1'

	delete dcon
	from #contact_clients dcon
	left join (select cc.contact_num from #contact_clients cc inner join #client_ids_table cl on cc.client_id = cl.client_id group by cc.contact_num) kcon
	on dcon.contact_num = kcon.contact_num
	where kcon.contact_num is null 

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

-----getting the list of contacts
select @vStep = 90
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' gathering messages + get latest contact info' + convert(varchar(26),getdate(),109)


if @vBillingGroup = '-1' or @vIsEmc = 1
	begin
		update  con set con.group_message = LEFT(invoicemessage.value('.','varchar(max)') , LEN(invoicemessage.value('.','varchar(max)')) -1 )--AS invoicemsg 
		FROM #contact_clients con
		CROSS APPLY
		( 
		SELECT ag.invoice_message + char(9) --+ ', '
			FROM  dbo.ar_group ag WITH (NOLOCK)
			inner join dbo.ar_client_group acg WITH (NOLOCK) on ag.group_id = acg.group_id
			WHERE acg.client_id = con.client_id and isnull(ag.invoice_message,'')<>''
			ORDER BY ag.created_date desc
			FOR XML PATH (''), TYPE
		) a ( invoicemessage )
	end

if @vBillingGroup <> '-1' and @vBillingGroup <> '0' and  @vIsEmc = 0
	begin
		update  con set con.group_message = LEFT(invoicemessage.value('.','varchar(max)') , LEN(invoicemessage.value('.','varchar(max)')) -1 )--AS invoicemsg 
		FROM #contact_clients con
		CROSS APPLY
		( 
		SELECT ltrim(rtrim(ag.invoice_message)) + char(9) --+ ', '
			FROM  dbo.ar_group ag WITH (NOLOCK)
			inner join dbo.ar_client_group acg WITH (NOLOCK) on ag.group_id = acg.group_id
			inner join #billing_group_table bg on ag.group_id = bg.group_id
			WHERE acg.client_id = con.client_id and isnull(ag.invoice_message,'')<>''
			ORDER BY ag.created_date desc
			FOR XML PATH (''), TYPE
		) a ( invoicemessage )
	end

--add eft messages
If  @vIsNewEft = 'N'
	begin
		update  con set con.eft_message = eft_info.invoice_message
		FROM #contact_clients con
		inner join dbo.ar_client_configuration config with (nolock) on con.client_id = config.client_id and isnull(eft_client,'N') = 'Y'
		inner join dbo.ar_eft_bank_info eft_info with (nolock) on config.fac_id = eft_info.fac_id
	end
else
	begin
		update  con set con.eft_message = coalesce(usfbc.invoice_message,cdnfbc.invoice_message,libeft.invoice_message)
		FROM #contact_clients con
		inner join #invoices inv with (nolock) on con.invoice_id = inv.invoice_id
		inner join dbo.ar_eft_client_configuration_history eftconfig with (nolock) on inv.client_id = eftconfig.client_id and eftconfig.[enabled] = 1
			and eftconfig.effective_date  <= inv.created_date and (eftconfig.ineffective_date  >= inv.created_date or eftconfig.ineffective_date is null)
		inner join dbo.ar_eft_facility_bank_configuration_history  fbc with (nolock) on inv.fac_id = fbc.fac_id
			and fbc.effective_date  <= inv.created_date and (fbc.ineffective_date  >= inv.created_date or fbc.ineffective_date is null)	 	
		inner join dbo.ar_lib_eft_bank_configuration_history libeft with (nolock) on fbc.eft_bank_configuration_id = libeft.eft_bank_configuration_id
			and libeft.effective_date  <= inv.created_date and (libeft.ineffective_date  >= inv.created_date or libeft.ineffective_date is null)	
		left join dbo.ar_eft_facility_us_bank_configuration_history usfbc with (nolock) on fbc.eft_bank_configuration_id = usfbc.eft_bank_configuration_id and inv.fac_id = usfbc.fac_id 
			and usfbc.effective_date  <= inv.created_date and (usfbc.ineffective_date  >= inv.created_date or usfbc.ineffective_date is null)	
		left join dbo.ar_eft_facility_ca_bank_configuration_history cdnfbc with (nolock) on fbc.eft_bank_configuration_id = cdnfbc.eft_bank_configuration_id and inv.fac_id = cdnfbc.fac_id 
			and cdnfbc.effective_date  <= inv.created_date and (cdnfbc.ineffective_date  >= inv.created_date or cdnfbc.ineffective_date is null)
	end	

--we need to determine if multiple invoices exist in a month, for different contacts, and update them to the contact info tied to the last created invoice

insert into #contact_union_table 
select a.contact_id, a.contact_num, a.payer_id, a.client_id, a.bill_date, a.inv_created_date, a.generated_date,
	ROW_NUMBER() OVER ( PARTITION BY a.payer_id, a.client_id, a.bill_date 
			order by  a.payer_id, a.client_id, a.bill_date desc, a.inv_created_date desc, a.generated_date desc) as rwnum

from
(select clcon.contact_id, clcon.contact_num, clcon.payer_id, clcon.client_id, clcon.bill_date, clcon.generated_date, max(inv.created_date) as inv_created_date
from #contact_clients clcon
	inner join #invoices inv with (nolock) on clcon.invoice_id	= inv.invoice_id and clcon.contact_id > -1
group by clcon.contact_id, clcon.payer_id, clcon.contact_num, clcon.client_id, clcon.bill_date, clcon.generated_date) a
inner join 	(select clcon.contact_id, clcon.contact_num, clcon.payer_id, clcon.client_id, clcon.bill_date, clcon.generated_date, max(inv.created_date) as inv_created_date
from #contact_clients clcon
	inner join #invoices inv with (nolock) on clcon.invoice_id	= inv.invoice_id and clcon.contact_id > -1
group by clcon.contact_id, clcon.contact_num, clcon.payer_id, clcon.client_id, clcon.bill_date, clcon.generated_date) b
on a.client_id = b.client_id and a.payer_id = b.payer_id and a.bill_date = b.bill_date and a.generated_date = b.generated_date and a.inv_created_date <> b.inv_created_date

delete mcon
from #contact_union_table mcon
inner join (select a.payer_id, a.client_id, a.bill_date, a.generated_date, a.inv_created_date
from #contact_union_table a
group by a.payer_id, a.client_id, a.bill_date, a.generated_date, a.inv_created_date having count(*)>1) dbl 
	on mcon.payer_id = dbl.payer_id and mcon.client_id = dbl.client_id and mcon.inv_created_date = dbl.inv_created_date and mcon.bill_date = dbl.bill_date and mcon.generated_date = dbl.generated_date
left join (select  c.payer_id, c.client_id, c.bill_date, c.generated_date, c.inv_created_date
from #contact_union_table c
group by c.payer_id, c.client_id, c.bill_date, c.generated_date, c.inv_created_date having count(*)=1) sgl on mcon.payer_id = sgl.payer_id and mcon.client_id = sgl.client_id
	and mcon.bill_date = sgl.bill_date and mcon.generated_date = sgl.generated_date
where sgl.client_id is null

if @debug_me='Y' select * from #contact_union_table order by row_num

IF (select COUNT(1) from #contact_union_table) > 0
	Begin	
		update a set a.contact_id = b.contact_id
				, a.contact_num = b.contact_num
				, a.consolidate_statement = b.consolidate_statement
				, a.non_consolidated_contact_num = b.non_consolidated_contact_num
				, a.remit_to_name = b.remit_to_name
				, a.remit_to_address1 = b.remit_to_address1
				, a.remit_to_address2 = b.remit_to_address2
				, a.remit_to_address3 = b.remit_to_address3
				, a.remit_to_city = b.remit_to_city
				, a.remit_to_county = b.remit_to_county
				, a.remit_to_prov_state = b.remit_to_prov_state
				, a.remit_to_postal_zip_code = b.remit_to_postal_zip_code
				, a.remit_to_phone = b.remit_to_phone
				, a.contact_title = b.contact_title
				, a.contact_first_name = b.contact_first_name
				, a.contact_last_name = b.contact_last_name
				, a.contact_address1 = b.contact_address1
				, a.contact_address2 = b.contact_address2
				, a.contact_address3 = b.contact_address3
				, a.contact_city = b.contact_city
				, a.contact_county = b.contact_county
				, a.contact_prov_state = b.contact_prov_state
				, a.contact_postal_zip_code = b.contact_postal_zip_code
				, a.contact_country = b.contact_country
				, a.contact_email = b.contact_email
				, a.account_number = b.account_number
				, a.summary_fac_id = b.summary_fac_id
				, a.summary_charge_center = b.summary_charge_center
		from #contact_clients a
			inner join #contact_union_table cutold on a.client_id = cutold.client_id and a.contact_num = cutold.contact_num 
				and a.bill_date = cutold.bill_date and cutold.row_num > 1
			inner join #contact_union_table cutnew on cutold.client_id = cutnew.client_id and cutold.bill_date = cutnew.bill_date
			inner join #contact_clients b on b.client_id = cutnew.client_id and b.contact_num = cutnew.contact_num 
				and b.bill_date = cutnew.bill_date and cutnew.row_num = 1

		update a set a.contact_id = b.contact_id
				, a.contact_num = b.contact_num
				, a.consolidate_statement = b.consolidate_statement
				, a.non_consolidated_contact_num = b.non_consolidated_contact_num
				, a.remit_to_name = b.remit_to_name
				, a.remit_to_address1 = b.remit_to_address1
				, a.remit_to_address2 = b.remit_to_address2
				, a.remit_to_address3 = b.remit_to_address3
				, a.remit_to_city = b.remit_to_city
				, a.remit_to_county = b.remit_to_county
				, a.remit_to_prov_state = b.remit_to_prov_state
				, a.remit_to_postal_zip_code = b.remit_to_postal_zip_code
				, a.remit_to_phone = b.remit_to_phone
				, a.contact_title = b.contact_title
				, a.contact_first_name = b.contact_first_name
				, a.contact_last_name = b.contact_last_name
				, a.contact_address1 = b.contact_address1
				, a.contact_address2 = b.contact_address2
				, a.contact_address3 = b.contact_address3
				, a.contact_city = b.contact_city
				, a.contact_county = b.contact_county
				, a.contact_prov_state = b.contact_prov_state
				, a.contact_postal_zip_code = b.contact_postal_zip_code
				, a.contact_country = b.contact_country
				, a.contact_email = b.contact_email
				, a.account_number = b.account_number
				, a.summary_fac_id = b.summary_fac_id
				, a.summary_charge_center = b.summary_charge_center
		from #contact_clients a
			inner join #contact_clients b on a.client_id = b.client_id and a.contact_num = b.contact_num and a.bill_date = b.bill_date
			--inner join dbo.ar_invoice inv with (nolock) on b.invoice_id	= inv.invoice_id
			inner join #invoices inv on b.invoice_id = inv.invoice_id
			inner join #contact_union_table ujoin on b.client_id = ujoin.client_id and b.contact_num = ujoin.contact_num 
				and b.bill_date = ujoin.bill_date and inv.created_date = ujoin.inv_created_date and ujoin.row_num = 1
		where a.invoice_id <> b.invoice_id

	end

if @vReprintFrom is not null
	begin

		declare @min_contact_num int
		if @vSortBy = 1
			select @min_contact_num = min(contact_num) from #contact_clients where sort_location like @vReprintFrom +'%'
		else
			If @vIsContact = 1
				select @min_contact_num = min(contact_num) from #contact_clients where contact_last_name like @vReprintFrom +'%'
			else
				select @min_contact_num = min(contact_num) from #contact_clients where summary_charge_client_name like @vReprintFrom +'%'

		delete from #contact_clients where contact_num < @min_contact_num
		
	end

if @vExportMode = 1 
	begin
			UPDATE dbo.ar_invoice
			SET ar_invoice.date_exported_ps = getDate()
			FROM dbo.ar_invoice
			JOIN #contact_clients ON ar_invoice.client_id = #contact_clients.client_id 
				AND ar_invoice.invoice_id = #contact_clients.invoice_id
	end

if @debug_me='Y'  select * from #contact_clients order by contact_num,non_consolidated_contact_num

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 100
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' gathering transaction detail data ' + convert(varchar(26),getdate(),109)
--*********************************************************************************************************

--update generated date on "other" statement rows for uniqueness in each bill date
update ccl set ccl.generated_date = dateadd(mm,contact_num,ccl.generated_date)
from #contact_clients ccl
inner join (select invoice_id from #contact_clients where contact_id <= -2.1  group by invoice_id having count(*) = 1) sngl on ccl.invoice_id = sngl.invoice_id
where ccl.contact_id <= -2.1  

if @vIsTrial = 0
	begin
		insert into #local_transactions
	
		select tx.invoice_id
			, ccl.contact_id
			, tx.batch_id
			, tx.entry_number
			, tx.client_id
			--, 'N' as auto_generated
			, isnull(tx.auto_generated,'N')
			, tx.transaction_id
			, tx.reversing_tx_id
			, tx.distribution_tx_id
			, 0 as applied_payment_id
			, tx.payer_id
			, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
			, tx.days_account_id
			, tx.dollars_account_id
			, tx.fac_id
			, tx.is_billed
			, tx.transaction_type
			, tx.parent_tx_type
			, tx.[description]
			, tx.alt_description
			, tx.cheque_number
			, tx.effective_date
			, tx.transaction_date
			, ccl.bill_date as bill_date
			, Null as applied_date
			, ccl.generated_date
			, tx.days_amount
			, tx.daily_rate
			, tx.monthly_rate
			, tx.amount
			, tx.care_level
			, Case when isnull(tx.revenue_code,'') = '' or tx.revenue_code = '-1' then '' else tx.revenue_code end as revenue_code
			, tx.hcpcs_code	
			, tx.item_type_id
			, tx.comment
			, tx.rate_type_id
			, tx.rugs_modifier
			, tx.medicare_day
			, tx.mppr_flag
			, tx.mark_as_billed_by
			, tx.mark_as_billed_date
			, tx.mark_as_billed_comment
			, Case when (tx.transaction_type in('r','dr','cl','cr','d') and tx.parent_tx_type = 'r'
				or ((tx.transaction_type = 'co'or tx.transaction_type = 'cw')
				and tx.auto_generated = 'y') or (tx.transaction_type = 'xr' 
				and tx.parent_tx_type = 'r')) then 1 
				when tx.transaction_type = 'c' then 3 
				else 2 end as transaction_type_group
			, 1
		from dbo.ar_transactions tx with (nolock)
			inner join (select distinct contact_id,invoice_id,bill_date,generated_date from #contact_clients) ccl on tx.invoice_id = ccl.invoice_id
			inner join dbo.ar_payers payer with (nolock) on tx.payer_id = payer.payer_id and tx.fac_id = payer.fac_id
			where tx.deleted = 'N'
			and not (tx.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
			and not (tx.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate') 
	end
else
	begin
		insert into #local_transactions --trials
		select tx.trial_invoice_id
			, ccl.contact_id
			, tx.batch_id
			, tx.entry_number
			, tx.client_id
			--, 'N' as auto_generated
			, isnull(tx.auto_generated,'N')
			, tx.transaction_id
			, tx.reversing_tx_id
			, tx.distribution_tx_id
			, 0 as applied_payment_id
			, tx.payer_id
			, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
			, tx.days_account_id
			, tx.dollars_account_id
			, tx.fac_id
			, tx.is_billed
			, tx.transaction_type
			, tx.parent_tx_type
			, tx.[description]
			, tx.alt_description
			, tx.cheque_number
			, tx.effective_date
			, tx.transaction_date
			, ccl.bill_date as bill_date
			, Null as applied_date
			, ccl.generated_date
			, tx.days_amount
			, tx.daily_rate
			, tx.monthly_rate
			, tx.amount
			, tx.care_level
			, Case when isnull(tx.revenue_code,'') = '' or tx.revenue_code = '-1' then '' else tx.revenue_code end as revenue_code
			, tx.hcpcs_code	
			, tx.item_type_id
			, tx.comment
			, tx.rate_type_id
			, tx.rugs_modifier
			, tx.medicare_day
			, tx.mppr_flag
			, tx.mark_as_billed_by
			, tx.mark_as_billed_date
			, tx.mark_as_billed_comment
			, Case when (tx.transaction_type in('r','dr','cl','cr','d') and tx.parent_tx_type = 'r'
				or ((tx.transaction_type = 'co'or tx.transaction_type = 'cw')
				and tx.auto_generated = 'y') or (tx.transaction_type = 'xr' 
				and tx.parent_tx_type = 'r')) then 1 
				when tx.transaction_type = 'c' then 3 
				else 2 end as transaction_type_group
			, 1
		from dbo.ar_transactions tx with (nolock)
			inner join (select distinct contact_id,invoice_id,bill_date,generated_date from #contact_clients) ccl on tx.trial_invoice_id = ccl.invoice_id
			inner join dbo.ar_payers payer with (nolock) on tx.payer_id = payer.payer_id and tx.fac_id = payer.fac_id
			where tx.deleted = 'N'
			and not (tx.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
			and not (tx.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate') 

		insert into #local_transactions	 --merged non-trials
		select tx.invoice_id
			, ccl.contact_id
			, tx.batch_id
			, tx.entry_number
			, tx.client_id
			--, 'N' as auto_generated
			, isnull(tx.auto_generated,'N')
			, tx.transaction_id
			, tx.reversing_tx_id
			, tx.distribution_tx_id
			, 0 as applied_payment_id
			, tx.payer_id
			, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
			, tx.days_account_id
			, tx.dollars_account_id
			, tx.fac_id
			, tx.is_billed
			, tx.transaction_type
			, tx.parent_tx_type
			, tx.[description]
			, tx.alt_description
			, tx.cheque_number
			, tx.effective_date
			, tx.transaction_date
			, ccl.bill_date as bill_date
			, Null as applied_date
			, ccl.generated_date
			, tx.days_amount
			, tx.daily_rate
			, tx.monthly_rate
			, tx.amount
			, tx.care_level
			, Case when isnull(tx.revenue_code,'') = '' or tx.revenue_code = '-1' then '' else tx.revenue_code end as revenue_code
			, tx.hcpcs_code	
			, tx.item_type_id
			, tx.comment
			, tx.rate_type_id
			, tx.rugs_modifier
			, tx.medicare_day
			, tx.mppr_flag
			, tx.mark_as_billed_by
			, tx.mark_as_billed_date
			, tx.mark_as_billed_comment
			, Case when (tx.transaction_type in('r','dr','cl','cr','d') and tx.parent_tx_type = 'r'
				or ((tx.transaction_type = 'co'or tx.transaction_type = 'cw')
				and tx.auto_generated = 'y') or (tx.transaction_type = 'xr' 
				and tx.parent_tx_type = 'r')) then 1 
				when tx.transaction_type = 'c' then 3 
				else 2 end as transaction_type_group
			, 1
		from dbo.ar_transactions tx with (nolock)
			inner join (select distinct contact_id,invoice_id,bill_date,generated_date from #contact_clients) ccl on tx.invoice_id = ccl.invoice_id
			inner join dbo.ar_payers payer with (nolock) on tx.payer_id = payer.payer_id and tx.fac_id = payer.fac_id
			where tx.deleted = 'N'
			and not (tx.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
			and not (tx.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate') 

	end

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 103
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' updating values based on transaction creation issues ' + convert(varchar(26),getdate(),109)

--update missing rate types on reversing transactions, so we can build the description later - reversing bug	
update rev set rev.rate_type_id = src.rate_type_id
from #local_transactions rev
inner join dbo.ar_transactions src with (nolock) on rev.reversing_tx_id = src.transaction_id and src.deleted='N' and rev.rate_type_id is null 

--CORE-9223 - 2 versions.  They both seem to result in the same descriptions
--update MPPR adjustment descriptions based on the parents charge code description
--update mppr set mppr.description = cc.description + ' Adjustment' 
--from #local_transactions mppr
--inner join dbo.ar_mppr_bumpup bmp with (nolock) on mppr.distribution_tx_id = bmp.bumpup_transaction_id 
--inner join dbo.ar_transactions src with (nolock) on mppr.distribution_tx_id = src.transaction_id and src.deleted='N' and mppr.description = 'MPPR Adjustment' 
--inner join dbo.ar_lib_charge_codes cc with (nolock) on src.item_type_id = cc.charge_code_id

--update MPPR adjustment descriptions based on the ancillary transaction description
--update mppr set mppr.description = prnt.description + ' Adjustment' 
--from #local_transactions mppr
--inner join dbo.ar_mppr_bumpup bmp with (nolock) on mppr.distribution_tx_id = bmp.bumpup_transaction_id 
--inner join dbo.ar_transactions src with (nolock) on bmp.reduction_transaction_id = src.transaction_id and src.deleted='N' and mppr.description = 'MPPR Adjustment' 
--inner join dbo.ar_transactions prnt with (nolock) on src.distribution_tx_id = prnt.transaction_id and src.deleted='N' 

update childcash set childcash.comment = parentcash.comment, childcash.cheque_number = parentcash.cheque_number 
	--,childcash.skip_bit = (case when lclpc.transaction_id is not null then 2 else 1 end)
from #local_transactions childcash
inner join dbo.ar_transactions parentcash with (nolock) on childcash.distribution_tx_id = parentcash.transaction_id
	and childcash.distribution_tx_id <> childcash.transaction_id and parentcash.distribution_tx_id = parentcash.transaction_id
	and childcash.transaction_type = 'C' and parentcash.transaction_type = 'C'

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

if @vSummarizeReversals = 1
	begin

		Select @vStep = 105;
		set @vgsStepStartTime = GETDATE()
		if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Summarizing Reversals ' + convert(varchar(26),getdate(),109);

		if @vPrivateStatementsIncluded =1
			begin
				insert into #local_transactions
	
				select tx.invoice_id
					, tx.contact_id
					, tx.batch_id
					, tx.entry_number
					, tx.client_id
					, tx.auto_generated
					, tx.transaction_id
					, tx.reversing_tx_id
					, tx.distribution_tx_id
					, tx.applied_payment_id
					, tx.payer_id
					, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
					, tx.days_account_id
					, tx.dollars_account_id
					, tx.fac_id
					, tx.is_billed
					, tx.transaction_type
					, tx.parent_tx_type
					, tx.[description]
					, tx.alt_description
					, tx.cheque_number
					, tx.effective_date
					, tx.transaction_date
					, tx.bill_date
					, tx.applied_date
					, tx.generated_date
					, tx.days_amount
					, tx.daily_rate
					, tx.monthly_rate
					, tx.amount + isnull(revtx.amount,0)
					, tx.care_level
					, tx.revenue_code
					, tx.hcpcs_code	
					, tx.item_type_id
					, tx.comment
					, tx.rate_type_id
					, tx.rugs_modifier
					, tx.medicare_day
					, tx.mppr_flag
					, tx.mark_as_billed_by
					, tx.mark_as_billed_date
					, tx.mark_as_billed_comment
					, tx.transaction_type_group
					, 2 as skip_bit
				from #local_transactions tx with (nolock)
				left join #local_transactions revtx with (nolock) on tx.reversing_tx_id = revtx.transaction_id and tx.bill_date = revtx.bill_date and 
					tx.generated_date = revtx.generated_date
				WHERE tx.contact_id > -2.1 and 
					((((tx.amount + isnull(revtx.amount,0)) <> 0 and revtx.reversing_tx_id is not null) or revtx.reversing_tx_id is null))

				delete from #local_transactions where skip_bit = 1 and contact_id >-2.1  
				update #local_transactions set skip_bit = 1 where skip_bit = 2 and contact_id >-2.1  
			end

	if @vOtherStatementsIncluded = 1
		begin
			insert into #local_transactions
	
				select tx.invoice_id
					, tx.contact_id
					, tx.batch_id
					, tx.entry_number
					, tx.client_id
					, tx.auto_generated
					, tx.transaction_id
					, tx.reversing_tx_id
					, tx.distribution_tx_id
					, tx.applied_payment_id
					, tx.payer_id
					, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
					, tx.days_account_id
					, tx.dollars_account_id
					, tx.fac_id
					, tx.is_billed
					, tx.transaction_type
					, tx.parent_tx_type
					, tx.[description]
					, tx.alt_description
					, tx.cheque_number
					, tx.effective_date
					, tx.transaction_date
					, tx.bill_date
					, tx.applied_date
					, tx.generated_date
					, tx.days_amount
					, tx.daily_rate
					, tx.monthly_rate
					, tx.amount + isnull(revtx.amount,0)
					, tx.care_level
					, tx.revenue_code
					, tx.hcpcs_code	
					, tx.item_type_id
					, tx.comment
					, tx.rate_type_id
					, tx.rugs_modifier
					, tx.medicare_day
					, tx.mppr_flag
					, tx.mark_as_billed_by
					, tx.mark_as_billed_date
					, tx.mark_as_billed_comment
					, tx.transaction_type_group
					, 2 as skip_bit
				from #local_transactions tx with (nolock)
				left join #local_transactions revtx with (nolock) on tx.reversing_tx_id = revtx.transaction_id and tx.bill_date = revtx.bill_date and 
					tx.generated_date = revtx.generated_date and tx.invoice_id = revtx.invoice_id
				WHERE tx.contact_id <= -2.1 and 
					((((tx.amount + isnull(revtx.amount,0)) <> 0 and revtx.reversing_tx_id is not null) or revtx.reversing_tx_id is null))

				delete from #local_transactions where skip_bit = 1 and contact_id <=-2.1  
				update #local_transactions set skip_bit = 1 where skip_bit = 2 and contact_id <=-2.1  
			end
		
		set @vgsStepEndTime=GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms' 
	end

if @vPrivateStatementsIncluded = 1
	begin
		if @vCombineChildren > 0
			begin

				Select @vStep = 110;
				set @vgsStepStartTime = GETDATE()
				if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Combining Private Child Transactions ' + convert(varchar(26),getdate(),109);

			if @vCombineChildren = 1
				begin

					insert into #child_transactions
					select 	  ctx.distribution_tx_id
							--, ctx.transaction_type
							, '' AS transaction_type
							, ctx.parent_tx_type
							, ctx.contact_id 
							, 0 as invoice_id
							, ctx.payer_id
							, sum(ctx.days_amount)
							, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
							, sum(ctx.monthly_rate)
							, sum(ctx.amount)
							, ctx.bill_date
							,ctx.generated_date
							, 0
					from #local_transactions ctx
					inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and anctx.payer_id = ctx.payer_id and ctx.contact_id = anctx.contact_id
					where  ctx.contact_id > -2.1 and anctx.contact_id > -2.1 and ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type
						and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900') and isnull(ctx.generated_date,'1/1/1900') = isnull(anctx.generated_date,'1/1/1900')
					group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.generated_date
					order by 1

					insert into #local_transactions
	
					select tx.invoice_id
						, tx.contact_id
						, tx.batch_id
						, tx.entry_number
						, tx.client_id
						, tx.auto_generated
						, tx.transaction_id
						, tx.reversing_tx_id
						, tx.distribution_tx_id
						, tx.applied_payment_id
						, tx.payer_id
						, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
						, tx.days_account_id
						, tx.dollars_account_id
						, tx.fac_id
						, tx.is_billed
						, tx.transaction_type
						, tx.parent_tx_type
						, tx.[description]
						, tx.alt_description
						, tx.cheque_number
						, tx.effective_date
						, tx.transaction_date
						, tx.bill_date
						, tx.applied_date
						, tx.generated_date
						, tx.days_amount
						, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
						, Null as monthly_rate
						, tx.amount + isnull(txca.amount,0) as amount
						, tx.care_level				
						, tx.revenue_code
						, tx.hcpcs_code	
						, tx.item_type_id
						, tx.comment
						, tx.rate_type_id
						, tx.rugs_modifier
						, tx.medicare_day
						, tx.mppr_flag
						, tx.mark_as_billed_by
						, tx.mark_as_billed_date
						, tx.mark_as_billed_comment
						, tx.transaction_type_group
						, 0
					from #local_transactions tx with (nolock)
					inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') 
						and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900') and tx.contact_id = txca.contact_id
						and tx.payer_id = txca.payer_id and tx.contact_id > -2.1

					delete tx 
					from #local_transactions tx
					inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id and tx.payer_id = parent.payer_id and tx.contact_id = parent.contact_id	
					inner join #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
						and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900')  and tx.contact_id = txca.contact_id
					where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.contact_id > -2.1 and parent.contact_id > -2.1

					delete tx 
					from #local_transactions tx
					inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id = parent.contact_id	
					where tx.skip_bit = 1 and parent.skip_bit = 0 and tx.contact_id > -2.1 and parent.contact_id > -2.1

		--********************************************************** children on different payer than parent
					delete from #child_transactions

					insert into #child_transactions
					select 	  ctx.distribution_tx_id
							--, ctx.transaction_type
							, '' AS transaction_type
							, ctx.parent_tx_type
							, ctx.contact_id 
							, 0 as invoice_id
							, ctx.payer_id
							, sum(ctx.days_amount)
							, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
							, sum(ctx.monthly_rate)
							, sum(ctx.amount)
							, ctx.bill_date
							,ctx.generated_date
							, 0
					from #local_transactions ctx
					inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and anctx.payer_id <> ctx.payer_id and ctx.contact_id = anctx.contact_id 
					where   ctx.contact_id > -2.1 and anctx.contact_id > -2.1 and ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type
					group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.generated_date
					order by 1

					insert into #local_transactions
	
					select tx.invoice_id
						, tx.contact_id
						, tx.batch_id
						, tx.entry_number
						, tx.client_id
						, tx.auto_generated
						, tx.transaction_id
						, tx.reversing_tx_id
						, tx.distribution_tx_id
						, tx.applied_payment_id
						, txca.payer_id
						, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
						, tx.days_account_id
						, tx.dollars_account_id
						, tx.fac_id
						, tx.is_billed
						, tx.transaction_type
						, tx.parent_tx_type
						, tx.[description]
						, tx.alt_description
						, tx.cheque_number
						, tx.effective_date
						, tx.transaction_date
						, txca.bill_date
						, tx.applied_date
						, tx.generated_date
						, tx.days_amount
						, isnull(txca.daily_rate,0) as daily_rate
						, Null as monthly_rate
						, isnull(txca.amount,0) as amount
						, tx.care_level				
						, tx.revenue_code
						, tx.hcpcs_code	
						, tx.item_type_id
						, tx.comment
						, tx.rate_type_id
						, tx.rugs_modifier
						, tx.medicare_day
						, tx.mppr_flag
						, tx.mark_as_billed_by
						, tx.mark_as_billed_date
						, tx.mark_as_billed_comment
						, tx.transaction_type_group
						, 0
					from #local_transactions tx with (nolock)
					inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id --and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
						and tx.payer_id <> txca.payer_id and tx.contact_id > -2.1 and tx.contact_id = txca.contact_id

					delete tx 
					from #local_transactions tx
					inner join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id--and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
					where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.contact_id > -2.1

		--********************************************************** 
				end

				if @vCombineChildren = 2
				begin
					insert into #child_transactions
					select 	  ctx.distribution_tx_id
							, '' AS transaction_type
							, ctx.parent_tx_type
							, ctx.contact_id 
							, 0 as invoice_id
							, ctx.payer_id
							, sum(ctx.days_amount)
							, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
							, sum(ctx.monthly_rate)
							, sum(ctx.amount)
							, ctx.bill_date
							, ctx.generated_date
							, 0
					from #local_transactions ctx
					inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and ctx.payer_id = anctx.payer_id and ctx.contact_id = anctx.contact_id
					where  ctx.contact_id > -2.1 and anctx.contact_id > -2.1 and ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type and ctx.transaction_type in('CR', 'CA')
						and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900') and isnull(ctx.generated_date,'1/1/1900') = isnull(anctx.generated_date,'1/1/1900')
					group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.generated_date
					order by 1

					insert into #local_transactions
	
					select tx.invoice_id
						, tx.contact_id
						, tx.batch_id
						, tx.entry_number
						, tx.client_id
						, tx.auto_generated
						, tx.transaction_id
						, tx.reversing_tx_id
						, tx.distribution_tx_id
						, tx.applied_payment_id
						, tx.payer_id
						, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
						, tx.days_account_id
						, tx.dollars_account_id
						, tx.fac_id
						, tx.is_billed
						, tx.transaction_type
						, tx.parent_tx_type
						, tx.[description]
						, tx.alt_description
						, tx.cheque_number
						, tx.effective_date
						, tx.transaction_date
						, tx.bill_date
						, tx.applied_date
						, tx.generated_date
						, tx.days_amount
						, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
						, Null as monthly_rate
						, tx.amount + isnull(txca.amount,0) as amount
						, tx.care_level				
						, tx.revenue_code
						, tx.hcpcs_code	
						, tx.item_type_id
						, tx.comment
						, tx.rate_type_id
						, tx.rugs_modifier
						, tx.medicare_day
						, tx.mppr_flag
						, tx.mark_as_billed_by
						, tx.mark_as_billed_date
						, tx.mark_as_billed_comment
						, tx.transaction_type_group
						, 0
					from #local_transactions tx with (nolock)
					inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
						and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900')
						and tx.payer_id = txca.payer_id and tx.contact_id > -2.1 and tx.contact_id = txca.contact_id

					delete tx 
					from #local_transactions tx
					inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id and tx.payer_id = parent.payer_id and tx.contact_id = parent.contact_id		
					inner join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
						and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900') and tx.contact_id = txca.contact_id
					where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.transaction_type in('CR', 'CA') and tx.contact_id > -2.1

					delete tx 
					from #local_transactions tx
					inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id = parent.contact_id	
					where tx.skip_bit = 1 and parent.skip_bit = 0 and tx.contact_id > -2.1 and parent.contact_id > -2.1

				end

				set @vgsStepEndTime=GETDATE()
				if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
			end
		end

if @vOtherStatementsIncluded = 1
	begin
		if @vCombineChildren > 0
			begin

				Select @vStep = 112;
				set @vgsStepStartTime = GETDATE()
				if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Combining Other Child Transactions ' + convert(varchar(26),getdate(),109);

			if @vCombineChildren = 1
				begin

					insert into #child_transactions
					select 	  ctx.distribution_tx_id
							--, ctx.transaction_type
							, '' AS transaction_type
							, ctx.parent_tx_type
							, ctx.contact_id 
							, ctx.invoice_id
							, ctx.payer_id
							, sum(ctx.days_amount)
							, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
							, sum(ctx.monthly_rate)
							, sum(ctx.amount)
							, ctx.bill_date
							, ctx.generated_date
							, 0
					from #local_transactions ctx
					inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and anctx.payer_id = ctx.payer_id and ctx.contact_id = anctx.contact_id
					where  ctx.contact_id <= -2.1 and anctx.contact_id <= -2.1 and ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type
						and ctx.invoice_id = anctx.invoice_id
					group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.invoice_id, ctx.generated_date
					order by 1

					insert into #local_transactions
	
					select tx.invoice_id
						, tx.contact_id
						, tx.batch_id
						, tx.entry_number
						, tx.client_id
						, tx.auto_generated
						, tx.transaction_id
						, tx.reversing_tx_id
						, tx.distribution_tx_id
						, tx.applied_payment_id
						, tx.payer_id
						, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
						, tx.days_account_id
						, tx.dollars_account_id
						, tx.fac_id
						, tx.is_billed
						, tx.transaction_type
						, tx.parent_tx_type
						, tx.[description]
						, tx.alt_description
						, tx.cheque_number
						, tx.effective_date
						, tx.transaction_date
						, tx.bill_date
						, tx.applied_date
						, tx.generated_date
						, tx.days_amount
						, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
						, Null as monthly_rate
						, tx.amount + isnull(txca.amount,0) as amount
						, tx.care_level				
						, tx.revenue_code
						, tx.hcpcs_code	
						, tx.item_type_id
						, tx.comment
						, tx.rate_type_id
						, tx.rugs_modifier
						, tx.medicare_day
						, tx.mppr_flag
						, tx.mark_as_billed_by
						, tx.mark_as_billed_date
						, tx.mark_as_billed_comment
						, tx.transaction_type_group
						, 0
					from #local_transactions tx with (nolock)
					inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') 
						and tx.invoice_id = txca.invoice_id and tx.payer_id = txca.payer_id and tx.contact_id <= -2.1 and tx.contact_id = txca.contact_id

					delete tx 
					from #local_transactions tx
					inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id and tx.payer_id = parent.payer_id and tx.contact_id = parent.contact_id		
					inner join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
						and tx.invoice_id = txca.invoice_id  and tx.contact_id = txca.contact_id
					where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.contact_id <= -2.1 and parent.contact_id <= -2.1

					delete tx 
					from #local_transactions tx
					inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id = parent.contact_id	
					where tx.skip_bit = 1 and parent.skip_bit = 0 and tx.contact_id <= -2.1 and parent.contact_id <= -2.1

				end

				if @vCombineChildren = 2
				begin
					insert into #child_transactions
					select 	  ctx.distribution_tx_id
							, '' AS transaction_type
							, ctx.parent_tx_type
							, ctx.contact_id 
							, ctx.invoice_id
							, ctx.payer_id
							, sum(ctx.days_amount)
							, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
							, sum(ctx.monthly_rate)
							, sum(ctx.amount)
							, ctx.bill_date
							, ctx.generated_date
							, 0
					from #local_transactions ctx
					inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and ctx.payer_id = anctx.payer_id and ctx.contact_id = anctx.contact_id
					where  ctx.contact_id <= -2.1 and anctx.contact_id <= -2.1 and ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type and ctx.transaction_type in('CR', 'CA')
						and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900') and ctx.invoice_id = anctx.invoice_id
					group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.invoice_id, ctx.generated_date
					order by 1

					insert into #local_transactions
	
					select tx.invoice_id
						, tx.contact_id
						, tx.batch_id
						, tx.entry_number
						, tx.client_id
						, tx.auto_generated
						, tx.transaction_id
						, tx.reversing_tx_id
						, tx.distribution_tx_id
						, tx.applied_payment_id
						, tx.payer_id
						, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
						, tx.days_account_id
						, tx.dollars_account_id
						, tx.fac_id
						, tx.is_billed
						, tx.transaction_type
						, tx.parent_tx_type
						, tx.[description]
						, tx.alt_description
						, tx.cheque_number
						, tx.effective_date
						, tx.transaction_date
						, tx.bill_date
						, tx.applied_date
						, tx.generated_date
						, tx.days_amount
						, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
						, Null as monthly_rate
						, tx.amount + isnull(txca.amount,0) as amount
						, tx.care_level				
						, tx.revenue_code
						, tx.hcpcs_code	
						, tx.item_type_id
						, tx.comment
						, tx.rate_type_id
						, tx.rugs_modifier
						, tx.medicare_day
						, tx.mppr_flag
						, tx.mark_as_billed_by
						, tx.mark_as_billed_date
						, tx.mark_as_billed_comment
						, tx.transaction_type_group
						, 0
					from #local_transactions tx with (nolock)
					inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
						and tx.invoice_id = txca.invoice_id	and tx.payer_id = txca.payer_id and tx.contact_id <= -2.1 and tx.contact_id = txca.contact_id

					delete tx 
					from #local_transactions tx
					inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id and tx.payer_id = parent.payer_id and tx.contact_id = parent.contact_id		
					inner join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
						and tx.invoice_id = txca.invoice_id and tx.contact_id = txca.contact_id
					where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.transaction_type in('CR', 'CA') and tx.contact_id <= -2.1 and parent.contact_id <= -2.1

					delete tx 
					from #local_transactions tx
					inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id = parent.contact_id		
					where tx.skip_bit = 1 and parent.skip_bit = 0 and tx.contact_id <= -2.1 and parent.contact_id <= -2.1

				end

				set @vgsStepEndTime=GETDATE()
				if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
			end
		end

--for ancillary charges that we are grouping, and the parent transaction doesn't exist, we want to ensure the group correctly
if @vShowResults = 'A' or @vShowResults = 'C' or @vShowResults = 'CC' or @vShowResults = 'R'
	begin

		Select @vStep = 115;
		set @vgsStepStartTime = GETDATE()
		if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' @vShowResults in(A,C,CC,R) - Combining Ancillary Child Transactions to parent not in the dataset ' + convert(varchar(26),getdate(),109);

		if @vPrivateStatementsIncluded = 1
		begin
			-- insert empty parent anicillary charge to roll children into - need this because the parent contains the charge code info
			insert into #local_transactions
	
			select distinct lcltx.invoice_id
				, lcltx.contact_id
				, tx.batch_id
				, tx.entry_number
				, tx.client_id
				--, 'N' as auto_generated
				, isnull(tx.auto_generated,'N')
				, tx.transaction_id
				, tx.reversing_tx_id
				, tx.distribution_tx_id
				, 0 as applied_payment_id
				, lcltx.payer_id
				, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id		
				, lcltx.days_account_id
				, lcltx.dollars_account_id
				, tx.fac_id
				, tx.is_billed
				, tx.transaction_type
				, tx.parent_tx_type
				, tx.[description]
				, tx.alt_description
				, tx.cheque_number
				, tx.effective_date
				, tx.transaction_date
				, lcltx.bill_date
				, Null as applied_date
				, lcltx.generated_date
				, tx.days_amount
				, 0 as daily_rate
				, Null as monthly_rate
				, 0 as amount
				, tx.care_level
				, tx.revenue_code
				, tx.hcpcs_code		
				, tx.item_type_id
				, tx.comment
				, tx.rate_type_id
				, tx.rugs_modifier
				, tx.medicare_day
				, tx.mppr_flag
				, tx.mark_as_billed_by
				, tx.mark_as_billed_date
				, tx.mark_as_billed_comment
				, Case when (tx.transaction_type in('r','dr','cl','cr','d')
					or ((tx.transaction_type = 'co'or tx.transaction_type = 'cw')
					and tx.auto_generated = 'y') or (tx.transaction_type = 'xr' 
					and tx.parent_tx_type = 'r')) then 1 
					when tx.transaction_type = 'c' then 3 
					else 2 end as transaction_type_group
				, 5
			from #local_transactions lcltx with (nolock)
			left join #local_transactions ntx on lcltx.distribution_tx_id = ntx.transaction_id and lcltx.parent_tx_type = 'A' and ntx.contact_id >-2.1
				and ntx.distribution_tx_id = ntx.transaction_id and lcltx.contact_id = ntx.contact_id 
			inner join dbo.ar_transactions tx with (nolock) on lcltx.distribution_tx_id = tx.transaction_id and lcltx.parent_tx_type = 'A'  
			where lcltx.contact_id >-2.1 and lcltx.parent_tx_type = 'A' and ntx.transaction_id is null and lcltx.payer_id = tx.payer_id

			delete from #child_transactions

			insert into #child_transactions
			select 	  ctx.distribution_tx_id
					--, ctx.transaction_type
					, '' AS transaction_type
					, ctx.parent_tx_type
					, ctx.contact_id 
					, 0 as invoice_id
					, ctx.payer_id
					, sum(ctx.days_amount)
					, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
					, sum(ctx.monthly_rate)
					, sum(ctx.amount)
					, ctx.bill_date
					, ctx.generated_date
					, 0
			from #local_transactions ctx
			inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and ctx.payer_id = anctx.payer_id and anctx.transaction_type = 'A' and anctx.skip_bit = 5
				and ctx.contact_id = anctx.contact_id 
			where  ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type
				and ctx.contact_id >-2.1 and anctx.contact_id >-2.1 
				and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900') and isnull(ctx.generated_date,'1/1/1900') = isnull(anctx.generated_date,'1/1/1900')
			group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.generated_date
			order by 1

			insert into #local_transactions
			select tx.invoice_id
				, tx.contact_id
				, tx.batch_id
				, tx.entry_number
				, tx.client_id
				, tx.auto_generated
				, tx.transaction_id
				, tx.reversing_tx_id
				, tx.distribution_tx_id
				, tx.applied_payment_id
				, tx.payer_id
				, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
				, tx.days_account_id
				, tx.dollars_account_id
				, tx.fac_id
				, tx.is_billed
				, tx.transaction_type
				, tx.parent_tx_type
				, tx.[description]
				, tx.alt_description
				, tx.cheque_number
				, tx.effective_date
				, tx.transaction_date
				, tx.bill_date
				, tx.applied_date
				, tx.generated_date
				, tx.days_amount
				--, tx.days_amount + isnull(txca.days_amount,0) as days_amount
				, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
				, Null as monthly_rate
				, tx.amount + isnull(txca.amount,0) as amount
				, tx.care_level
				, tx.revenue_code
				, tx.hcpcs_code		
				, tx.item_type_id
				, tx.comment
				, tx.rate_type_id
				, tx.rugs_modifier
				, tx.medicare_day
				, tx.mppr_flag
				, tx.mark_as_billed_by
				, tx.mark_as_billed_date
				, tx.mark_as_billed_comment
				, tx.transaction_type_group
				, 0
			from #local_transactions tx with (nolock)
			inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and tx.contact_id = txca.contact_id
				and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900')
			where tx.skip_bit = 5 and tx.contact_id >-2.1 

			--********************************************************** children on different payer than parent
	-- insert empty parent anicillary charge to roll children into - need this because the parent contains the charge code info
			insert into #local_transactions
	
			select distinct lcltx.invoice_id
				, lcltx.contact_id
				, tx.batch_id
				, tx.entry_number
				, tx.client_id
				--, 'N' as auto_generated
				, isnull(tx.auto_generated,'N')
				, tx.transaction_id
				, tx.reversing_tx_id
				, tx.distribution_tx_id
				, 0 as applied_payment_id
				, lcltx.payer_id
				, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
				, lcltx.days_account_id
				, lcltx.dollars_account_id
				, tx.fac_id
				, tx.is_billed
				, tx.transaction_type
				, tx.parent_tx_type
				, tx.[description]
				, tx.alt_description
				, tx.cheque_number
				, tx.effective_date
				, tx.transaction_date
				, lcltx.bill_date
				, Null as applied_date
				, lcltx.generated_date
				, tx.days_amount
				, 0 as daily_rate
				, Null as monthly_rate
				, 0 as amount
				, tx.care_level
				, tx.revenue_code
				, tx.hcpcs_code		
				, tx.item_type_id
				, tx.comment
				, tx.rate_type_id
				, tx.rugs_modifier
				, tx.medicare_day
				, tx.mppr_flag
				, tx.mark_as_billed_by
				, tx.mark_as_billed_date
				, tx.mark_as_billed_comment
				, Case when (tx.transaction_type in('r','dr','cl','cr','d')
					or ((tx.transaction_type = 'co'or tx.transaction_type = 'cw')
					and tx.auto_generated = 'y') or (tx.transaction_type = 'xr' 
					and tx.parent_tx_type = 'r')) then 1 
					when tx.transaction_type = 'c' then 3 
					else 2 end as transaction_type_group
				, 5
			from #local_transactions lcltx with (nolock)
			left join #local_transactions ntx on lcltx.distribution_tx_id = ntx.transaction_id and lcltx.parent_tx_type = 'A' and ntx.contact_id >-2.1 
				and ntx.distribution_tx_id = ntx.transaction_id and lcltx.payer_id <> ntx.payer_id and lcltx.contact_id = ntx.contact_id
			inner join dbo.ar_transactions tx with (nolock) on lcltx.distribution_tx_id = tx.transaction_id and lcltx.parent_tx_type = 'A'  
			where lcltx.parent_tx_type = 'A' and ntx.transaction_id is null and lcltx.payer_id <> tx.payer_id and lcltx.contact_id >-2.1  

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id 	and tx.contact_id = parent.contact_id
			left join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and tx.contact_id = txca.contact_id
			where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.contact_id >-2.1  and parent.contact_id >-2.1 
			and txca.distribution_tx_id is not null and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900')
			and tx.contact_id >-2.1  and parent.contact_id >-2.1 

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id = parent.contact_id
			where tx.skip_bit = 1 and parent.skip_bit = 0 and isnull(tx.bill_date,'1/1/1900') = isnull(parent.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(parent.generated_date,'1/1/1900')
				and tx.contact_id >-2.1  and parent.contact_id >-2.1 

			delete from #child_transactions

			insert into #child_transactions
			select 	  ctx.distribution_tx_id
					--, ctx.transaction_type
					, '' AS transaction_type
					, ctx.parent_tx_type
					, ctx.contact_id 
					, 0 as invoice_id
					, ctx.payer_id
					, sum(ctx.days_amount)
					, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
					, sum(ctx.monthly_rate)
					, sum(ctx.amount)
					, ctx.bill_date
					, ctx.generated_date
					, 0
			from #local_transactions ctx
			inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and ctx.contact_id = anctx.contact_id
				and anctx.transaction_type = 'A' and anctx.skip_bit = 5
			where  ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type and ctx.contact_id >-2.1  and anctx.contact_id >-2.1 
				--and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900')
			group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.generated_date
			order by 1 

			insert into #local_transactions
	
			select tx.invoice_id
				, tx.contact_id
				, tx.batch_id
				, tx.entry_number
				, tx.client_id
				, tx.auto_generated
				, tx.transaction_id
				, tx.reversing_tx_id
				, tx.distribution_tx_id
				, tx.applied_payment_id
				, txca.payer_id
				, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
				, tx.days_account_id
				, tx.dollars_account_id
				, tx.fac_id
				, tx.is_billed
				--, tx.transaction_type
				, 'A' as transaction_type
				, tx.parent_tx_type
				, tx.[description]
				, tx.alt_description
				, tx.cheque_number
				, tx.effective_date
				, tx.transaction_date
				, txca.bill_date
				, tx.applied_date
				, tx.generated_date
				, tx.days_amount
				, isnull(txca.daily_rate,0) as daily_rate
				, Null as monthly_rate
				, isnull(txca.amount,0) as amount
				, tx.care_level				
				, tx.revenue_code
				, tx.hcpcs_code	
				, tx.item_type_id
				, tx.comment
				, tx.rate_type_id
				, tx.rugs_modifier
				, tx.medicare_day
				, tx.mppr_flag
				, tx.mark_as_billed_by
				, tx.mark_as_billed_date
				, tx.mark_as_billed_comment
				, tx.transaction_type_group
				, 0
			from #local_transactions tx with (nolock)
			inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id  and tx.contact_id = txca.contact_id--and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
				--and tx.payer_id <> txca.payer_id
			where tx.skip_bit = 5

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id and tx.contact_id = parent.contact_id
			left join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and tx.contact_id = txca.contact_id 
			where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.contact_id >-2.1  and parent.contact_id >-2.1 
			and txca.distribution_tx_id is not null and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900')

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id = parent.contact_id
			where tx.skip_bit = 1 and parent.skip_bit = 0 and isnull(tx.bill_date,'1/1/1900') = isnull(parent.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(parent.generated_date,'1/1/1900')
			and tx.contact_id >-2.1  and parent.contact_id >-2.1 
	
			delete from #local_transactions where skip_bit=5	
		end

		if @vOtherStatementsIncluded = 1
		begin
			-- insert empty parent anicillary charge to roll children into - need this because the parent contains the charge code info
			insert into #local_transactions
	
			select distinct lcltx.invoice_id
				, lcltx.contact_id
				, tx.batch_id
				, tx.entry_number
				, tx.client_id
				--, 'N' as auto_generated
				, isnull(tx.auto_generated,'N')
				, tx.transaction_id
				, tx.reversing_tx_id
				, tx.distribution_tx_id
				, 0 as applied_payment_id
				, lcltx.payer_id
				, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
				, lcltx.days_account_id
				, lcltx.dollars_account_id
				, tx.fac_id
				, tx.is_billed
				, tx.transaction_type
				, tx.parent_tx_type
				, tx.[description]
				, tx.alt_description
				, tx.cheque_number
				, tx.effective_date
				, tx.transaction_date
				, lcltx.bill_date
				, Null as applied_date
				, lcltx.generated_date
				, tx.days_amount
				, 0 as daily_rate
				, Null as monthly_rate
				, 0 as amount
				, tx.care_level
				, tx.revenue_code
				, tx.hcpcs_code		
				, tx.item_type_id
				, tx.comment
				, tx.rate_type_id
				, tx.rugs_modifier
				, tx.medicare_day
				, tx.mppr_flag
				, tx.mark_as_billed_by
				, tx.mark_as_billed_date
				, tx.mark_as_billed_comment
				, Case when (tx.transaction_type in('r','dr','cl','cr','d')
					or ((tx.transaction_type = 'co'or tx.transaction_type = 'cw')
					and tx.auto_generated = 'y') or (tx.transaction_type = 'xr' 
					and tx.parent_tx_type = 'r')) then 1 
					when tx.transaction_type = 'c' then 3 
					else 2 end as transaction_type_group
				, 5
			from #local_transactions lcltx with (nolock)
			left join #local_transactions ntx on lcltx.distribution_tx_id = ntx.transaction_id and lcltx.parent_tx_type = 'A' and ntx.contact_id <= -2.1
				and ntx.distribution_tx_id = ntx.transaction_id and lcltx.contact_id = ntx.contact_id and lcltx.invoice_id = ntx.invoice_id 
			inner join dbo.ar_transactions tx with (nolock) on lcltx.distribution_tx_id = tx.transaction_id and lcltx.parent_tx_type = 'A'  
			where lcltx.contact_id <= -2.1 and lcltx.parent_tx_type = 'A' and ntx.transaction_id is null and lcltx.payer_id = tx.payer_id

			delete from #child_transactions

			insert into #child_transactions
			select 	  ctx.distribution_tx_id
					--, ctx.transaction_type
					, '' AS transaction_type
					, ctx.parent_tx_type
					, ctx.contact_id 
					, ctx.invoice_id
					, ctx.payer_id
					, sum(ctx.days_amount)
					, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
					, sum(ctx.monthly_rate)
					, sum(ctx.amount)
					, ctx.bill_date
					, ctx.generated_date
					, 0
			from #local_transactions ctx
			inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and ctx.payer_id = anctx.payer_id and anctx.transaction_type = 'A' and anctx.skip_bit = 5
				and ctx.contact_id = anctx.contact_id and ctx.invoice_id = anctx.invoice_id
			where  ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type
				and ctx.contact_id <= -2.1 and anctx.contact_id <= -2.1 
				and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900') 
			group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.invoice_id, ctx.generated_date
			order by 1

			insert into #local_transactions
			select tx.invoice_id
				, tx.contact_id
				, tx.batch_id
				, tx.entry_number
				, tx.client_id
				, tx.auto_generated
				, tx.transaction_id
				, tx.reversing_tx_id
				, tx.distribution_tx_id
				, tx.applied_payment_id
				, tx.payer_id
				, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
				, tx.days_account_id
				, tx.dollars_account_id
				, tx.fac_id
				, tx.is_billed
				, tx.transaction_type
				, tx.parent_tx_type
				, tx.[description]
				, tx.alt_description
				, tx.cheque_number
				, tx.effective_date
				, tx.transaction_date
				, tx.bill_date
				, tx.applied_date
				, tx.generated_date
				, tx.days_amount
				--, tx.days_amount + isnull(txca.days_amount,0) as days_amount
				, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
				, Null as monthly_rate
				, tx.amount + isnull(txca.amount,0) as amount
				, tx.care_level
				, tx.revenue_code
				, tx.hcpcs_code		
				, tx.item_type_id
				, tx.comment
				, tx.rate_type_id
				, tx.rugs_modifier
				, tx.medicare_day
				, tx.mppr_flag
				, tx.mark_as_billed_by
				, tx.mark_as_billed_date
				, tx.mark_as_billed_comment
				, tx.transaction_type_group
				, 0
			from #local_transactions tx with (nolock)
			inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id
				and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') and tx.invoice_id = txca.invoice_id and tx.contact_id = txca.contact_id 
			where tx.skip_bit = 5 and tx.contact_id <= -2.1 

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id and tx.contact_id = parent.contact_id and tx.invoice_id = parent.invoice_id
			left join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and tx.invoice_id = txca.invoice_id and tx.contact_id = txca.contact_id
			where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.contact_id <= 2  and parent.contact_id <= -2.1 
			and txca.distribution_tx_id is not null and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id = parent.contact_id
				and tx.invoice_id = parent.invoice_id
			where tx.skip_bit = 1 and parent.skip_bit = 0 and isnull(tx.bill_date,'1/1/1900') = isnull(parent.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(parent.generated_date,'1/1/1900')
			and tx.contact_id <= -2.1  and parent.contact_id <= -2.1 
	
			delete from #local_transactions where skip_bit=5	
		end

--********************************************************** 

		set @vgsStepEndTime=GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

		if @vCombineChildren = 0 --need to summarize ancillaries that have a parent and combine children was not selected
			begin
				if @vPrivateStatementsIncluded = 1
					begin
							Select @vStep = 120;
							set @vgsStepStartTime = GETDATE()
							if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' @vShowResults in(A,C,CC,R) - Combining Children not selected - Combine Ancillary Child Transactions to parent ' + convert(varchar(26),getdate(),109);

							delete from #child_transactions --eliminate the missing parent ones

							insert into #child_transactions
							select 	  ctx.distribution_tx_id
									--, ctx.transaction_type
									, '' AS transaction_type
									, ctx.parent_tx_type
									, ctx.contact_id 
									, 0 as invoice_id
									, ctx.payer_id
									, sum(ctx.days_amount)
									, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
									, sum(ctx.monthly_rate)
									, sum(ctx.amount)
									, ctx.bill_date
									, ctx.generated_date
									, 0
							from #local_transactions ctx
							inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and ctx.payer_id = anctx.payer_id and anctx.transaction_type = 'A' and anctx.skip_bit <> 5 and ctx.contact_id = anctx.contact_id
							where  ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type and ctx.contact_id >-2.1  and anctx.contact_id >-2.1 
								and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900') and isnull(ctx.generated_date,'1/1/1900') = isnull(anctx.generated_date,'1/1/1900')
							group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.generated_date
							order by 1

							insert into #local_transactions
							select tx.invoice_id
								, tx.contact_id
								, tx.batch_id
								, tx.entry_number
								, tx.client_id
								, tx.auto_generated
								, tx.transaction_id
								, tx.reversing_tx_id
								, tx.distribution_tx_id
								, tx.applied_payment_id
								, tx.payer_id
								, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
								, tx.days_account_id
								, tx.dollars_account_id
								, tx.fac_id
								, tx.is_billed
								, tx.transaction_type
								, tx.parent_tx_type
								, tx.[description]
								, tx.alt_description
								, tx.cheque_number
								, tx.effective_date
								, tx.transaction_date
								, tx.bill_date
								, tx.applied_date
								, tx.generated_date
								, tx.days_amount
								--, tx.days_amount + isnull(txca.days_amount,0) as days_amount
								, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
								, Null as monthly_rate
								, tx.amount + isnull(txca.amount,0) as amount
								, tx.care_level
								, tx.revenue_code
								, tx.hcpcs_code		
								, tx.item_type_id
								, tx.comment
								, tx.rate_type_id
								, tx.rugs_modifier
								, tx.medicare_day
								, tx.mppr_flag
								, tx.mark_as_billed_by
								, tx.mark_as_billed_date
								, tx.mark_as_billed_comment
								, tx.transaction_type_group
								, 0
							from #local_transactions tx with (nolock)
							inner join dbo.ar_payers payr with (nolock) on tx.payer_id = payr.payer_id and tx.fac_id = payr.fac_id
							inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and tx.contact_id = txca.contact_id
								and tx.contact_id >-2.1  and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900')

						delete tx 
						from #local_transactions tx
						inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id	and tx.contact_id >-2.1  and parent.contact_id >-2.1 
						left join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id 
						where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.contact_id = txca.contact_id
						and txca.distribution_tx_id is not null and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(txca.generated_date,'1/1/1900')

						delete tx 
						from #local_transactions tx
						inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id >-2.1  and parent.contact_id >-2.1 
						where tx.skip_bit = 1 and parent.skip_bit = 0 and isnull(tx.bill_date,'1/1/1900') = isnull(parent.bill_date,'1/1/1900') and isnull(tx.generated_date,'1/1/1900') = isnull(parent.generated_date,'1/1/1900')

			--********************************************************** children on different payer than parent
						delete from #child_transactions

						insert into #child_transactions
						select 	  ctx.distribution_tx_id
								--, ctx.transaction_type
								, '' AS transaction_type
								, ctx.parent_tx_type
								, ctx.contact_id 
								, 0 as invoice_id
								, ctx.payer_id
								, sum(ctx.days_amount)
								, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
								, sum(ctx.monthly_rate)
								, sum(ctx.amount)
								, ctx.bill_date
								, ctx.generated_date
								, 0
						from #local_transactions ctx
						join dbo.ar_payers payer on payer.payer_id = ctx.payer_id and payer.fac_id = ctx.fac_id 
						inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and anctx.payer_id <> ctx.payer_id and anctx.transaction_type = 'A' and anctx.skip_bit <> 5
							and ctx.contact_id >-2.1  and anctx.contact_id >-2.1  and ctx.contact_id = anctx.contact_id
						where  ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type 
							--and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900')
						group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.generated_date
						order by 1

						insert into #local_transactions
	
						select tx.invoice_id
							, tx.contact_id
							, tx.batch_id
							, tx.entry_number
							, tx.client_id
							, tx.auto_generated
							, tx.transaction_id
							, tx.reversing_tx_id
							, tx.distribution_tx_id
							, tx.applied_payment_id
							, txca.payer_id
							, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
							, tx.days_account_id
							, tx.dollars_account_id
							, tx.fac_id
							, tx.is_billed
							, tx.transaction_type
							, tx.parent_tx_type
							, tx.[description]
							, tx.alt_description
							, tx.cheque_number
							, tx.effective_date
							, tx.transaction_date
							, txca.bill_date
							, tx.applied_date
							, tx.generated_date
							, tx.days_amount
							, isnull(txca.daily_rate,0) as daily_rate
							, Null as monthly_rate
							, isnull(txca.amount,0) as amount
							, tx.care_level				
							, tx.revenue_code
							, tx.hcpcs_code	
							, tx.item_type_id
							, tx.comment
							, tx.rate_type_id
							, tx.rugs_modifier
							, tx.medicare_day
							, tx.mppr_flag
							, tx.mark_as_billed_by
							, tx.mark_as_billed_date
							, tx.mark_as_billed_comment
							, tx.transaction_type_group
							, 0
						from #local_transactions tx with (nolock)
						inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id  and tx.contact_id = txca.contact_id--and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
							and tx.payer_id <> txca.payer_id and tx.contact_id >-2.1

						delete tx 
						from #local_transactions tx
						inner join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and tx.contact_id = txca.contact_id--and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900')
							and tx.contact_id >-2.1
						where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0

						delete tx 
						from #local_transactions tx
						inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id >-2.1
						where tx.skip_bit = 1 and parent.skip_bit = 0
			
			--********************************************************** 
						set @vgsStepEndTime=GETDATE()
						if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
			end

				if @vOtherStatementsIncluded = 1
					begin
							Select @vStep = 121;
							set @vgsStepStartTime = GETDATE()
							if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' @vShowResults in(A,C,CC,R) - Combining Children not selected - Combine Ancillary Child Transactions to parent ' + convert(varchar(26),getdate(),109);

							delete from #child_transactions --eliminate the missing parent ones

							insert into #child_transactions
							select 	  ctx.distribution_tx_id
									--, ctx.transaction_type
									, '' AS transaction_type
									, ctx.parent_tx_type
									, ctx.contact_id 
									, ctx.invoice_id
									, ctx.payer_id
									, sum(ctx.days_amount)
									, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
									, sum(ctx.monthly_rate)
									, sum(ctx.amount)
									, ctx.bill_date
									, ctx.generated_date
									, 0
							from #local_transactions ctx
							inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and ctx.payer_id = anctx.payer_id and anctx.transaction_type = 'A' and anctx.skip_bit <> 5
								and ctx.contact_id <= -2.1  and anctx.contact_id <= -2.1  and ctx.contact_id = anctx.contact_id
							where  ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type
								and isnull(ctx.bill_date,'1/1/1900') = isnull(anctx.bill_date,'1/1/1900') and ctx.invoice_id = anctx.invoice_id
							group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.contact_id, ctx.payer_id, ctx.bill_date, ctx.invoice_id, ctx.generated_date
							order by 1

							insert into #local_transactions
							select tx.invoice_id
								, tx.contact_id
								, tx.batch_id
								, tx.entry_number
								, tx.client_id
								, tx.auto_generated
								, tx.transaction_id
								, tx.reversing_tx_id
								, tx.distribution_tx_id
								, tx.applied_payment_id
								, tx.payer_id
								, Case when tx.transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 then isnull(tx.parent_payer_id, 0) else null end as parent_payer_id
								, tx.days_account_id
								, tx.dollars_account_id
								, tx.fac_id
								, tx.is_billed
								, tx.transaction_type
								, tx.parent_tx_type
								, tx.[description]
								, tx.alt_description
								, tx.cheque_number
								, tx.effective_date
								, tx.transaction_date
								, tx.bill_date
								, tx.applied_date
								, tx.generated_date
								, tx.days_amount
								--, tx.days_amount + isnull(txca.days_amount,0) as days_amount
								, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
								, Null as monthly_rate
								, tx.amount + isnull(txca.amount,0) as amount
								, tx.care_level
								, tx.revenue_code
								, tx.hcpcs_code		
								, tx.item_type_id
								, tx.comment
								, tx.rate_type_id
								, tx.rugs_modifier
								, tx.medicare_day
								, tx.mppr_flag
								, tx.mark_as_billed_by
								, tx.mark_as_billed_date
								, tx.mark_as_billed_comment
								, tx.transaction_type_group
								, 0
							from #local_transactions tx with (nolock)
							inner join dbo.ar_payers payr with (nolock) on tx.payer_id = payr.payer_id and tx.fac_id = payr.fac_id
							inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and tx.contact_id = txca.contact_id
								and tx.contact_id <= -2.1 and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') and tx.invoice_id = txca.invoice_id

						delete tx 
						from #local_transactions tx
						inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id	and tx.contact_id <= -2.1  and parent.contact_id <= -2.1 and parent.contact_id = tx.contact_id	
						left join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id 
						where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.contact_id = txca.contact_id
						and txca.distribution_tx_id is not null and isnull(tx.bill_date,'1/1/1900') = isnull(txca.bill_date,'1/1/1900') and tx.invoice_id = txca.invoice_id

						delete tx 
						from #local_transactions tx
						inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id and tx.contact_id <= -2.1  and parent.contact_id <= -2.1 and parent.contact_id = tx.contact_id	
						where tx.skip_bit = 1 and parent.skip_bit = 0 and isnull(tx.bill_date,'1/1/1900') = isnull(parent.bill_date,'1/1/1900') and tx.invoice_id = parent.invoice_id


						set @vgsStepEndTime=GETDATE()
						if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
				end

		end
	end

Select @vStep = 125;
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Combining Consecutive Room Charges with no rate change ' + convert(varchar(26),getdate(),109);

delete from #local_transactions where parent_tx_type='R' and amount = 0.00 --cleanup before useless data before combining

If @vPrivateStatementsIncluded = 1 
	begin
		--flag duplicates to be skipped
		update tx set tx.skip_bit = 8
		from
		#local_transactions tx
		inner join (select tx.bill_date,tx.generated_date,tx.contact_id,tx.client_id,tx.effective_Date,tx.parent_tx_type,tx.transaction_type,tx.daily_rate,tx.monthly_rate,tx.days_amount, 
						case when tx.reversing_tx_id is null then 0 else 1 end as reversed
					from #local_transactions tx
					inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
					where tx.parent_tx_type='R' and ccl.contact_id > -2.1
					group by tx.bill_date,tx.generated_date,tx.contact_id,tx.client_id,tx.effective_Date,tx.parent_tx_type,tx.transaction_type,tx.daily_rate,tx.monthly_rate,tx.days_amount,
						case when tx.reversing_tx_id is null then 0 else 1 end
					having count(*) >1
					) dups on tx.bill_date = dups.bill_date and tx.generated_date = dups.generated_date and tx.client_id = dups.client_id and tx.contact_id = dups.contact_id and
					tx.effective_Date = dups.effective_Date and	tx.parent_tx_type = dups.parent_tx_type and tx.transaction_type = dups.transaction_type and
					isnull(tx.daily_rate,0) = isnull(dups.daily_rate,0) and isnull(tx.monthly_rate,0) = isnull(dups.monthly_rate,0) and tx.days_amount = dups.days_amount
					and (case when tx.reversing_tx_id is null then 0 else 1 end) = dups.reversed

		--flag groups that sum to $0 to be skipped
		update marked set skip_bit = 8
		from #local_transactions marked
		inner join (
					select tx.client_id, tx.contact_id, tx.bill_date, tx.generated_date, tx.effective_date, tx.transaction_type,tx.description, sum(tx.amount) as ttl, count(*) as cnt
					from #local_transactions tx
					inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
					where tx.parent_tx_type='R' and ccl.contact_id > -2.1 
					group by tx.client_id, tx.contact_id, tx.bill_date, tx.generated_date, tx.effective_date, tx.transaction_type, description having count (*) > 1
					) sum0 on marked.client_id = sum0.client_id and marked.contact_id = sum0.contact_id and marked.bill_date = sum0.bill_date
						and marked.generated_date = sum0.generated_date and marked.effective_date = sum0.effective_date and marked.transaction_type = sum0.transaction_type
						and marked.description = sum0.description and sum0.ttl = 0 and marked.skip_bit <> 8

		--non-reversed charges
			update nxt set nxt.skip_bit =(case when pre.daily_rate=nxt.daily_rate and pre.monthly_rate=nxt.monthly_rate and dateadd(dd,abs(pre.days_amount),pre.effective_date) = nxt.effective_date
				and datepart(mm,pre.effective_date) = datepart(mm,nxt.effective_date) and pre.generated_date=nxt.generated_date and pre.transaction_type=nxt.transaction_type 
				and ((@vCombineRecurringAncillary=1 and pre.item_type_id=nxt.item_type_id and pre.transaction_type='A' and nxt.transaction_type='A' ) OR (pre.parent_tx_type='R' and nxt.parent_tx_type='R')
					or (@vCombineCouncilPayerContribution = 1 and pre.parent_payer_id = nxt.parent_payer_id and pre.transaction_type='PC' and nxt.transaction_type='PC' 
					))
				then 9 else 1 end)
			from (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.generated_date
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.contact_id,tx.client_id
					order by  tx.contact_id,tx.client_id,tx.generated_date,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' 
					or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null)
					or (@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC'))
					and tx.reversing_tx_id is null and tx.skip_bit <> 8  and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC')  or ccl.contact_id > -2.1) 
					) pre
			join (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.generated_date
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.contact_id,tx.client_id
					order by  tx.contact_id,tx.client_id,tx.generated_date,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' 
				  or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null)
				  or (@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC'))
				and tx.reversing_tx_id is null and tx.skip_bit <> 8  and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC')  or ccl.contact_id > -2.1) 
				) nxt
			on pre.client_id=nxt.client_id and pre.contact_id=nxt.contact_id and pre.generated_date=nxt.generated_date and pre.transaction_type=nxt.transaction_type 
				and pre.rwnum=(nxt.rwnum-1)

		update myup set myup.days_amount = myup.days_amount + conttl.days_ttl, myup.amount = myup.amount + conttl.ttl--, myup.skip_bit = 7
		from #local_transactions myup
		inner join 
			(select contact_id,
				client_id, 
				skip_bit, 
				generated_date,
				transaction_type,
				isnull(parent_payer_id,0) as parent_payer_id,
				isnull(daily_rate,0) as daily_rate,
				isnull(monthly_rate,0) as monthly_rate,
				year(effective_date) as grp_year, 
				month(effective_date) as grp_month, 
				min(effective_date) as min_date,
				max(effective_date) as max_date, 
				sum(days_amount) as days_ttl, 
				sum(amount) as ttl
			from #local_transactions where (parent_tx_type='R' 
										or (transaction_type='A' and @vCombineRecurringAncillary=1 and auto_generated='R')
										or (transaction_type = 'PC' and @vCombineCouncilPayerContribution = 1 )) 
				and reversing_tx_id is null and skip_bit = 9
			group by contact_id, client_id, generated_date, skip_bit, transaction_type, isnull(parent_payer_id,0),isnull(daily_rate,0),isnull(monthly_rate,0), year(effective_date), month(effective_date)) conttl
			on myup.contact_id =  conttl.contact_id and myup.client_id =  conttl.client_id and myup.transaction_type =  conttl.transaction_type and myup.client_id = conttl.client_id and myup.generated_date = conttl.generated_date and 
				dateadd(dd,abs(myup.days_amount),myup.effective_date)  = conttl.min_date and isnull(myup.daily_rate,0) =  conttl.daily_rate and isnull(myup.monthly_rate,0) =  conttl.monthly_rate 
				and myup.skip_bit <> 9 and myup.skip_bit <> 8
				and myup.reversing_tx_id is null
				and (myup.transaction_type <> 'PC' or myup.parent_payer_id = conttl.parent_payer_id)

			delete from #local_transactions where skip_bit=9

		--negative reversed charges
			update nxt set nxt.skip_bit =(case when pre.daily_rate=nxt.daily_rate and pre.monthly_rate=nxt.monthly_rate and dateadd(dd,abs(pre.days_amount),pre.effective_date) = nxt.effective_date
				and datepart(mm,pre.effective_date) = datepart(mm,nxt.effective_date) and pre.generated_date=nxt.generated_date and pre.transaction_type=nxt.transaction_type 
				and ((@vCombineRecurringAncillary=1 and pre.item_type_id=nxt.item_type_id and pre.transaction_type='A' and nxt.transaction_type='A' ) OR (@vCombineCouncilPayerContribution=1 and pre.parent_payer_id=nxt.parent_payer_id and pre.transaction_type='PC' and nxt.transaction_type='PC' ) OR (pre.parent_tx_type='R' and nxt.parent_tx_type='R'))
				then 9 else 1 end)
			from (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.generated_date
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.contact_id,tx.client_id
					order by  tx.contact_id,tx.client_id,tx.generated_date,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC'))
			and tx.reversing_tx_id is not null and tx.days_amount < 0 and tx.skip_bit <> 8 and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC')  or ccl.contact_id > -2.1)) pre
			join (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.generated_date
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.contact_id,tx.client_id
					order by  tx.contact_id,tx.client_id,tx.generated_date,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1))
			and tx.reversing_tx_id is not null and tx.days_amount < 0 and tx.skip_bit <> 8 and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC')  or ccl.contact_id > -2.1) ) nxt			
			on pre.contact_id=nxt.contact_id and pre.client_id=nxt.client_id and pre.generated_date=nxt.generated_date and pre.transaction_type=nxt.transaction_type 
				and pre.rwnum=(nxt.rwnum-1)

		update myup set myup.days_amount = myup.days_amount + conttl.days_ttl, myup.amount = myup.amount + conttl.ttl
		from #local_transactions myup
		inner join 
			(select contact_id,
				client_id, 
				skip_bit, 
				generated_date,
				transaction_type,
				isnull(parent_payer_id,0) as parent_payer_id,
				isnull(daily_rate,0) as daily_rate,
				isnull(monthly_rate,0) as monthly_rate,
				year(effective_date) as grp_year, 
				month(effective_date) as grp_month, 
				min(effective_date) as min_date,
				max(effective_date) as max_date, 
				sum(days_amount) as days_ttl, 
				sum(amount) as ttl
			from #local_transactions where (parent_tx_type='R' or (transaction_type='A' and @vCombineRecurringAncillary=1 and auto_generated='R') OR (transaction_type='PC' and @vCombineCouncilPayerContribution=1 )) 
				and reversing_tx_id is not null and skip_bit = 9 and days_amount < 0
			group by contact_id,client_id, skip_bit, generated_date, transaction_type, isnull(parent_payer_id,0), isnull(daily_rate,0),isnull(monthly_rate,0), year(effective_date), month(effective_date)) conttl
			on myup.contact_id =  conttl.contact_id and myup.client_id =  conttl.client_id and myup.transaction_type =  conttl.transaction_type and myup.client_id =  conttl.client_id and 
				dateadd(dd,abs(myup.days_amount),myup.effective_date)  = conttl.min_date and myup.skip_bit <> 9 and myup.skip_bit <> 8
				and myup.reversing_tx_id is not null and myup.days_amount < 0 and myup.generated_date =  conttl.generated_date
				and isnull(myup.daily_rate,0) =  conttl.daily_rate and isnull(myup.monthly_rate,0) =  conttl.monthly_rate 
				and (myup.transaction_type <> 'PC' or myup.parent_payer_id = conttl.parent_payer_id)

			delete from #local_transactions where skip_bit=9

		--positive reversed charges
			update nxt set nxt.skip_bit =(case when pre.daily_rate=nxt.daily_rate and pre.monthly_rate=nxt.monthly_rate and dateadd(dd,abs(pre.days_amount),pre.effective_date) = nxt.effective_date
				and datepart(mm,pre.effective_date) = datepart(mm,nxt.effective_date) and pre.generated_date=nxt.generated_date and pre.transaction_type=nxt.transaction_type 
				and ((@vCombineRecurringAncillary=1 and pre.item_type_id=nxt.item_type_id and pre.transaction_type='A' and nxt.transaction_type='A' ) OR (@vCombineCouncilPayerContribution=1 and pre.parent_payer_id=nxt.parent_payer_id and pre.transaction_type='PC' and nxt.transaction_type='PC' ) OR (pre.parent_tx_type='R' and nxt.parent_tx_type='R'))
				then 9 else 1 end)
			from (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.generated_date
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.contact_id,tx.client_id
					order by  tx.contact_id,tx.client_id,tx.generated_date,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) OR (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1 ))
				and tx.reversing_tx_id is not null and tx.days_amount > 0 and tx.skip_bit <> 8 and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC')  or ccl.contact_id > -2.1)) pre
			join (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.generated_date
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.contact_id,tx.client_id
					order by  tx.contact_id,tx.client_id,tx.generated_date,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1 ))
				and tx.reversing_tx_id is not null and tx.days_amount > 0 and tx.skip_bit <> 8 and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC')  or ccl.contact_id > -2.1)) nxt
			on pre.contact_id=nxt.contact_id and pre.client_id=nxt.client_id and pre.generated_date=nxt.generated_date and pre.transaction_type=nxt.transaction_type 
				and pre.rwnum=(nxt.rwnum-1)

		update myup set myup.days_amount = myup.days_amount + conttl.days_ttl, myup.amount = myup.amount + conttl.ttl
		from #local_transactions myup
		inner join 
			(select contact_id,
				client_id, 
				skip_bit,
				generated_date, 
				transaction_type,
				isnull(parent_payer_id,0) as parent_payer_id,
				isnull(daily_rate,0) as daily_rate,
				isnull(monthly_rate,0) as monthly_rate, 
				year(effective_date) as grp_year, 
				month(effective_date) as grp_month, 
				min(effective_date) as min_date,
				max(effective_date) as max_date, 
				sum(days_amount) as days_ttl, 
				sum(amount) as ttl
			from #local_transactions where (parent_tx_type='R' or (transaction_type='A' and @vCombineRecurringAncillary=1 and auto_generated='R') or (transaction_type='PC' and @vCombineCouncilPayerContribution=1 )) 
				and reversing_tx_id is not null and skip_bit = 9 and days_amount > 0
			group by contact_id,client_id, skip_bit, generated_date, transaction_type, isnull(parent_payer_id,0), isnull(daily_rate,0),isnull(monthly_rate,0), year(effective_date), month(effective_date)) conttl
			on myup.client_id =  conttl.client_id and myup.transaction_type =  conttl.transaction_type and myup.client_id =  conttl.client_id and myup.contact_id =  conttl.contact_id and 
				dateadd(dd,abs(myup.days_amount),myup.effective_date)  = conttl.min_date and myup.skip_bit <> 9 and myup.skip_bit <> 8
				and myup.reversing_tx_id is not null and myup.days_amount > 0 and myup.generated_date =  conttl.generated_date
				and isnull(myup.daily_rate,0) =  conttl.daily_rate and isnull(myup.monthly_rate,0) =  conttl.monthly_rate 
				and (myup.transaction_type <> 'PC' or myup.parent_payer_id = conttl.parent_payer_id)				

			delete from #local_transactions where skip_bit=9
			update #local_transactions set skip_bit = 1 where skip_bit = 8

	end

if @vOtherStatementsIncluded = 1 
	begin

		--flag duplicates to be skipped
		update tx set tx.skip_bit = 8
		from
		#local_transactions tx
		inner join (select tx.bill_date,tx.invoice_id,tx.contact_id,tx.client_id,tx.effective_Date,tx.parent_tx_type,tx.transaction_type,tx.daily_rate,tx.monthly_rate,tx.days_amount, 
						case when tx.reversing_tx_id is null then 0 else 1 end as reversed
					from #local_transactions tx
					inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
					where tx.parent_tx_type='R' and ccl.contact_id <= -2.1
					group by tx.bill_date,tx.invoice_id,tx.contact_id,tx.client_id,tx.effective_Date,tx.parent_tx_type,tx.transaction_type,tx.daily_rate,tx.monthly_rate,tx.days_amount,
						case when tx.reversing_tx_id is null then 0 else 1 end
					having count(*) >1
					) dups on tx.bill_date = dups.bill_date and tx.invoice_id = dups.invoice_id and tx.client_id = dups.client_id and tx.contact_id = dups.contact_id and
					tx.effective_Date = dups.effective_Date and	tx.parent_tx_type = dups.parent_tx_type and tx.transaction_type = dups.transaction_type and
					isnull(tx.daily_rate,0) = isnull(dups.daily_rate,0) and isnull(tx.monthly_rate,0) = isnull(dups.monthly_rate,0) and tx.days_amount = dups.days_amount
					and (case when tx.reversing_tx_id is null then 0 else 1 end) = dups.reversed

		--flag groups that sum to $0 to be skipped
		update marked set skip_bit = 8
		from #local_transactions marked
		inner join (
					select tx.contact_id,tx.client_id, tx.bill_date, tx.invoice_id, tx.effective_date, tx.transaction_type,tx.description, sum(tx.amount) as ttl, count(*) as cnt
					from #local_transactions tx
					inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
					where tx.parent_tx_type='R' and ccl.contact_id <= -2.1 
					group by tx.contact_id,tx.client_id, tx.bill_date, tx.invoice_id, tx.effective_date, tx.transaction_type, description having count (*) > 1
					) sum0 on marked.contact_id = sum0.contact_id and marked.client_id = sum0.client_id and marked.bill_date = sum0.bill_date
						and marked.invoice_id = sum0.invoice_id and marked.effective_date = sum0.effective_date and marked.transaction_type = sum0.transaction_type
						and marked.description = sum0.description and sum0.ttl = 0 and marked.skip_bit <> 8

		--non-reversed charges
			update nxt set nxt.skip_bit =(case when pre.daily_rate=nxt.daily_rate and pre.monthly_rate=nxt.monthly_rate and dateadd(dd,abs(pre.days_amount),pre.effective_date) = nxt.effective_date
				and datepart(mm,pre.effective_date) = datepart(mm,nxt.effective_date) and pre.invoice_id=nxt.invoice_id and pre.transaction_type=nxt.transaction_type 
				and ((@vCombineRecurringAncillary=1 and pre.item_type_id=nxt.item_type_id and pre.transaction_type='A' and nxt.transaction_type='A' ) OR (@vCombineCouncilPayerContribution=1 and pre.parent_payer_id=nxt.parent_payer_id and pre.transaction_type='PC' and nxt.transaction_type='PC' ) OR (pre.parent_tx_type='R' and nxt.parent_tx_type='R'))
				then 9 else 1 end)
			from (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.invoice_id
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.client_id
					order by  tx.contact_id,tx.client_id,tx.invoice_id,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1 ))
				and tx.reversing_tx_id is null and tx.skip_bit <> 8  and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC')  or ccl.contact_id > -2.1) 
				) pre
			join (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.invoice_id
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.client_id
					order by  tx.contact_id,tx.client_id,tx.invoice_id,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1 ))
				and tx.reversing_tx_id is null and tx.skip_bit <> 8  and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC') or ccl.contact_id <= -2.1) 
				) nxt
			on pre.contact_id=nxt.contact_id and pre.client_id=nxt.client_id and pre.invoice_id=nxt.invoice_id and pre.transaction_type=nxt.transaction_type 
				and pre.rwnum=(nxt.rwnum-1)

		update myup set myup.days_amount = myup.days_amount + conttl.days_ttl, myup.amount = myup.amount + conttl.ttl--, myup.skip_bit = 7
		from #local_transactions myup
		inner join 
			(select contact_id,
				client_id, 
				skip_bit, 
				invoice_id,
				transaction_type,
				isnull(parent_payer_id,0) as parent_payer_id,
				isnull(daily_rate,0) as daily_rate,
				isnull(monthly_rate,0) as monthly_rate,
				year(effective_date) as grp_year, 
				month(effective_date) as grp_month, 
				min(effective_date) as min_date,
				max(effective_date) as max_date, 
				sum(days_amount) as days_ttl, 
				sum(amount) as ttl
			from #local_transactions where (parent_tx_type='R' or (transaction_type='A' and @vCombineRecurringAncillary=1 and auto_generated='R')
															   or (transaction_type='PC' and @vCombineCouncilPayerContribution=1 )) 
				and reversing_tx_id is null and skip_bit = 9
			group by contact_id,client_id, invoice_id, skip_bit, transaction_type, isnull(parent_payer_id,0), isnull(daily_rate,0),isnull(monthly_rate,0), year(effective_date), month(effective_date)) conttl
			on myup.contact_id =  conttl.contact_id and myup.client_id =  conttl.client_id and myup.transaction_type =  conttl.transaction_type and myup.client_id = conttl.client_id and myup.invoice_id = conttl.invoice_id and 
				dateadd(dd,abs(myup.days_amount),myup.effective_date)  = conttl.min_date and isnull(myup.daily_rate,0) =  conttl.daily_rate and isnull(myup.monthly_rate,0) =  conttl.monthly_rate 
				and myup.skip_bit <> 9 and myup.skip_bit <> 8
				and myup.reversing_tx_id is null
				and (myup.transaction_type <> 'PC' or myup.parent_payer_id = conttl.parent_payer_id)
				

			delete from #local_transactions where skip_bit=9

		--negative reversed charges
			update nxt set nxt.skip_bit =(case when pre.daily_rate=nxt.daily_rate and pre.monthly_rate=nxt.monthly_rate and dateadd(dd,abs(pre.days_amount),pre.effective_date) = nxt.effective_date
				and datepart(mm,pre.effective_date) = datepart(mm,nxt.effective_date) and pre.invoice_id=nxt.invoice_id and pre.transaction_type=nxt.transaction_type 
				and ((@vCombineRecurringAncillary=1 and pre.item_type_id=nxt.item_type_id and pre.transaction_type='A' and nxt.transaction_type='A' ) OR (@vCombineCouncilPayerContribution=1 and pre.parent_payer_id=nxt.parent_payer_id and pre.transaction_type='PC' and nxt.transaction_type='PC' ) OR (pre.parent_tx_type='R' and nxt.parent_tx_type='R'))
				then 9 else 1 end)
			from (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.invoice_id
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.client_id
					order by  tx.contact_id,tx.client_id,tx.invoice_id,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1 ))
			and tx.reversing_tx_id is not null and tx.days_amount < 0 and tx.skip_bit <> 8 and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC') or ccl.contact_id <= -2.1)) pre
			join (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.invoice_id
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.client_id
					order by  tx.contact_id,tx.client_id,tx.invoice_id,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1 ))
			and tx.reversing_tx_id is not null and tx.days_amount < 0 and tx.skip_bit <> 8 and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC') or ccl.contact_id <= -2.1)) nxt
			on pre.contact_id=nxt.contact_id and pre.client_id=nxt.client_id and pre.invoice_id=nxt.invoice_id and pre.transaction_type=nxt.transaction_type 
				and pre.rwnum=(nxt.rwnum-1)

		update myup set myup.days_amount = myup.days_amount + conttl.days_ttl, myup.amount = myup.amount + conttl.ttl
		from #local_transactions myup
		inner join 
			(select contact_id,
				client_id, 
				skip_bit, 
				invoice_id,
				transaction_type,
				isnull(parent_payer_id,0) as parent_payer_id,
				isnull(daily_rate,0) as daily_rate,
				isnull(monthly_rate,0) as monthly_rate,
				year(effective_date) as grp_year, 
				month(effective_date) as grp_month, 
				min(effective_date) as min_date,
				max(effective_date) as max_date, 
				sum(days_amount) as days_ttl, 
				sum(amount) as ttl
			from #local_transactions where (parent_tx_type='R' or (transaction_type='A' and @vCombineRecurringAncillary=1 and auto_generated='R') or (transaction_type='PC' and @vCombineCouncilPayerContribution=1 )) 
				and reversing_tx_id is not null and skip_bit = 9 and days_amount < 0
			group by contact_id,client_id, skip_bit, invoice_id, transaction_type, isnull(parent_payer_id,0), isnull(daily_rate,0),isnull(monthly_rate,0), year(effective_date), month(effective_date)) conttl
			on myup.contact_id = conttl.contact_id and myup.client_id = conttl.client_id and myup.transaction_type =  conttl.transaction_type and myup.client_id =  conttl.client_id and 
				dateadd(dd,abs(myup.days_amount),myup.effective_date) = conttl.min_date and myup.skip_bit <> 9 and myup.skip_bit <> 8
				and myup.reversing_tx_id is not null and myup.days_amount < 0 and myup.invoice_id =  conttl.invoice_id
				and isnull(myup.daily_rate,0) =  conttl.daily_rate and isnull(myup.monthly_rate,0) =  conttl.monthly_rate 
				and (myup.transaction_type <> 'PC' or myup.parent_payer_id = conttl.parent_payer_id)

			delete from #local_transactions where skip_bit=9

		--positive reversed charges
			update nxt set nxt.skip_bit =(case when pre.daily_rate=nxt.daily_rate and pre.monthly_rate=nxt.monthly_rate and dateadd(dd,abs(pre.days_amount),pre.effective_date) = nxt.effective_date
				and datepart(mm,pre.effective_date) = datepart(mm,nxt.effective_date) and pre.invoice_id=nxt.invoice_id and pre.transaction_type=nxt.transaction_type 
				and ((@vCombineRecurringAncillary=1 and pre.item_type_id=nxt.item_type_id and pre.transaction_type='A' and nxt.transaction_type='A' ) OR (@vCombineCouncilPayerContribution=1 and pre.parent_payer_id=nxt.parent_payer_id and pre.transaction_type='PC' and nxt.transaction_type='PC' ) OR (pre.parent_tx_type='R' and nxt.parent_tx_type='R'))
				then 9 else 1 end)
			from (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.invoice_id
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.client_id
					order by  tx.contact_id,tx.client_id,tx.invoice_id,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1  ))
				and tx.reversing_tx_id is not null and tx.days_amount > 0 and tx.skip_bit <> 8 and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC') or ccl.contact_id <= -2.1)) pre
			join (select tx.transaction_id
				,tx.contact_id
				,tx.client_id
				,tx.invoice_id
				,tx.parent_tx_type
				,tx.transaction_type
				,tx.effective_date
				,isnull(tx.daily_rate,0) as daily_rate
				,isnull(tx.monthly_rate,0) as monthly_rate
				,tx.days_amount
				,tx.amount
				,tx.item_type_id
				,tx.parent_payer_id
				,tx.skip_bit
				,ROW_NUMBER() OVER ( PARTITION BY tx.client_id
					order by  tx.contact_id,tx.client_id,tx.invoice_id,tx.transaction_type,tx.parent_payer_id,isnull(tx.daily_rate,0),isnull(tx.monthly_rate,0),tx.effective_date,tx.transaction_id) as rwnum
			from #local_transactions tx
			inner join #contact_clients ccl on tx.invoice_id = ccl.invoice_id and tx.contact_id = ccl.contact_id
			where (tx.parent_tx_type='R' or (tx.transaction_type='A' and @vCombineRecurringAncillary=1 and tx.auto_generated='R' and tx.item_type_id is not null) or (tx.transaction_type='PC' and @vCombineCouncilPayerContribution=1 ))
				and tx.reversing_tx_id is not null and tx.days_amount > 0 and tx.skip_bit <> 8 and ((@vCombineCouncilPayerContribution = 1 and tx.transaction_type = 'PC') or ccl.contact_id <= -2.1)) nxt
			on pre.contact_id=nxt.contact_id and pre.client_id=nxt.client_id and pre.invoice_id=nxt.invoice_id and pre.transaction_type=nxt.transaction_type 
				and pre.rwnum=(nxt.rwnum-1)

		update myup set myup.days_amount = myup.days_amount + conttl.days_ttl, myup.amount = myup.amount + conttl.ttl
		from #local_transactions myup
		inner join 
			(select contact_id,
				client_id, 
				skip_bit,
				invoice_id, 
				transaction_type,
				isnull(parent_payer_id,0) as parent_payer_id,
				isnull(daily_rate,0) as daily_rate,
				isnull(monthly_rate,0) as monthly_rate, 
				year(effective_date) as grp_year, 
				month(effective_date) as grp_month, 
				min(effective_date) as min_date,
				max(effective_date) as max_date, 
				sum(days_amount) as days_ttl, 
				sum(amount) as ttl
			from #local_transactions where (parent_tx_type='R' or (transaction_type='A' and @vCombineRecurringAncillary=1 and auto_generated='R') or (transaction_type='PC' and @vCombineCouncilPayerContribution=1 )) 
				and reversing_tx_id is not null and skip_bit = 9 and days_amount > 0
			group by contact_id, client_id, skip_bit, invoice_id, transaction_type, isnull(parent_payer_id,0), isnull(daily_rate,0),isnull(monthly_rate,0), year(effective_date), month(effective_date)) conttl
			on myup.contact_id = conttl.contact_id and myup.client_id = conttl.client_id and myup.transaction_type =  conttl.transaction_type and myup.client_id =  conttl.client_id and 
				dateadd(dd,abs(myup.days_amount),myup.effective_date) = conttl.min_date and myup.skip_bit <> 9 and myup.skip_bit <> 8
				and myup.reversing_tx_id is not null and myup.days_amount > 0 and myup.invoice_id =  conttl.invoice_id
				and isnull(myup.daily_rate,0) =  conttl.daily_rate and isnull(myup.monthly_rate,0) =  conttl.monthly_rate 
				and (myup.transaction_type <> 'PC' or myup.parent_payer_id = conttl.parent_payer_id)

			delete from #local_transactions where skip_bit=9
			update #local_transactions set skip_bit = 1 where skip_bit = 8

	end

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

Select @vStep = 130;
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Formating and grouping transaction Data ' + convert(varchar(26),getdate(),109);
	
if @vShowResults = 'D'

	begin

		INSERT INTO #transactions	
		SELECT 
			  concl.invoice_id
			, tx.fac_id
			, concl.contact_id
			, concl.contact_num
			, tx.client_id
			, tx.payer_id
			, libpayer.description AS payer
			, libpayer.payer_type
			, tx.batch_id
			, tx.entry_number
			, tx.distribution_tx_id
			, tx.transaction_id
			, tx.reversing_tx_id
			, isnull(tx.auto_generated, 'N') as auto_generated
			, concl.bill_date
			, tx.transaction_date as posting_date
			, tx.effective_date
			, Null as effective_from_date
			, Null as effective_thru_date
			, tx.generated_date
			, libcc.charge_code
			, isnull(rtx.charge_frequency,'O') as frequency
			, tx.revenue_code
			, tx.hcpcs_code
			, tx.mppr_flag
			, Case when tx.transaction_type = 'R' and isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> '' 
					then rtype.long_description + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then 
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' + convert(varchar(4),YEAR(tx.effective_date))
					end) 
					+ (case when isnull(arpayer.show_care_level,'N') = 'Y'  and isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
				and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') = ''  
				and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'CL' and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X','CA') and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' then tx.description
				when tx.transaction_type ='PC' and @vCombineCouncilPayerContribution=1  then 
					LEFT(tx.description,CHARINDEX(':',tx.description)-1)+': ' + FORMAT(tx.effective_date,'MMM dd') + 
						(case 
							when (abs(tx.days_amount) > 1 and (DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) < 10) then '-' + '0' + CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' + convert(varchar(4),YEAR(tx.effective_date))
							when abs(tx.days_amount) > 1 then '-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' + convert(varchar(4),YEAR(tx.effective_date))
							else ' ' +	convert(varchar(4),YEAR(tx.effective_date)) end)
				when tx.transaction_type ='CA' and isnull(tx.alt_description,'')='' then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')'
				when tx.transaction_type = 'CO' and tx.parent_tx_type <> 'R' then tx.description --+  ' Coinsurance'
				when tx.transaction_type = 'XR' and tx.parent_tx_type ='A' then tx.description --+  ' Reimb. Reduction' 
				when tx.transaction_type = 'CX' and tx.parent_tx_type ='R' then 'Room Excess' 
				when (tx.transaction_type in('XR','CO', 'D', 'CR') or (tx.transaction_type = 'CL' and isnull(tx.alt_description,'')='')) and tx.parent_tx_type = 'R' then
				(Case 
					when isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> ''  
						then rtype.long_description + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(arpayer.show_care_level,'N') = 'Y' and isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
						and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' +
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then  
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'XR'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'CO'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else
							' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end) --+ ' Coinsurance'
					else 
						(case when tx.transaction_type = 'XR' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
							(case when abs(tx.days_amount) > 1 then
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else  ' ' +	convert(varchar(4),YEAR(tx.effective_date))
							end)
						else 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') +
							(case when abs(tx.days_amount) > 1 then 
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else ' ' + convert(varchar(4),YEAR(tx.effective_date))
							end) --+
							--(case when tx.transaction_type = 'D' then ' Deductible' 
							--	when tx.transaction_type = 'CO' then ' Coinsurance' else '' end)  
						end)
					end
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				) --+ (case when tx.transaction_type = 'CL' then ' Coverage Deductible' else '' end) 
				 --+ (case when tx.transaction_type = 'CR' then ' Contractural Adj.' else '' end) 
				else tx.description end as detail_description
			, tx.care_level
			, Case when tx.transaction_type = 'R' and libpayer.pps_flag='Y' then ltrim(rtrim(str(tx.medicare_day))) + '-' 
				+ltrim(rtrim(str((
					case when tx.days_amount < 0 and (tx.days_amount*-1) > 1 then tx.days_amount*-1 + tx.medicare_day -1
					when tx.days_amount > 0 and (tx.days_amount*-1) = 1 then tx.days_amount*-1  + tx.medicare_day
					when tx.days_amount > 1 then tx.days_amount + tx.medicare_day -1
					else tx.days_amount + tx.medicare_day end))))
				else Null
					end as benefit_days
			, tx.parent_tx_type
			, tx.transaction_type
			, tx.daily_rate as unit_amount
			, case when tx.transaction_type = 'XR' then Null else tx.days_amount end as number_of_units
			, tx.amount
			, acct.account_number as gl_account
			, daysacct.account_number as days_account
			, case when tx.is_billed = 1 and isnull(tx.invoice_id,0) > 0 then 'Y'
				when tx.is_billed = 1 and isnull(tx.invoice_id,0) < 0 then 'N/A' else 'N' end as billed
			, tx.comment
			, tx.cheque_number
			, case when libcc.adjustment_type is not null and tx.transaction_type = 'X' then libcc.transaction_type + '_' + libcc.adjustment_type 
				when recur.transaction_id is not null then 'Recur'
				when tx.mppr_flag = 1 or convert(bit, case when bump.bumpup_transaction_id is null then 0 else 1 end) = 'true' then 'MPPR'
				else tx.transaction_type end as adjusted_tx_type
			, case when recur.transaction_id is null then 0 else 1 end as recurring_tx
			, case when tx.reversing_tx_id is null then 0 else 1 end as reversed
			, tx.transaction_type_group
			, 0 as ancillary_year
			, 0 as ancillary_month
			, 0 as balance_due
			, 0 as other_payer
			, NULL as aging_total
			, NULL as aging_current_label
			, NULL as aging_current_amount
			, NULL as aging_30_label
			, NULL as aging_30_amount
			, NULL as aging_60_label
			, NULL as aging_60_amount
			, NULL as aging_90_label
			, NULL as aging_90_amount
			, NULL as aging_120_label
			, NULL as aging_120_amount
			, NULL as aging_150_label
			, NULL as aging_150_amount
			, NULL as aging_180_label
			, NULL as aging_180_amount
			, NULL as aging_210_label
			, NULL as aging_210_amount
			, 0 as detail_order		
		FROM #local_transactions tx with (nolock)
		inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
		inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
		inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'
		left join dbo.ar_transactions_location_room roomLocation with (nolock) on roomLocation.transaction_id = tx.transaction_id    
		left join dbo.ar_transaction_recurring_tx_refs recur with (nolock) on tx.transaction_id = recur.transaction_id
		left join dbo.ar_recurring_transactions rtx with (nolock) on rtx.transaction_id = recur.recurring_tx_id
		left join dbo.ar_batch batch with (nolock) on tx.batch_id = batch.batch_id
		left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
		left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
		left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
		left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
		left join dbo.ar_mppr_bumpup bump with (nolock) on tx.distribution_tx_id = bump.bumpup_transaction_id  
		where tx.transaction_type <> 'TA'
	end

if @vShowResults = 'A'

	begin

		INSERT INTO #transactions	
		SELECT 
			  concl.invoice_id
			, tx.fac_id
			, concl.contact_id
			, concl.contact_num
			, tx.client_id
			, tx.payer_id
			, libpayer.description AS payer
			, libpayer.payer_type
			, tx.batch_id
			, tx.entry_number
			, tx.distribution_tx_id
			, tx.transaction_id
			, tx.reversing_tx_id
			, isnull(tx.auto_generated, 'N') as auto_generated
			, concl.bill_date
			, tx.transaction_date as posting_date
			, tx.effective_date
			, Null as effective_from_date
			, Null as effective_thru_date
			, tx.generated_date
			, libcc.charge_code
			, isnull(rtx.charge_frequency,'O') as frequency
			, tx.revenue_code
			, tx.hcpcs_code
			, tx.mppr_flag
			, Case when tx.transaction_type = 'R' and isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> '' 
					then rtype.long_description + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then 
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' + convert(varchar(4),YEAR(tx.effective_date))
					end) 
					+ (case when isnull(arpayer.show_care_level,'N') = 'Y'  and isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
				and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') = ''  
				and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'CL' and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X','CA') and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' then tx.description
				when tx.transaction_type ='CA' and isnull(tx.alt_description,'')='' then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')'
				when tx.transaction_type = 'CO' and tx.parent_tx_type <> 'R' then tx.description --+  ' Coinsurance'
				when tx.transaction_type = 'XR' and tx.parent_tx_type ='A' then tx.description --+  ' Reimb. Reduction' 
				when tx.transaction_type = 'CX' and tx.parent_tx_type ='R' then 'Room Excess' 
				when (tx.transaction_type in('XR','CO', 'D', 'CR') or (tx.transaction_type = 'CL' and isnull(tx.alt_description,'')='')) and tx.parent_tx_type = 'R' then
				(Case 
					when isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> ''  
						then rtype.long_description + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(arpayer.show_care_level,'N') = 'Y' and isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
						and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' +
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then  
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'XR'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'CO'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else
							' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end) --+ ' Coinsurance'
					else 
						(case when tx.transaction_type = 'XR' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
							(case when abs(tx.days_amount) > 1 then
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else  ' ' +	convert(varchar(4),YEAR(tx.effective_date))
							end)
						else 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') +
							(case when abs(tx.days_amount) > 1 then 
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else ' ' + convert(varchar(4),YEAR(tx.effective_date))
							end) --+
							--(case when tx.transaction_type = 'D' then ' Deductible' 
							--	when tx.transaction_type = 'CO' then ' Coinsurance' else '' end)  
						end)
					end
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				) --+ (case when tx.transaction_type = 'CL' then ' Coverage Deductible' else '' end) 
				 --+ (case when tx.transaction_type = 'CR' then ' Contractural Adj.' else '' end) 
				else tx.description end as detail_description
			, tx.care_level
			, Case when tx.transaction_type = 'R' and libpayer.pps_flag='Y' then ltrim(rtrim(str(tx.medicare_day))) + '-' 
				+ltrim(rtrim(str((
					case when tx.days_amount < 0 and (tx.days_amount*-1) > 1 then tx.days_amount*-1 + tx.medicare_day -1
					when tx.days_amount > 0 and (tx.days_amount*-1) = 1 then tx.days_amount*-1  + tx.medicare_day
					when tx.days_amount > 1 then tx.days_amount + tx.medicare_day -1
					else tx.days_amount + tx.medicare_day end))))
				else Null
					end as benefit_days
			, tx.parent_tx_type
			, tx.transaction_type
			, tx.daily_rate as unit_amount
			, case when tx.transaction_type = 'XR' then Null else tx.days_amount end as number_of_units
			, tx.amount
			, acct.account_number as gl_account
			, daysacct.account_number as days_account
			, case when tx.is_billed = 1 and isnull(tx.invoice_id,0) > 0 then 'Y'
				when tx.is_billed = 1 and isnull(tx.invoice_id,0) < 0 then 'N/A' else 'N' end as billed
			, tx.comment
			, tx.cheque_number
			, case when libcc.adjustment_type is not null and tx.transaction_type = 'X' then libcc.transaction_type + '_' + libcc.adjustment_type 
				when recur.transaction_id is not null then 'Recur'
				when tx.mppr_flag = 1 or convert(bit, case when bump.bumpup_transaction_id is null then 0 else 1 end) = 'true' then 'MPPR'
				else tx.transaction_type end as adjusted_tx_type
			, case when recur.transaction_id is null then 0 else 1 end as recurring_tx
			, case when tx.reversing_tx_id is null then 0 else 1 end as reversed
			, tx.transaction_type_group
			, 0 as ancillary_year
			, 0 as ancillary_month
			, 0 as balance_due
			, 0 as other_payer
			, NULL as aging_total
			, NULL as aging_current_label
			, NULL as aging_current_amount
			, NULL as aging_30_label
			, NULL as aging_30_amount
			, NULL as aging_60_label
			, NULL as aging_60_amount
			, NULL as aging_90_label
			, NULL as aging_90_amount
			, NULL as aging_120_label
			, NULL as aging_120_amount
			, NULL as aging_150_label
			, NULL as aging_150_amount
			, NULL as aging_180_label
			, NULL as aging_180_amount
			, NULL as aging_210_label
			, NULL as aging_210_amount
			, 0 as detail_order				
		FROM #local_transactions tx with (nolock)
		inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
		inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
		inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'  
		left join dbo.ar_transactions_location_room roomLocation with (nolock) on roomLocation.transaction_id = tx.transaction_id   
		left join dbo.ar_transaction_recurring_tx_refs recur with (nolock) on tx.transaction_id = recur.transaction_id
		left join dbo.ar_recurring_transactions rtx with (nolock) on rtx.transaction_id = recur.recurring_tx_id
		left join dbo.ar_batch batch with (nolock) on tx.batch_id = batch.batch_id
		left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
		left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
		left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
		left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
		left join dbo.ar_mppr_bumpup bump with (nolock) on tx.distribution_tx_id = bump.bumpup_transaction_id  
		WHERE 
			tx.transaction_type <> 'A' and tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA')

		If @vPrivateStatementsIncluded = 1 
			begin
				INSERT INTO #transactions		
				SELECT 
					  --concl.invoice_id
					 min(concl.invoice_id) as invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					--, case when tx.is_billed = 0 then 'Ancillary Charges' else 
					--	'Ancillary Charges ' + convert(varchar(3), tx.bill_date,100) +' ' + convert(varchar(4),datepart(yyyy,tx.bill_date),100) end as detail_description
					, Case when min(tx.effective_date) <> max(tx.effective_date) then 'Ancillary Charges: ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else 'Ancillary Charge(s)' end as detail_description
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, '' as transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, 'A' as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.bill_date) as ancillary_year
					, datepart(mm,tx.bill_date) as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
				FROM #local_transactions tx with (nolock)
				inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					tx.transaction_type = 'A' and concl.contact_id > -2.1
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.transaction_type, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date)

				INSERT INTO #transactions	
				SELECT 
					  min(concl.invoice_id) as invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then  tx.description +': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else tx.description end as detail_description
					--, tx.description as detail_description
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, '' as transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, 'A' as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.bill_date) as ancillary_year
					, datepart(mm,tx.bill_date) as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
				FROM #local_transactions tx with (nolock)
				inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA' and concl.contact_id > -2.1
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.transaction_type, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date), tx.description 
		end

	if @vOtherStatementsIncluded = 1 
		begin
			INSERT INTO #transactions		
				SELECT 
					 concl.invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					--, case when tx.is_billed = 0 then 'Ancillary Charges' else 
					--	'Ancillary Charges ' + convert(varchar(3), tx.bill_date,100) +' ' + convert(varchar(4),datepart(yyyy,tx.bill_date),100) end as detail_description
					, Case when min(tx.effective_date) <> max(tx.effective_date) then 'Ancillary Charges: ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else 'Ancillary Charge(s)' end as detail_description
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, '' as transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, 'A' as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.bill_date) as ancillary_year
					, datepart(mm,tx.bill_date) as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
				FROM #local_transactions tx with (nolock)
				inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					tx.transaction_type = 'A' and concl.contact_id <= -2.1
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.transaction_type, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.invoice_id, concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date)

				INSERT INTO #transactions	
				SELECT 
					  concl.invoice_id 
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then  tx.description +': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else tx.description end as detail_description
					--, tx.description as detail_description
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, '' as transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, 'A' as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.bill_date) as ancillary_year
					, datepart(mm,tx.bill_date) as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
				FROM #local_transactions tx with (nolock)
				inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA' and concl.contact_id <= -2.1
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.transaction_type, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.invoice_id, concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date), tx.description 
		end

	end

if @vShowResults = 'C'

	begin

		INSERT INTO #transactions	
		SELECT 
			  concl.invoice_id
			, tx.fac_id
			, concl.contact_id
			, concl.contact_num
			, tx.client_id
			, tx.payer_id
			, libpayer.description AS payer
			, libpayer.payer_type
			, tx.batch_id
			, tx.entry_number
			, tx.distribution_tx_id
			, tx.transaction_id
			, tx.reversing_tx_id
			, isnull(tx.auto_generated, 'N') as auto_generated
			, concl.bill_date
			, tx.transaction_date as posting_date
			, tx.effective_date
			, Null as effective_from_date
			, Null as effective_thru_date
			, tx.generated_date
			, libcc.charge_code
			, isnull(rtx.charge_frequency,'O') as frequency
			, tx.revenue_code
			, tx.hcpcs_code
			, tx.mppr_flag
			, Case when tx.transaction_type = 'R' and isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> '' 
					then rtype.long_description + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then 
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' + convert(varchar(4),YEAR(tx.effective_date))
					end) 
					+ (case when isnull(arpayer.show_care_level,'N') = 'Y'  and isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
				and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') = ''  
				and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'CL' and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X','CA') and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' then tx.description
				when tx.transaction_type ='CA' and isnull(tx.alt_description,'')='' then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')'
				when tx.transaction_type = 'CO' and tx.parent_tx_type <> 'R' then tx.description --+  ' Coinsurance'
				when tx.transaction_type = 'XR' and tx.parent_tx_type ='A' then tx.description --+  ' Reimb. Reduction' 
				when tx.transaction_type = 'CX' and tx.parent_tx_type ='R' then 'Room Excess' 
				when (tx.transaction_type in('XR','CO', 'D', 'CR') or (tx.transaction_type = 'CL' and isnull(tx.alt_description,'')='')) and tx.parent_tx_type = 'R' then
				(Case 
					when isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> ''  
						then rtype.long_description + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(arpayer.show_care_level,'N') = 'Y' and isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
						and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' +
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then  
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'XR'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'CO'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else
							' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end) --+ ' Coinsurance'
					else 
						(case when tx.transaction_type = 'XR' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
							(case when abs(tx.days_amount) > 1 then
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else  ' ' +	convert(varchar(4),YEAR(tx.effective_date))
							end)
						else 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') +
							(case when abs(tx.days_amount) > 1 then 
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else ' ' + convert(varchar(4),YEAR(tx.effective_date))
							end) --+
							--(case when tx.transaction_type = 'D' then ' Deductible' 
							--	when tx.transaction_type = 'CO' then ' Coinsurance' else '' end)  
						end)
					end
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				) --+ (case when tx.transaction_type = 'CL' then ' Coverage Deductible' else '' end) 
				 --+ (case when tx.transaction_type = 'CR' then ' Contractural Adj.' else '' end) 
				else tx.description end as detail_description
			, tx.care_level
			, Case when tx.transaction_type = 'R' and libpayer.pps_flag='Y' then ltrim(rtrim(str(tx.medicare_day))) + '-' 
				+ltrim(rtrim(str((
					case when tx.days_amount < 0 and (tx.days_amount*-1) > 1 then tx.days_amount*-1 + tx.medicare_day -1
					when tx.days_amount > 0 and (tx.days_amount*-1) = 1 then tx.days_amount*-1  + tx.medicare_day
					when tx.days_amount > 1 then tx.days_amount + tx.medicare_day -1
					else tx.days_amount + tx.medicare_day end))))
				else Null
					end as benefit_days
			, tx.parent_tx_type
			, tx.transaction_type
			, tx.daily_rate as unit_amount
			, case when tx.transaction_type = 'XR' then Null else tx.days_amount end as number_of_units
			, tx.amount
			, acct.account_number as gl_account
			, daysacct.account_number as days_account
			, case when tx.is_billed = 1 and isnull(tx.invoice_id,0) > 0 then 'Y'
				when tx.is_billed = 1 and isnull(tx.invoice_id,0) < 0 then 'N/A' else 'N' end as billed
			, tx.comment
			, tx.cheque_number
			, case when libcc.adjustment_type is not null and tx.transaction_type = 'X' then libcc.transaction_type + '_' + libcc.adjustment_type 
				when recur.transaction_id is not null then 'Recur'
				when tx.mppr_flag = 1 or convert(bit, case when bump.bumpup_transaction_id is null then 0 else 1 end) = 'true' then 'MPPR'
				else tx.transaction_type end as adjusted_tx_type
			, case when recur.transaction_id is null then 0 else 1 end as recurring_tx
			, case when tx.reversing_tx_id is null then 0 else 1 end as reversed
			, tx.transaction_type_group	
			, 0 as ancillary_year
			, 0 as ancillary_month	
			, 0 as balance_due
			, 0 as other_payer
			, NULL as aging_total
			, NULL as aging_current_label
			, NULL as aging_current_amount
			, NULL as aging_30_label
			, NULL as aging_30_amount
			, NULL as aging_60_label
			, NULL as aging_60_amount
			, NULL as aging_90_label
			, NULL as aging_90_amount
			, NULL as aging_120_label
			, NULL as aging_120_amount
			, NULL as aging_150_label
			, NULL as aging_150_amount
			, NULL as aging_180_label
			, NULL as aging_180_amount
			, NULL as aging_210_label
			, NULL as aging_210_amount
			, 0 as detail_order		
		FROM #local_transactions tx with (nolock)
		inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
		inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
		inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'
		left join dbo.ar_transactions_location_room roomLocation with (nolock) on roomLocation.transaction_id = tx.transaction_id     
		left join dbo.ar_transaction_recurring_tx_refs recur with (nolock) on tx.transaction_id = recur.transaction_id
		left join dbo.ar_recurring_transactions rtx with (nolock) on rtx.transaction_id = recur.recurring_tx_id
		left join dbo.ar_batch batch with (nolock) on tx.batch_id = batch.batch_id
		left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
		left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
		left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
		left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
		left join dbo.ar_mppr_bumpup bump with (nolock) on tx.distribution_tx_id = bump.bumpup_transaction_id  
		WHERE 
			libcc.charge_code_id is null and tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA')

		If @vPrivateStatementsIncluded = 1 
			begin

				INSERT INTO #transactions	
				SELECT 
					  min(concl.invoice_id) as invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, libcc.charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')<>'' then 
						--(Case when min(tx.effective_date) <> max(tx.effective_date) then 
						--	'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + tx.alt_description
						(Case when min(tx.effective_date) <> max(tx.effective_date) then tx.alt_description + ': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else
							tx.alt_description 
						end)
						else 
						--(Case when min(tx.effective_date) <> max(tx.effective_date) then 
						--	'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + libcc.description
						(Case when min(tx.effective_date) <> max(tx.effective_date) then libcc.description + ': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')

						else
							libcc.description
						end)
						end as detail_description	
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
					FROM #local_transactions tx with (nolock)
					inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					left join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					where tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA') and concl.invoice_id > -2.1
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.parent_tx_type, tx.transaction_type, tx.care_level, libcc.charge_code 
					,tx.alt_description, libcc.description, tx.is_billed, tx.transaction_type_group, tx.bill_date, concl.contact_id, concl.contact_num, concl.bill_date, tx.generated_date
					, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date)

				INSERT INTO #transactions	
				SELECT 
					  min(concl.invoice_id) as invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then  tx.description +': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else tx.description end as detail_description
					--, tx.description as detail_description
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, tx.transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.bill_date) as ancillary_year
					, datepart(mm,tx.bill_date) as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
				FROM #local_transactions tx with (nolock)
				inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					libcc.charge_code_id is null and tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA' and concl.invoice_id > -2.1
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.transaction_type, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date), tx.description 

			end

		If @vOtherStatementsIncluded = 1 
			begin

				INSERT INTO #transactions	
				SELECT 
					  concl.invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, libcc.charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')<>'' then 
						--(Case when min(tx.effective_date) <> max(tx.effective_date) then 
						--	'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + tx.alt_description
						(Case when min(tx.effective_date) <> max(tx.effective_date) then tx.alt_description + ': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else
							tx.alt_description 
						end)
						else 
						--(Case when min(tx.effective_date) <> max(tx.effective_date) then 
						--	'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + libcc.description
						(Case when min(tx.effective_date) <> max(tx.effective_date) then libcc.description + ': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')

						else
							libcc.description
						end)
						end as detail_description	
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
					FROM #local_transactions tx with (nolock)
					inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					left join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					where tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA') and concl.invoice_id <= -2.1
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.parent_tx_type, tx.transaction_type, tx.care_level, libcc.charge_code 
					,tx.alt_description, libcc.description, tx.is_billed, tx.transaction_type_group, tx.bill_date, concl.contact_id, concl.contact_num, concl.invoice_id, concl.bill_date, tx.generated_date
					, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date)

				INSERT INTO #transactions	
				SELECT 
					  concl.invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then  tx.description +': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else tx.description end as detail_description
					--, tx.description as detail_description
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, tx.transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.bill_date) as ancillary_year
					, datepart(mm,tx.bill_date) as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
				FROM #local_transactions tx with (nolock)
				inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					libcc.charge_code_id is null and tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA' and concl.invoice_id <= -2.1
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.transaction_type, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.invoice_id, concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date), tx.description 

			end

	end

if @vShowResults = 'CC'

	begin

		INSERT INTO #transactions	
		SELECT 
			  concl.invoice_id
			, tx.fac_id
			, concl.contact_id
			, concl.contact_num
			, tx.client_id
			, tx.payer_id
			, libpayer.description AS payer
			, libpayer.payer_type
			, tx.batch_id
			, tx.entry_number
			, tx.distribution_tx_id
			, tx.transaction_id
			, tx.reversing_tx_id
			, isnull(tx.auto_generated, 'N') as auto_generated
			, concl.bill_date
			, tx.transaction_date as posting_date
			, tx.effective_date
			, Null as effective_from_date
			, Null as effective_thru_date
			, tx.generated_date
			, libcc.charge_code
			, isnull(rtx.charge_frequency,'O') as frequency
			, tx.revenue_code
			, tx.hcpcs_code
			, tx.mppr_flag
			, Case when tx.transaction_type = 'R' and isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> '' 
					then rtype.long_description + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then 
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' + convert(varchar(4),YEAR(tx.effective_date))
					end) 
					+ (case when isnull(arpayer.show_care_level,'N') = 'Y'  and isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
				and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') = ''  
				and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'CL' and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X','CA') and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' then tx.description
				when tx.transaction_type ='CA' and isnull(tx.alt_description,'')='' then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')'
				when tx.transaction_type = 'CO' and tx.parent_tx_type <> 'R' then tx.description --+  ' Coinsurance'
				when tx.transaction_type = 'XR' and tx.parent_tx_type ='A' then tx.description --+  ' Reimb. Reduction' 
				when tx.transaction_type = 'CX' and tx.parent_tx_type ='R' then 'Room Excess' 
				when (tx.transaction_type in('XR','CO', 'D', 'CR') or (tx.transaction_type = 'CL' and isnull(tx.alt_description,'')='')) and tx.parent_tx_type = 'R' then
				(Case 
					when isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> ''  
						then rtype.long_description + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(arpayer.show_care_level,'N') = 'Y' and isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
						and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' +
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then  
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'XR'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'CO'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else
							' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + (case when isnull(tx.care_level,'') <> '' then ' (' +isnull(tx.care_level,'') + ')' else '' end) --+ ' Coinsurance'
					else 
						(case when tx.transaction_type = 'XR' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
							(case when abs(tx.days_amount) > 1 then
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else  ' ' +	convert(varchar(4),YEAR(tx.effective_date))
							end)
						else 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') +
							(case when abs(tx.days_amount) > 1 then 
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else ' ' + convert(varchar(4),YEAR(tx.effective_date))
							end) --+
							--(case when tx.transaction_type = 'D' then ' Deductible' 
							--	when tx.transaction_type = 'CO' then ' Coinsurance' else '' end)  
						end)
					end
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				) --+ (case when tx.transaction_type = 'CL' then ' Coverage Deductible' else '' end) 
				 --+ (case when tx.transaction_type = 'CR' then ' Contractural Adj.' else '' end) 
				else tx.description end as detail_description
			, tx.care_level
			, Case when tx.transaction_type = 'R' and libpayer.pps_flag='Y' then ltrim(rtrim(str(tx.medicare_day))) + '-' 
				+ltrim(rtrim(str((
					case when tx.days_amount < 0 and (tx.days_amount*-1) > 1 then tx.days_amount*-1 + tx.medicare_day -1
					when tx.days_amount > 0 and (tx.days_amount*-1) = 1 then tx.days_amount*-1  + tx.medicare_day
					when tx.days_amount > 1 then tx.days_amount + tx.medicare_day -1
					else tx.days_amount + tx.medicare_day end))))
				else Null
					end as benefit_days
			, tx.parent_tx_type
			, tx.transaction_type
			, tx.daily_rate as unit_amount
			, case when tx.transaction_type = 'XR' then Null else tx.days_amount end as number_of_units
			, tx.amount
			, acct.account_number as gl_account
			, daysacct.account_number as days_account
			, case when tx.is_billed = 1 and isnull(tx.invoice_id,0) > 0 then 'Y'
				when tx.is_billed = 1 and isnull(tx.invoice_id,0) < 0 then 'N/A' else 'N' end as billed
			, tx.comment
			, tx.cheque_number
			, case when libcc.adjustment_type is not null and tx.transaction_type = 'X' then libcc.transaction_type + '_' + libcc.adjustment_type 
				when recur.transaction_id is not null then 'Recur'
				when tx.mppr_flag = 1 or convert(bit, case when bump.bumpup_transaction_id is null then 0 else 1 end) = 'true' then 'MPPR'
				else tx.transaction_type end as adjusted_tx_type
			, case when recur.transaction_id is null then 0 else 1 end as recurring_tx
			, case when tx.reversing_tx_id is null then 0 else 1 end as reversed
			, tx.transaction_type_group	
			, 0 as ancillary_year
			, 0 as ancillary_month	
			, 0 as balance_due
			, 0 as other_payer
			, NULL as aging_total
			, NULL as aging_current_label
			, NULL as aging_current_amount
			, NULL as aging_30_label
			, NULL as aging_30_amount
			, NULL as aging_60_label
			, NULL as aging_60_amount
			, NULL as aging_90_label
			, NULL as aging_90_amount
			, NULL as aging_120_label
			, NULL as aging_120_amount
			, NULL as aging_150_label
			, NULL as aging_150_amount
			, NULL as aging_180_label
			, NULL as aging_180_amount
			, NULL as aging_210_label
			, NULL as aging_210_amount
			, 0 as detail_order		
		FROM #local_transactions tx with (nolock)
		inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
		inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
		inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
		left join dbo.ar_transactions_location_room roomLocation with (nolock) on roomLocation.transaction_id = tx.transaction_id  
		left join dbo.ar_transaction_recurring_tx_refs recur with (nolock) on tx.transaction_id = recur.transaction_id
		left join dbo.ar_recurring_transactions rtx with (nolock) on rtx.transaction_id = recur.recurring_tx_id
		left join dbo.ar_batch batch with (nolock) on tx.batch_id = batch.batch_id
		left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
		left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
		left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
		left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
		left join dbo.ar_mppr_bumpup bump with (nolock) on tx.distribution_tx_id = bump.bumpup_transaction_id  
		WHERE 
			libcc.charge_code_id is null and tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA')

		If @vPrivateStatementsIncluded = 1 
			begin

				INSERT INTO #transactions	
				SELECT 
					  min(concl.invoice_id) as invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					--, Case when min(tx.effective_date) <> max(tx.effective_date) then 
					--		'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + cat.cat_description
					, Case when min(tx.effective_date) <> max(tx.effective_date) then cat.cat_description + ': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else
							cat.cat_description
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month
					, 0 as balance_due	
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order	
					FROM #local_transactions tx with (nolock)
					inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					inner join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					where tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA') and concl.invoice_id > -2.1
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.parent_tx_type,
					tx.transaction_type, tx.care_level, cat.item_cat_id, cat.cat_description,tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date)

				INSERT INTO #transactions	
				SELECT 
					  min(concl.invoice_id) as invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					--, Case when min(tx.effective_date) <> max(tx.effective_date) then 
					--		'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + libcc.description
					, Case when min(tx.effective_date) <> max(tx.effective_date) then libcc.description + ' ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else
							libcc.description
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
					FROM #local_transactions tx with (nolock)
					inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					left join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					where cat.item_cat_id is null and tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA') and concl.invoice_id > -2.1
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.parent_tx_type,
					tx.transaction_type, tx.care_level, libcc.charge_code, libcc.description, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date)

				INSERT INTO #transactions	
				SELECT 
					  min(concl.invoice_id) as invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then  tx.description +': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else tx.description end as detail_description
					--, tx.description as detail_description
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, tx.transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.bill_date) as ancillary_year
					, datepart(mm,tx.bill_date) as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
				FROM #local_transactions tx with (nolock)
				inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					libcc.charge_code_id is null and tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA' and concl.invoice_id > -2.1
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.transaction_type, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date), tx.description

			end

		If @vOtherStatementsIncluded = 1 
			begin

				INSERT INTO #transactions	
				SELECT 
					  concl.invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					--, Case when min(tx.effective_date) <> max(tx.effective_date) then 
					--		'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + cat.cat_description
					, Case when min(tx.effective_date) <> max(tx.effective_date) then cat.cat_description + ': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else
							cat.cat_description
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month
					, 0 as balance_due	
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order	
					FROM #local_transactions tx with (nolock)
					inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					inner join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					where tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA') and concl.invoice_id <= -2.1
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.parent_tx_type,
					tx.transaction_type, tx.care_level, cat.item_cat_id, cat.cat_description,tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.invoice_id, concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date)

				INSERT INTO #transactions	
				SELECT 
					  concl.invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					--, Case when min(tx.effective_date) <> max(tx.effective_date) then 
					--		'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + libcc.description
					, Case when min(tx.effective_date) <> max(tx.effective_date) then libcc.description + ' ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else
							libcc.description
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
					FROM #local_transactions tx with (nolock)
					inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					left join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					where cat.item_cat_id is null and tx.transaction_type <> 'TA' and not (tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA') and concl.invoice_id <= -2.1
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.parent_tx_type,
					tx.transaction_type, tx.care_level, libcc.charge_code, libcc.description, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.invoice_id, concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date)

				INSERT INTO #transactions	
				SELECT 
					  concl.invoice_id
					, tx.fac_id
					, concl.contact_id
					, concl.contact_num
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, libpayer.payer_type
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, 0 as reversing_tx_id
					, '' as auto_generated
					, concl.bill_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, tx.generated_date
					, '' as charge_code
					, '' as frequency
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then  tx.description +': ' + format(min(tx.effective_date),'MMM dd') + '-' + format(max(tx.effective_date),'dd')
						else tx.description end as detail_description
					--, tx.description as detail_description
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, tx.transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.bill_date) as ancillary_year
					, datepart(mm,tx.bill_date) as ancillary_month
					, 0 as balance_due
					, 0 as other_payer
					, NULL as aging_total
					, NULL as aging_current_label
					, NULL as aging_current_amount
					, NULL as aging_30_label
					, NULL as aging_30_amount
					, NULL as aging_60_label
					, NULL as aging_60_amount
					, NULL as aging_90_label
					, NULL as aging_90_amount
					, NULL as aging_120_label
					, NULL as aging_120_amount
					, NULL as aging_150_label
					, NULL as aging_150_amount
					, NULL as aging_180_label
					, NULL as aging_180_amount
					, NULL as aging_210_label
					, NULL as aging_210_amount
					, 0 as detail_order		
				FROM #local_transactions tx with (nolock)
				inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					libcc.charge_code_id is null and tx.transaction_type = 'CO' and tx.parent_tx_type = 'CA' and concl.invoice_id <= -2.1
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.transaction_type, tx.is_billed, tx.transaction_type_group, tx.bill_date, tx.generated_date,
					concl.invoice_id, concl.contact_id, concl.contact_num, concl.bill_date, datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date), tx.description

			end

	end

--summarize Tax transactions
INSERT INTO #transactions	
SELECT 
	  concl.invoice_id
	, tx.fac_id
	, concl.contact_id
	, concl.contact_num
	, tx.client_id
	, tx.payer_id
	, libpayer.description AS payer
	, libpayer.payer_type
	, tx.batch_id
	, 0 as entry_number
	, 0 as distribution_tx_id
	, 0 as transaction_id
	, 0 as reversing_tx_id
	, isnull(tx.auto_generated, 'N') as auto_generated
	, concl.bill_date
	, tx.transaction_date as posting_date
	, max(tx.effective_date)
	, Null as effective_from_date
	, Null as effective_thru_date
	, tx.generated_date
	, '' as charge_code
	, 'O' as frequency
	, tx.revenue_code
	, tx.hcpcs_code
	, tx.mppr_flag
	, tx.description
	, tx.care_level
	, 0 as benefit_days
	, tx.parent_tx_type
	, tx.transaction_type
	, Null as unit_amount
	, Null as number_of_units
	, sum(tx.amount) as amount
	, acct.account_number as gl_account
	, daysacct.account_number as days_account
	, 'Y' as billed
	, tx.comment
	, tx.cheque_number
	, tx.transaction_type as adjusted_tx_type
	, 0 as recurring_tx
	, 0 as reversed
	, tx.transaction_type_group	
	, 0 as ancillary_year
	, 0 as ancillary_month	
	, 0 as balance_due
	, 0 as other_payer
	, NULL as aging_total
	, NULL as aging_current_label
	, NULL as aging_current_amount
	, NULL as aging_30_label
	, NULL as aging_30_amount
	, NULL as aging_60_label
	, NULL as aging_60_amount
	, NULL as aging_90_label
	, NULL as aging_90_amount
	, NULL as aging_120_label
	, NULL as aging_120_amount
	, NULL as aging_150_label
	, NULL as aging_150_amount
	, NULL as aging_180_label
	, NULL as aging_180_amount
	, NULL as aging_210_label
	, NULL as aging_210_amount
	, 0 as detail_order		
FROM #local_transactions tx with (nolock)
inner join #contact_clients concl with (nolock) on tx.invoice_id = concl.invoice_id and tx.contact_id = concl.contact_id
inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
where tx.transaction_type = 'TA'
group by concl.invoice_id, tx.fac_id, concl.contact_id, concl.contact_num, tx.client_id, tx.payer_id, libpayer.description, libpayer.payer_type, tx.batch_id
, isnull(tx.auto_generated, 'N'), concl.bill_date, tx.generated_date, tx.transaction_date, tx.effective_date, tx.revenue_code, tx.hcpcs_code, tx.mppr_flag, tx.description, tx.care_level
, tx.parent_tx_type, tx.transaction_type, acct.account_number, daysacct.account_number, tx.comment, tx.cheque_number, tx.transaction_type_group	

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 150
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' removing reversals that have been combined from different invoices ' + convert(varchar(26),getdate(),109)

delete  rev
from #transactions rev
inner join #transactions rev2 on rev.transaction_id = rev2.reversing_tx_id and rev.transaction_id > 0 
	and rev.contact_num = rev2.contact_num and rev.client_id = rev2.client_id

set @vRowCount = @@rowcount

if @debug_me='Y' Print ltrim(rtrim(str(@vRowCount)))+' combined reversing rows removed.'
	

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 160
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' calculating balance forwards ' + convert(varchar(26),getdate(),109)

If @vPrivateStatementsIncluded = 1 -- calculate BF's for private statements as they are included
begin	

	insert into #transactions
	select 
		  min(concl.invoice_id) as invoice_id
		, concl.summary_fac_id
		, concl.contact_id
		, concl.contact_num
		, concl.client_id
		, concl.payer_id
		, '' as payer
		, '' as payer_type
		, Null as batch_id
		, Null as entry_number
		, Null as distribution_tx_id
		, Null as transaction_id
		, Null as reversing_tx_id
		, Null as auto_generated
		, Null as bill_date
		, Null as posting_date	
		, Null as effective_date
		, Null as effective_from_date
		, Null as effective_thru_date	
		, Null as generated_date	
		, Null as charge_code
		, Null as frequency
		, Null as revenue_code
		, Null as hcpcs_code
		, Null as mppr_flag
		, 'BALANCE FORWARD' as tx_description
		, Null as care_level		
		, Null as benefit_days
		, Null as parent_tx_type
		, '00' as transaction_type
		, Null as unit_amount
		, Null as units
		, 0.0 as amount
		, Null as gl_account
		, Null as days_account
		, Null as billed
		, '' as comment
		, '' as cheque_number
		, Null as adjusted_tx_type
		, Null as recurring_tx
		, Null as reversed
		, Null as transaction_type_group
		, 0 as ancillary_year
		, 0 as ancillary_month
		, 0 as balance_due
		, 0 as other_payer
		, NULL as aging_total
		, NULL as aging_current_label
		, NULL as aging_current_amount
		, NULL as aging_30_label
		, NULL as aging_30_amount
		, NULL as aging_60_label
		, NULL as aging_60_amount
		, NULL as aging_90_label
		, NULL as aging_90_amount
		, NULL as aging_120_label
		, NULL as aging_120_amount
		, NULL as aging_150_label
		, NULL as aging_150_amount
		, NULL as aging_180_label
		, NULL as aging_180_amount
		, NULL as aging_210_label
		, NULL as aging_210_amount
		, 0 as detail_order
			
	from #contact_clients concl
	where concl.contact_id > -2.1
	group by  concl.contact_id, concl.contact_num, concl.summary_fac_id, concl.client_id, concl.bill_date, concl.payer_id

	insert into #balance_forward_union 
	SELECT 
		  clientInv.contact_id
		, clientInv.contact_num
		, clientInv.client_id
		, 0--clientInv.invoice_id
		, clientInv.bill_date
		, ''
		, SUM(txn.amount) as amount	
	FROM dbo.ar_transactions txn WITH (NOLOCK)
	inner join (select distinct contact_id, contact_num, client_id, bill_date from #contact_clients where contact_id > -2.1) clientInv
		on clientInv.client_id = txn.client_id
	join dbo.ar_invoice invoice WITH (NOLOCK) ON invoice.invoice_id = txn.invoice_id --and clientInv.invoice_id<>invoice.invoice_id
		and invoice.deleted = 'N'
		and invoice.trial_flag = 'N'
		and invoice.fac_id = txn.fac_id 
		--and invoice.effective_date < (dateadd(mm,-1, clientInv.bill_date))
		--and invoice.effective_date < (dateadd(dd,-1, clientInv.bill_date))
		and invoice.effective_date < clientInv.bill_date
		and txn.deleted = 'N'
	join dbo.ar_lib_payers libpayer WITH (NOLOCK) on libpayer.payer_id=txn.payer_id
			and libpayer.deleted = 'N' and ((libpayer.payer_type = 'Private' and libpayer.bill_form = 'private') or (libpayer.payer_type = 'Outpatient' and libpayer.outpatient_payer_type = 'Private'))
		--	--and libpayer.bill_form = 'private' and (libpayer.payer_type  = 'Private' OR libpayer.payer_type  = 'Outpatient')
	join dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id = libpayer.payer_id and payer.fac_id = txn.fac_id and (@vExportMode = 0 or (@vExportMode = 1 and payer.export_ps_flag = 'Y'))
	where txn.deleted='N' 
		and not (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
		and not (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate')             
	group by clientInv.contact_id, clientInv.contact_num, clientInv.client_id, clientInv.bill_date
	having SUM(txn.amount) <> 0

	union all

	SELECT 
		  clientInv.contact_id
		, clientInv.contact_num
		, clientInv.client_id
		, 0--clientInv.invoice_id
		, clientInv.bill_date
		, ''
		, SUM(txn.amount) as amount	
	FROM #transactions txn WITH (NOLOCK)
	inner join (select distinct contact_id, contact_num, client_id, bill_date,generated_date from #contact_clients where contact_id > -2.1) clientInv
		on clientInv.client_id = txn.client_id and clientInv.contact_id = txn.contact_id and clientInv.bill_date = txn.bill_date and txn.contact_id > -2.1
	inner join dbo.ar_invoice_statement invstat WITH (NOLOCK) ON txn.invoice_id = invstat.invoice_id and convert(varchar(10),invstat.generated_date, 101) < clientInv.generated_date
	left join (select invoice_id from #contact_clients where contact_id > -2.1 group by invoice_id having count(*) > 1) multinv on txn.invoice_id = multinv.invoice_id  
	where multinv.invoice_id is null     
	group by clientInv.contact_id, clientInv.contact_num, clientInv.client_id, clientInv.bill_date
	having SUM(txn.amount) <> 0

	union all

		SELECT 
		  clientInv.contact_id
		, clientInv.contact_num
		, clientInv.client_id
		, 0--clientInv.invoice_id
		, clientInv.bill_date
		, ''
		, SUM(txn.amount) as amount	
	FROM #transactions txn WITH (NOLOCK)
	inner join (select distinct contact_id, contact_num, client_id, bill_date,generated_date from #contact_clients where contact_id > -2.1) clientInv
		on clientInv.client_id = txn.client_id and clientInv.contact_id <> txn.contact_id and clientInv.bill_date = txn.bill_date and txn.contact_id > -2.1
	inner join dbo.ar_invoice_statement invstat WITH (NOLOCK) ON txn.invoice_id = invstat.invoice_id and convert(varchar(10),invstat.generated_date, 101) < clientInv.generated_date
	left join (select invoice_id from #contact_clients where contact_id > -2.1 group by invoice_id having count(*) > 1) multinv on txn.invoice_id = multinv.invoice_id  
	where multinv.invoice_id is null     
	group by clientInv.contact_id, clientInv.contact_num, clientInv.client_id, clientInv.bill_date
	having SUM(txn.amount) <> 0

	union all
--findme
	SELECT 
		  clientInv.contact_id
		, clientInv.contact_num
		, clientInv.client_id
		, 0--clientInv.invoice_id
		, clientInv.bill_date
		, ''
		, SUM(txn.amount) as amount	
	--select txn.*
	FROM #transactions txn WITH (NOLOCK)
	inner join (select distinct contact_id, contact_num, client_id, bill_date,generated_date from #contact_clients where contact_id > -2.1) clientInv
		on clientInv.client_id = txn.client_id and clientInv.contact_id = txn.contact_id and clientInv.bill_date = txn.bill_date and txn.contact_id > -2.1
	inner join dbo.ar_invoice_statement invstat WITH (NOLOCK) ON txn.invoice_id = invstat.invoice_id and convert(varchar(10),invstat.generated_date, 101) < clientInv.generated_date
	left join (select invoice_id from #contact_clients where contact_id > -2.1 group by invoice_id having count(*) > 1) multinv on txn.invoice_id = multinv.invoice_id  
	where multinv.invoice_id is not null     
	group by clientInv.contact_id, clientInv.contact_num, clientInv.client_id, clientInv.bill_date
	having SUM(txn.amount) <> 0

	union all
	
	SELECT 
		  clientInv.contact_id
		, clientInv.contact_num
		, clientInv.client_id
		, 0 
		, clientInv.bill_date
		, ''
		, SUM(txn.amount) as amount
	FROM dbo.ar_transactions txn WITH (NOLOCK)
		inner join (select distinct contact_id, contact_num, client_id, bill_date from #contact_clients where contact_id > -2.1) clientInv
			on clientInv.client_id = txn.client_id
		join dbo.ar_lib_payers libpayer WITH (NOLOCK) on libpayer.payer_id=txn.payer_id
			and libpayer.deleted = 'N' and ((libpayer.payer_type = 'Private' and libpayer.bill_form = 'private') or (libpayer.payer_type = 'Outpatient' and libpayer.outpatient_payer_type = 'Private'))
		--	--and libpayer.bill_form = 'private' and (libpayer.payer_type  = 'Private' OR libpayer.payer_type  = 'Outpatient')
		join dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id = libpayer.payer_id and payer.fac_id = txn.fac_id and (@vExportMode = 0 or (@vExportMode = 1 and payer.export_ps_flag = 'Y'))
	where txn.deleted='N' 
	and txn.invoice_id < 0 -- for 'mark as billed' -999
		and not (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
		and not (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate') 
		--and txn.effective_date < (dateadd(mm,-1, clientInv.bill_date))
	group by clientInv.contact_id, clientInv.contact_num, clientInv.client_id, clientInv.bill_date
	having SUM(txn.amount) <> 0

	if @vInvoiceIdList is not null
		begin

			INSERT INTO #balance_forward_union
			SELECT   
					  t.contact_id
					, t.contact_num
					, t.client_id
					, 0 
					, t.bill_date
					, ''
					, SUM(t.amount) as amount	
			FROM (
					SELECT DISTINCT 
					  txn.transaction_id
					, clientInv.contact_id
					, clientInv.contact_num
					, clientInv.client_id
					, clientInv.bill_date
					, txn.amount 
				FROM #contact_clients payr WITH (NOLOCK) 
				inner join dbo.ar_invoice inv WITH (NOLOCK) ON payr.client_id = inv.client_id and inv.deleted = 'N' and inv.trial_flag = 'N'
					and payr.inv_effective_date = inv.effective_date and payr.contact_id > -2.1
				inner join dbo.ar_invoice_statement invstat WITH (NOLOCK) ON inv.invoice_id = invstat.invoice_id 
				inner join dbo.ar_transactions txn WITH (NOLOCK) ON inv.invoice_id = txn.invoice_id and txn.deleted='N'
				inner join dbo.ar_lib_payers libpayer WITH (NOLOCK) ON txn.payer_id = libpayer.payer_id AND (libpayer.deleted = 'N') 
					and ((libpayer.payer_type = 'Private' and libpayer.bill_form = 'private') or (libpayer.payer_type = 'Outpatient' and libpayer.outpatient_payer_type = 'Private'))	
				join dbo.ar_payers payer WITH (NOLOCK) on inv.payer_id = payer.payer_id and inv.fac_id = payer.fac_id 
				inner join (select distinct contact_id, contact_num, client_id, bill_date,generated_date from #contact_clients where contact_id > -2.1) clientInv
					on payr.contact_id = clientInv.contact_id and payr.contact_num = clientInv.contact_num and payr.client_id = clientInv.client_id and convert(varchar(10),inv.effective_date , 101) = clientInv.bill_date
					and convert(varchar(10),invstat.generated_date,101) < convert(varchar(10),payr.generated_date , 101)
				left join #contact_clients invids on invids.client_id = payr.client_id and invids.payer_id = payr.payer_id and invids.bill_date = payr.bill_date
					and inv.invoice_id = invids.invoice_id
				where invids.invoice_id is null 
					and not (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
					and not (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate') 
				) t    
				group by t.contact_id, t.contact_num, t.client_id, t.bill_date 
				having SUM(t.amount) <> 0;

		end
end

if @vOtherStatementsIncluded = 1 -- calculate BF's for other payer statements as they are included
begin

	insert into #transactions
	select 
		  concl.invoice_id
		, concl.summary_fac_id
		, concl.contact_id
		, concl.contact_num
		, concl.client_id
		, concl.payer_id
		, '' as payer
		, '' as payer_type
		, Null as batch_id
		, Null as entry_number
		, Null as distribution_tx_id
		, Null as transaction_id
		, Null as reversing_tx_id
		, Null as auto_generated
		, Null as bill_date
		, Null as posting_date	
		, Null as effective_date
		, Null as effective_from_date
		, Null as effective_thru_date	
		, Null as generated_date	
		, Null as charge_code
		, Null as frequency
		, Null as revenue_code
		, Null as hcpcs_code
		, Null as mppr_flag
		, 'BALANCE FORWARD' as tx_description
		, Null as care_level		
		, Null as benefit_days
		, Null as parent_tx_type
		, '00' as transaction_type
		, Null as unit_amount
		, Null as units
		, 0.0 as amount
		, Null as gl_account
		, Null as days_account
		, Null as billed
		, '' as comment
		, '' as cheque_number
		, Null as adjusted_tx_type
		, Null as recurring_tx
		, Null as reversed
		, Null as transaction_type_group
		, 0 as ancillary_year
		, 0 as ancillary_month
		, 0 as balance_due
		, 0 as other_payer
		, NULL as aging_total
		, NULL as aging_current_label
		, NULL as aging_current_amount
		, NULL as aging_30_label
		, NULL as aging_30_amount
		, NULL as aging_60_label
		, NULL as aging_60_amount
		, NULL as aging_90_label
		, NULL as aging_90_amount
		, NULL as aging_120_label
		, NULL as aging_120_amount
		, NULL as aging_150_label
		, NULL as aging_150_amount
		, NULL as aging_180_label
		, NULL as aging_180_amount
		, NULL as aging_210_label
		, NULL as aging_210_amount
		, 0 as detail_order
			
	from #contact_clients concl
	where concl.contact_id <= -2.1

	insert into #balance_forward_union 
	SELECT 
		  clientInv.contact_id
		, clientInv.contact_num
		, clientInv.client_id
		, clientInv.payer_id
		, clientInv.bill_date
		, ''
		, SUM(txn.amount) as amount	
	FROM dbo.ar_transactions txn WITH (NOLOCK)
	inner join (select distinct contact_id, contact_num, client_id, payer_id, bill_date from #contact_clients where contact_id <= -2.1) clientInv
		on clientInv.client_id = txn.client_id and clientInv.payer_id = txn.payer_id
	join dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id=txn.payer_id and payer.fac_id=txn.fac_id
	join dbo.ar_invoice invoice WITH (NOLOCK) ON invoice.invoice_id = txn.invoice_id
		and invoice.deleted = 'N'
		and invoice.trial_flag = 'N'
		and invoice.fac_id = txn.fac_id 
		and invoice.effective_date < clientInv.bill_date
	where txn.deleted='N' 
		and not (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
		and not (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate')          
	group by clientInv.contact_id, clientInv.contact_num, clientInv.client_id, clientInv.payer_id, clientInv.bill_date
	having SUM(txn.amount) <> 0

	union all

	SELECT 
		  clientInv.contact_id
		, clientInv.contact_num
		, clientInv.client_id
		, clientInv.payer_id 
		, clientInv.bill_date
		, ''
		, SUM(txn.amount) as amount	
	--select txn.*
	FROM #transactions txn WITH (NOLOCK)
	inner join (select distinct contact_id, contact_num, client_id, payer_id, bill_date, invoice_id from #contact_clients where contact_id <= -2.1) clientInv
		on clientInv.client_id = txn.client_id and clientInv.payer_id = txn.payer_id and clientInv.bill_date = txn.bill_date --and clientInv.contact_id = txn.contact_id 
			and txn.contact_id <= -2.1 
	left join (select invoice_id from #contact_clients where contact_id <= -2.1 group by invoice_id having count(*) > 1) multinv on txn.invoice_id = multinv.invoice_id  
	where txn.invoice_id < clientInv.invoice_id and ((txn.contact_id = clientInv.contact_id and multinv.invoice_id is not null) or multinv.invoice_id is null)    
	--where txn.invoice_id < clientInv.invoice_id --and txn.contact_id = clientInv.contact_id
	group by clientInv.contact_id, clientInv.contact_num, clientInv.client_id, clientInv.payer_id, clientInv.bill_date, clientInv.invoice_id
	having SUM(txn.amount) <> 0

	union all

	SELECT 
		  clientInv.contact_id
		, clientInv.contact_num
		, clientInv.client_id
		, clientInv.payer_id 
		, clientInv.bill_date
		, ''
		, SUM(txn.amount) as amount
	FROM dbo.ar_transactions txn WITH (NOLOCK)
		inner join (select distinct contact_id, contact_num, client_id, payer_id, bill_date from #contact_clients where contact_id <= -2.1) clientInv
			on clientInv.client_id = txn.client_id and clientInv.payer_id = txn.payer_id 
		join dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id=txn.payer_id and payer.fac_id=txn.fac_id
	where txn.deleted='N' 
	and not (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
	and not (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate')    
	and txn.invoice_id < 0 -- for 'mark as billed' -999
	group by clientInv.contact_id, clientInv.contact_num, clientInv.client_id, clientInv.payer_id, clientInv.bill_date
	having SUM(txn.amount) <> 0

	if @vInvoiceIdList is not null
		begin
			INSERT INTO #balance_forward_union
			SELECT   
					  t.contact_id
					, t.contact_num
					, t.client_id
					, 0 
					, t.bill_date
					, ''
					, SUM(t.amount) as amount	
			FROM (
					SELECT DISTINCT 
					  txn.transaction_id
					, clientInv.contact_id
					, clientInv.contact_num
					, clientInv.client_id
					, clientInv.bill_date
					, txn.amount 
				FROM #contact_clients payr WITH (NOLOCK) 
				inner join dbo.ar_invoice inv WITH (NOLOCK) ON payr.client_id = inv.client_id and inv.deleted = 'N' and inv.trial_flag = 'N' 
					and payr.inv_effective_date = inv.effective_date and payr.contact_id <= -2.1
				inner join dbo.ar_transactions txn WITH (NOLOCK) ON inv.invoice_id = txn.invoice_id and txn.deleted='N'
				inner join dbo.ar_lib_payers libpayer WITH (NOLOCK) ON txn.payer_id = libpayer.payer_id AND (libpayer.deleted = 'N') 
					and libpayer.bill_form  = 'private' and libpayer.payer_type <> 'Private' and not( libpayer.payer_type = 'Outpatient' and outpatient_payer_type = 'Private')	
				join dbo.ar_payers payer WITH (NOLOCK) on inv.payer_id = payer.payer_id and inv.fac_id = payer.fac_id 
				inner join (select distinct contact_id, contact_num, client_id, bill_date,generated_date from #contact_clients where contact_id <= -2.1) clientInv
					on payr.contact_id = clientInv.contact_id and payr.contact_num = clientInv.contact_num and payr.client_id = clientInv.client_id and convert(varchar(10),inv.effective_date , 101) = clientInv.bill_date
				left join #contact_clients invids on invids.client_id = payr.client_id and invids.payer_id = payr.payer_id and invids.bill_date = payr.bill_date
					and inv.invoice_id = invids.invoice_id
				where invids.invoice_id is null 
					and not (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
					and not (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate') 
				) t    
				group by t.contact_id, t.contact_num, t.client_id, t.bill_date 
				having SUM(t.amount) <> 0;
		end
end

--------------------------------------------------------------------------------
-- CONSOLIDATE AMOUNT
-------------------------------------------------------------------------------- 

insert into #balance_forward_amount
select contact_id,contact_num,client_id,payer_id,invoice_date,payer_type,sum(amount)
from #balance_forward_union 
group by contact_id,contact_num,client_id,payer_id,invoice_date,payer_type
having sum(amount) <>0
order by contact_id,contact_num,client_id,invoice_date,payer_type

if @debug_me='Y' select * from #balance_forward_union order by contact_num, client_id
if @debug_me='Y' select * from #balance_forward_amount order by contact_num, client_id

update csd set csd.amount = bfttl.ttl
from #transactions csd
inner join (select bf.contact_num,bf.client_id,bf.payer_id,bf.invoice_date,sum(bf.amount) ttl 
	from #balance_forward_amount bf
	group by bf.contact_num,bf.client_id,bf.payer_id,bf.invoice_date) bfttl on csd.contact_num = bfttl.contact_num 
		and csd.client_id = bfttl.client_id and csd.payer_id = bfttl.payer_id
where csd.other_payer <> 1 and csd.transaction_type = '00'

update concl set concl.previous_balance_due = csd.amount
from #contact_clients concl
inner join #transactions csd on concl.contact_num = csd.contact_num and concl.client_id = csd.client_id and csd.transaction_type = '00' 

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 180
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' calculating other payer summary ' + convert(varchar(26),getdate(),109)

--OtherPayers

IF @vOtherPayerSummary = 1
    BEGIN

		SELECT DISTINCT client_id, bill_date INTO #OtherPayerInfo FROM #contact_clients where contact_id <> -2.1 and contact_id <> -3.1;
	    
		insert into #transactions (invoice_id, fac_id, contact_id, contact_num, client_id, transaction_type, tx_description, comment,
		amount, balance_due, other_payer, detail_order, bill_date, payer_type, effective_date)                            
                SELECT 
                            max(concl.invoice_id) as invoice_id
                            , concl.summary_fac_id
                            , concl.contact_id
                            , concl.contact_num
                            , concl.client_id
                            , 'YZ' as transaction_type
                            , libpayer.[description] as [description]
                            , '' as comment
                            , tx.amount as amount
                            , 0 as balance_due
                            , 1 as other_payer
                            --, libpayer.payer_type as payer_type
                            , 0 as detail_order
                            , concl.bill_date
							, libPayer.payer_type 
							, tx.effective_date as effective_date  
                FROM   #contact_clients concl
                INNER JOIN 
                (
				SELECT client_id,payer_id, bill_date, SUM(amount) amount, max(effective_date) as effective_date
                        FROM
                                (SELECT  
                                                t.client_id, 
                                                t.payer_id, 
                                                c.bill_date,
												t.effective_date,
                                                t.amount 
                                    FROM dbo.ar_transactions_rollup_client AS t WITH (NOLOCK)
                                    INNER JOIN #OtherPayerInfo c
                                    ON t.client_id = c.client_id AND t.effective_date < DATEADD(dd,1, c.bill_date)
                                    INNER JOIN dbo.ar_lib_payers libpayer WITH (NOLOCK)  
                                    ON t.payer_id = libpayer.payer_id AND libPayer.deleted = 'N' 
                                    AND isnull(libpayer.informational_payer_flag,0) = 1
									AND (isnull(libpayer.informational_payer_use_standard_rate, 0) = 0 or t.transaction_type <> 'CR')
                                    UNION ALL
                                    SELECT
                                                t.client_id, 
                                                t.payer_id,
                                                c.bill_date,
												t.effective_date,
                                                (CASE WHEN t.transaction_type = 'C' THEN - 1 * h.amount ELSE t .amount END) AS amount 
                                    FROM dbo.ar_transactions AS t WITH (NOLOCK)
                                    INNER JOIN #OtherPayerInfo c
                                    ON t.client_id = c.client_id
                                    INNER JOIN dbo.ar_lib_payers libpayer WITH (NOLOCK)  
                                    ON t.payer_id = libpayer.payer_id AND libPayer.deleted = 'N' 
                                    AND isnull(libpayer.informational_payer_flag,0) = 1 
									AND (isnull(libpayer.informational_payer_use_standard_rate, 0) = 0 or t.transaction_type <> 'CR') 
                                    LEFT JOIN dbo.ar_applied_payment_history AS h WITH (NOLOCK) 
                                    ON h.transaction_id = t.transaction_id 
                                    AND h.fac_id = t.fac_id AND ISNULL(h.deleted, 'N') = 'N' 
                                    AND h.current_period_date IS NOT NULL
                                    WHERE t.deleted = 'N' AND (CASE WHEN t.transaction_type = 'C' THEN h.applied_to_date ELSE t.effective_date END) < DATEADD(dd,1, c.bill_date)
                                                AND t.payer_id > 0 AND t.transaction_date IS NOT NULL 
                                                AND t.OpenClose_Flag = 'O'
                                    UNION ALL
                                    SELECT 
                                                h.client_id, 
                                                h.payer_id,
                                                c.bill_date,
												h.applied_to_date as effective_date,
                                                - (1 * h.amount) AS amount
                                    FROM dbo.ar_applied_payment_history AS h WITH (NOLOCK)
                                    INNER JOIN #OtherPayerInfo c
                                    ON h.client_id = c.client_id and  h.applied_to_date < DATEADD(dd,1,c.bill_date) 
                                    INNER JOIN dbo.ar_lib_payers libpayer WITH (NOLOCK)  
                                    ON h.payer_id = libpayer.payer_id AND libPayer.deleted = 'N' 
                                    AND isnull(libpayer.informational_payer_flag,0) = 1
                                    WHERE h.deleted = 'N' 
                                    AND h.payer_id > 0 AND h.transaction_id = -1 
                                    AND h.OpenClose_Flag = 'O'
                                    ) op
                                GROUP BY client_id, payer_id, bill_date
                                --HAVING SUM(amount) <> 0

                ) tx         
                ON concl.client_id = tx.client_id  AND tx.bill_date= concl.bill_date and concl.contact_id <> -2.1 and concl.contact_id <> -3.1
                INNER JOIN dbo.ar_lib_payers libpayer WITH (NOLOCK)  
                ON tx.payer_id = libpayer.payer_id AND libPayer.deleted = 'N' 
                AND isnull(libpayer.informational_payer_flag,0) = 1
				WHERE tx.amount > 0 
                GROUP BY concl.contact_id, tx.amount,concl.contact_num, concl.summary_fac_id, concl.client_id, libpayer.[description], libPayer.payer_type, concl.bill_date,tx.effective_date

            update csd set csd.balance_due = csdttl.ttl
            from #transactions csd
            inner join (select contact_id, contact_num, invoice_id, bill_date ,sum(amount) ttl from #transactions 
            where other_payer = 1 group by contact_id, contact_num, invoice_id, bill_date) csdttl on 
            csd.invoice_id = csdttl.invoice_id and csd.contact_id = csdttl.contact_id and csd.contact_num = csdttl.contact_num 
            and csd.bill_date = csdttl.bill_date and csd.other_payer = 1;

        END 

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
--select * from #transactions where other_payer = 1
select @vStep = 190
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' gathering current trust balances ' + convert(varchar(26),getdate(),109)

--Trust balances
	    
insert into #transactions (invoice_id, fac_id, contact_id, contact_num, client_id, transaction_type, tx_description, comment,
amount, balance_due, other_payer, detail_order, bill_date)                            
SELECT cc.invoice_id
    , cc.summary_fac_id
    , cc.contact_id
    , cc.contact_num
    , cc.client_id
    , 'YY' as transaction_type
    , stdact.[description] as [description]
    , '' as comment
    , sum(tx.amount) as amount
    , 0 as balance_due
    , 3 as other_payer
    , 0 as detail_order
    , cc.bill_date
from dbo.ta_transaction tx with (nolock)
inner join
	(select max(invoice_id) as invoice_id,summary_fac_id, contact_id, contact_num, client_id, bill_date from #contact_clients where contact_id <> -2.1 and contact_id <> -3.1
		group by summary_fac_id, contact_id, contact_num, client_id, bill_date) cc
	on tx.client_id = cc.client_id and tx.deleted = 'N' and tx.transaction_date is not null
inner join dbo.ta_client_configuration tcc with (nolock) on cc.client_id = tcc.client_id and tcc.deleted = 'N' and isnull(tcc.trust_balance_on_bill,'N') = 'Y'
inner join dbo.ta_std_account stdact with (nolock) on tx.std_account_id = stdact.std_account_id
where cc.contact_id <> -2.1 and contact_id <> -3.1
group by cc.invoice_id, cc.summary_fac_id, cc.contact_id, cc.contact_num, cc.client_id, stdact.[description], cc.bill_date
order by stdact.[description]


update csd set csd.balance_due = csdttl.ttl
from #transactions csd
inner join (select contact_id, contact_num, invoice_id, bill_date ,sum(amount) ttl from #transactions 
where other_payer = 3 group by contact_id, contact_num, invoice_id, bill_date) csdttl on 
csd.invoice_id = csdttl.invoice_id and csd.contact_id = csdttl.contact_id and csd.contact_num = csdttl.contact_num 
and csd.bill_date = csdttl.bill_date and csd.other_payer = 3;

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 195
set @vgsStepStartTime = GETDATE()

if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' calculating various total values ' + convert(varchar(26),getdate(),109)

update csd set csd.balance_due = csdttl.ttl
from #transactions csd
inner join (select contact_id,contact_num,client_id,sum(amount) ttl from #transactions 
		where other_payer = 0
		group by contact_id,contact_num,client_id) csdttl on
	csd.contact_id = csdttl.contact_id and csd.contact_num = csdttl.contact_num and csd.client_id = csdttl.client_id  and csd.other_payer = 0 
--		and csd.other_payer <> 1 and csd.transaction_type <> '00' and csd.transaction_type <> 'C' and csd.tx_charge_code <> 'LateFeeSys'

update concl set concl.summary_client_balance_due = csdttl.ttl
from #contact_clients concl
inner join (select contact_id,contact_num,client_id,sum(amount) ttl from #transactions 
		where other_payer = 0 and transaction_type <> '00' and transaction_type <> 'C' and (charge_code <> 'LateFeeSys' or charge_code is null)
		group by contact_id,contact_num,client_id) csdttl on
	concl.contact_id = csdttl.contact_id and concl.contact_num = csdttl.contact_num and concl.client_id = csdttl.client_id

update concl set concl.payments = csdttl.ttl
from #contact_clients concl
inner join (select contact_id,contact_num,client_id,sum(payments) ttl from #contact_clients 
		group by contact_id,contact_num,client_id) csdttl on
	concl.contact_id = csdttl.contact_id and concl.contact_num = csdttl.contact_num and concl.client_id = csdttl.client_id

update concl set concl.summary_current_balance = bdttl.ttl
from #contact_clients concl
inner join (select contact_id,contact_num,sum(amount) ttl from  #transactions csd
			where other_payer = 0 group by contact_id, contact_num) bdttl 
	on concl.contact_id = bdttl.contact_id and concl.contact_num = bdttl.contact_num
 
update concl set concl.summary_previous_balance_due = bfttl.ttl
from #contact_clients concl
inner join (select contact_id,contact_num,sum(amount) ttl from #transactions  
			where transaction_type = '00' group by contact_id, contact_num) bfttl 
	on concl.contact_id = bfttl.contact_id and concl.contact_num = bfttl.contact_num --and concl.consolidate_statement = 1

update concl set concl.summary_payments = payttl.ttl
from #contact_clients concl
inner join (select contact_id,contact_num,sum(amount) ttl from #transactions 
			where transaction_type = 'C' group by contact_id, contact_num) payttl 
	on concl.contact_id = payttl.contact_id and concl.contact_num = payttl.contact_num --and concl.consolidate_statement = 1

update concl set concl.summary_late_fees = latefee.ttl
from #contact_clients concl
inner join (select contact_id,contact_num,sum(amount) ttl from #transactions 	
			where charge_code = 'LateFeeSys' group by contact_id, contact_num) latefee 
	on concl.contact_id = latefee.contact_id and concl.contact_num = latefee.contact_num 


set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

--Aging
IF @vShowAging = 1
BEGIN
	CREATE TABLE #temp_bucket_sum 
	(
		amount money,
		client_id int, 
		aging_date datetime,
		bill_date datetime,
		payer_id int,
		bucket_index int
	);

	IF @vPrivateStatementsIncluded = 1
	BEGIN
		SET @vStep = 200;
		SET @vgsStepStartTime = GETDATE();
		IF  @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Start aging calculations ' + convert(varchar(26),getdate(),109);
       
		INSERT INTO #transactions (invoice_id, fac_id, contact_id, contact_num, client_id, payer_id, transaction_type, comment
		, balance_due, other_payer, aging_total, aging_current_label, aging_current_amount, aging_30_label, aging_30_amount, aging_60_label, aging_60_amount, aging_90_label
		, aging_90_amount, aging_120_label, aging_120_amount, aging_150_label, aging_150_amount, aging_180_label, aging_180_amount, aging_210_label, aging_210_amount
		, detail_order, bill_date)                           
				SELECT  
									max(concl.invoice_id) as invoice_id
									, concl.summary_fac_id
									, concl.contact_id
									, concl.contact_num
									, concl.client_id
									, concl.payer_id
									, 'ZZ' as transaction_type
									, '' as detail_comment
									, 0 as balance_due
									, 2 as other_payer
									, 0.0 as aging_total
									, convert(varchar(2),datepart(mm,concl.aging_date)) + '/' + convert(varchar(4),datepart(yyyy,concl.aging_date)) as aging_current_label
									, 0.0 as aging_current_amount
									, convert(varchar(2),datepart(mm,(dateadd(mm,-1,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-1,concl.aging_date)))) as aging_30_label
									, 0.0 as aging_30_amount
									, convert(varchar(2),datepart(mm,(dateadd(mm,-2,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-2,concl.aging_date)))) as aging_60_label
									, 0.0 as aging_60_amount
									, convert(varchar(2),datepart(mm,(dateadd(mm,-3,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-3,concl.aging_date)))) as aging_90_label
									, 0.0 as aging_90_amount
									, convert(varchar(2),datepart(mm,(dateadd(mm,-4,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-4,concl.aging_date)))) as aging_120_label
									, 0.0 as aging_120_amount
									, convert(varchar(2),datepart(mm,(dateadd(mm,-5,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-5,concl.aging_date)))) as aging_150_label
									, 0.0 as aging_150_amount
									, convert(varchar(2),datepart(mm,(dateadd(mm,-6,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-6,concl.aging_date)))) as aging_180_label
									, 0.0 as aging_180_amount
									, '+ '+convert(varchar(2),datepart(mm,(dateadd(mm,-7,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-7,concl.aging_date)))) as aging_210_label
									, 0.0 as aging_210_amount
									, 0 as detail_order 
									, concl.bill_date
   					FROM #contact_clients concl
					WHERE concl.payer_id = 0
					GROUP BY concl.contact_id, concl.contact_num,concl.bill_date, concl.aging_date, concl.summary_fac_id, concl.client_id, concl.payer_id;

		SELECT DISTINCT csd.client_id, cc.aging_date,cc.bill_date,cc.payer_id  INTO #aging_clients 
		FROM #transactions csd
		INNER JOIN #contact_clients cc ON csd.client_id = cc.client_id AND cc. payer_id = 0 AND csd.transaction_type='ZZ';

		-- Temp table used to calculate amount for each bucket
		INSERT INTO #temp_bucket_sum (amount, client_id, aging_date, bill_date, payer_id, bucket_index)
			SELECT SUM(s.amount) AS amount, s.client_id, s.aging_date ,s.bill_date, s.payer_id, 
			CASE WHEN s.month_diff < 0 THEN 0 WHEN s.month_diff > 7 THEN 7 ELSE s.month_diff END AS bucket_index 
			FROM (
				SELECT 
						cl.client_id    
						, cl.aging_date 
						, cl.bill_date
						, cl.payer_id
						, CASE WHEN h.transaction_id is null THEN txn.amount ELSE -1*h.amount END AS 'amount'
						, CASE WHEN h.transaction_id is null 
								THEN DATEDIFF(MONTH, txn.effective_date,  DATEADD(dd,1, cl.bill_date)) 
								ELSE DATEDIFF(MONTH, h.applied_to_date,  DATEADD(dd,1, cl.bill_date)) 
							END AS 'month_diff'
				FROM dbo.ar_transactions txn WITH (NOLOCK)
				INNER JOIN #aging_clients cl
				ON cl.client_id = txn.client_id
				INNER JOIN dbo.ar_invoice invoice WITH (NOLOCK) 
				ON invoice.invoice_id = txn.invoice_id  AND invoice.effective_date < DATEADD(dd,1,cl.bill_date)
				AND invoice.deleted = 'N' AND invoice.trial_flag = 'N' AND invoice.fac_id = txn.fac_id 
				AND txn.deleted = 'N'
				INNER JOIN dbo.ar_lib_payers libpayer WITH (NOLOCK) on libpayer.payer_id=txn.payer_id
				AND libpayer.deleted = 'N' and ((libpayer.payer_type = 'Private' and libpayer.bill_form = 'private') or (libpayer.payer_type = 'Outpatient' and libpayer.outpatient_payer_type = 'Private'))
				INNER JOIN dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id = txn.payer_id and payer.fac_id = txn.fac_id 
				LEFT JOIN ar_applied_payment_history h on txn.transaction_id = h.transaction_id AND h.deleted = 'N' 
				WHERE txn.deleted='N' 
				AND NOT (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
				AND NOT (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate')             
				UNION ALL
				SELECT
					  cl.client_id    
					, cl.aging_date 
					, cl.bill_date
					, cl.payer_id
					, CASE WHEN h.transaction_id is null THEN txn.amount ELSE -1*h.amount END AS 'amount'
					, CASE WHEN h.transaction_id is null 
						THEN DATEDIFF(MONTH, txn.effective_date,  DATEADD(dd,1, cl.bill_date)) 
						ELSE DATEDIFF(MONTH, h.applied_to_date,  DATEADD(dd,1, cl.bill_date)) 
					  END AS 'month_diff'
				FROM dbo.ar_transactions txn WITH (NOLOCK)
				INNER JOIN #aging_clients cl ON cl.client_id = txn.client_id
				INNER JOIN dbo.ar_lib_payers libpayer WITH (NOLOCK) on libpayer.payer_id=txn.payer_id
				AND libpayer.deleted = 'N' and ((libpayer.payer_type = 'Private' and libpayer.bill_form = 'private') or (libpayer.payer_type = 'Outpatient' and libpayer.outpatient_payer_type = 'Private'))
				INNER JOIN dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id=txn.payer_id and payer.fac_id=txn.fac_id
				LEFT JOIN ar_applied_payment_history h on txn.transaction_id = h.transaction_id AND h.deleted = 'N' 
				WHERE txn.deleted='N' 
					AND txn.invoice_id < 0 
					AND NOT (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
					AND NOT (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate') 
				)s
				GROUP BY s.client_id, s.aging_date, s.bill_date, s.payer_id, CASE WHEN s.month_diff < 0 THEN 0 WHEN s.month_diff > 7 THEN 7 ELSE s.month_diff END 

		-- --- Update each bucket using #temp_bucket_sum ---

		--Current bucket: bucket_index = 0 
		UPDATE std SET std.aging_current_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id = 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 0
		WHERE std.transaction_type = 'ZZ' and std.payer_id = 0;

		--Bucket 30: bucket_index = 1 
		UPDATE std SET std.aging_30_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id = 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 1
		WHERE std.transaction_type = 'ZZ' and std.payer_id = 0;

		--Bucket 60: bucket_index = 2
		UPDATE std SET std.aging_60_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id = 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 2
		WHERE std.transaction_type = 'ZZ' and std.payer_id = 0;

		--Bucket 90: bucket_index = 3	
		UPDATE std SET std.aging_90_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id = 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 3
		WHERE std.transaction_type = 'ZZ' and std.payer_id = 0;

		--Bucket 120: bucket_index = 4
		UPDATE std SET std.aging_120_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id = 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 4
		WHERE std.transaction_type = 'ZZ' and std.payer_id = 0;

		--Bucket 150: bucket_index = 5
		UPDATE std SET std.aging_150_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id = 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 5
		WHERE std.transaction_type = 'ZZ' and std.payer_id = 0;

		--Bucket 180: bucket_index = 6
		UPDATE std SET std.aging_180_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id = 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 6
		WHERE std.transaction_type = 'ZZ' and std.payer_id = 0;

		--Bucket 210:  bucket_index = 7
		UPDATE std SET std.aging_210_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id = 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 7
		WHERE std.transaction_type = 'ZZ' and std.payer_id = 0;

		SET @vgsStepEndTime = GETDATE();
		IF  @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete aging calculations: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms';
	END

	IF @vOtherStatementsIncluded = 1
	BEGIN
		SET @vStep = 210;
		SET @vgsStepStartTime = GETDATE();
		IF  @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Start other payer aging calculations ' + convert(varchar(26),getdate(),109);
       
		INSERT INTO #transactions (invoice_id, fac_id, contact_id, contact_num, client_id, payer_id, transaction_type, comment
		, balance_due, other_payer, aging_total, aging_current_label, aging_current_amount, aging_30_label, aging_30_amount, aging_60_label, aging_60_amount, aging_90_label
		, aging_90_amount, aging_120_label, aging_120_amount, aging_150_label, aging_150_amount, aging_180_label, aging_180_amount, aging_210_label, aging_210_amount
		, detail_order, bill_date)                           
				SELECT
					max(concl.invoice_id) as invoice_id
					, concl.summary_fac_id
					, concl.contact_id
					, concl.contact_num
					, concl.client_id
					, concl.payer_id
					, 'ZZ' as transaction_type
					, '' as detail_comment
					, 0 as balance_due
					, 2 as other_payer
					, 0.0 as aging_total
					, convert(varchar(2),datepart(mm,concl.aging_date)) + '/' + convert(varchar(4),datepart(yyyy,concl.aging_date)) as aging_current_label
					, 0.0 as aging_current_amount
					, convert(varchar(2),datepart(mm,(dateadd(mm,-1,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-1,concl.aging_date)))) as aging_30_label
					, 0.0 as aging_30_amount
					, convert(varchar(2),datepart(mm,(dateadd(mm,-2,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-2,concl.aging_date)))) as aging_60_label
					, 0.0 as aging_60_amount
					, convert(varchar(2),datepart(mm,(dateadd(mm,-3,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-3,concl.aging_date)))) as aging_90_label
					, 0.0 as aging_90_amount
					, convert(varchar(2),datepart(mm,(dateadd(mm,-4,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-4,concl.aging_date)))) as aging_120_label
					, 0.0 as aging_120_amount
					, convert(varchar(2),datepart(mm,(dateadd(mm,-5,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-5,concl.aging_date)))) as aging_150_label
					, 0.0 as aging_150_amount
					, convert(varchar(2),datepart(mm,(dateadd(mm,-6,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-6,concl.aging_date)))) as aging_180_label
					, 0.0 as aging_180_amount
					, '+ '+convert(varchar(2),datepart(mm,(dateadd(mm,-7,concl.aging_date)))) + '/' + convert(varchar(4),datepart(yyyy,(dateadd(mm,-7,concl.aging_date)))) as aging_210_label
					, 0.0 as aging_210_amount
					, 0 as detail_order 
					, concl.bill_date
   				FROM #contact_clients concl
				WHERE concl.payer_id <> 0 and concl.contact_id <= -2.1 
				GROUP BY concl.contact_id, concl.contact_num,concl.bill_date, concl.aging_date, concl.summary_fac_id, concl.client_id, concl.payer_id;

		SELECT DISTINCT csd.client_id, cc.aging_date,cc.bill_date,cc.payer_id INTO #aging_clients_other 
		FROM #transactions csd
		INNER JOIN #contact_clients cc ON csd.client_id = cc.client_id AND cc. payer_id <> 0 AND csd.transaction_type='ZZ';

		-- Temp table used to calculate amount for each bucket
		INSERT INTO #temp_bucket_sum (amount, client_id, aging_date, bill_date, payer_id, bucket_index)
			SELECT SUM(s.amount) AS amount, s.client_id, s.aging_date ,s.bill_date, s.payer_id, 
			CASE WHEN s.month_diff < 0 THEN 0 WHEN s.month_diff > 7 THEN 7 ELSE s.month_diff END AS bucket_index 
			FROM (
				SELECT 
						cl.client_id    
						, cl.aging_date 
						, cl.bill_date
						, cl.payer_id
						, CASE WHEN h.transaction_id is null THEN txn.amount ELSE -1*h.amount END AS 'amount'
						, CASE WHEN h.transaction_id is null 
							THEN DATEDIFF(MONTH, txn.effective_date,  DATEADD(dd,1, cl.bill_date)) 
							ELSE DATEDIFF(MONTH, h.applied_to_date,  DATEADD(dd,1, cl.bill_date)) 
						END AS 'month_diff'
				FROM dbo.ar_transactions txn WITH (NOLOCK)
				INNER JOIN #aging_clients_other cl
				ON cl.client_id = txn.client_id and cl.payer_id = txn.payer_id
				INNER JOIN dbo.ar_invoice invoice WITH (NOLOCK) 
				ON cl.client_id = invoice.client_id and invoice.invoice_id = txn.invoice_id  AND invoice.effective_date < DATEADD(dd,1,cl.bill_date)
				AND invoice.deleted = 'N' AND invoice.trial_flag = 'N' AND invoice.fac_id = txn.fac_id 
				AND txn.deleted = 'N'
				INNER JOIN dbo.ar_lib_payers libpayer WITH (NOLOCK) on libpayer.payer_id=txn.payer_id AND libpayer.deleted = 'N'
				INNER JOIN dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id = txn.payer_id and payer.fac_id = txn.fac_id 
				LEFT JOIN ar_applied_payment_history h on txn.transaction_id = h.transaction_id AND h.deleted = 'N'
				WHERE txn.deleted='N' 
				AND NOT (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
				AND NOT (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate')             
				UNION ALL
				SELECT 
						cl.client_id    
						, cl.aging_date 
						, cl.bill_date
						, cl.payer_id
						, CASE WHEN h.transaction_id is null THEN txn.amount ELSE -1*h.amount END AS 'amount'
						, CASE WHEN h.transaction_id is null 
							THEN DATEDIFF(MONTH, txn.effective_date,  DATEADD(dd,1, cl.bill_date)) 
							ELSE DATEDIFF(MONTH, h.applied_to_date,  DATEADD(dd,1, cl.bill_date)) 
						END AS 'month_diff'
			FROM dbo.ar_transactions txn WITH (NOLOCK)
			INNER JOIN #aging_clients_other cl
			ON cl.client_id = txn.client_id and cl.payer_id = txn.payer_id
			INNER JOIN dbo.ar_lib_payers libpayer WITH (NOLOCK) on libpayer.payer_id=txn.payer_id AND libpayer.deleted = 'N'
			INNER JOIN dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id=txn.payer_id and payer.fac_id=txn.fac_id
			LEFT JOIN ar_applied_payment_history h on txn.transaction_id = h.transaction_id AND h.deleted = 'N'
 			WHERE txn.deleted='N' 
			AND txn.invoice_id < 0 
			AND NOT (txn.transaction_type = 'CA' AND payer.anc_rate_field = 'daily_rate')
			AND NOT (txn.transaction_type = 'CR' AND payer.daily_rate_field = 'daily_rate') 
			)s
			GROUP BY s.client_id, s.aging_date, s.bill_date, s.payer_id, CASE WHEN s.month_diff < 0 THEN 0 WHEN s.month_diff > 7 THEN 7 ELSE s.month_diff END 

		-- --- Update each bucket using #temp_bucket_sum ---

		--Current bucket: bucket_index = 0 
		UPDATE std SET std.aging_current_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id <> 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.payer_id = b.payer_id 
			AND concl.bill_date = b.bill_date AND b.bucket_index = 0
		WHERE std.transaction_type = 'ZZ' and std.payer_id <> 0 and concl.payer_id = std.payer_id;

	   --Bucket 30: bucket_index = 1 
		UPDATE std SET std.aging_30_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id <> 0 
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id  AND b.bucket_index = 1
		WHERE std.transaction_type = 'ZZ' and std.payer_id <> 0 and concl.payer_id = std.payer_id;
	
		--Bucket 60: bucket_index = 2
		UPDATE std SET std.aging_60_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id <> 0 
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 2
		WHERE std.transaction_type = 'ZZ' and std.payer_id <> 0 and concl.payer_id = std.payer_id;

		--Bucket 90: bucket_index = 3
		UPDATE std SET std.aging_90_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id <> 0  
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date
			AND concl.payer_id = b.payer_id AND b.bucket_index = 3
		WHERE std.transaction_type = 'ZZ' and std.payer_id <> 0 and concl.payer_id = std.payer_id;

		--Bucket 120: bucket_index = 4
		UPDATE std SET std.aging_120_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id <> 0 
		LEFT OUTER JOIN  #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 4
		WHERE std.transaction_type = 'ZZ' and std.payer_id <> 0 and concl.payer_id = std.payer_id;

		--Bucket 150: bucket_index = 5
		UPDATE std SET std.aging_150_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id <> 0 
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 5
		WHERE std.transaction_type = 'ZZ' and std.payer_id <> 0 and concl.payer_id = std.payer_id;

		--Bucket 180: bucket_index = 6
		UPDATE std SET std.aging_180_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id <> 0 
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id AND b.bucket_index = 6
		WHERE std.transaction_type = 'ZZ' and std.payer_id <> 0 and concl.payer_id = std.payer_id;

		--Bucket 210:  bucket_index = 7
		UPDATE std SET std.aging_210_amount = ISNULL(b.amount,0)
		FROM #transactions std
		INNER JOIN #contact_clients concl on std.client_id = concl.client_id and std.bill_date = concl.bill_date and concl.payer_id <> 0
		LEFT OUTER JOIN #temp_bucket_sum b ON std.client_id = b.client_id AND concl.aging_date = b.aging_date AND concl.bill_date = b.bill_date 
			AND concl.payer_id = b.payer_id  AND b.bucket_index = 7
		WHERE std.transaction_type = 'ZZ' and std.payer_id <> 0 and concl.payer_id = std.payer_id;

		SET @vgsStepEndTime = GETDATE();
		IF  @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete other payer aging calculations: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms';
	END
END


--Update aging totals 

UPDATE #transactions SET aging_total = 
aging_current_amount + aging_30_amount + aging_60_amount + aging_90_amount 
+ aging_120_amount + aging_150_amount + aging_180_amount + aging_210_amount
WHERE transaction_type = 'ZZ' ;

select @vStep = 220
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' set detail order and update contact data as needed ' + convert(varchar(26),getdate(),109)

update tx set tx.detail_order	= (Case when tx.transaction_type = '00' then 0
									when tx.transaction_type = 'C' and isnull(tx.charge_code,'') <> 'LateFeeSys' then 10
									when tx.transaction_type = 'CR' and isnull(tx.charge_code,'') <> 'LateFeeSys' then 15
									when tx.transaction_type = 'R' and isnull(tx.charge_code,'') <> 'LateFeeSys' then 20
									when tx.transaction_type = 'DR' and isnull(tx.charge_code,'') <> 'LateFeeSys' then 25
									when tx.transaction_type = 'A' and isnull(tx.charge_code,'') <> 'LateFeeSys' then 40
									when tx.transaction_type = 'CA' and isnull(tx.charge_code,'') <> 'LateFeeSys' then 50
									when tx.transaction_type = 'PC' and isnull(tx.charge_code,'') <> 'LateFeeSys' then 55
									when tx.charge_code = 'LateFeeSys' then 60
									when tx.transaction_type = 'TA' and isnull(tx.charge_code,'') <> 'LateFeeSys' then 70	
									when tx.transaction_type = 'YY' then 100								
									when tx.transaction_type = 'YZ' then 150
									when tx.transaction_type = 'ZZ' then 200
									else 30 END)
from #transactions tx

update concl set concl.pre_consolidated_payment_due_date = concl.payment_due_date, concl.payment_due_date = maxddate.duedate 
from #contact_clients concl
inner join (select contact_id,contact_num,max(payment_due_date) duedate from #contact_clients 
		where payment_due_date is not null group by contact_id, contact_num) maxddate 
	on concl.contact_id = maxddate.contact_id and concl.contact_num = maxddate.contact_num

--get most recent contact name and address for each contact, and assign it to all other residents - put here for debug reasons (we can see what the conacts were prior to the update)
update con set 
	con.contact_title = LatestContact.contact_title,
	con.contact_first_name = LatestContact.contact_first_name,
	con.contact_last_name = LatestContact.contact_last_name,
	con.contact_address1 = LatestContact.contact_address1,
	con.contact_address2 = LatestContact.contact_address2,
	con.contact_address3 = LatestContact.contact_address3,
	con.contact_city = LatestContact.contact_city,
	con.contact_prov_state = LatestContact.contact_prov_state,
	con.contact_postal_zip_code = LatestContact.contact_postal_zip_code,
	con.contact_country = LatestContact.contact_country,
	con.contact_county = LatestContact.contact_county,
	con.contact_email = LatestContact.contact_email,	
	con.private_bills_to = Case when con.private_bills_to <> LatestContact.private_bills_to then 'M' else con.private_bills_to end
from #contact_clients con
inner join (select ccl.contact_id,ccl.contact_num,ccl.bill_date,ccl.invoice_id,	ccl.contact_title, ccl.contact_first_name, ccl.contact_last_name, ccl.contact_address1
			, ccl.contact_address2, ccl.contact_address3, ccl.contact_city, ccl.contact_prov_state, ccl.contact_postal_zip_code, ccl.contact_country, ccl.contact_county, contact_email,private_bills_to
			, ROW_NUMBER() OVER ( PARTITION BY ccl.contact_id,ccl.bill_date 
			order by  ccl.contact_id,ccl.contact_num,ccl.bill_date desc, inv.created_date desc) as rwnum
			from #contact_clients ccl
			inner join dbo.ar_invoice inv with (nolock) on ccl.invoice_id = inv.invoice_id
		) LatestContact on con.contact_num = LatestContact.contact_num and con.bill_date = LatestContact.bill_date and LatestContact.rwnum = 1

update con set con.private_bills_to = 'M'
from #contact_clients con
inner join #contact_clients m on con.contact_num = m.contact_num and con.bill_date = m.bill_date  
where m.private_bills_to = 'M' and con.private_bills_to <> 'M' 

insert into #contact_return_to --set return to address info
select distinct
	  ccl.contact_num
	, case when fgi.fac_id is null then hfac.facility_code else fgi.remit_to_group_number end as return_to_group_number
	, case when fgi.fac_id is null then hfac.name else fgi.facility_group_name end as return_to_name
	, case when fgi.fac_id is null then hfac.address1 else fgi.facility_group_address1 end as return_to_address1
	, case when fgi.fac_id is null then hfac.address2 else fgi.facility_group_address2 end as return_to_address2
	, case when fgi.fac_id is null then '' else fgi.facility_group_address3 end as return_to_address3
	, case when fgi.fac_id is null then hfac.city else fgi.facility_group_city end as return_to_city
	, case when fgi.fac_id is null then faccnty.name else fgi.facility_group_county end as return_to_county
	, case when fgi.fac_id is null then hfac.prov else fgi.facility_group_prov_state end as return_to_prov_state
	, case when fgi.fac_id is null then fl.country else fgi.facility_group_country end as return_to_country
	, case when fgi.fac_id is null then hfac.pc else fgi.facility_group_postal_zip_code end as return_to_postal_zip_code
	, case when fgi.fac_id is null then hfac.tel else fgi.facility_group_phone end as return_to_phone
from #contact_clients ccl
inner join (select contact_num,max(invoice_id) as max_invoice_id from #contact_clients group by contact_num) mccl on 
	ccl.contact_num = mccl.contact_num
inner join #facility_list fl on ccl.fac_id = fl.fac_id
inner join dbo.ar_invoice inv with (nolock) on mccl.max_invoice_id = inv.invoice_id
left join #facilty_group_info fgi on ccl.fac_id = fgi.fac_id
inner join dbo.facility_audit hfac with (nolock) on ccl.fac_id = hfac.fac_id
	and hfac.effective_date  <= inv.created_date AND (hfac.ineffective_date  >= inv.created_date or hfac.ineffective_date is null)	
left join dbo.county faccnty with (nolock) on hfac.county_id = faccnty.county_id
--select * from #contact_return_to
--select * from #contact_clients
--check for override remit to address info - default private payer takes precident, then most recent invoices payer per contact.
--if @vIsEmc = 0 
update con set 
	con.remit_to_name				= LatestContact.remit_to_name,
	con.remit_to_address1			= LatestContact.remit_to_address1,
	con.remit_to_address2			= LatestContact.remit_to_address2,
	con.remit_to_address3			= LatestContact.remit_to_address3,
	con.remit_to_city				= LatestContact.remit_to_city,
	con.remit_to_prov_state			= LatestContact.remit_to_prov_state,
	con.remit_to_postal_zip_code	= LatestContact.remit_to_postal_zip_code,
	con.remit_to_phone				= LatestContact.remit_to_phone,
	con.remit_to_county				= LatestContact.remit_to_county,
	con.remit_to_country			= LatestContact.remit_to_country
from #contact_clients con
inner join (select 
			ccl.contact_id,
			ccl.contact_num,
			ccl.bill_date,
			ccl.invoice_id,	
			case when isnull(pyraud.provider_override,'N') = 'Y' then pyraud.provider_name else ccl.remit_to_name end as remit_to_name, 
			case when isnull(pyraud.provider_override,'N') = 'Y' then pyraud.provider_address1 else ccl.remit_to_address1 end as remit_to_address1, 
			case when isnull(pyraud.provider_override,'N') = 'Y' then pyraud.provider_address2 else ccl.remit_to_address2 end as remit_to_address2, 
			case when isnull(pyraud.provider_override,'N') = 'Y' then '' else ccl.remit_to_address3 end as remit_to_address3,
			case when isnull(pyraud.provider_override,'N') = 'Y' then pyraud.provider_city else ccl.remit_to_city end as remit_to_city, 
			case when isnull(pyraud.provider_override,'N') = 'Y' then pyraud.provider_prov_state else ccl.remit_to_prov_state end as remit_to_prov_state, 
			case when isnull(pyraud.provider_override,'N') = 'Y' then pyraud.provider_postal_zip_code else ccl.remit_to_postal_zip_code end as remit_to_postal_zip_code, 
			case when isnull(pyraud.provider_override,'N') = 'Y' then pyraud.provider_tel else ccl.remit_to_phone end as remit_to_phone, 
			case when isnull(pyraud.provider_override,'N') = 'Y' then cnty.name else ccl.remit_to_county end as remit_to_county,
			case when isnull(pyraud.provider_override,'N') = 'Y' then country.item_description else ccl.remit_to_country end as remit_to_country, 
			ROW_NUMBER() OVER ( PARTITION BY ccl.contact_id,ccl.contact_num,ccl.bill_date 
			order by  ccl.contact_id,ccl.contact_num,ccl.bill_date desc, case when cfg.default_payer_id = inv.payer_id then dateadd(yyyy, 100, inv.created_date) else inv.created_date end desc, inv.invoice_id desc) as rwnum
			from #contact_clients ccl
			inner join dbo.ar_invoice inv with (nolock) on ccl.invoice_id = inv.invoice_id
			inner join dbo.ar_configuration cfg on ccl.fac_id = cfg.fac_id and cfg.deleted = 'N'
			inner join dbo.ar_payers pyr with (nolock) on inv.payer_id = pyr.payer_id and inv.fac_id = pyr.fac_id 
			inner join dbo.ar_payers_audit pyraud with (nolock) on inv.payer_id = pyraud.payer_id and inv.fac_id = pyraud.fac_id and 
				pyraud.effective_date  <= inv.created_date AND (pyraud.ineffective_date  >= inv.created_date or pyraud.ineffective_date is null)
			left join dbo.county cnty with (nolock) on pyraud.provider_county_id = cnty.county_id
			left join common_code country with (nolock) on pyraud.provider_country_id = country.item_id
			left join #facilty_group_info fgi on ccl.fac_id = fgi.fac_id
			where fgi.fac_id is null
		) LatestContact on con.contact_num = LatestContact.contact_num and con.bill_date = LatestContact.bill_date and LatestContact.rwnum = 1
--select * from #contact_clients

if @debug_me='Y'  select * from #transactions order by contact_id,client_id,invoice_id,other_payer,transaction_type

--select * from ar_payers_audit

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 240
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' $0 suppression updates and other payer Aging and information payer data deletion' + convert(varchar(26),getdate(),109)

delete from #transactions where transaction_type not in ('00', 'YY', 'YZ', 'ZZ') and other_payer = 0 and amount = 0 --remove any detail values that have a $0 total and aren't a balance forward, other payer total or aging

delete from #transactions where transaction_type in ('YY', 'YZ') and other_payer <> 0 and (contact_id = -2.1 or contact_id = -3.1)--remove any detail values that have a $0 total and aren't a balance forward, other payer total or aging

if @vShowResults = 'D' -- suppress charge codes that sum to $0

update csd set csd.detail_order=999
from #transactions csd
inner join (select 	contact_num,contact_id,client_id, charge_code, frequency,dateadd(mm, datediff(mm, 0,effective_date) + 0, 0) as effective_date, sum(amount) as ttl
	from #transactions where charge_code is not null 
	group by contact_num,contact_id,client_id, charge_code, frequency, dateadd(mm, datediff(mm, 0, effective_date) + 0, 0)) supress on 
	csd.contact_num = supress.contact_num and csd.contact_id = supress.contact_id and csd.client_id = supress.client_id and csd.charge_code = supress.charge_code 
	and csd.frequency = supress.frequency and dateadd(mm, datediff(mm, 0, csd.effective_date) + 0, 0) = supress.effective_date and supress.ttl = 0

--suppress other transactions that sum to $0.00
update marked set marked.detail_order=999
from #transactions marked
inner join (
			select contact_num, contact_id, client_id, bill_date, generated_date, effective_date, transaction_type, tx_description, sum(amount) as ttl, count(*) as cnt
			from #transactions 
			where transaction_type <> '00' and other_payer = 0 and detail_order <> 999
			group by contact_num, contact_id, client_id, bill_date, generated_date, effective_date, transaction_type, tx_description having count (*) > 1
			) sum0 on marked.contact_num = sum0.contact_num and marked.contact_id = sum0.contact_id and marked.client_id = sum0.client_id and marked.bill_date = sum0.bill_date
				and marked.generated_date = sum0.generated_date and marked.effective_date = sum0.effective_date and marked.transaction_type = sum0.transaction_type
				and marked.tx_description = sum0.tx_description and sum0.ttl = 0 and marked.detail_order <> 999

--select detail_order,* from #transactions
--delete ccl --remove contact clients that have a single invoice, but one has no 'real' transactions and everything is $0.00
--from #contact_clients ccl
--inner join (select contact_num, contact_id, client_id from #contact_clients where contact_id > -2.1 group by contact_num, contact_id, client_id having count(1) = 1) minv
--	on ccl.contact_num = minv.contact_num and ccl.contact_id = minv.contact_id and ccl.client_id = minv.client_id
--inner join (select contact_num, contact_id, client_id from #transactions 
--	where detail_order <> 999 and other_payer = 0 group by contact_num, contact_id, client_id having count(1) = 1 and contact_id > -2.1) mtx
--	on ccl.contact_num = mtx.contact_num and ccl.contact_id = mtx.contact_id and ccl.client_id = mtx.client_id
--left join #transactions csd on csd.invoice_id = ccl.invoice_id and csd.transaction_type = '00' and csd.amount <> 0.00
--where csd.invoice_id is null

if @debug_me='Y'  select * from #transactions

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 260
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' udpate merged contacts with the most recent statement invoice # ' + convert(varchar(26),getdate(),109)

--remove extra invoices added for Balance Forward Calculations
if @vInvoiceIdList is not null
	begin
		delete rem 
		from #contact_clients rem
		LEFT join 
			(select con.contact_num
			from #contact_clients con
			inner join #invoice_ids_table inv on con.invoice_id = inv.invoice_id) kep on rem.contact_num = kep.contact_num
		where kep.contact_num is null
	end

update con set 
	con.statement_invoice_number = getinvnum.statement_invoice_number
from #contact_clients con
inner join (select cc.contact_num, client_id, max(cc.invoice_id) invoice_id
	from #contact_clients cc
	group by contact_num, client_id) latest on con.contact_num = latest.contact_num and con.client_id = latest.client_id 
inner join #contact_clients getinvnum with (nolock) on latest.invoice_id = getinvnum.invoice_id
		
set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
				
select @vStep = 270;
set @vgsStepStartTime = GETDATE();
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Add contact numbers and client list  ' + convert(varchar(26),getdate(),109);

DECLARE @ContactNums TABLE
				(
					contact_id numeric(18,1), 
					contact_number varchar(86),
					contact_email varchar(75),
					online_id varchar(35),
					fac_id int
				);

if @vExportMode = 0

	INSERT INTO @ContactNums(contact_id, contact_number, contact_email, online_id, fac_id)
				SELECT DISTINCT cont.contact_id, CASE WHEN cont.contact_id = 0 THEN '0'
													ELSE
												(CASE WHEN @vIncludePrefixFacilityCode = 1 THEN 
													(CASE WHEN @vIsEmc = 1 THEN 
															(CASE 
																WHEN fg.facility_group_id IS NULL AND (f.facility_code IS NULL OR LTRIM(f.facility_code)='') THEN c.contact_number
																WHEN fg.facility_group_id IS NULL THEN f.facility_code + '-' +  c.contact_number
																WHEN (fg.facility_group_code IS NULL OR LTRIM (fg.facility_group_code) = '') THEN c.contact_number 
																ELSE fg.facility_group_code  + '-' +  c.contact_number END)
														ELSE -- @vIncludePrefixFacilityCode = 0
															(CASE WHEN (f.facility_code IS NULL OR LTRIM(f.facility_code)='') THEN c.contact_number
																ELSE  
																f.facility_code + '-' +  c.contact_number END)
															END)
												ELSE c.contact_number END)  
												END
												AS contact_number
												,c.email_address
												,c.contact_number as online_id
												,f.fac_id
				FROM (SELECT DISTINCT contact_id, fac_id FROM #contact_clients) cont
				LEFT OUTER JOIN dbo.contact c WITH(NOLOCK)
				ON cont.contact_id = c.contact_id
				INNER JOIN dbo.facility f WITH(NOLOCK)
				ON f.fac_id = cont.fac_id
				LEFT OUTER JOIN (SELECT fgm.fac_id, fg.facility_group_id, fg.facility_group_code 
							FROM dbo.facility_group fg WITH(NOLOCK)
							INNER JOIN dbo.facility_group_mapping fgm WITH(NOLOCK) 
							ON fgm.facility_group_id = fg.facility_group_id 
							WHERE fg.[type_id] = 1 ) fg
				ON f.fac_id = fg.fac_id;
else

	INSERT INTO @ContactNums(contact_id, contact_number, contact_email, online_id, fac_id)
				SELECT DISTINCT cont.contact_id, c.contact_number, c.email_address, c.contact_number, cont.fac_id
				FROM (SELECT DISTINCT contact_id, fac_id FROM #contact_clients) cont
				LEFT OUTER JOIN dbo.contact c WITH(NOLOCK)
				ON cont.contact_id = c.contact_id

update  con set con.client_list = stuff(clients,1,0,'')
FROM #contact_clients con
CROSS APPLY
( 
SELECT top 2 concl.summary_charge_client_name + ' ('+concl.summary_charge_client_number+')| ' --+ ', '
	FROM  #contact_clients concl
	WHERE con.contact_num = concl.contact_num and con.contact_id = concl.contact_id and con.payer_id = concl.payer_id
	group by concl.summary_charge_client_name,concl.summary_charge_client_number 
	ORDER BY concl.summary_charge_client_name,concl.summary_charge_client_number
	FOR XML PATH ('')
) a ( clients )

update #contact_clients set client_list = left(client_list,len(client_list)-1)

update con  set con.client_list = con.client_list +'...'
from
#contact_clients con
inner join (select contact_num, contact_id from (select contact_num, contact_id, client_id from #contact_clients group by contact_num, contact_id, client_id) getcl group by  contact_num, contact_id  having count(*) > 2 ) maxcl
on con.contact_num = maxcl.contact_num and con.contact_id = maxcl.contact_id

set @vgsStepEndTime=GETDATE();
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms';
	
	
select @vStep = 300
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' returning final result ' + convert(varchar(26),getdate(),109)
--*********************************************************************************************************
if @vExportMode = 0
	select 
			ccl.fac_id
		, c.item_description as fac_country
		, ccl.contact_id
		, ccl.contact_num
		, ccl.consolidate_statement
		, cn.online_id
		, ccl.client_id
		, ccl.invoice_id
		, ccl.statement_invoice_number
		, ccl.payer
		, ltrim(rtrim(ccl.remit_to_name)) as remit_to_name
		, ltrim(rtrim(case when isnull(ccl.remit_to_address3,'')<>'' and isnull(ccl.remit_to_address2,'')<>'' and isnull(ccl.remit_to_address1,'')<>''  
				then ccl.remit_to_address1 + @vCflr + ccl.remit_to_address2+ @vCflr + ccl.remit_to_address3
			when isnull(ccl.remit_to_address3,'')='' and isnull(ccl.remit_to_address2,'')<>'' and isnull(ccl.remit_to_address1,'')<>'' 
				then ccl.remit_to_address1 + @vCflr + ccl.remit_to_address2
			when isnull(ccl.remit_to_address3,'')<>'' and isnull(ccl.remit_to_address2,'')='' and isnull(ccl.remit_to_address1,'')<>'' 
				then ccl.remit_to_address1 + @vCflr + ccl.remit_to_address3
			when isnull(ccl.remit_to_address3,'')<>'' and isnull(ccl.remit_to_address2,'')<>'' and isnull(ccl.remit_to_address1,'')='' 
				then ccl.remit_to_address2 + @vCflr + ccl.remit_to_address3
			when isnull(ccl.remit_to_address3,'')='' and isnull(ccl.remit_to_address2,'')<>'' and isnull(ccl.remit_to_address1,'')='' 
				then ccl.remit_to_address2
			when isnull(ccl.remit_to_address3,'')<>'' and isnull(ccl.remit_to_address2,'')='' and isnull(ccl.remit_to_address1,'')='' 
				then ccl.remit_to_address3
			else ccl.remit_to_address1 end)) as remit_to_address
		, ltrim(rtrim(isnull(ccl.remit_to_city, '') + ', ' + isnull(ccl.remit_to_prov_state, '') + ' ' +  isnull(ccl.remit_to_postal_zip_code, ''))) as remit_to_address2
		, isnull(ccl.remit_to_city, '') as remit_to_city
		, isnull(ccl.remit_to_county, '') as remit_to_county
		, isnull(ccl.remit_to_prov_state, '') as remit_to_prov_state
		, isnull(ccl.remit_to_postal_zip_code, '') as remit_to_postal_zip_code
		, ccl.remit_to_phone
		, ltrim(rtrim(return_add.return_to_name)) as return_to_name
		, ltrim(rtrim(case when isnull(return_add.return_to_address3,'')<>'' and isnull(return_add.return_to_address2,'')<>'' and isnull(return_add.return_to_address1,'')<>''  
				then return_add.return_to_address1 + @vCflr + return_add.return_to_address2+ @vCflr + return_add.return_to_address3
			when isnull(return_add.return_to_address3,'')='' and isnull(return_add.return_to_address2,'')<>'' and isnull(return_add.return_to_address1,'')<>'' 
				then return_add.return_to_address1 + @vCflr + return_add.return_to_address2
			when isnull(return_add.return_to_address3,'')<>'' and isnull(return_add.return_to_address2,'')='' and isnull(return_add.return_to_address1,'')<>'' 
				then return_add.return_to_address1 + @vCflr + return_add.return_to_address3
			when isnull(return_add.return_to_address3,'')<>'' and isnull(return_add.return_to_address2,'')<>'' and isnull(return_add.return_to_address1,'')='' 
				then return_add.return_to_address2 + @vCflr + return_add.return_to_address3
			when isnull(return_add.return_to_address3,'')='' and isnull(return_add.return_to_address2,'')<>'' and isnull(return_add.return_to_address1,'')='' 
				then return_add.return_to_address2
			when isnull(return_add.return_to_address3,'')<>'' and isnull(return_add.return_to_address2,'')='' and isnull(return_add.return_to_address1,'')='' 
				then return_add.return_to_address3
			else return_add.return_to_address1 end)) as return_to_address
		, ltrim(rtrim(isnull(return_add.return_to_city, '') + ', ' + isnull(return_add.return_to_prov_state, '') + ' ' +  isnull(return_add.return_to_postal_zip_code, ''))) as return_to_address2
		, isnull(return_add.return_to_city, '') as return_to_city
		, isnull(return_add.return_to_county, '') as return_to_county
		, isnull(return_add.return_to_prov_state, '') as return_to_prov_state
		, isnull(return_add.return_to_postal_zip_code, '') as return_to_postal_zip_code
		, return_add.return_to_phone
		, Case when private_bills_to = 'G' and ccl.contact_id <> 0 and ccl.contact_id <>-3.1 then 
				(ltrim(rtrim(case when isnull(ccl.contact_title,'')<>'' then ccl.contact_title + ' ' + ccl.contact_first_name + ' ' + ccl.contact_last_name 
				else ccl.contact_first_name + ' ' + ccl.contact_last_name end)))
			when ccl.contact_id = 0 or private_bills_to = 'M' or ccl.contact_id = -3.1 then 'No contact information available for:' 
			when ccl.contact_id = -2.1 then ccl.contact_first_name
			else 'No default payer address available for:' end	as contact_name
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0 and ccl.contact_id <> -3.1) or ccl.contact_id = -2.1 then 
				(ltrim(rtrim(case when isnull(ccl.contact_address3,'')<>'' and isnull(ccl.contact_address2,'')<>'' and isnull(ccl.contact_address1,'')<>'' 
				then ccl.contact_address1 + @vCflr + ccl.contact_address2 + @vCflr + ccl.contact_address3
			when isnull(ccl.contact_address3,'')='' and isnull(ccl.contact_address2,'')<>'' and isnull(ccl.contact_address1,'')<>'' 
				then ccl.contact_address1 + @vCflr + ccl.contact_address2
			when isnull(ccl.contact_address3,'')<>'' and isnull(ccl.contact_address2,'')='' and isnull(ccl.contact_address1,'')<>'' 
				then ccl.contact_address1 + @vCflr + ccl.contact_address3
			when isnull(ccl.contact_address3,'')<>'' and isnull(ccl.contact_address2,'')<>'' and isnull(ccl.contact_address1,'')='' 
				then ccl.contact_address2 + @vCflr + ccl.contact_address3
			when isnull(ccl.contact_address3,'')='' and isnull(ccl.contact_address2,'')<>'' and isnull(ccl.contact_address1,'')='' 
				then ccl.contact_address2
			when isnull(ccl.contact_address3,'')<>'' and isnull(ccl.contact_address2,'')='' and isnull(ccl.contact_address1,'')='' 
				then ccl.contact_address3
				else isnull(ccl.contact_address1,'') end)))
			when ccl.contact_id = 0 or private_bills_to = 'M' or ccl.contact_id = -3.1 then ccl.summary_charge_client_name + ' ('+ccl.summary_charge_client_number+')'
			else ccl.payer end as contact_address
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1 then 
				(ltrim(rtrim(case when isnull(ccl.contact_city, '')<>'' and  isnull(ccl.contact_prov_state, '')<>'' then ccl.contact_city + ', ' + ccl.contact_prov_state + ' ' 
					+ isnull(ccl.contact_postal_zip_code, '')
				when isnull(ccl.contact_city, '')<>'' and isnull(ccl.contact_prov_state, '')='' then ccl.contact_city + ', ' + isnull(ccl.contact_postal_zip_code, '')
				when isnull(ccl.contact_city, '')='' and isnull(ccl.contact_prov_state, '')<>'' then ccl.contact_prov_state + ', ' + isnull(ccl.contact_postal_zip_code, '')
				else '' end)))
			else '' end as contact_address2
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_city, '') else '' end as contact_city
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_county, '') else '' end as contact_county
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_prov_state, '') else '' end as contact_prov_state
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_postal_zip_code, '') else '' end as contact_postal_zip_code
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_country, '') else '' end as contact_country
		, Case when private_bills_to = 'G' and ccl.contact_id <> 0 and @vAccountNumberSource = 'C' then cn.contact_number 
			when private_bills_to = 'G' and ccl.contact_id <> 0 and @vAccountNumberSource = 'R' and charindex('|',ccl.client_list,1) > 0 then cn.contact_number
			when private_bills_to = 'G' and @vAccountNumberSource = 'R' and charindex('|',ccl.client_list,1) = 0 and @vIncludePrefixFacilityCode = 0 then ccl.summary_charge_client_number
			when private_bills_to = 'G' and @vAccountNumberSource = 'R' and charindex('|',ccl.client_list,1) = 0 and @vIncludePrefixFacilityCode = 1 and @vIsEmc = 0
				and (f.facility_code IS NULL OR LTRIM(f.facility_code)='') then ccl.summary_charge_client_number
			when private_bills_to = 'G' and @vAccountNumberSource = 'R' and charindex('|',ccl.client_list,1) = 0 and @vIncludePrefixFacilityCode = 1 and @vIsEmc = 0
				and (f.facility_code IS NOT NULL OR LTRIM(f.facility_code)<>'') then f.facility_code + '-' + ccl.summary_charge_client_number
			when private_bills_to = 'G' and @vAccountNumberSource = 'R' and charindex('|',ccl.client_list,1) = 0 and @vIncludePrefixFacilityCode = 1 and @vIsEmc = 1
				and return_add.return_to_group_number IS NOT NULL then return_add.return_to_group_number + '-' + ccl.summary_charge_client_number 
			when private_bills_to = 'G' and @vAccountNumberSource = 'R' and charindex('|',ccl.client_list,1) = 0 and @vIncludePrefixFacilityCode = 1 and @vIsEmc = 1
				and return_add.return_to_group_number IS NULL and (f.facility_code IS NOT NULL OR LTRIM(f.facility_code)<>'') then f.facility_code  + '-' + ccl.summary_charge_client_number 
			when private_bills_to = 'G' and @vAccountNumberSource = 'R' and charindex('|',ccl.client_list,1) = 0 and @vIncludePrefixFacilityCode = 1 and @vIsEmc = 1
				and return_add.return_to_group_number IS NULL and (f.facility_code IS NULL OR LTRIM(f.facility_code)='') then ccl.summary_charge_client_number 
			else Null end as account_number
		, Case when @vUseEffectiveDateAsBillDate = 1 then ccl.bill_date else dateadd(mm, datediff(mm, 0, ccl.bill_date) + 1, 0) end as bill_date
		, ccl.inv_effective_date as effective_date
		, ccl.generated_date
		, Case when fac.show_payment_due_date = 1 then ccl.payment_due_date else Null end as payment_due_date
		, Case when fac.show_payment_due_date = 1 then ccl.pre_consolidated_payment_due_date else Null end as pre_consolidated_payment_due_date
		, coalesce(convert(datetime,convert(varchar(10),ccl.statement_through_date, 101)),ccl.bill_date) as statement_through_date
		, ccl.amount_due
		, case when ccl.contact_id <> -2.1 then ccl.eft_message else '' end as eft_message
		, replace(ccl.client_list,'|',';') as client_list
		, case when ccl.contact_id <> -2.1 then ccl.client_message else '' end as client_message
		, case when ccl.contact_id <> -2.1 then ccl.group_message else '' end as group_message
		, case when ccl.contact_id <> -2.1 then ccl.global_message else '' end as global_message
		, case when ccl.contact_id <> -2.1 then @vStatementMessage else '' end as statement_message
		, fac.gst_hst
		, fac.gst_number
		, ccl.previous_balance_due
		, ccl.payments
		, ltrim(rtrim(ccl.summary_charge_center)) as summary_charge_center
		, ccl.summary_charge_client_name
		, ccl.summary_charge_client_number
		, ccl.summary_charge_client_location
		, case when @vDisplayAdmitDate = 1 then ccl.summary_charge_client_admission else Null end as summary_charge_client_admission
		, case when @vDisplayDischargeDate = 1 then  ccl.summary_charge_client_discharge else Null end as summary_charge_client_discharge
		, ccl.summary_current_balance
		, ccl.summary_previous_balance_due
		, ccl.summary_payments
		, ccl.summary_late_fees	
		, ccl.summary_client_balance_due
		, csd.transaction_type
		, csd.detail_order
		, csd.effective_date as detail_effective_date
		, case when csd.effective_thru_date <> csd.effective_date then 'thru' else '' end as detail_thru
		, csd.effective_thru_date as detail_effective_thru_date
		, Case when isnull(csd.units,0) < 0 or (csd.transaction_type = 'C' and csd.reversed = 1 and csd.amount > 0) THEN '** ' +
				(case when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') <> '' 
					and isnull(csd.cheque_number,'') = '' then isnull(csd.tx_description,'') + ' - ' + csd.comment
				when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') = '' 
					and isnull(csd.cheque_number,'') <> '' then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number
				when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') <> '' 
					and isnull(csd.cheque_number,'') <> '' then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number + ' - ' + csd.comment
				when csd.transaction_type = 'C' and @vCashReceiptComments = 0 and isnull(csd.cheque_number,'') <> '' 
					then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number
				when csd.transaction_type = 'A' and @vAncillaryComments = 1 and @vShowResults = 'D' and isnull(csd.comment,'') <> ''  then isnull(csd.tx_description,'') + ' - ' + csd.comment
				when csd.transaction_type = 'X' and @vAdjustmentComments = 1 and isnull(csd.comment,'') <> '' then isnull(csd.tx_description,'') + ' - ' + csd.comment
				else isnull(csd.tx_description,'') end
				) +' **'
			else (case when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') <> '' 
					and isnull(csd.cheque_number,'') = '' then isnull(csd.tx_description,'') + ' - ' + csd.comment
				when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') = '' 
					and isnull(csd.cheque_number,'') <> '' then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number
				when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') <> '' 
					and isnull(csd.cheque_number,'') <> '' then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number + ' - ' + csd.comment
				when csd.transaction_type = 'C' and @vCashReceiptComments = 0 and isnull(csd.cheque_number,'') <> '' 
					then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number
				when csd.transaction_type = 'A' and @vAncillaryComments = 1 and @vShowResults = 'D' and isnull(csd.comment,'') <> ''  then isnull(csd.tx_description,'') + ' - ' + csd.comment
				when csd.transaction_type = 'X' and @vAdjustmentComments = 1 and isnull(csd.comment,'') <> '' then isnull(csd.tx_description,'') + ' - ' + csd.comment
				else isnull(csd.tx_description,'') end	
				)
			end as detail_description
		, csd.comment as detail_comment
		, Case when isnull(csd.units,0) < 0 or (csd.transaction_type = 'C' and csd.reversed = 1 and csd.amount > 0)then 1 else 0 end as reversed_tx
		, Case when csd.transaction_type = 'R' and csd.unit_amount is null then Null 
			when csd.transaction_type = 'XR' and isnull(csd.units,0) = 0 then Null
			when csd.transaction_type = 'D' then Null  
			when csd.transaction_type not in('R','XR','CO','CR','D') and isnull(csd.unit_amount,0) = 0 then Null 
			else csd.units end as detail_units
		, Case when csd.transaction_type = 'D' then Null 
			when isnull(csd.unit_amount,0) = 0 then Null 
			when round((csd.units * csd.unit_amount),2) <> round(csd.amount, 2) then Null else round(csd.unit_amount, 2) end as detail_unit_amount
		, round(csd.amount, 2) as detail_amount
		, csd.balance_due
		, csd.other_payer
		, csd.payer_type
		, csd.aging_total
		, csd.aging_current_label
		, csd.aging_current_amount
		, csd.aging_30_label
		, csd.aging_30_amount
		, csd.aging_60_label
		, csd.aging_60_amount
		, csd.aging_90_label
		, csd.aging_90_amount
		, csd.aging_120_label
		, csd.aging_120_amount
		, csd.aging_150_label
		, csd.aging_150_amount
		, csd.aging_180_label
		, csd.aging_180_amount
		, csd.aging_210_label
		, csd.aging_210_amount
		, fac.cheques_payable_to
		, Case when (@vShowResults = 'C' or @vShowResults = 'CC') and csd.transaction_type = 'A' then Dense_rank() over 
			(ORDER BY ccl.contact_num, csd.detail_order, csd.tx_description) else 0 end ccorder
		, Case when @vTransactionOrder = 'P' then Dense_rank() over (ORDER BY ccl.contact_num, csd.detail_order, FORMAT(csd.effective_date,'YYYY'), FORMAT(csd.effective_date,'MM'),
			Case when isnull(csd.units,0) < 0 or (csd.transaction_type = 'C' and csd.reversed = 1 and csd.amount > 0)then 1 else 0 end desc, csd.effective_date, csd.tx_description)
			when @vTransactionOrder = 'D' then Dense_rank() over (ORDER BY ccl.contact_num, 
			 (case when csd.transaction_type = '00' then '1/1/1900'
				when csd.transaction_type in ('YY','YZ','ZZ') then dateadd(yyyy,100,ccl.bill_date)
				else csd.effective_date end), csd.detail_order, Case when isnull(csd.units,0) < 0 or (csd.transaction_type = 'C' and csd.reversed = 1 and csd.amount > 0)then 1 else 0 end desc, csd.tx_description) 
			else 0 end txsort
		, Dense_rank() over (ORDER BY ccl.contact_num, ccl.non_consolidated_contact_num	, ccl.remit_to_name) statement_num
		, Case when csd.transaction_type = 'PC' then Dense_rank() over 
				(ORDER BY Left(csd.tx_description,charindex(':', csd.tx_description)), csd.effective_date, csd.transaction_type)
				else Dense_rank() over 
				(ORDER BY csd.effective_date, csd.transaction_type, csd.tx_description)
				end txtypeorder
		, @status_code status_code
		, @status_text status_text
	 
	from #contact_clients ccl
	left join #facility_list fac on ccl.fac_id = fac.fac_id
	inner join #transactions csd on ccl.invoice_id= csd.invoice_id and ccl.client_id = csd.client_id and ccl.contact_id = csd.contact_id
			and ccl.contact_num = csd.contact_num --and (ccl.contact_id = @vReceiverIds or @vReceiverIds = -1)
	inner join dbo.facility f with (nolock) on ccl.fac_id = f.fac_id
	inner join dbo.common_code c with (nolock) on f.country_id = c.item_id
	inner join #contact_return_to return_add on ccl.contact_num = return_add.contact_num
	LEFT OUTER JOIN @ContactNums cn
	ON ccl.contact_id = cn.contact_id and ccl.fac_id = cn.fac_id
	where csd.detail_order <> 999 --and csd.detail_amount is not null
		and (csd.amount is not null or csd.other_payer > 0)
		and (@vMinimumBalance is null or ccl.summary_current_balance >= @vMinimumBalance)
		and (@vSuppress0value = 0 or (@vSuppress0value = 1 and  (csd.amount <> 0.00 or csd.transaction_type in('00','YY','YZ','ZZ'))) or csd.payer_id = 0)
	order by statement_num, ccl.summary_charge_center, ccl.summary_charge_client_name, ccl.summary_charge_client_number, ccl.bill_date, 
		Case when ccl.contact_id <= -2.1 then ccl.invoice_id else 0 end, ccl.generated_date, txsort, ccorder, txtypeorder
else
	select 
		 
		  ccl.contact_num
		, Dense_rank() over (ORDER BY ccl.contact_num, ccl.non_consolidated_contact_num	, ccl.remit_to_name) statement_num
		, ltrim(rtrim(return_add.return_to_group_number)) as facility_group_number
		, ltrim(rtrim(return_add.return_to_name)) as facility_group_name
		, isnull(return_add.return_to_address1,'') as facility_group_address_1
		, isnull(return_add.return_to_address2,'') as facility_group_address_2
		, isnull(return_add.return_to_address3,'') as facility_group_address_3
		, isnull(return_add.return_to_county, '') as facility_group_county
		, isnull(return_add.return_to_city, '') as facility_group_city
		, isnull(return_add.return_to_prov_state, '') as facility_group_state
		, isnull(return_add.return_to_country, '') as facility_group_country
		, isnull(return_add.return_to_postal_zip_code, '') as facility_group_zip_code
		, isnull(return_add.return_to_phone,'') as facility_group_telephone	
		--, ltrim(rtrim(str(abs(ccl.contact_id)))) as contact_id
		, Case when private_bills_to = 'G' and ccl.contact_id <> 0 then cn.contact_number else '' end as guarantor_id 
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0 and ccl.contact_id <>-3.1) or private_bills_to = 'D' then ccl.contact_first_name else '' end as guarantor_first_name
		, Case when private_bills_to = 'G' and ccl.contact_id <> 0 and ccl.contact_id <>-3.1 then ccl.contact_last_name
			when ccl.contact_id = 0 or private_bills_to = 'M' or ccl.contact_id = -3.1 then 'No contact information available for:' 
			when ccl.contact_id = -2.1 then ccl.contact_last_name
			else 'No default payer address available for:' end	as guarantor_last_name
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0 and ccl.contact_id <> -3.1) or ccl.contact_id = -2.1 then isnull(ccl.contact_address1,'')
			when ccl.contact_id = 0 or private_bills_to = 'M' or ccl.contact_id = -3.1 then ccl.summary_charge_client_name + ' ('+ccl.summary_charge_client_number+')'
			else ccl.payer end as guarantor_address_1
		, isnull(ccl.contact_address2,'') as guarantor_address_2
		, isnull(ccl.contact_address3,'') as guarantor_address_3
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_county, '') else '' end as guarantor_county
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_city, '') else '' end as guarantor_city
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_prov_state, '') else '' end as guarantor_state		
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_country, '') else '' end as guarantor_country
		, Case when (private_bills_to = 'G' and ccl.contact_id <> 0) or ccl.contact_id = -2.1  then isnull(ccl.contact_postal_zip_code, '') else '' end as guarantor_zip_code
		, isnull(cn.contact_email,'') as guarantor_email_address
		, ltrim(rtrim(ccl.remit_to_name)) as remit_to_name
		, isnull(ccl.remit_to_address1,'') as remit_to_address_1
		, isnull(ccl.remit_to_address2,'') as remit_to_address_2
		, isnull(ccl.remit_to_address3,'') as remit_to_address_3
		, isnull(ccl.remit_to_county, '') as remit_to_county
		, isnull(ccl.remit_to_city, '') as remit_to_city
		, isnull(ccl.remit_to_prov_state, '') as remit_to_state
		, isnull(ccl.remit_to_country, '') as remit_to_country
		, isnull(ccl.remit_to_postal_zip_code, '') as remit_to_zip_code
		, isnull(ccl.remit_to_phone, '') as remit_to_phone_number
		, ccl.summary_current_balance as grand_total
		, ccl.summary_late_fees	as late_fees
		, ccl.summary_previous_balance_due as balance_forward_amount
		, ccl.summary_payments as cash_payments_received
		, cn.online_id
		, @vTermClient as term_used_for_patient
		, @vTermAdmission as term_used_for_admission
		, @vTermDischarge as term_used_for_discharge
		--, @vTermRoom as term_used_for_room
		--, @vTermFacility as term_used_for_facility
		, case when @vShowInvoiceNumber = 1 then 'Y' else 'N' end as show_invoice_number
		, case when @vShowLocation = 1 then 'Y' else 'N' end as show_location
		, case when @vDisplayAdmitDate = 1 then 'Y' else 'N' end as show_admit_date
		, case when @vDisplayDischargeDate = 1 then 'Y' else 'N' end as show_discharge_date
		, case when @vShowResidentNumber = 1 then 'Y' else 'N' end as show_patient_number
		, case when @vShowTransactionWarningMessage = 1 then 'Y' else 'N' end as show_transaction_warning_message
		, case when @vIncludePrefixFacilityCode = 1 then 'Y' else 'N' end as prefix_fac_code_to_acct_no
		--, @vDisplayUnitAndAmountFlag as display_unit_and_amount_flag
		, Case when isnull(fac.cheques_payable_to,'') <> '' and isnull(eftconfig.enabled,0) <> 1 and ccl.summary_current_balance > 0
			then 'Please make ' + (case when c.item_description = 'United States' then 'checks' else 'cheques' end) + ' payable to: ' + fac.cheques_payable_to else '' end as checks_payable_to		
		, isnull(@vPaymentInstructions,'') as payment_instruction
		, isnull(replace(@vTransactionWarningMessage, '<<stmt_thru_date>>', convert(varchar(10),coalesce(convert(datetime,convert(varchar(10),ccl.statement_through_date, 101)),ccl.bill_date), 101)),'') as transaction_warning_message
		, @vAccountNumberLabel as account_number_label
		, Case when @vAccountNumberSource = 'R' and charindex('|',ccl.client_list,1) > 0 then 'C' else @vAccountNumberSource end as account_number_source
		, ccl.fac_id as facility_id
		, ltrim(rtrim(isnull(ccl.summary_charge_center_code,''))) as facility_code
		, ltrim(rtrim(ccl.summary_charge_center)) as facility_name
		, ccl.client_id
		, convert(varchar(10),ccl.summary_charge_client_admission, 101) as patient_admit_date
		, convert(varchar(10),ccl.summary_charge_client_discharge, 101) as patient_discharge_date
		, ccl.summary_charge_client_number as patient_number
		, ccl.summary_charge_client_first_name as patient_first_name
		, ccl.summary_charge_client_last_name as patient_last_name
		, ccl.summary_charge_client_name as patient_name
		, convert(varchar(10),ccl.summary_charge_client_dob, 101) as patient_dob
		, isnull(ccl.summary_charge_client_location,'') as patient_location	
		, case when isnull(eftconfig.enabled,0) = 1 then 'Y' else 'N' end as eft_enabled
		, case when ccl.contact_id <> -2.1 then isnull(ccl.client_message,'') else '' end as patient_invoice_message
		, case when ccl.contact_id <> -2.1 then isnull(ccl.group_message,'') else '' end as patient_group_message
		, case when ccl.contact_id <> -2.1 then isnull(ccl.eft_message,'') else '' end as eft_message
		--, case when ccl.contact_id <> -2.1 then ccl.global_message else '' end as global_message
		--, case when ccl.contact_id <> -2.1 then @vStatementMessage else '' end as statement_message
		, ccl.statement_invoice_number as invoice_number
		, Case when @vUseEffectiveDateAsBillDate = 1 then convert(varchar(10),ccl.bill_date, 101) else convert(varchar(10),dateadd(mm, datediff(mm, 0, ccl.bill_date) + 1, 0), 101) end as invoice_date
		, convert(varchar(10),ccl.payment_due_date, 101) as invoice_due_date
		--, convert(varchar(10),ccl.inv_effective_date, 101) as effective_date
		--, convert(varchar(10),ccl.generated_date, 101) as generated_date
		, ccl.summary_client_balance_due as current_invoice_charges
		, csd.balance_due as total_amount_due
		, convert(varchar(10),csd.effective_date, 101) as date_of_service
		--, case when csd.effective_thru_date <> csd.effective_date then 'thru' else '' end as detail_thru
		--, convert(varchar(10),csd.effective_thru_date, 101) as detail_effective_thru_date
		, csd.transaction_type
		, Case when isnull(csd.units,0) < 0 or (csd.transaction_type = 'C' and csd.reversed = 1 and csd.amount > 0) THEN '** ' +
				(case when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') <> '' 
					and isnull(csd.cheque_number,'') = '' then isnull(csd.tx_description,'') + ' - ' + csd.comment
				when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') = '' 
					and isnull(csd.cheque_number,'') <> '' then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number
				when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') <> '' 
					and isnull(csd.cheque_number,'') <> '' then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number + ' - ' + csd.comment
				when csd.transaction_type = 'C' and @vCashReceiptComments = 0 and isnull(csd.cheque_number,'') <> '' 
					then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number
				when csd.transaction_type = 'A' and @vAncillaryComments = 1 and @vShowResults = 'D' and isnull(csd.comment,'') <> ''  then isnull(csd.tx_description,'') + ' - ' + csd.comment
					+ (case when @vDisplayUnitAndAmountFlag = 1 and isnull(csd.units,0) <> 0 and csd.unit_amount is not null and round((csd.units * csd.unit_amount),2) = round(csd.amount, 2) 
					then ' (' + ltrim(rtrim(str(csd.units))) + '@' + convert(varchar(10),convert(Money,csd.unit_amount)) + ')' else '' end)
				when csd.transaction_type = 'X' and @vAdjustmentComments = 1 and isnull(csd.comment,'') <> '' then isnull(csd.tx_description,'') + ' - ' + csd.comment
					+ (case when @vDisplayUnitAndAmountFlag = 1 and isnull(csd.units,0) <> 0 and csd.unit_amount is not null and round((csd.units * csd.unit_amount),2) = round(csd.amount, 2) 
					then ' (' + ltrim(rtrim(str(csd.units))) + '@' + convert(varchar(10),convert(Money,csd.unit_amount)) + ')' else '' end)
				else isnull(csd.tx_description,'') 
					+ (case when @vDisplayUnitAndAmountFlag = 1 and isnull(csd.units,0) <> 0 and csd.unit_amount is not null and round((csd.units * csd.unit_amount),2) = round(csd.amount, 2) 
					then ' (' + ltrim(rtrim(str(csd.units))) + '@' + convert(varchar(10),convert(Money,csd.unit_amount)) + ')' else '' end)
				end
				) +' **'
			else (case when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') <> '' 
					and isnull(csd.cheque_number,'') = '' then isnull(csd.tx_description,'') + ' - ' + csd.comment
				when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') = '' 
					and isnull(csd.cheque_number,'') <> '' then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number
				when csd.transaction_type = 'C' and @vCashReceiptComments = 1 and isnull(csd.comment,'') <> '' 
					and isnull(csd.cheque_number,'') <> '' then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number + ' - ' + csd.comment
				when csd.transaction_type = 'C' and @vCashReceiptComments = 0 and isnull(csd.cheque_number,'') <> '' 
					then isnull(csd.tx_description,'') + ' - #' + csd.cheque_number
				when csd.transaction_type = 'A' and @vAncillaryComments = 1 and @vShowResults = 'D' and isnull(csd.comment,'') <> ''  then isnull(csd.tx_description,'') + ' - ' + csd.comment
					+ (case when @vDisplayUnitAndAmountFlag = 1 and isnull(csd.units,0) <> 0 and csd.unit_amount is not null and round((csd.units * csd.unit_amount),2) = round(csd.amount, 2) 
					then ' (' + ltrim(rtrim(str(csd.units))) + '@' + convert(varchar(10),convert(Money,csd.unit_amount)) + ')' else '' end)
				when csd.transaction_type = 'X' and @vAdjustmentComments = 1 and isnull(csd.comment,'') <> '' then isnull(csd.tx_description,'') + ' - ' + csd.comment
					+ (case when @vDisplayUnitAndAmountFlag = 1 and isnull(csd.units,0) <> 0 and csd.unit_amount is not null and round((csd.units * csd.unit_amount),2) = round(csd.amount, 2) 
					then ' (' + ltrim(rtrim(str(csd.units))) + '@' + convert(varchar(10),convert(Money,csd.unit_amount)) + ')' else '' end)
				else isnull(csd.tx_description,'') 
					+ (case when @vDisplayUnitAndAmountFlag = 1 and isnull(csd.units,0) <> 0 and csd.unit_amount is not null and round((csd.units * csd.unit_amount),2) = round(csd.amount, 2) 
					then ' (' + ltrim(rtrim(str(csd.units))) + '@' + convert(varchar(10),convert(Money,csd.unit_amount)) + ')' else '' end)
				end	
				)
			end as transaction_description
		--, csd.comment as detail_comment
		--, Case when isnull(csd.units,0) < 0 or (csd.transaction_type = 'C' and csd.reversed = 1 and csd.amount > 0)then 1 else 0 end as reversed_tx
		, Case when csd.transaction_type = 'R' and csd.unit_amount is null then Null 
			when csd.transaction_type = 'XR' and isnull(csd.units,0) = 0 then Null
			when csd.transaction_type = 'D' then Null  
			when csd.transaction_type not in('R','XR','CO','CR','D') and isnull(csd.unit_amount,0) = 0 then Null 
			else csd.units end as quantity
		, Case when csd.transaction_type = 'D' then Null 
			when isnull(csd.unit_amount,0) = 0 then Null 
			when round((csd.units * csd.unit_amount),2) <> round(csd.amount, 2) then Null else round(csd.unit_amount, 2) end as unit_amount
		, round(csd.amount, 2) as transaction_total_amount
		, Case when fac.show_payment_due_date = 1 then 'Y' else 'N' end as show_payment_due_date
		, convert(varchar(10),ccl.pre_consolidated_payment_due_date, 101) as pre_consolidated_payment_due_date
		, convert(varchar(10),coalesce(convert(datetime,convert(varchar(10),ccl.statement_through_date, 101)),ccl.bill_date), 101) as statement_through_date			
		--, ccl.client_list
		--, fac.gst_hst
		--, fac.gst_number
		, csd.detail_order
		, csd.other_payer
		, csd.payer_type
		, Case when (@vShowResults = 'C' or @vShowResults = 'CC') and csd.transaction_type = 'A' then Dense_rank() over 
			(ORDER BY ccl.contact_num, csd.detail_order, csd.tx_description) else 0 end ccorder
		, Case when @vTransactionOrder = 'P' then Dense_rank() over (ORDER BY ccl.contact_num, csd.detail_order, FORMAT(csd.effective_date,'YYYY'), FORMAT(csd.effective_date,'MM'),
			Case when isnull(csd.units,0) < 0 or (csd.transaction_type = 'C' and csd.reversed = 1 and csd.amount > 0)then 1 else 0 end desc, csd.effective_date, csd.tx_description)
			when @vTransactionOrder = 'D' then Dense_rank() over (ORDER BY ccl.contact_num, 
			 (case when csd.transaction_type = '00' then '1/1/1900'
				when csd.transaction_type in ('YY','YZ','ZZ') then dateadd(yyyy,100,ccl.bill_date)
				else csd.effective_date end), csd.detail_order, Case when isnull(csd.units,0) < 0 or (csd.transaction_type = 'C' and csd.reversed = 1 and csd.amount > 0)then 1 else 0 end desc, csd.tx_description) 
			else 0 end txsort
		--, Dense_rank() over (ORDER BY ccl.contact_num, ccl.non_consolidated_contact_num	, ccl.remit_to_name) statement_num
		, Case when csd.transaction_type = 'PC' then Dense_rank() over 
				(ORDER BY Left(csd.tx_description,charindex(':', csd.tx_description)), csd.effective_date, csd.transaction_type)
				else Dense_rank() over 
				(ORDER BY csd.effective_date, csd.transaction_type, csd.tx_description)
				end txtypeorder
		, @status_code status_code
		, @status_text status_text
	 
	from #contact_clients ccl
	left join #facility_list fac on ccl.fac_id = fac.fac_id
	inner join #transactions csd on ccl.invoice_id= csd.invoice_id and ccl.client_id = csd.client_id and ccl.contact_id = csd.contact_id
			and ccl.contact_num = csd.contact_num --and (ccl.contact_id = @vReceiverIds or @vReceiverIds = -1)
	inner join dbo.facility f with (nolock) on ccl.fac_id = f.fac_id
	inner join dbo.common_code c with (nolock) on f.country_id = c.item_id
	inner join #contact_return_to return_add on ccl.contact_num = return_add.contact_num
	left join #invoices inv on ccl.invoice_id = inv.invoice_id
	left join dbo.ar_eft_client_configuration_history eftconfig with (nolock) on ccl.client_id = eftconfig.client_id
		and eftconfig.effective_date  <= inv.created_date AND (eftconfig.ineffective_date  >= inv.created_date or eftconfig.ineffective_date is null)	
	LEFT OUTER JOIN @ContactNums cn
	ON ccl.contact_id = cn.contact_id and ccl.fac_id = cn.fac_id
	where csd.detail_order <> 999 --and csd.detail_amount is not null
		and (csd.amount is not null or csd.other_payer > 0)
		and (@vMinimumBalance is null or ccl.summary_current_balance >= @vMinimumBalance)
		and (@vSuppress0value = 0 or (@vSuppress0value = 1 and  (csd.amount <> 0.00 or csd.transaction_type in('00','YY','YZ','ZZ'))) or csd.payer_id = 0)
	order by statement_num, ccl.summary_charge_center, ccl.summary_charge_client_name, ccl.summary_charge_client_number, ccl.bill_date, 
		Case when ccl.contact_id <= -2.1 then ccl.invoice_id else 0 end, ccl.generated_date, txsort, ccorder, txtypeorder

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
if @debug_me='Y' Print 'Successful execution of stored procedure ' + Object_name(@@ProcID) + convert(varchar(26),getdate(),109);

	if @sprocParamLogEnable > 0
	BEGIN
		BEGIN TRY
			set @endTime = GETDATE()

			update ar_sproc_params_log set end_time = @endTime, elapsed_time_in_ms = DATEDIFF(MILLISECOND,@startTime, @endTime)
			where sproc_log_id = @sprocExecId

		END TRY
		BEGIN CATCH
			--we do not want to break the execution of this stored procedure, do nothing here.
		END CATCH
	END

END TRY 

BEGIN CATCH 

	if @sprocParamLogEnable > 0
	BEGIN
		BEGIN TRY
			set @endTime = GETDATE()

			update ar_sproc_params_log set end_time = @endTime, elapsed_time_in_ms = DATEDIFF(MILLISECOND,@startTime, @endTime),
				error_code = Error_number(), error_message = Error_message()
				where sproc_log_id = @sprocExecId

		END TRY
		BEGIN CATCH
			--we do not want to break the execution of this stored procedure, do nothing here.
		END CATCH
	END

	if @status_code = 0 Set @Status_Code = 1 else set @status_code = 2  --- convert 3 to 2
	if @status_code = 1
	BEGIN
		select @Status_Text = Rtrim(Left('Stored Procedure Failed with error Code : ' +   Cast(@@error as Varchar(10)) +  ' Line Number : ' +  Cast(ERROR_LINE() as Varchar(5)) + ' ' +  ERROR_MESSAGE(),3000))

		if @debug_me='Y' Print 'Stored procedure failure in step:'+ convert(varchar(3),@vstep) + '	' + convert(varchar(26),getdate())
		if @debug_me='Y' Print 'Error code: '+convert(varchar(3),@vStep) + '; Error description:	' + @Status_Text
	END
	
	if @vExportMode = 0
	 
		Select 
			  NULL as fac_id
			, NULL as fac_country
			, NULL as contact_id
			, NULL as contact_num
			, NULL as consolidate_statement
			, NULL as online_id
			, NULL as client_id 
			, NULL as invoice_id
			, NULL as statement_invoice_number
			, NULL as remit_to_name
			, NULL as remit_to_address
			, NULL as remit_to_address2
			, NULL as remit_to_city
			, NULL as remit_to_county
			, NULL as remit_to_prov_state
			, NULL as remit_to_postal_zip_code
			, NULL as remit_to_phone
			, NULL as return_to_name
			, NULL as return_to_address
			, NULL as return_to_address2
			, NULL as return_to_city
			, NULL as return_to_county
			, NULL as return_to_prov_state
			, NULL as return_to_postal_zip_code
			, NULL as return_to_phone
			, NULL as contact_name
			, NULL as contact_address
			, NULL as contact_address2
			, NULL as contact_city
			, NULL as contact_county
			, NULL as contact_prov_state
			, NULL as contact_postal_zip_code
			, NULL as contact_country
			, NULL as account_number
			, NULL as bill_date
			, NULL as effective_date
			, NULL as generated_date
			, NULL as payment_due_date
			, NULL as pre_consolidated_payment_due_date
			, NULL as statement_through_date
			, NULL as amount_due
			, NULL as eft_message
			, NULL as client_list
			, NULL as client_message
			, NULL as group_message
			, NULL as global_message
			, NULL as statement_message
			, NULL as gst_hst
			, NULL as gst_number
			, NULL as previous_balance_due
			, NULL as payments
			, NULL as summary_charge_center	
			, NULL as summary_charge_client_name
			, NULL as summary_charge_client_number
			, NULL as summary_charge_client_location
			, NULL as summary_charge_client_admission
			, NULL as summary_charge_client_discharge
			, NULL as summary_current_balance
			, NULL as summary_previous_balance_due
			, NULL as summary_payments
			, NULL as summary_late_fees	
			, NULL as summary_client_balance_due
			, NULL as transaction_type
			, NULL as detail_effective_date 
			, NULL as detail_thru
			, NULL as detail_effective_thru_date
			, NULL as detail_description
			, NULL as detail_comment
			, NULL as reversed_tx
			, NULL as detail_units
			, NULL as detail_unit_amount
			, NULL as detail_amount
			, NULL as balance_due
			, NULL as other_payer
			, NULL as payer_type
			, NULL as aging_total
			, NULL as aging_current_label
			, NULL as aging_current_amount
			, NULL as aging_30_label
			, NULL as aging_30_amount
			, NULL as aging_60_label
			, NULL as aging_60_amount
			, NULL as aging_90_label
			, NULL as aging_90_amount
			, NULL as aging_120_label
			, NULL as aging_120_amount
			, NULL as aging_150_label
			, NULL as aging_150_amount
			, NULL as aging_180_label
			, NULL as aging_180_amount
			, NULL as aging_210_label
			, NULL as aging_210_amount
			, NULL as cheques_payable_to
			, NULL as ccorder
			, Null as statement_num
			, NULL as txtypeorder
			, NULL as status_code
			, NULL as status_text

	else

		select
			  NULL as contact_num
			, NULL as statement_num
			, NULL as facility_group_number
			, NULL as facility_group_name
			, NULL as facility_group_address_1
			, NULL as facility_group_address_2
			, NULL as facility_group_address_3
			, NULL as facility_group_county
			, NULL as facility_group_city
			, NULL as facility_group_state
			, NULL as facility_group_country
			, NULL as facility_group_zip_code
			, NULL as facility_group_telephone
			, NULL as facility_group_county
			, NULL as guarantor_id 
			, NULL as guarantor_first_name
			, NULL as guarantor_last_name
			, NULL as guarantor_address_1
			, NULL as guarantor_address_2
			, NULL as guarantor_address_3
			, NULL as guarantor_county
			, NULL as guarantor_city
			, NULL as guarantor_state
			, NULL as guarantor_country
			, NULL as guarantor_zip_code
			, NULL as guarantor_email_address
			, NULL as guarantor_county
			, NULL as remit_to_name
			, NULL as remit_to_address_1
			, NULL as remit_to_address_2
			, NULL as remit_to_address_3
			, NULL as remit_to_county
			, NULL as remit_to_city
			, NULL as remit_to_state
			, NULL as remit_to_country
			, NULL as remit_to_zip_code
			, NULL as remit_to_phone_number
			, NULL as remit_to_county
			, NULL as grand_total
			, NULL as late_fees
			, NULL as balance_forward_amount
			, NULL as cash_payments_received
			, NULL as online_id
			, NULL as term_used_for_patient
			, NULL as term_used_for_admission
			, NULL as term_used_for_discharge
			, NULL as show_invoice_number
			, NULL as show_location
			, NULL as show_admit_date
			, NULL as show_discharge_date
			, NULL as show_patient_number
			, NULL as show_transaction_warning_message
			, NULL as prefix_fac_code_to_acct_no
			, NULL as checks_payable_to		
			, NULL as payment_instruction
			, NULL as transaction_warning_message
			, NULL as account_number_label
			, NULL as account_number_source	
			, NULL as facility_id
			, NULL as facility_code
			, NULL as facility_name
			, NULL as client_id
			, NULL as patient_admit_date
			, NULL as patient_discharge_date
			, NULL as patient_number
			, NULL as patient_first_name
			, NULL as patient_last_name
			, NULL as patient_name
			, NULL as patient_dob
			, NULL as patient_location	
			, NULL as eft_enabled
			, NULL as patient_invoice_message
			, NULL as patient_group_message
			, NULL as eft_message
			, NULL as invoice_number
			, NULL as invoice_date
			, NULL as invoice_due_date
			, NULL as current_invoice_charges
			, NULL as total_amount_due
			, NULL as date_of_service
			, NULL as transaction_type
			, NULL as transaction_description
			, NULL as quantity
			, NULL as unit_amount
			, NULL as transaction_total_amount
			, NULL as show_payment_due_date
			, NULL as pre_consolidated_payment_due_date
			, NULL as statement_through_date			
			, NULL as detail_order
			, NULL as other_payer
			, NULL as payer_type
			, NULL as ccorder
			, NULL as txsort
			, NULL as txtypeorder
			, NULL as status_code
			, NULL as status_text

		
END CATCH 

RETURN 

END
GO
GRANT EXECUTE ON  dbo.sproc_prp_rl_statements   to PUBLIC
GO

GO

print 'C_Branch/04_StoredProcedures/sproc_prp_rl_statements.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_statements.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_transaction_report.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


--  PCC-104361       :   script to create sproc_prp_rl_transaction_report Procedure  
--						-- 
-- Written By:          Ritch Moore
-- Reviewed By:         
-- 
-- Script Type:         DDL 
-- Target DB Type:      Client
-- Target ENVIRONMENT:  BOTH (US/CA) 
-- 
-- 
-- Re-Runable:          YES 
-- 
-- Description of Script : Create sproc_prp_rl_transaction_report Procedure
-- 
-- Special Instruction: 
-- 
-- =================================================================================

/***********************************************************************************
Revision History:
2016-11-17  Ritch Moore		PCC-104362	3.7.12		Initial creation of this stored proc
2017-01-13	Ritch Moore		PCC-107953	3.7.12		Include All Unbilled Transactions To logic
2017-01-23	Ritch Moore		PCC-108421	3.7.12		Cash transactions will show the applied history in the Transactions report
2017-01-25	Ritch Moore		PCC-108556	3.7.12		Use alternate description for CL transaction types, if set
2017-02-07	Ritch Moore		PCC-109548	3.7.12		Fix Misc. Cash batch/entry issue
2017-02-08	Ritch Moore		PCC-109555	3.7.12		Comment out section for combining of multipayer cash transactions
2017-02-14	Ritch Moore		PCC-110057	3.7.12		Summarize reversal issue fix
2017-02-22	Ritch Moore		PCC-110313	3.7.12		Comment out delete after combining child transactions on a different payer than the parent
2017-02-14	Ritch Moore		PCC-110108	3.7.12.0.2	Suppress unit amounts for recurring ancillaries
2017-03-16	Ritch Moore		PCC-111098	3.7.12.0.2	Final sort updates
2017-03-16	Ritch Moore		PCC-112043	3.7.12.0.2	Previous balance calculation changes
2017-03-16	Ritch Moore		PCC-112068	3.7.12.0.2	Previous balance calculation changes
2017-03-21	Ritch Moore		PCC-112281	3.7.12.0.10	Revenue Code lookup changes
2017-04-03	Ritch Moore		PCC-112743	3.7.12.0.10	Don't calculate balance forwards when certain filters are selected
2017-04-05	Ritch Moore		PCC-113387	3.7.12.0.8	Add temp table index for previous balance performance
2017-04-06	Ritch Moore		PCC-113588	3.7.12.0.10	Summarize reversals, regardless of billing dates, if they are in the dataset
2017-04-06	Ritch Moore		PCC-113376	3.7.12.0.10	Use and display transaction date for cash and format cash transaction description
2017-04-07	Ritch Moore		PCC-113566	3.7.12.0.10	Summarize by Charge Code and Charge Code Category changes
2017-04-13	Ritch Moore		PCC-113993	3.7.12.0.13	Remove Billed and Unbilled text when combining all ancillaries by billing date
2017-04-17	Ritch Moore		PCC-113995	3.7.12.0.13	Show marked as billed transactions separately for the ancillary summary options
2017-04-17	Ritch Moore		PCC-114363	3.7.12.0.13 Charge codes without categories defined will be summarized by charge code and charge code description
2017-04-24	Ritch Moore		PCC-114810	3.7.12.0.14 Trim leading and trailing spaces from incoming revenue codes
2017-04-27	Ritch Moore		PCC-114180	3.7.13		Adjust grouping to keep all ancillary charges together 
2017-05-30	Ritch Moore		PCC-116087	3.7.13.1	Include transactions that are created using the 'Apply Payments' link
2017-06-07	Ritch Moore		PCC-116893	3.7.13.1	Remove Trust Transfer transaction - already account for as an applied payment
2017-06-07	Ritch Moore		PCC-117291	3.7.13.1	Show previous balance even when one resident is selected and no transactions exist
2017-07-18	Michael Shlayen PCC-118477	3.7.14		TRANSACTIONS: add location to room charges on transaction report
2017-12-06	Ritch Moore		CORE-7954	3.7.14.2	Isolate previous balance calculation for all unbilled transactions
***********************************************************************************/

IF EXISTS ( SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE 
				FROM INFORMATION_SCHEMA.ROUTINES
				WHERE ROUTINE_SCHEMA = 'dbo' and ROUTINE_NAME = 'sproc_prp_rl_transaction_report' and ROUTINE_TYPE = 'PROCEDURE' ) 
BEGIN
	DROP PROCEDURE dbo.sproc_prp_rl_transaction_report
END
GO

SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON  --Keep it ON as we have used Reserved words in out database as STatus, floor....
GO


Create Procedure dbo.sproc_prp_rl_transaction_report
  @fac_id int
, @client_id int -- 0 = Only Misc. Cash
, @start_date datetime
, @end_date datetime
, @payer_id_list varchar(max) = Null
, @payer_type_list varchar(max) = Null
, @transaction_types varchar(max) = Null
, @dollars_account_list varchar(max) = Null
, @days_account_list varchar(max) = Null
, @charge_code_list varchar(max) = Null
, @revenue_code_list varchar(max) = Null
, @account_type_list varchar(max) = Null
, @hcpcs_code_list varchar(max) = Null
, @summarize_reversals bit = 0 
, @show_results varchar(2)--D = Detail, C = Summarize by Charge Code, CC = Summarize by Charge Code Category, A = Summarize all Ancillary Charges
, @combine_children tinyint = 0 -- 0 = all transactions, 1 = combine all children, 2 = reimbursement rate (combine CA and CR with parent)
, @suppress_0_value bit = 0
, @only_clients_with_transactions bit = 1 
, @show_comments bit = 1
, @include_misc_cash bit = 0
, @include_billed bit = 1
, @include_unbilled bit = 1
, @include_marked_as_billed bit =0
, @show_details bit = 0
, @print_report_by varchar(20) = 'service_date' --'posting_date', 'service_date', 'billing_date'
, @report_format varchar(3) ='pdf' --'pdf', 'csv'
, @execution_user_login varchar(60)
, @debug_me char(1)
, @rows_returned int out
, @status_code int out
, @status_text varchar(3000) out

/********************************************************************************
exec  sproc_prp_rl_transaction_report
  @fac_id = 10
, @client_id = -1
, @start_date = Null--'7/1/2015'
, @end_date = '10/31/2015'
, @payer_id_list	= '-1'
, @payer_type_list	= Null--'Medicaid,Medicare A,Medicare D,Other,Medicare B,Outpatient,Managed Care,Private'--'Private,Medicare A'--Null--'Medicare A'
, @transaction_types = '-1'--'C'--'X_R, X_W, X_B, X_O, A, C, CX, CA, MPPR, CR, CO, CW, CL, D, DR, Recur, XR, R, TA, PC'
, @dollars_account_list = '-1'
, @days_account_list = '-1'
, @charge_code_list = '-1'
, @revenue_code_list = '-1'
, @account_type_list = '-1'
, @hcpcs_code_list = '-1'
, @summarize_reversals = 1
, @show_results  = 'D' --D = Detail, C = Summarize by Charge Code, CC = Summarize by Charge Code Category, A = Summarize all Ancillary Charges
, @combine_children = 0 -- 0 = all transactions, 1 = combine all children, 2 = reimbursement rate (combine CA and CR with parent)
, @suppress_0_value = 0 
, @only_clients_with_transactions = 0
, @show_comments = 0
, @include_misc_cash = 0
, @include_billed = 1
, @include_unbilled = 1
, @include_marked_as_billed = 1
, @show_details = 1
, @print_report_by = 'service_date' --'service_date', 'posting_date', 'billing_date'
, @report_format = 'pdf'
, @execution_user_login = 'PCC-moorer'
, @debug_me  = 'N'
, @rows_returned  = 0 
, @status_code  = 0 
, @status_text  = Null 


**********************************************************************************/

as
Begin

SET NOCOUNT ON;
--declare Standard local variables required for any store proc
DECLARE  @vStep int
		,@vErr varchar(max)
		,@vdelim char(1)
		,@vReportDate datetime
		,@vRowCount int
		,@vCflr varchar(10)
		,@vBeginBoldTag varchar(3)
		,@vEndBoldTag varchar(4)

--Facility Related variables, also used in capturing execution Statistics 
Declare @vFacIDs varchar(max)		
Declare @PRP_FacList as table(FacId int)
Declare @vFacWarningMsg varchar(max) --- to know whether it the returned list is restricted

----Local Variables
DECLARE @vFacID int
	, @vClientID int
	, @vStartDate datetime
	, @vEndDate datetime
	, @vPayerTypeList varchar(max)
	, @vPayerIdList varchar(max)
	, @vTransactionTypes varchar(max)
	, @vDollarsAccountList varchar(max)
	, @vDaysAccountList varchar(max)
	, @vChargeCodeList varchar(max)
	, @vRevenueCodeList varchar(max)
	, @vAccountTypeList varchar(max)
	, @vHcpcsCodeList varchar(max) 
	, @vSummarizeReversals bit
	, @vShowResults varchar(2)
	, @vCombineChildren tinyint
	, @vSuppress0value bit
	, @vOnlyClientsWithTransactions bit
	, @vShowComments bit
	, @vIncludeMiscCash bit
	, @vPrintReportBy varchar(20)
	, @vReportFormat varchar(3)
	, @vIncludeCash bit
	, @vIncludeBilled bit
	, @vIncludeUnBilled bit
	, @vIncludeMarkedAsBilled bit
	, @vIncludeMPPR bit
	, @vIncludeRecurring bit
	, @vShowDetails bit
	, @vCurrentDate smalldatetime
	, @vCalcBF bit

-----Governor and Statistics Variables 
Declare  @vgs_program_name varchar(200)
		 ,@vgs_start_time datetime
		 ,@vgs_execution_user varchar(60)
		 ,@vgs_fill_end_time datetime
		 ,@vgsStepStartTime datetime
		 ,@vgsStepEndTime datetime

----client Access Varaibles
Declare @vCheckClientId varchar(max)
Declare @vClientIDs varchar(max)		
Declare @vClientWarningMsg varchar(max)--- to know whether it the returned list is restricted

DECLARE @payer_ids_table 
	table (
			payer_id int
		  );

DECLARE @payer_type_table 
	table (
			payer_type varchar(20)
		  );

DECLARE @dollars_account_ids_table 
	table (
			account_id int
		  );

DECLARE @days_account_ids_table 
	table (
			account_id int
		  );

DECLARE @charge_code_ids_table 
	table (
			charge_code_id int
		  );

DECLARE @transaction_type_list 
	table (
			transaction_type varchar(5)
			);

DECLARE @account_type_ids_table 
	table (
			account_type_id int
		  );

DECLARE @revenue_code_table 
	table (
			revenue_code varchar(15)
		  );

DECLARE @hcpcs_code_table 
	table (
			hcpcs_code varchar(5)
		  );

create table #transactions

	(
		  fac_id						int
		, client_id						int
		, payer_id						int
		, payer							varchar(100)
		, batch_id						int
		, entry_number					int
		, distribution_tx_id			bigint
		, transaction_id				bigint
		, auto_generated				varchar(1)
		, billing_date					datetime
		, posting_date					datetime
		, effective_date				datetime
		, effective_from_date			datetime
		, effective_thru_date			datetime
		, charge_code					varchar(12)
		, revenue_code					varchar(5)
		, hcpcs_code					varchar(5)
		, mppr_flag						bit
		, tx_description				varchar(200)
		, care_level					varchar(5)
		, benefit_days					varchar(10)
		, parent_tx_type				varchar(2)
		, transaction_type				varchar(2)
		, unit_amount					money
		, units							int
		, amount						money
		, gl_account					varchar(75)
		, days_account					varchar(75)
		, billed						varchar(5)
		, comment						varchar(200)
		, cheque_number					varchar(50)
		, mark_as_billed_by				varchar(60)
		, mark_as_billed_date			datetime
		, mark_as_billed_comment		varchar(256)
		, adjusted_tx_type				varchar(10)
		, recurring_tx					bit
		, reversed						bit
		, transaction_type_group		tinyint
		, ancillary_year				smallint
		, ancillary_month				tinyint
		, ar_applied_payment_history_id	int

	);

create table #local_transactions
	(
		  invoice_id					int
		, batch_id						int
		, entry_number					int
		, client_id						int
		, auto_generated				varchar(1)
		, transaction_id				int
		, reversing_tx_id				int
		, distribution_tx_id			int
		, applied_payment_id			int
		, payer_id						int
		, days_account_id				int
		, dollars_account_id			int
		, fac_id						int
		, is_billed						bit
		, transaction_type				varchar(2)
		, parent_tx_type				varchar(2)
		, [description]					varchar(100)
		, alt_description				varchar(100)
		, cheque_number					varchar(50)
		, effective_date				datetime
		, transaction_date				datetime
		, billing_date					datetime
		, applied_date					datetime
		, days_amount					int
		, daily_rate					money
		, monthly_rate					money
		, amount						money
		, care_level					varchar(5)
		, revenue_code					varchar(5)
		, hcpcs_code					varchar(5)
		, item_type_id					int
		, comment						varchar(200)
		, rate_type_id					int
		, rugs_modifier					varchar(2)
		, medicare_day					int
		, mppr_flag						bit
		, mark_as_billed_by				varchar(60)
		, mark_as_billed_date			datetime
		, mark_as_billed_comment		varchar(256)
		, transaction_type_group		tinyint
		, skip_bit						tinyint
		, ar_applied_payment_history_id	int
	);

CREATE CLUSTERED INDEX _tmp_idx_local_transactions on #local_transactions(invoice_id,transaction_type,distribution_tx_id,reversing_tx_id);

create table #child_transactions
	(
		  distribution_tx_id			int
		, transaction_type				varchar(2)
		, parent_tx_type				varchar(2)
		, payer_id						int
		, days_amount					int
		, daily_rate					money
		, monthly_rate					money
		, amount						money
		, billing_date					datetime
		, skip_bit						bit

	);

create table #balance_forward_union
	(	  fac_id		int
		, client_id		int 
		, payer_id		int
		, amount		money 
	);

create table #balance_forward_amount
	(	 fac_id			int
		,client_id		int 
		,payer_id		int 
		,amount			money 
	);

BEGIN TRY

Set @status_code = 0   ---- Status Code 0 = Success, 1 = Exception
set @status_text = null;
set @rows_returned = 0;
Set @vgs_program_name  = Object_name(@@ProcID);  ---Current Store Proc Name
Set @vgs_start_time = getdate();
Set @vgs_execution_user = @execution_user_login;
set @vdelim = ','
set @vCflr = Char(13)
set @vBeginBoldTag = '<b>'
set @vEndBoldTag = '</b>'
set @vStep = 0
set @vgsStepStartTime = GETDATE()

if @debug_me='Y' Print 'STEP ' + convert(varchar(20), @vStep) + ' Executing store proc :  ' + @vgs_program_name  + convert(varchar(26),getdate(),109)


select @vStep = 1
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Setting local variables  ' +  convert(varchar(26),getdate(),109)

----Parameter Sniffing - use local variables when they are used in a where clause
SET  @vFacID							= @fac_id
SET  @vClientID							= @client_id
SET  @vStartDate						= @start_date
SET  @vEndDate							= Case when @print_report_by = 'billing_date' and @end_date is not null then convert(datetime, convert(varchar(10),@end_date , 101) + ' 23:59:59')else @end_date end
SET  @vPayerIdList						= @payer_id_list;
SET  @vPayerTypeList					= @payer_type_list;
SET	 @vDollarsAccountList				= @dollars_account_list
SET	 @vDaysAccountList					= @days_account_list
SET  @vChargeCodeList					= @charge_code_list
SET  @vRevenueCodeList					= @revenue_code_list
SET  @vAccountTypeList					= @account_type_list
SET  @vHcpcsCodeList					= @hcpcs_code_list
SET  @vTransactionTypes					= @transaction_types
SET  @vSummarizeReversals				= @summarize_reversals
SET  @vShowResults						= @show_results;
SET  @vCombineChildren					= @combine_children
SET  @vSuppress0value					= @suppress_0_value
SET  @vOnlyClientsWithTransactions		= @only_clients_with_transactions
SET  @vShowComments						= @show_comments
SET  @vIncludeMiscCash					= @include_misc_cash
SET  @vPrintReportBy					= @print_report_by
SET  @vReportFormat						= @report_format
SET  @vIncludeBilled					= @include_billed
SET  @vIncludeUnBilled					= @include_unbilled
SET  @vIncludeMarkedAsBilled			= @include_marked_as_billed
SET	 @vShowDetails						= @show_details
SET  @vCurrentDate						= convert(datetime, convert(varchar(10),getdate() , 101) + ' 23:59:59')
SET  @vIncludeMPPR						= 0
SET  @vIncludeRecurring					= 0

if @vShowResults = 'R' --due to bad data, we need to load a unique set of revenue codes in order to gather their descriptions (only when grouping by revenue code)
begin
	create table #revenue_codes
		(	  revenue_code	varchar(15)
			, description	varchar(140) 
		);

	insert into #revenue_codes --get properly scoped revenue codes first.  If multiple codes exist, take the oldest
	select revcd.revenue_code, addcc.item_description
	from
	(select min(cc.item_id) id, ltrim(rtrim(cc.short_description)) revenue_code
	from
	dbo.ar_common_code cc with (nolock)
	inner join dbo.ar_common_type ct with (nolock) on cc.[type_id] = ct.[type_id] and cc.deleted='N' and ct.item_code = 'REVCD'
	left join dbo.facility fac with (nolock) on cc.fac_id = fac.fac_id or cc.fac_id = -1 or cc.reg_id = fac.regional_id or cc.state_code = fac.prov
	where fac.fac_id = @vFacID
	group by cc.short_description) revcd
	inner join dbo.ar_common_code addcc with (nolock) on revcd.id = addcc.item_id

	insert into #revenue_codes --load any additional revenue codes (taking the oldest if there are duplicates) in case they are used
	select revcd.revenue_code, addcc.item_description
	from
	(select min(cc.item_id) id, ltrim(rtrim(cc.short_description)) revenue_code
	from
	dbo.ar_common_code cc with (nolock)
	inner join dbo.ar_common_type ct with (nolock) on cc.[type_id] = ct.[type_id] and cc.deleted='N' and ct.item_code = 'REVCD'
	group by cc.short_description) revcd
	inner join dbo.ar_common_code addcc with (nolock) on revcd.id = addcc.item_id
	left join #revenue_codes scp on revcd.revenue_code = scp.revenue_code
	where scp.revenue_code is null

end

if @vStartDate is null --include unbilled only to...
	begin
		SET  @vIncludeBilled = 0
		SET  @vIncludeUnBilled = 1
		SET  @vIncludeMarkedAsBilled = 0
	end

--If isnull(@vClientID, '-1') <> '-1' 
--	SET  @vOnlyClientsWithTransactions= 1

if isnull(@vPayerTypeList,'-1') <>'-1'
	INSERT into @payer_type_table select ltrim(rtrim(items)) from dbo.Split(@vPayerTypeList,@vdelim)

if isnull(@vPayerIdList,'-1') <>'-1'
	INSERT into @payer_ids_table select Cast(items as int) from dbo.Split(@vPayerIdList,@vdelim)

if @vPrintReportBy = 'billing_date' and isnull(@vPayerTypeList,'-1') <>'-1'
	begin
		INSERT into @payer_ids_table 
		select libpayer.payer_id 
		from dbo.ar_lib_payers libpayer with (nolock)
		inner join @payer_type_table ptype on libpayer.payer_type = ptype.payer_type and libpayer.deleted='N' and 
		((libpayer.payer_type <> 'Outpatient' and libpayer.bill_form = 'private') or (libpayer.payer_type = 'Outpatient' and libpayer.outpatient_payer_type = 'Private')) 

		set @vPayerTypeList = Null
		set @vPayerIdList = '-1'
	end

if isnull(@vDollarsAccountList,'-1') <>'-1'
	INSERT into @dollars_account_ids_table select ltrim(rtrim(items)) from dbo.Split(@vDollarsAccountList,@vdelim)

if isnull(@vDaysAccountList,'-1') <>'-1'
	INSERT into @days_account_ids_table select Cast(items as int) from dbo.Split(@vDaysAccountList,@vdelim)

if isnull(@vChargeCodeList,'-1') <>'-1'
	INSERT into @charge_code_ids_table select Cast(items as int) from dbo.Split(@vChargeCodeList,@vdelim)

if isnull(@vTransactionTypes, '-1') <> '-1'
	begin
		--INSERT into @transaction_type_list select replace(ltrim(rtrim(items)),'_','') from dbo.Split(@vTransactionTypes,@vdelim)
		INSERT into @transaction_type_list select ltrim(rtrim(items)) from dbo.Split(@vTransactionTypes,@vdelim)
		if (select count(*) from @transaction_type_list where transaction_type = 'MPPR') > 0
			SET  @vIncludeMPPR = 1
		if (select count(*) from @transaction_type_list where transaction_type = 'Recur') > 0
			SET  @vIncludeRecurring	= 1
		if (select count(*) from @transaction_type_list where transaction_type <> 'X' and transaction_type like 'X_%') > 0
			INSERT into @transaction_type_list select 'X'
	end

if isnull(@vTransactionTypes, '-1') = '-1' or (select count(*) from @transaction_type_list where transaction_type = 'C') > 0
	set @vIncludeCash = 1
else
	set @vIncludeCash = 0 

if isnull(@vAccountTypeList,'-1') <>'-1'
	INSERT into @account_type_ids_table select Cast(items as int) from dbo.Split(@vAccountTypeList,@vdelim)

if isnull(@vRevenueCodeList,'-1') <>'-1'
	INSERT into @revenue_code_table select ltrim(rtrim(items)) from dbo.Split(@vRevenueCodeList,@vdelim)

if isnull(@vHcpcsCodeList,'-1') <>'-1'
	INSERT into @hcpcs_code_table select ltrim(rtrim(items)) from dbo.Split(@vHcpcsCodeList,@vdelim)

if isnull(@vTransactionTypes, '-1') = '-1' and isnull(@vDollarsAccountList,'-1') = '-1' and isnull(@vDaysAccountList,'-1') = '-1' and isnull(@vChargeCodeList,'-1') = '-1' and
	isnull(@vAccountTypeList,'-1') = '-1' and isnull(@vRevenueCodeList,'-1') = '-1' and isnull(@vHcpcsCodeList,'-1') = '-1'
	set @vCalcBF = 1
else 
	set @vCalcBF = 0

if @debug_me='Y' 
	begin
		select '@payer_type_table',* from @payer_type_table
		select '@payer_ids_table',* from @payer_ids_table
		select '@dollars_account_ids_table',* from @dollars_account_ids_table
		select '@days_account_ids_table',* from @days_account_ids_table
		select '@transaction_type_list',* from @transaction_type_list
		select '@charge_code_ids_table',* from @charge_code_ids_table
		select '@account_type_ids_table',* from @account_type_ids_table
		select '@revenue_code_table',* from @revenue_code_table
		select '@hcpcs_code_table',* from @hcpcs_code_table
	end

set @vgsStepEndTime=GETDATE();
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

select @vStep = 5
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' Validating Input Parameters  ' +  convert(varchar(26),getdate(),109)

----Validate all input parameters
if (
		@execution_user_login is null
	)
	begin
		set @vErr = 'One or more of the following input parameters is invalid... '
					+ ', @execution_user_login=' + isnull(@execution_user_login,'null/empty')
		
		RAISERROR (@vErr -- Message text
						,11 -- Severity (RAISERROR with severity 11-19 will cause execution to jump to the CATCH block)
						,1 -- State
						);
	end

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

Select @vStep = 10;
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Gathering transaction Data ' + convert(varchar(26),getdate(),109);


if @vPrintReportBy = 'posting_date'
	begin
	insert into #local_transactions
	
	select tx.invoice_id
		, tx.batch_id
		, tx.entry_number
		, tx.client_id
		--, 'N' as auto_generated
		, isnull(tx.auto_generated,'N')
		, tx.transaction_id
		, tx.reversing_tx_id
		, tx.distribution_tx_id
		, 0 as applied_payment_id
		, tx.payer_id
		, tx.days_account_id
		, tx.dollars_account_id
		, tx.fac_id
		, tx.is_billed
		, tx.transaction_type
		, tx.parent_tx_type
		, tx.[description]
		, tx.alt_description
		, tx.cheque_number
		, tx.effective_date
		, tx.transaction_date
		, inv.effective_Date as billing_date
		, Null as applied_date
		, tx.days_amount
		, tx.daily_rate
		, tx.monthly_rate
		, tx.amount
		, tx.care_level
		, Case when isnull(tx.revenue_code,'') = '' or tx.revenue_code = '-1' then '' else tx.revenue_code end as revenue_code
		, tx.hcpcs_code	
		, tx.item_type_id
		, tx.comment
		, tx.rate_type_id
		, tx.rugs_modifier
		, tx.medicare_day
		, tx.mppr_flag
		, tx.mark_as_billed_by
		, tx.mark_as_billed_date
		, tx.mark_as_billed_comment
		, Case when (tx.transaction_type in('r','dr','cl','cr','d') and tx.parent_tx_type = 'r'
			or ((tx.transaction_type = 'co'or tx.transaction_type = 'cw')
			and tx.auto_generated = 'y') or (tx.transaction_type = 'xr' 
			and tx.parent_tx_type = 'r')) then 1 
			when tx.transaction_type = 'c' then 3 
			else 2 end as transaction_type_group
		, 1
		, 0
	from dbo.ar_transactions tx with (nolock)
	inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'  and tx.fac_id= @vFacID and (@vClientID = -1 or tx.client_id = @vClientID) 
	left join dbo.ar_invoice inv with (nolock) on tx.invoice_id = inv.invoice_id 
	left join @payer_ids_table pids on tx.payer_id = pids.payer_id
	left join @payer_type_table ptypes on libpayer.payer_type = ptypes.payer_type	
	left join @dollars_account_ids_table dola on tx.dollars_account_id = dola.account_id
	left join @days_account_ids_table daya on tx.days_account_id = daya.account_id
	left join @charge_code_ids_table cc on tx.item_type_id = cc.charge_code_id
	left join dbo.ar_lib_accounts dollibac with (nolock) on tx.dollars_account_id = dollibac.account_id
	left join @account_type_ids_table dolactype on dollibac.account_type_id = dolactype.account_type_id
	left join dbo.ar_lib_accounts daylibac with (nolock) on tx.days_account_id = daylibac.account_id
	left join @account_type_ids_table dayactype on daylibac.account_type_id = dayactype.account_type_id
	left join @revenue_code_table revcd on tx.revenue_code = revcd.revenue_code
	left join @hcpcs_code_table hcpcs on tx.hcpcs_code = hcpcs.hcpcs_code

	WHERE 
		tx.deleted = 'N' --and tx.transaction_type <>'C' 
		and tx.transaction_date is not null 
		and
		(
		(isnull(@vPayerIdList,'-1') <> '-1' and pids.payer_id is not null)
		or
		(isnull(@vPayerTypeList,'-1') <> '-1' and  ptypes.payer_type is not null)
		or
		(isnull(@vPayerIdList,'-1') = '-1' and isnull(@vPayerTypeList,'-1') = '-1')
		)
		and
		((isnull(@vDollarsAccountList,'-1') <>'-1' and dola.account_id is not null) or isnull(@vDollarsAccountList,'-1') = '-1' )
		and
		((isnull(@vDaysAccountList,'-1') <>'-1' and daya.account_id is not null) or isnull(@vDaysAccountList,'-1') = '-1' )
		and
		((isnull(@vChargeCodeList,'-1') <>'-1' and cc.charge_code_id is not null) or isnull(@vChargeCodeList,'-1') = '-1' )
		and
		((isnull(@vAccountTypeList,'-1') <>'-1' and (dayactype.account_type_id is not null or dolactype.account_type_id is not null)) or isnull(@vAccountTypeList,'-1') ='-1')
		and
		((isnull(@vRevenueCodeList,'-1') <>'-1' and revcd.revenue_code is not null) or isnull(@vRevenueCodeList,'-1') = '-1' )
		and
		((isnull(@vHcpcsCodeList,'-1') <>'-1' and hcpcs.hcpcs_code is not null) or isnull(@vHcpcsCodeList,'-1') = '-1' )
		and
		(
		(@vIncludeBilled = 1 and @vIncludeUnBilled = 1 and @vIncludeMarkedAsBilled = 1)
		or
		(@vIncludeBilled = 1 and @vIncludeUnBilled = 1 and @vIncludeMarkedAsBilled = 0 and ((tx.invoice_id <> -999 and tx.is_billed = 1) or tx.is_billed = 0))
		or
		(@vIncludeBilled = 1 and @vIncludeUnBilled = 0 and @vIncludeMarkedAsBilled = 0 and tx.is_billed = 1 and tx.invoice_id <> -999)		
		or
		(@vIncludeBilled = 1 and @vIncludeUnBilled = 0 and @vIncludeMarkedAsBilled = 1 and tx.is_billed = 1 and tx.invoice_id is not null)	
		or
		(@vIncludeBilled = 0 and @vIncludeUnBilled = 1 and @vIncludeMarkedAsBilled = 1 and ((tx.invoice_id = -999 and tx.is_billed = 1) or tx.is_billed = 0))
		or
		(@vIncludeBilled = 0 and @vIncludeUnBilled = 1 and @vIncludeMarkedAsBilled = 0 and tx.is_billed = 0 and tx.invoice_id is null)
		or
		(@vIncludeBilled = 0 and @vIncludeUnBilled = 0 and @vIncludeMarkedAsBilled = 1 and tx.invoice_id = -999)	
		)
		and
		(
		(@vPrintReportBy = 'posting_date' and tx.transaction_date is not null and ((tx.transaction_date >= @vStartDate or @vStartDate is null)
			and tx.transaction_date <= @vEndDate))
		)

	end
else
	begin
	--all non applied cash transactions
	insert into #local_transactions
	
	select tx.invoice_id
		, tx.batch_id
		, tx.entry_number
		, tx.client_id
		--, 'N' as auto_generated
		, isnull(tx.auto_generated,'N')
		, tx.transaction_id
		, tx.reversing_tx_id
		, tx.distribution_tx_id
		, 0 as applied_payment_id
		, tx.payer_id
		, tx.days_account_id
		, tx.dollars_account_id
		, tx.fac_id
		, tx.is_billed
		, tx.transaction_type
		, tx.parent_tx_type
		, tx.[description]
		, tx.alt_description
		, tx.cheque_number
		, tx.effective_date
		, tx.transaction_date
		, inv.effective_Date as billing_date
		, Null as applied_date
		, tx.days_amount
		, tx.daily_rate
		, tx.monthly_rate
		, tx.amount
		, tx.care_level
		, Case when isnull(tx.revenue_code,'') = '' or tx.revenue_code = '-1' then '' else tx.revenue_code end as revenue_code
		, tx.hcpcs_code	
		, tx.item_type_id
		, tx.comment
		, tx.rate_type_id
		, tx.rugs_modifier
		, tx.medicare_day
		, tx.mppr_flag
		, tx.mark_as_billed_by
		, tx.mark_as_billed_date
		, tx.mark_as_billed_comment
		, Case when (tx.transaction_type in('r','dr','cl','cr','d') and tx.parent_tx_type = 'r'
			or ((tx.transaction_type = 'co'or tx.transaction_type = 'cw')
			and tx.auto_generated = 'y') or (tx.transaction_type = 'xr' 
			and tx.parent_tx_type = 'r')) then 1 
			when tx.transaction_type = 'c' then 3 
			else 2 end as transaction_type_group
		, 1
		, pay.applied_payment_id
	from dbo.ar_transactions tx with (nolock)
	inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'  and tx.fac_id= @vFacID and (@vClientID = -1 or tx.client_id = @vClientID) 
	left join dbo.ar_invoice inv with (nolock) on tx.invoice_id = inv.invoice_id 
	left join @payer_ids_table pids on tx.payer_id = pids.payer_id
	left join @payer_type_table ptypes on libpayer.payer_type = ptypes.payer_type	
	left join @dollars_account_ids_table dola on tx.dollars_account_id = dola.account_id
	left join @days_account_ids_table daya on tx.days_account_id = daya.account_id
	left join @charge_code_ids_table cc on tx.item_type_id = cc.charge_code_id
	left join dbo.ar_lib_accounts dollibac with (nolock) on tx.dollars_account_id = dollibac.account_id
	left join @account_type_ids_table dolactype on dollibac.account_type_id = dolactype.account_type_id
	left join dbo.ar_lib_accounts daylibac with (nolock) on tx.days_account_id = daylibac.account_id
	left join @account_type_ids_table dayactype on daylibac.account_type_id = dayactype.account_type_id
	left join @revenue_code_table revcd on tx.revenue_code = revcd.revenue_code
	left join @hcpcs_code_table hcpcs on tx.hcpcs_code = hcpcs.hcpcs_code
	left join dbo.ar_applied_payment_history pay with (nolock) on tx.transaction_id = pay.transaction_id

	WHERE 
		tx.deleted = 'N' --and tx.transaction_type <>'C' 
		and tx.transaction_date is not null 
		and pay.transaction_id is null
		and
		(
		(isnull(@vPayerIdList,'-1') <> '-1' and pids.payer_id is not null)
		or
		(isnull(@vPayerTypeList,'-1') <> '-1' and  ptypes.payer_type is not null)
		or
		(isnull(@vPayerIdList,'-1') = '-1' and isnull(@vPayerTypeList,'-1') = '-1')
		)
		and
		((isnull(@vDollarsAccountList,'-1') <>'-1' and dola.account_id is not null) or isnull(@vDollarsAccountList,'-1') = '-1' )
		and
		((isnull(@vDaysAccountList,'-1') <>'-1' and daya.account_id is not null) or isnull(@vDaysAccountList,'-1') = '-1' )
		and
		((isnull(@vChargeCodeList,'-1') <>'-1' and cc.charge_code_id is not null) or isnull(@vChargeCodeList,'-1') = '-1' )
		and
		((isnull(@vAccountTypeList,'-1') <>'-1' and (dayactype.account_type_id is not null or dolactype.account_type_id is not null)) or isnull(@vAccountTypeList,'-1') ='-1')
		and
		((isnull(@vRevenueCodeList,'-1') <>'-1' and revcd.revenue_code is not null) or isnull(@vRevenueCodeList,'-1') = '-1' )
		and
		((isnull(@vHcpcsCodeList,'-1') <>'-1' and hcpcs.hcpcs_code is not null) or isnull(@vHcpcsCodeList,'-1') = '-1' )
		and
		(
		(@vIncludeBilled = 1 and @vIncludeUnBilled = 1 and @vIncludeMarkedAsBilled = 1)
		or
		(@vIncludeBilled = 1 and @vIncludeUnBilled = 1 and @vIncludeMarkedAsBilled = 0 and ((tx.invoice_id <> -999 and tx.is_billed = 1) or tx.is_billed = 0))
		or
		(@vIncludeBilled = 1 and @vIncludeUnBilled = 0 and @vIncludeMarkedAsBilled = 0 and tx.is_billed = 1 and tx.invoice_id <> -999)		
		or
		(@vIncludeBilled = 1 and @vIncludeUnBilled = 0 and @vIncludeMarkedAsBilled = 1 and tx.is_billed = 1 and tx.invoice_id is not null)	
		or
		(@vIncludeBilled = 0 and @vIncludeUnBilled = 1 and @vIncludeMarkedAsBilled = 1 and ((tx.invoice_id = -999 and tx.is_billed = 1) or tx.is_billed = 0))
		or
		(@vIncludeBilled = 0 and @vIncludeUnBilled = 1 and @vIncludeMarkedAsBilled = 0 and tx.is_billed = 0 and tx.invoice_id is null)
		or
		(@vIncludeBilled = 0 and @vIncludeUnBilled = 0 and @vIncludeMarkedAsBilled = 1 and tx.invoice_id = -999)	
		)
		and
		(
		(
		(@vPrintReportBy = 'service_date' and tx.transaction_date is not null and ((tx.effective_date >= @vStartDate or @vStartDate is null)
			and tx.effective_date <=  @vEndDate)) 
		)
		or
		(
		(@vPrintReportBy = 'posting_date' and tx.transaction_date is not null and ((tx.transaction_date >= @vStartDate or @vStartDate is null)
			and tx.transaction_date <= @vEndDate))
		)
		or
		(@vPrintReportBy = 'billing_date' and tx.transaction_date is not null and (((inv.effective_date >= @vStartDate or @vStartDate is null)
			and (inv.effective_date <= @vEndDate or @vEndDate is null)) or (inv.effective_date is null and tx.effective_date >= @vStartDate and @vEndDate is null))
		)
		)
		and
		(
		(@vPrintReportBy = 'billing_date' and ((tx.invoice_id <> -999 and tx.is_billed = 1) or (tx.is_billed = 0 and @vEndDate is null)))
		or
		(@vPrintReportBy <> 'billing_date')		
		) 

		--need to remove trust transfers that are already accounted for in order to balance (except when full receipt amount goes to trust)
		delete from tfer
		from #local_transactions tfer
		inner join dbo.ar_transactions tx with (nolock) on tfer.distribution_tx_id = tx.transaction_id and tx.deleted='N' and tx.trust_amount is not null
		left join dbo.ar_applied_payment_history pay with (nolock) on tfer.transaction_id = pay.transaction_id
		inner join dbo.ar_applied_payment_history parent_pay with (nolock) on tfer.distribution_tx_id = parent_pay.transaction_id 
		where pay.transaction_id is null
		
		
	    --all applied cash transactions	
		insert into #local_transactions

		select tx.invoice_id
			, tx.batch_id
			, tx.entry_number
			, tx.client_id
			, tx.auto_generated
			, tx.transaction_id
			, tx.reversing_tx_id
			, tx.distribution_tx_id
			, pay.applied_payment_id
			, tx.payer_id
			, tx.days_account_id
			, tx.dollars_account_id
			, tx.fac_id
			, tx.is_billed
			, tx.transaction_type
			, tx.parent_tx_type
			, Case when @vPrintReportBy = 'service_date' then  tx.[description] + ' applied on ' + FORMAT(pay.applied_date,'MMM dd, yyyy')  else tx.[description] end as [description]
			, tx.alt_description
			, tx.cheque_number
			, Case when @vPrintReportBy = 'service_date' then pay.applied_to_date else tx.effective_date end as effective_date
			, tx.transaction_date
			, inv.effective_date as billing_date
			, pay.applied_date
			, tx.days_amount
			, tx.daily_rate
			, tx.monthly_rate
			, -1 * pay.amount as amount
			, tx.care_level
			, Case when isnull(tx.revenue_code,'') = '' or tx.revenue_code = '-1' then '' else tx.revenue_code end as revenue_code
			, tx.hcpcs_code	
			, tx.item_type_id
			, tx.comment
			, tx.rate_type_id
			, tx.rugs_modifier
			, tx.medicare_day
			, tx.mppr_flag
			, tx.mark_as_billed_by
			, tx.mark_as_billed_date
			, tx.mark_as_billed_comment
			, 3 as transaction_type_group
			, 1
			, pay.applied_payment_id
		FROM dbo.ar_applied_payment_history pay with (nolock) 
		inner join dbo.ar_lib_payers libpayer with (nolock) on pay.fac_id = @vFacID and libpayer.payer_id = pay.payer_id and pay.deleted='N' and (@vClientID = -1 or pay.client_id = @vClientID) 
			and libpayer.deleted = 'N' 
		inner join dbo.ar_transactions tx with (nolock) on pay.transaction_id = tx.transaction_id AND tx.deleted = 'N'
		left join dbo.ar_invoice inv with (nolock) on tx.invoice_id = inv.invoice_id  	 
		left join  @payer_ids_table pids on tx.payer_id = pids.payer_id
		left join  @payer_type_table ptypes on libpayer.payer_type = ptypes.payer_type
		left join @charge_code_ids_table cc on tx.item_type_id = cc.charge_code_id
		left join  @dollars_account_ids_table dola on tx.dollars_account_id = dola.account_id
		left join  @days_account_ids_table daya on tx.days_account_id = daya.account_id	
		left join dbo.ar_lib_accounts dollibac with (nolock) on tx.dollars_account_id = dollibac.account_id
		left join @account_type_ids_table dolactype on dollibac.account_type_id = dolactype.account_type_id
		left join dbo.ar_lib_accounts daylibac with (nolock) on tx.days_account_id = daylibac.account_id
		left join @account_type_ids_table dayactype on daylibac.account_type_id = dayactype.account_type_id
		left join @revenue_code_table revcd on tx.revenue_code = revcd.revenue_code
		left join @hcpcs_code_table hcpcs on tx.hcpcs_code = hcpcs.hcpcs_code
		WHERE 
			(
			(isnull(@vPayerIdList,'-1') <> '-1' and pids.payer_id is not null)
			or
			(isnull(@vPayerTypeList,'-1') <> '-1' and  ptypes.payer_type is not null)
			or
			(isnull(@vPayerIdList,'-1') = '-1' and isnull(@vPayerTypeList,'-1') = '-1')
			)
			and
			((isnull(@vDollarsAccountList,'-1') <>'-1' and dola.account_id is not null) or isnull(@vDollarsAccountList,'-1') = '-1' )
			and
			((isnull(@vDaysAccountList,'-1') <>'-1' and daya.account_id is not null) or isnull(@vDaysAccountList,'-1') = '-1' )
			and
			((isnull(@vChargeCodeList,'-1') <>'-1' and cc.charge_code_id is not null) or isnull(@vChargeCodeList,'-1') = '-1' )
			and
			((isnull(@vAccountTypeList,'-1') <>'-1' and (dayactype.account_type_id is not null or dolactype.account_type_id is not null)) or isnull(@vAccountTypeList,'-1') ='-1')
			and
			((isnull(@vRevenueCodeList,'-1') <>'-1' and revcd.revenue_code is not null) or isnull(@vRevenueCodeList,'-1') = '-1' )
			and
			((isnull(@vHcpcsCodeList,'-1') <>'-1' and hcpcs.hcpcs_code is not null) or isnull(@vHcpcsCodeList,'-1') = '-1' )
			and
			(
			(
			(@vPrintReportBy = 'service_date' and pay.applied_to_date is not null and ((pay.applied_to_date >= @vStartDate or @vStartDate is null)
				and pay.applied_to_date <=  @vEndDate)) 
			)
			or
			(
			(@vPrintReportBy = 'posting_date' and tx.transaction_date is not null and ((tx.transaction_date >= @vStartDate or @vStartDate is null)
				and tx.transaction_date <= @vEndDate))
			)
			or
			(@vPrintReportBy = 'billing_date' and tx.transaction_date is not null and (((inv.effective_date >= @vStartDate or @vStartDate is null)
				and (inv.effective_date <= @vEndDate or @vEndDate is null)) or (inv.effective_date is null and tx.effective_date >= @vStartDate and @vEndDate is null))
			)
			)
			and
			(
			(@vPrintReportBy = 'billing_date' and ((tx.invoice_id <> -999 and tx.is_billed = 1) or (tx.is_billed = 0 and @vEndDate is null)))
			or
			(@vPrintReportBy <> 'billing_date')		
			) 	 
			and
			(
			(@vIncludeBilled = 1 and @vIncludeUnBilled = 1 and @vIncludeMarkedAsBilled = 1)
			or
			(@vIncludeBilled = 1 and @vIncludeUnBilled = 1 and @vIncludeMarkedAsBilled = 0 and ((tx.invoice_id <> -999 and tx.is_billed = 1) or tx.is_billed = 0))
			or
			(@vIncludeBilled = 1 and @vIncludeUnBilled = 0 and @vIncludeMarkedAsBilled = 0 and tx.is_billed = 1 and tx.invoice_id <> -999)		
			or
			(@vIncludeBilled = 1 and @vIncludeUnBilled = 0 and @vIncludeMarkedAsBilled = 1 and tx.is_billed = 1 and tx.invoice_id is not null)	
			or
			(@vIncludeBilled = 0 and @vIncludeUnBilled = 1 and @vIncludeMarkedAsBilled = 1 and ((tx.invoice_id = -999 and tx.is_billed = 1) or tx.is_billed = 0))
			or
			(@vIncludeBilled = 0 and @vIncludeUnBilled = 1 and @vIncludeMarkedAsBilled = 0 and tx.is_billed = 0 and tx.invoice_id is null)
			or
			(@vIncludeBilled = 0 and @vIncludeUnBilled = 0 and @vIncludeMarkedAsBilled = 1 and tx.invoice_id = -999)			
			)     
			and 
			(tx.transaction_date is not null or pay.transaction_id  = '-1') and pay.current_period_date is not null 

	--all applied non-transactional cash -- only displays by service date
	if @vPrintReportBy = 'service_date'

		insert into #local_transactions
		select Null as invoice_id
			, Null as batch_id
			, Null as entry_number
			, pay.client_id
			, Null as auto_generated
			, pay.transaction_id
			, Null as reversing_tx_id
			, Null as distribution_tx_id
			, pay.applied_payment_id
			, pay.payer_id
			, Null as days_account_id
			, Null as dollars_account_id
			, pay.fac_id
			, Null as is_billed
			, 'C' as transaction_type
			, Null as parent_tx_type
			, 'Credit applied on ' + FORMAT(pay.applied_date,'MMM dd, yyyy') as [description]
			, Null as alt_description
			, Null as cheque_number
			, pay.applied_to_date as effective_date
			, pay.current_period_date as transaction_date
			, Null as  billing_date
			, pay.applied_date
			, Null as days_amount
			, Null as daily_rate
			, Null as monthly_rate
			, -1 * pay.amount as amount
			, Null as care_level
			, '' as revenue_code
			, Null as hcpcs_code	
			, Null as item_type_id
			, Null as comment
			, Null as rate_type_id
			, Null as rugs_modifier
			, Null as medicare_day
			, 0 as mppr_flag
			, Null as mark_as_billed_by
			, Null as mark_as_billed_date
			, Null as mark_as_billed_comment
			, 3 as transaction_type_group
			, 1
			, pay.applied_payment_id
		FROM dbo.ar_applied_payment_history pay with (nolock) 
		inner join dbo.ar_lib_payers libpayer with (nolock) on pay.fac_id = @vFacID and libpayer.payer_id = pay.payer_id and pay.deleted='N' and (@vClientID = -1 or pay.client_id = @vClientID) 
			and libpayer.deleted = 'N' and transaction_id = -1	 
		left join  @payer_ids_table pids on pay.payer_id = pids.payer_id
		left join  @payer_type_table ptypes on libpayer.payer_type = ptypes.payer_type
		WHERE 
			(
			(isnull(@vPayerIdList,'-1') <> '-1' and pids.payer_id is not null)
			or
			(isnull(@vPayerTypeList,'-1') <> '-1' and  ptypes.payer_type is not null)
			or
			(isnull(@vPayerIdList,'-1') = '-1' and isnull(@vPayerTypeList,'-1') = '-1')
			)
			and
			(isnull(@vDollarsAccountList,'-1') = '-1' )
			and
			(isnull(@vDaysAccountList,'-1') = '-1' )
			and
			(isnull(@vChargeCodeList,'-1') = '-1' )
			and
			(isnull(@vAccountTypeList,'-1') ='-1')
			and
			( isnull(@vRevenueCodeList,'-1') = '-1' )
			and
			(isnull(@vHcpcsCodeList,'-1') = '-1' )
			and
			(@vPrintReportBy = 'service_date' and pay.applied_to_date is not null and ((pay.applied_to_date >= @vStartDate or @vStartDate is null)
				and pay.applied_to_date <=  @vEndDate))     
			and 
			pay.transaction_id  = '-1' and pay.current_period_date is not null 
			and (@vIncludeBilled = 1 or @vIncludeUnBilled = 1)
	end

if @vIncludeMiscCash = 1
	begin

		insert into #local_transactions
	
		select tx.invoice_id
			, tx.batch_id
			, tx.entry_number
			, tx.client_id
			, isnull(tx.auto_generated,'N')
			, tx.transaction_id
			, tx.reversing_tx_id
			, tx.distribution_tx_id
			, 0 as applied_payment_id
			, tx.payer_id
			, tx.days_account_id
			, tx.misc_cash_account_id
			, tx.fac_id
			, tx.is_billed
			, tx.transaction_type
			, tx.parent_tx_type
			, tx.[description]
			, tx.alt_description
			, tx.cheque_number
			, tx.effective_date
			, tx.transaction_date
			, Null as billing_date
			, Null as applied_date
			, tx.days_amount
			, tx.daily_rate
			, tx.monthly_rate
			, tx.amount
			, tx.care_level
			, tx.revenue_code
			, tx.hcpcs_code	
			, tx.item_type_id
			, tx.comment
			, tx.rate_type_id
			, tx.rugs_modifier
			, tx.medicare_day
			, tx.mppr_flag
			, tx.mark_as_billed_by
			, tx.mark_as_billed_date
			, tx.mark_as_billed_comment
			, 3 as transaction_type_group
			, 1
			, 0 as ar_applied_payment_history_id
		from dbo.ar_transactions tx with (nolock)
		left join  @dollars_account_ids_table dola on tx.misc_cash_account_id = dola.account_id
		WHERE 
			tx.deleted = 'N' and tx.transaction_type ='C' and tx.transaction_date is not null and tx.client_id is null and tx.fac_id= @vFacID
			and
			((isnull(@vDollarsAccountList,'-1') <>'-1' and dola.account_id is not null) or isnull(@vDollarsAccountList,'-1') = '-1' )
			and
			(
			((@vPrintReportBy = 'service_date' and tx.transaction_date is not null and ((tx.effective_date >= @vStartDate or @vStartDate is null)
				and tx.effective_date <=  @vEndDate))
			)
			or
			(
			(@vPrintReportBy = 'posting_date' and tx.transaction_date is not null and ((tx.transaction_date >= @vStartDate or @vStartDate is null)
				and tx.transaction_date <= @vEndDate))
			))
	end

--update comment on multiple payer cash transactions
update childcash set childcash.comment = parentcash.comment, childcash.cheque_number = parentcash.cheque_number 
	--,childcash.skip_bit = (case when lclpc.transaction_id is not null then 2 else 1 end)
from #local_transactions childcash
inner join dbo.ar_transactions parentcash with (nolock) on childcash.distribution_tx_id = parentcash.transaction_id
	and childcash.distribution_tx_id <> childcash.transaction_id and parentcash.distribution_tx_id = parentcash.transaction_id
	and childcash.transaction_type = 'C' and parentcash.transaction_type = 'C'

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

if @vSummarizeReversals = 1
	begin

		Select @vStep = 15;
		set @vgsStepStartTime = GETDATE()
		if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Summarizing Reversals ' + convert(varchar(26),getdate(),109);

		insert into #local_transactions
	
		select tx.invoice_id
			, tx.batch_id
			, tx.entry_number
			, tx.client_id
			, tx.auto_generated
			, tx.transaction_id
			, tx.reversing_tx_id
			, tx.distribution_tx_id
			, tx.applied_payment_id
			, tx.payer_id
			, tx.days_account_id
			, tx.dollars_account_id
			, tx.fac_id
			, tx.is_billed
			, tx.transaction_type
			, tx.parent_tx_type
			, tx.[description]
			, tx.alt_description
			, tx.cheque_number
			, tx.effective_date
			, tx.transaction_date
			, tx.billing_date
			, tx.applied_date
			, tx.days_amount
			, tx.daily_rate
			, tx.monthly_rate
			, tx.amount + isnull(revtx.amount,0)
			, tx.care_level
			, tx.revenue_code
			, tx.hcpcs_code	
			, tx.item_type_id
			, tx.comment
			, tx.rate_type_id
			, tx.rugs_modifier
			, tx.medicare_day
			, tx.mppr_flag
			, tx.mark_as_billed_by
			, tx.mark_as_billed_date
			, tx.mark_as_billed_comment
			, tx.transaction_type_group
			, 2 as skip_bit
			, tx.ar_applied_payment_history_id
		from #local_transactions tx with (nolock)
		left join #local_transactions revtx with (nolock) on tx.reversing_tx_id = revtx.transaction_id
		WHERE 
			(((tx.amount + isnull(revtx.amount,0)) <> 0 and revtx.reversing_tx_id is not null) or revtx.reversing_tx_id is null)

		delete from #local_transactions where skip_bit = 1
		update #local_transactions set skip_bit = 1 where skip_bit = 2
		
		set @vgsStepEndTime=GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms' 
	end

if @vCombineChildren > 0
	begin

		Select @vStep = 20;
		set @vgsStepStartTime = GETDATE()
		if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Combining Child Transactions ' + convert(varchar(26),getdate(),109);

	if @vCombineChildren = 1
		begin

			insert into #child_transactions
			select 	  ctx.distribution_tx_id
					--, ctx.transaction_type
					, '' AS transaction_type
					, ctx.parent_tx_type
					, ctx.payer_id
					, sum(ctx.days_amount)
					, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
					, sum(ctx.monthly_rate)
					, sum(ctx.amount)
					, ctx.billing_date
					, 0
			from #local_transactions ctx
			join dbo.ar_payers payer on payer.payer_id = ctx.payer_id and payer.fac_id = ctx.fac_id 
			inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and anctx.payer_id = ctx.payer_id
			where  ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type
				and isnull(ctx.billing_date,'1/1/1900') = isnull(anctx.billing_Date,'1/1/1900')
			group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.payer_id, ctx.billing_Date
			order by 1


			insert into #local_transactions
	
			select tx.invoice_id
				, tx.batch_id
				, tx.entry_number
				, tx.client_id
				, tx.auto_generated
				, tx.transaction_id
				, tx.reversing_tx_id
				, tx.distribution_tx_id
				, tx.applied_payment_id
				, tx.payer_id
				, tx.days_account_id
				, tx.dollars_account_id
				, tx.fac_id
				, tx.is_billed
				, tx.transaction_type
				, tx.parent_tx_type
				, tx.[description]
				, tx.alt_description
				, tx.cheque_number
				, tx.effective_date
				, tx.transaction_date
				, tx.billing_date
				, tx.applied_date
				, tx.days_amount
				, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
				, Null as monthly_rate
				, tx.amount + isnull(txca.amount,0) as amount
				, tx.care_level				
				, tx.revenue_code
				, tx.hcpcs_code	
				, tx.item_type_id
				, tx.comment
				, tx.rate_type_id
				, tx.rugs_modifier
				, tx.medicare_day
				, tx.mppr_flag
				, tx.mark_as_billed_by
				, tx.mark_as_billed_date
				, tx.mark_as_billed_comment
				, tx.transaction_type_group
				, 0
				, tx.ar_applied_payment_history_id
			from #local_transactions tx with (nolock)
			inner join dbo.ar_payers payr with (nolock) on tx.payer_id = payr.payer_id and tx.fac_id = payr.fac_id
			inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and isnull(tx.billing_date,'1/1/1900') = isnull(txca.billing_Date,'1/1/1900')
				and tx.payer_id = txca.payer_id

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id and tx.payer_id = parent.payer_id	
			inner join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and isnull(tx.billing_date,'1/1/1900') = isnull(txca.billing_Date,'1/1/1900')
			where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id
			where tx.skip_bit = 1 and parent.skip_bit = 0

--********************************************************** children on different payer than parent

			delete from #child_transactions

			insert into #child_transactions
			select 	  ctx.distribution_tx_id
					--, ctx.transaction_type
					, '' AS transaction_type
					, ctx.parent_tx_type
					, ctx.payer_id
					, sum(ctx.days_amount)
					, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
					, sum(ctx.monthly_rate)
					, sum(ctx.amount)
					, ctx.billing_date
					, 0
			from #local_transactions ctx
			join dbo.ar_payers payer on payer.payer_id = ctx.payer_id and payer.fac_id = ctx.fac_id 
			inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and anctx.payer_id <> ctx.payer_id
			where  ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type
			group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.payer_id, ctx.billing_Date
			order by 1

			insert into #local_transactions
	
			select tx.invoice_id
				, tx.batch_id
				, tx.entry_number
				, tx.client_id
				, tx.auto_generated
				, tx.transaction_id
				, tx.reversing_tx_id
				, tx.distribution_tx_id
				, tx.applied_payment_id
				, txca.payer_id
				, tx.days_account_id
				, tx.dollars_account_id
				, tx.fac_id
				, tx.is_billed
				, tx.transaction_type
				, tx.parent_tx_type
				, tx.[description]
				, tx.alt_description
				, tx.cheque_number
				, tx.effective_date
				, tx.transaction_date
				, txca.billing_Date
				, tx.applied_date
				, tx.days_amount
				, isnull(txca.daily_rate,0) as daily_rate
				, Null as monthly_rate
				, isnull(txca.amount,0) as amount
				, tx.care_level				
				, tx.revenue_code
				, tx.hcpcs_code	
				, tx.item_type_id
				, tx.comment
				, tx.rate_type_id
				, tx.rugs_modifier
				, tx.medicare_day
				, tx.mppr_flag
				, tx.mark_as_billed_by
				, tx.mark_as_billed_date
				, tx.mark_as_billed_comment
				, tx.transaction_type_group
				, 0
				, tx.ar_applied_payment_history_id
			from #local_transactions tx with (nolock)
			inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id --and isnull(tx.billing_date,'1/1/1900') = isnull(txca.billing_Date,'1/1/1900')
				and tx.payer_id <> txca.payer_id

			delete tx 
			from #local_transactions tx
			inner join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id--and isnull(tx.billing_date,'1/1/1900') = isnull(txca.billing_Date,'1/1/1900')
			where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0

--********************************************************** 

		end

		if @vCombineChildren = 2
		begin
			insert into #child_transactions
			select 	  ctx.distribution_tx_id
					, '' AS transaction_type
					, ctx.parent_tx_type
					, ctx.payer_id
					, sum(ctx.days_amount)
					, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
					, sum(ctx.monthly_rate)
					, sum(ctx.amount)
					, ctx.billing_date
					, 0
			from #local_transactions ctx
			join dbo.ar_payers payer on payer.payer_id = ctx.payer_id and payer.fac_id = ctx.fac_id 
			inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and ctx.payer_id = anctx.payer_id
			where  ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type and ctx.transaction_type in('CR', 'CA')
				and isnull(ctx.billing_date,'1/1/1900') = isnull(anctx.billing_Date,'1/1/1900')
			group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.payer_id, ctx.billing_Date
			order by 1

			insert into #local_transactions
	
			select tx.invoice_id
				, tx.batch_id
				, tx.entry_number
				, tx.client_id
				, tx.auto_generated
				, tx.transaction_id
				, tx.reversing_tx_id
				, tx.distribution_tx_id
				, tx.applied_payment_id
				, tx.payer_id
				, tx.days_account_id
				, tx.dollars_account_id
				, tx.fac_id
				, tx.is_billed
				, tx.transaction_type
				, tx.parent_tx_type
				, tx.[description]
				, tx.alt_description
				, tx.cheque_number
				, tx.effective_date
				, tx.transaction_date
				, tx.billing_date
				, tx.applied_date
				, tx.days_amount
				, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
				, Null as monthly_rate
				, tx.amount + isnull(txca.amount,0) as amount
				, tx.care_level				
				, tx.revenue_code
				, tx.hcpcs_code	
				, tx.item_type_id
				, tx.comment
				, tx.rate_type_id
				, tx.rugs_modifier
				, tx.medicare_day
				, tx.mppr_flag
				, tx.mark_as_billed_by
				, tx.mark_as_billed_date
				, tx.mark_as_billed_comment
				, tx.transaction_type_group
				, 0
				, tx.ar_applied_payment_history_id
			from #local_transactions tx with (nolock)
			inner join dbo.ar_payers payr with (nolock) on tx.payer_id = payr.payer_id and tx.fac_id = payr.fac_id
			inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and isnull(tx.billing_date,'1/1/1900') = isnull(txca.billing_Date,'1/1/1900')
				and tx.payer_id = txca.payer_id

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id and tx.payer_id = parent.payer_id	
			inner join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id and isnull(tx.billing_date,'1/1/1900') = isnull(txca.billing_Date,'1/1/1900')
			where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0 and tx.transaction_type in('CR', 'CA')

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id
			where tx.skip_bit = 1 and parent.skip_bit = 0

		end

		set @vgsStepEndTime=GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
	end

--for ancillary charges that we are grouping, and the parent transaction doesn't exist, we want to ensure the group correctly
if @vShowResults = 'A' or @vShowResults = 'C' or @vShowResults = 'CC' or @vShowResults = 'R'
	begin

		Select @vStep = 25;
		set @vgsStepStartTime = GETDATE()
		if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' @vShowResults in(A,C,CC,R) - Combining Ancillary Child Transactions to parent not in the dataset ' + convert(varchar(26),getdate(),109);

		-- insert empty parent anicillary charge to roll children into - need this because the parent contains the charge code info
		insert into #local_transactions
	
		select distinct tx.invoice_id
			, tx.batch_id
			, tx.entry_number
			, tx.client_id
			--, 'N' as auto_generated
			, isnull(tx.auto_generated,'N')
			, tx.transaction_id
			, tx.reversing_tx_id
			, tx.distribution_tx_id
			, 0 as applied_payment_id
			, lcltx.payer_id								
			, lcltx.days_account_id
			, lcltx.dollars_account_id
			, tx.fac_id
			, tx.is_billed
			, tx.transaction_type
			, tx.parent_tx_type
			, tx.[description]
			, tx.alt_description
			, tx.cheque_number
			, tx.effective_date
			, tx.transaction_date
			, lcltx.billing_date
			, Null as applied_date
			, tx.days_amount
			, 0 as daily_rate
			, Null as monthly_rate
			, 0 as amount
			, tx.care_level
			, tx.revenue_code
			, tx.hcpcs_code		
			, tx.item_type_id
			, tx.comment
			, tx.rate_type_id
			, tx.rugs_modifier
			, tx.medicare_day
			, tx.mppr_flag
			, tx.mark_as_billed_by
			, tx.mark_as_billed_date
			, tx.mark_as_billed_comment
			, Case when (tx.transaction_type in('r','dr','cl','cr','d')
				or ((tx.transaction_type = 'co'or tx.transaction_type = 'cw')
				and tx.auto_generated = 'y') or (tx.transaction_type = 'xr' 
				and tx.parent_tx_type = 'r')) then 1 
				when tx.transaction_type = 'c' then 3 
				else 2 end as transaction_type_group
			, 5
			, lcltx.ar_applied_payment_history_id
		from #local_transactions lcltx with (nolock)
		left join #local_transactions ntx on lcltx.distribution_tx_id = ntx.transaction_id and lcltx.parent_tx_type = 'A'
			and ntx.distribution_tx_id = ntx.transaction_id
		inner join dbo.ar_transactions tx with (nolock) on lcltx.distribution_tx_id = tx.transaction_id and lcltx.parent_tx_type = 'A'  
		where lcltx.parent_tx_type = 'A' and ntx.transaction_id is null and lcltx.payer_id = tx.payer_id

		delete from #child_transactions

		insert into #child_transactions
		select 	  ctx.distribution_tx_id
				--, ctx.transaction_type
				, '' AS transaction_type
				, ctx.parent_tx_type
				, ctx.payer_id
				, sum(ctx.days_amount)
				, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
				, sum(ctx.monthly_rate)
				, sum(ctx.amount)
				, ctx.billing_date
				, 0
		from #local_transactions ctx
		left join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and ctx.payer_id = anctx.payer_id and anctx.transaction_type = 'A' and anctx.skip_bit = 5
		where  anctx.transaction_id is not null and ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type
			and isnull(ctx.billing_date,'1/1/1900') = isnull(anctx.billing_Date,'1/1/1900')
		group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.payer_id, ctx.billing_Date
		order by 1

		insert into #local_transactions
		select tx.invoice_id
			, tx.batch_id
			, tx.entry_number
			, tx.client_id
			, tx.auto_generated
			, tx.transaction_id
			, tx.reversing_tx_id
			, tx.distribution_tx_id
			, tx.applied_payment_id
			, tx.payer_id
			, tx.days_account_id
			, tx.dollars_account_id
			, tx.fac_id
			, tx.is_billed
			, tx.transaction_type
			, tx.parent_tx_type
			, tx.[description]
			, tx.alt_description
			, tx.cheque_number
			, tx.effective_date
			, tx.transaction_date
			, tx.billing_date
			, tx.applied_date
			, tx.days_amount
			--, tx.days_amount + isnull(txca.days_amount,0) as days_amount
			, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
			, Null as monthly_rate
			, tx.amount + isnull(txca.amount,0) as amount
			, tx.care_level
			, tx.revenue_code
			, tx.hcpcs_code		
			, tx.item_type_id
			, tx.comment
			, tx.rate_type_id
			, tx.rugs_modifier
			, tx.medicare_day
			, tx.mppr_flag
			, tx.mark_as_billed_by
			, tx.mark_as_billed_date
			, tx.mark_as_billed_comment
			, tx.transaction_type_group
			, 0
			, tx.ar_applied_payment_history_id
		from #local_transactions tx with (nolock)
		inner join dbo.ar_payers payr with (nolock) on tx.payer_id = payr.payer_id and tx.fac_id = payr.fac_id
		inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id
			and isnull(tx.billing_date,'1/1/1900') = isnull(txca.billing_Date,'1/1/1900')
		where tx.skip_bit = 5

		--********************************************************** children on different payer than parent
-- insert empty parent anicillary charge to roll children into - need this because the parent contains the charge code info
		insert into #local_transactions
	
		select tx.invoice_id
			, tx.batch_id
			, tx.entry_number
			, tx.client_id
			--, 'N' as auto_generated
			, isnull(tx.auto_generated,'N')
			, tx.transaction_id
			, tx.reversing_tx_id
			, tx.distribution_tx_id
			, 0 as applied_payment_id
			, lcltx.payer_id								
			, lcltx.days_account_id
			, lcltx.dollars_account_id
			, tx.fac_id
			, tx.is_billed
			, tx.transaction_type
			, tx.parent_tx_type
			, tx.[description]
			, tx.alt_description
			, tx.cheque_number
			, tx.effective_date
			, tx.transaction_date
			, lcltx.billing_date
			, Null as applied_date
			, tx.days_amount
			, Null as daily_rate
			, Null as monthly_rate
			, Null as amount
			, tx.care_level
			, tx.revenue_code
			, tx.hcpcs_code		
			, tx.item_type_id
			, tx.comment
			, tx.rate_type_id
			, tx.rugs_modifier
			, tx.medicare_day
			, tx.mppr_flag
			, tx.mark_as_billed_by
			, tx.mark_as_billed_date
			, tx.mark_as_billed_comment
			, Case when (tx.transaction_type in('r','dr','cl','cr','d')
				or ((tx.transaction_type = 'co'or tx.transaction_type = 'cw')
				and tx.auto_generated = 'y') or (tx.transaction_type = 'xr' 
				and tx.parent_tx_type = 'r')) then 1 
				when tx.transaction_type = 'c' then 3 
				else 2 end as transaction_type_group
			, 5
			, lcltx.ar_applied_payment_history_id
		from #local_transactions lcltx with (nolock)
		left join #local_transactions ntx on lcltx.distribution_tx_id = ntx.transaction_id and lcltx.parent_tx_type = 'A'
			and ntx.distribution_tx_id = ntx.transaction_id and lcltx.payer_id <> ntx.payer_id
		inner join dbo.ar_transactions tx with (nolock) on lcltx.distribution_tx_id = tx.transaction_id and lcltx.parent_tx_type = 'A'  
		where lcltx.parent_tx_type = 'A' and ntx.transaction_id is null and lcltx.payer_id <> tx.payer_id

		delete from #child_transactions

		insert into #child_transactions
		select 	  ctx.distribution_tx_id
				--, ctx.transaction_type
				, '' AS transaction_type
				, ctx.parent_tx_type
				, ctx.payer_id
				, sum(ctx.days_amount)
				, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
				, sum(ctx.monthly_rate)
				, sum(ctx.amount)
				, ctx.billing_date
				, 0
		from #local_transactions ctx
		join dbo.ar_payers payer on payer.payer_id = ctx.payer_id and payer.fac_id = ctx.fac_id 
		inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and anctx.payer_id <> ctx.payer_id and anctx.transaction_type = 'A' and anctx.skip_bit = 5
		where  ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type --and ctx.distribution_tx_id=632698342 
			--and isnull(ctx.billing_date,'1/1/1900') = isnull(anctx.billing_Date,'1/1/1900')
		group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.payer_id, ctx.billing_Date
		order by 1

		insert into #local_transactions
	
		select tx.invoice_id
			, tx.batch_id
			, tx.entry_number
			, tx.client_id
			, tx.auto_generated
			, tx.transaction_id
			, tx.reversing_tx_id
			, tx.distribution_tx_id
			, tx.applied_payment_id
			, txca.payer_id
			, tx.days_account_id
			, tx.dollars_account_id
			, tx.fac_id
			, tx.is_billed
			, tx.transaction_type
			, tx.parent_tx_type
			, tx.[description]
			, tx.alt_description
			, tx.cheque_number
			, tx.effective_date
			, tx.transaction_date
			, txca.billing_Date
			, tx.applied_date
			, tx.days_amount
			, isnull(txca.daily_rate,0) as daily_rate
			, Null as monthly_rate
			, isnull(txca.amount,0) as amount
			, tx.care_level				
			, tx.revenue_code
			, tx.hcpcs_code	
			, tx.item_type_id
			, tx.comment
			, tx.rate_type_id
			, tx.rugs_modifier
			, tx.medicare_day
			, tx.mppr_flag
			, tx.mark_as_billed_by
			, tx.mark_as_billed_date
			, tx.mark_as_billed_comment
			, tx.transaction_type_group
			, 0
			, tx.ar_applied_payment_history_id
		from #local_transactions tx with (nolock)
		inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id --and isnull(tx.billing_date,'1/1/1900') = isnull(txca.billing_Date,'1/1/1900')
			and tx.payer_id <> txca.payer_id
		where tx.skip_bit = 5

		delete from #local_transactions where skip_bit=5		
--********************************************************** 

		set @vgsStepEndTime=GETDATE()
		if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

		if @vCombineChildren = 0 --need to summarize ancillaries that have a parent and combine children was not selected
			begin
				Select @vStep = 30;
				set @vgsStepStartTime = GETDATE()
				if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' @vShowResults in(A,C,CC,R) - Combining Children not selected - Combine Ancillary Child Transactions to parent ' + convert(varchar(26),getdate(),109);

				delete from #child_transactions --eliminate the missing parent ones

				insert into #child_transactions
				select 	  ctx.distribution_tx_id
						--, ctx.transaction_type
						, '' AS transaction_type
						, ctx.parent_tx_type
						, ctx.payer_id
						, sum(ctx.days_amount)
						, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
						, sum(ctx.monthly_rate)
						, sum(ctx.amount)
						, ctx.billing_date
						, 0
				from #local_transactions ctx
				left join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and ctx.payer_id = anctx.payer_id and anctx.transaction_type = 'A' and anctx.skip_bit <> 5
				where  anctx.transaction_id is not null and ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type
					and isnull(ctx.billing_date,'1/1/1900') = isnull(anctx.billing_Date,'1/1/1900')
				group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.payer_id, ctx.billing_Date
				order by 1

				insert into #local_transactions
				select tx.invoice_id
					, tx.batch_id
					, tx.entry_number
					, tx.client_id
					, tx.auto_generated
					, tx.transaction_id
					, tx.reversing_tx_id
					, tx.distribution_tx_id
					, tx.applied_payment_id
					, tx.payer_id
					, tx.days_account_id
					, tx.dollars_account_id
					, tx.fac_id
					, tx.is_billed
					, tx.transaction_type
					, tx.parent_tx_type
					, tx.[description]
					, tx.alt_description
					, tx.cheque_number
					, tx.effective_date
					, tx.transaction_date
					, tx.billing_date
					, tx.applied_date
					, tx.days_amount
					--, tx.days_amount + isnull(txca.days_amount,0) as days_amount
					, tx.daily_rate + isnull(txca.daily_rate,0) as daily_rate
					, Null as monthly_rate
					, tx.amount + isnull(txca.amount,0) as amount
					, tx.care_level
					, tx.revenue_code
					, tx.hcpcs_code		
					, tx.item_type_id
					, tx.comment
					, tx.rate_type_id
					, tx.rugs_modifier
					, tx.medicare_day
					, tx.mppr_flag
					, tx.mark_as_billed_by
					, tx.mark_as_billed_date
					, tx.mark_as_billed_comment
					, tx.transaction_type_group
					, 0
					, tx.ar_applied_payment_history_id
				from #local_transactions tx with (nolock)
				inner join dbo.ar_payers payr with (nolock) on tx.payer_id = payr.payer_id and tx.fac_id = payr.fac_id
				inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id
					and isnull(tx.billing_date,'1/1/1900') = isnull(txca.billing_Date,'1/1/1900')

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.transaction_id = tx.distribution_tx_id 	
			left join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id 
			where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0
			and txca.distribution_tx_id is not null and isnull(tx.billing_date,'1/1/1900') = isnull(txca.billing_Date,'1/1/1900')

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id
			where tx.skip_bit = 1 and parent.skip_bit = 0 and isnull(tx.billing_date,'1/1/1900') = isnull(parent.billing_Date,'1/1/1900')

--********************************************************** children on different payer than parent
			delete from #child_transactions

			insert into #child_transactions
			select 	  ctx.distribution_tx_id
					--, ctx.transaction_type
					, '' AS transaction_type
					, ctx.parent_tx_type
					, ctx.payer_id
					, sum(ctx.days_amount)
					, sum(case when isnull(ctx.days_amount,0) < 0 and isnull(ctx.daily_rate,0) < 0 and ctx.amount < 0 then (ctx.daily_rate * -1) else ctx.daily_rate end)
					, sum(ctx.monthly_rate)
					, sum(ctx.amount)
					, ctx.billing_date
					, 0
			from #local_transactions ctx
			join dbo.ar_payers payer on payer.payer_id = ctx.payer_id and payer.fac_id = ctx.fac_id 
			inner join #local_transactions anctx on ctx.distribution_tx_id = anctx.transaction_id and anctx.payer_id <> ctx.payer_id and anctx.transaction_type = 'A' and anctx.skip_bit <> 5
			where  ctx.parent_tx_type is not null and ctx.transaction_type <> ctx.parent_tx_type 
				--and isnull(ctx.billing_date,'1/1/1900') = isnull(anctx.billing_Date,'1/1/1900')
			group by ctx.distribution_tx_id, ctx.parent_tx_type, ctx.payer_id, ctx.billing_Date
			order by 1

			insert into #local_transactions
	
			select tx.invoice_id
				, tx.batch_id
				, tx.entry_number
				, tx.client_id
				, tx.auto_generated
				, tx.transaction_id
				, tx.reversing_tx_id
				, tx.distribution_tx_id
				, tx.applied_payment_id
				, txca.payer_id
				, tx.days_account_id
				, tx.dollars_account_id
				, tx.fac_id
				, tx.is_billed
				, tx.transaction_type
				, tx.parent_tx_type
				, tx.[description]
				, tx.alt_description
				, tx.cheque_number
				, tx.effective_date
				, tx.transaction_date
				, txca.billing_Date
				, tx.applied_date
				, tx.days_amount
				, isnull(txca.daily_rate,0) as daily_rate
				, Null as monthly_rate
				, isnull(txca.amount,0) as amount
				, tx.care_level				
				, tx.revenue_code
				, tx.hcpcs_code	
				, tx.item_type_id
				, tx.comment
				, tx.rate_type_id
				, tx.rugs_modifier
				, tx.medicare_day
				, tx.mppr_flag
				, tx.mark_as_billed_by
				, tx.mark_as_billed_date
				, tx.mark_as_billed_comment
				, tx.transaction_type_group
				, 0
				, tx.ar_applied_payment_history_id
			from #local_transactions tx with (nolock)
			inner join #child_transactions txca with (nolock) on tx.transaction_id = txca.distribution_tx_id --and isnull(tx.billing_date,'1/1/1900') = isnull(txca.billing_Date,'1/1/1900')
				and tx.payer_id <> txca.payer_id

			delete tx 
			from #local_transactions tx
			inner join  #child_transactions txca on tx.distribution_tx_id = txca.distribution_tx_id and tx.payer_id = txca.payer_id--and isnull(tx.billing_date,'1/1/1900') = isnull(txca.billing_Date,'1/1/1900')
			where tx.transaction_id <> tx.distribution_tx_id and tx.skip_bit <> 0

			delete tx 
			from #local_transactions tx
			inner join #local_transactions parent on parent.distribution_tx_id = tx.distribution_tx_id and parent.transaction_id = tx.transaction_id
			where tx.skip_bit = 1 and parent.skip_bit = 0
			
--********************************************************** 
			set @vgsStepEndTime=GETDATE()
			if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
		end
	end

If @vCalcBF = 1
	begin
		Select @vStep = 60;
		set @vgsStepStartTime = GETDATE()
		if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Gathering Previous Balance Data ' + convert(varchar(26),getdate(),109);

		create index #local_transactions__clientID on #local_transactions(client_id);

		if @vStartDate is null -- all unbilled
		begin
				insert into #balance_forward_union
				SELECT 
					  txn.fac_id
					, txn.client_id
					, txn.payer_id
					, SUM(txn.amount) as amount	
				FROM dbo.ar_transactions txn WITH (NOLOCK)
					join dbo.ar_lib_payers libpayer WITH (NOLOCK) on libpayer.payer_id=txn.payer_id 
						and libpayer.deleted = 'N'
					join dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id = txn.payer_id and payer.fac_id = txn.fac_id 
					left join  @payer_ids_table pids on txn.payer_id = pids.payer_id
					left join  @payer_type_table ptypes on libpayer.payer_type = ptypes.payer_type
					left join (select distinct(client_id) from #local_transactions) cl on txn.client_id = cl.client_id
				where txn.fac_id = @vFacID and txn.deleted='N' and txn.invoice_id is not null
					and (@vClientID = -1 or txn.client_id = @vClientID)
					and ((@vOnlyClientsWithTransactions = 1 and cl.client_id is not null) or @vOnlyClientsWithTransactions = 0)
					and
					(
					(isnull(@vPayerIdList,'-1') <> '-1' and pids.payer_id is not null)
					or
					(isnull(@vPayerTypeList,'-1') <> '-1' and  ptypes.payer_type is not null)
					or
					(isnull(@vPayerIdList,'-1') = '-1' and isnull(@vPayerTypeList,'-1') = '-1')
					)
					and
					(
					(@vPrintReportBy = 'service_date' and txn.transaction_date is not null and txn.effective_date <=  @vEndDate)
					or
					(@vPrintReportBy = 'posting_date' and txn.transaction_date is not null and txn.transaction_date <= @vEndDate)
					)          
				group by txn.fac_id, txn.client_id, txn.payer_id

		end

	else
		begin
	
		If @vPrintReportBy = 'billing_date'
			begin
				insert into #balance_forward_union
				SELECT 
					  txn.fac_id
					, txn.client_id
					, txn.payer_id
					, SUM(txn.amount) as amount	
				FROM dbo.ar_transactions txn WITH (NOLOCK)
					join dbo.ar_lib_payers libpayer WITH (NOLOCK) on libpayer.payer_id=txn.payer_id 
						and libpayer.deleted = 'N' and (txn.client_id = @vClientID or @vClientID = -1)
					join dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id = txn.payer_id and payer.fac_id = txn.fac_id 
					left join dbo.ar_invoice inv WITH (NOLOCK) on txn.invoice_id = inv.invoice_id
					left join  @payer_ids_table pids on txn.payer_id = pids.payer_id
					left join  @payer_type_table ptypes on libpayer.payer_type = ptypes.payer_type
					left join (select distinct(client_id) from #local_transactions) cl on txn.client_id = cl.client_id
				where txn.fac_id = @vFacID and txn.deleted='N'
					and (@vClientID = -1 or txn.client_id = @vClientID)
					and ((@vOnlyClientsWithTransactions = 1 and cl.client_id is not null) or @vOnlyClientsWithTransactions = 0)
					and
					(
					(isnull(@vPayerIdList,'-1') <> '-1' and pids.payer_id is not null)
					or
					(isnull(@vPayerTypeList,'-1') <> '-1' and  ptypes.payer_type is not null)
					or
					(isnull(@vPayerIdList,'-1') = '-1' and isnull(@vPayerTypeList,'-1') = '-1')
					)
					and
					(
					(@vPrintReportBy = 'service_date' and txn.transaction_date is not null and txn.effective_date <  @vStartDate)
					or
					(@vPrintReportBy = 'posting_date' and txn.transaction_date is not null and txn.transaction_date < @vStartDate)
					or
					(@vPrintReportBy = 'billing_date' and txn.transaction_date is not null and (inv.effective_date < @vStartDate or (txn.invoice_id = -999 and txn.effective_date < @vStartDate))
					))            
				group by txn.fac_id, txn.client_id, txn.payer_id

			end
			
			If @vPrintReportBy = 'posting_date'
					 begin
					 insert into #balance_forward_union
                           SELECT 
                                    txn.fac_id
                                  , txn.client_id
                                  , txn.payer_id
                                  , SUM(txn.amount) as amount 
                           FROM dbo.ar_transactions txn WITH (NOLOCK)
                                  join dbo.ar_lib_payers libpayer WITH (NOLOCK) on libpayer.payer_id=txn.payer_id 
                                         and libpayer.deleted = 'N'
                                  join dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id = txn.payer_id and payer.fac_id = txn.fac_id 
                                  left join  @payer_ids_table pids on txn.payer_id = pids.payer_id
                                  left join  @payer_type_table ptypes on libpayer.payer_type = ptypes.payer_type
                                  --left join dbo.ar_applied_payment_history pay with (nolock) on txn.transaction_id = pay.transaction_id
                                  left join (select distinct(client_id) from #local_transactions) cl on txn.client_id = cl.client_id
                           where txn.fac_id = @vFacID and txn.deleted='N'
                                  --and (pay.transaction_id is null)
                                  and (@vClientID = -1 or txn.client_id = @vClientID)
                                  and ((@vOnlyClientsWithTransactions = 1 and cl.client_id is not null) or @vOnlyClientsWithTransactions = 0)
                                  and
                                  (
                                  (isnull(@vPayerIdList,'-1') <> '-1' and pids.payer_id is not null)
                                  or
                                  (isnull(@vPayerTypeList,'-1') <> '-1' and  ptypes.payer_type is not null)
                                  or
                                  (isnull(@vPayerIdList,'-1') = '-1' and isnull(@vPayerTypeList,'-1') = '-1')
                                  )
                                  and
                                  (txn.transaction_date is not null and txn.transaction_date < @vStartDate)
                                           
                           group by txn.fac_id, txn.client_id, txn.payer_id
					 end
			
		else
			begin
				insert into #balance_forward_union
				SELECT 
					  txn.fac_id
					, txn.client_id
					, txn.payer_id
					, SUM(txn.amount) as amount	
				FROM dbo.ar_transactions txn WITH (NOLOCK)
					join dbo.ar_lib_payers libpayer WITH (NOLOCK) on libpayer.payer_id=txn.payer_id 
						and libpayer.deleted = 'N'
					join dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id = txn.payer_id and payer.fac_id = txn.fac_id 
					left join  @payer_ids_table pids on txn.payer_id = pids.payer_id
					left join  @payer_type_table ptypes on libpayer.payer_type = ptypes.payer_type
					left join dbo.ar_applied_payment_history pay with (nolock) on txn.transaction_id = pay.transaction_id
					left join (select distinct(client_id) from #local_transactions) cl on txn.client_id = cl.client_id
				where txn.fac_id = @vFacID and txn.deleted='N'
					and pay.transaction_id is null
					and (@vClientID = -1 or txn.client_id = @vClientID)
					and ((@vOnlyClientsWithTransactions = 1 and cl.client_id is not null) or @vOnlyClientsWithTransactions = 0)
					and
					(
					(isnull(@vPayerIdList,'-1') <> '-1' and pids.payer_id is not null)
					or
					(isnull(@vPayerTypeList,'-1') <> '-1' and  ptypes.payer_type is not null)
					or
					(isnull(@vPayerIdList,'-1') = '-1' and isnull(@vPayerTypeList,'-1') = '-1')
					)
					and
					(
					(@vPrintReportBy = 'service_date' and txn.transaction_date is not null and txn.effective_date <  @vStartDate)
					or
					(@vPrintReportBy = 'posting_date' and txn.transaction_date is not null and txn.transaction_date < @vStartDate)
					)          
				group by txn.fac_id, txn.client_id, txn.payer_id

				union all
				SELECT 
					  pay.fac_id
					, pay.client_id
					, pay.payer_id
					, SUM(-1*pay.amount) as amount	
				FROM dbo.ar_applied_payment_history pay with (nolock) 
				inner join dbo.ar_lib_payers libpayer with (nolock) on libpayer.payer_id = pay.payer_id and pay.deleted='N' and (@vClientID = -1 or pay.client_id = @vClientID) 
					and libpayer.deleted = 'N'  	
				--left join dbo.ar_transactions tx with (nolock) on pay.transaction_id = tx.transaction_id AND tx.deleted = 'N' 
				join dbo.ar_payers payer WITH (NOLOCK) on payer.payer_id = pay.payer_id and payer.fac_id = pay.fac_id 
				left join  @payer_ids_table pids on pay.payer_id = pids.payer_id
				left join  @payer_type_table ptypes on libpayer.payer_type = ptypes.payer_type
				left join (select distinct(client_id) from #local_transactions) cl on pay.client_id = cl.client_id
				where pay.fac_id = @vFacID and pay.deleted='N' and (@vClientID = -1 or pay.client_id = @vClientID)
				and ((@vOnlyClientsWithTransactions = 1 and cl.client_id is not null) or @vOnlyClientsWithTransactions = 0)
					and
					(
					(isnull(@vPayerIdList,'-1') <> '-1' and pids.payer_id is not null)
					or
					(isnull(@vPayerTypeList,'-1') <> '-1' and  ptypes.payer_type is not null)
					or
					(isnull(@vPayerIdList,'-1') = '-1' and isnull(@vPayerTypeList,'-1') = '-1')
					)
					and
					(
					(@vPrintReportBy = 'service_date' and pay.current_period_date is not null and pay.applied_to_date is not null and pay.applied_to_date <  @vStartDate)
					or
					(@vPrintReportBy = 'posting_date' and pay.current_period_date is not null and pay.current_period_date < @vStartDate)
					) 
				group by pay.fac_id, pay.client_id, pay.payer_id

			end
		end
		--------------------------------------------------------------------------------
		-- CONSOLIDATE AMOUNT
		-------------------------------------------------------------------------------- 
		
		insert into #balance_forward_amount
		select fac_id,client_id,payer_id,sum(amount)
		from #balance_forward_union 
		group by fac_id,client_id,payer_id
		order by fac_id,client_id,payer_id

	set @vgsStepEndTime=GETDATE()
	if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

end

Select @vStep = 70;
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Formating and grouping transaction Data ' + convert(varchar(26),getdate(),109);
	
if @vShowResults = 'D'

	begin

		INSERT INTO #transactions	
		SELECT 
			  tx.fac_id
			, tx.client_id
			, tx.payer_id
			, libpayer.description AS payer
			, tx.batch_id
			, tx.entry_number
			, tx.distribution_tx_id
			, tx.transaction_id
			, isnull(tx.auto_generated, 'N') as auto_generated
			, tx.billing_date
			, tx.transaction_date as posting_date
			, tx.effective_date
			, Null as effective_from_date
			, Null as effective_thru_date
			, libcc.charge_code
			, tx.revenue_code
			, tx.hcpcs_code
			, tx.mppr_flag
			, Case when tx.transaction_type = 'R' and isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> '' 
					then rtype.long_description + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then 
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' + convert(varchar(4),YEAR(tx.effective_date))
					end) +
					' (' +isnull(tx.care_level,'') + ')'
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) +
					' (' +isnull(tx.care_level,'') + ')'
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
				and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') = ''  
				and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) + 	' (' +isnull(tx.care_level,'') + ')'
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'CL' and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X','CA') and isnull(tx.alt_description,'')<>''  and batch.batch_id is null then tx.alt_description 
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')<>'' and batch.batch_id is not null then 
					tx.alt_description + ' #' + ltrim(rtrim(str(batch.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number)))
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' and batch.batch_id is not null then 
					tx.description + ' #' + ltrim(rtrim(str(batch.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number)))
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' and batch.batch_id is null and recur.transaction_id is not null
					then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')'
				when tx.transaction_type = 'CA' and isnull(tx.alt_description,'')='' and batch.batch_id is not null and tx.mppr_flag = 0 then 
					tx.description + ' #' + ltrim(rtrim(str(batch.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number)))
				when tx.transaction_type ='CA' and isnull(tx.alt_description,'')='' and batch.batch_id is null and recur.transaction_id is not null
					then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')' 
				when tx.transaction_type = 'CO' and tx.parent_tx_type <> 'R' then tx.description +  ' Coinsurance'
				when tx.transaction_type = 'XR' and tx.parent_tx_type ='A' then tx.description +  ' Reimb. Reduction' 
				when tx.transaction_type = 'CX' and tx.parent_tx_type ='R' then 'Room Excess' 
				when (tx.transaction_type in('R','XR','CO', 'D', 'CR') or (tx.transaction_type = 'CL' and isnull(tx.alt_description,'')='')) and tx.parent_tx_type = 'R' then
				(Case 
					when isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> ''  
						then rtype.long_description + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(arpayer.show_care_level,'N') = 'Y' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
						and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' +
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + ' (' +isnull(tx.care_level,'') + ')'
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then  
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'XR'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) +	' (' +isnull(tx.care_level,'') + ')'
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'CO'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else
							' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + ' (' +isnull(tx.care_level,'') + ')' + ' Coinsurance'
					else 
						(case when tx.transaction_type = 'XR' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
							(case when abs(tx.days_amount) > 1 then
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else  ' ' +	convert(varchar(4),YEAR(tx.effective_date))
							end)
						else 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') +
							(case when abs(tx.days_amount) > 1 then 
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else ' ' + convert(varchar(4),YEAR(tx.effective_date))
							end) +
							(case when tx.transaction_type = 'D' then ' Deductible' 
								when tx.transaction_type = 'CO' then ' Coinsurance' else '' end)  
						end)
					end
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				) + (case when tx.transaction_type = 'CL' then ' Coverage Deductible' else '' end) 
				 + (case when tx.transaction_type = 'CR' then ' Cont.Adj.' else '' end) 
				else tx.description end as detail_description
			, tx.care_level
			, Case when tx.transaction_type = 'R' and libpayer.pps_flag='Y' then ltrim(rtrim(str(tx.medicare_day))) + '-' 
				+ltrim(rtrim(str((
					case when tx.days_amount < 0 and (tx.days_amount*-1) > 1 then tx.days_amount*-1 + tx.medicare_day -1
					when tx.days_amount > 0 and (tx.days_amount*-1) = 1 then tx.days_amount*-1  + tx.medicare_day
					when tx.days_amount > 1 then tx.days_amount + tx.medicare_day -1
					else tx.days_amount + tx.medicare_day end))))
				else Null
					end as benefit_days
			, tx.parent_tx_type
			, tx.transaction_type
			, tx.daily_rate as unit_amount
			, case when tx.transaction_type = 'XR' then Null else tx.days_amount end as number_of_units
			, tx.amount
			, acct.account_number as gl_account
			, daysacct.account_number as days_account
			, case when tx.is_billed = 1 and isnull(tx.invoice_id,0) > 0 then 'Y'
				when tx.is_billed = 1 and isnull(tx.invoice_id,0) < 0 then 'N/A' else 'N' end as billed
			, tx.comment
			, tx.cheque_number
			, Case when tx.invoice_id = -999 then isnull(tx.mark_as_billed_by,'System') else null end as mark_as_billed_by
			, Case when tx.invoice_id = -999 then tx.mark_as_billed_date else null end as mark_as_billed_date
			, Case when tx.invoice_id = -999 then tx.mark_as_billed_comment else null end as mark_as_billed_comment
			, case when libcc.adjustment_type is not null and tx.transaction_type = 'X' then libcc.transaction_type + '_' + libcc.adjustment_type 
				when recur.transaction_id is not null then 'Recur'
				when tx.mppr_flag = 1 or convert(bit, case when bump.bumpup_transaction_id is null then 0 else 1 end) = 'true' then 'MPPR'
				else tx.transaction_type end as adjusted_tx_type
			, case when recur.transaction_id is null then 0 else 1 end as recurring_tx
			, case when tx.reversing_tx_id is null then 0 else 1 end as reversed
			, tx.transaction_type_group
			, 0 as ancillary_year
			, 0 as ancillary_month		
			, tx.ar_applied_payment_history_id
		FROM #local_transactions tx with (nolock)
		inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
		inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
		left join dbo.ar_transactions_location_room roomLocation with (nolock) on roomLocation.transaction_id = tx.transaction_id
		left join dbo.ar_transaction_recurring_tx_refs recur with (nolock) on tx.transaction_id = recur.transaction_id
		left join dbo.ar_batch batch with (nolock) on tx.batch_id = batch.batch_id
		left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
		left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
		left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
		left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
		left join dbo.ar_mppr_bumpup bump with (nolock) on tx.distribution_tx_id = bump.bumpup_transaction_id  

	end

if @vShowResults = 'A'

	begin

		INSERT INTO #transactions	
		SELECT 
			  tx.fac_id
			, tx.client_id
			, tx.payer_id
			, libpayer.description AS payer
			, tx.batch_id
			, tx.entry_number
			, tx.distribution_tx_id
			, tx.transaction_id
			, isnull(tx.auto_generated, 'N') as auto_generated
			, tx.billing_date
			, tx.transaction_date as posting_date
			, tx.effective_date
			, Null as effective_from_date
			, Null as effective_thru_date
			, libcc.charge_code
			, tx.revenue_code
			, tx.hcpcs_code
			, tx.mppr_flag
			, Case when tx.transaction_type = 'R' and isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> '' 
					then rtype.long_description + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then 
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' + convert(varchar(4),YEAR(tx.effective_date))
					end) +
					' (' +isnull(tx.care_level,'') + ')'
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) +
					' (' +isnull(tx.care_level,'') + ')'
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
				and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') = ''  
				and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) + 	' (' +isnull(tx.care_level,'') + ')'
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'CL' and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X','CA') and isnull(tx.alt_description,'')<>''  and batch.batch_id is null then tx.alt_description 
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')<>'' and batch.batch_id is not null then 
					tx.alt_description + ' #' + ltrim(rtrim(str(batch.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number)))
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' and batch.batch_id is not null then 
					tx.description + ' #' + ltrim(rtrim(str(batch.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number)))
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' and batch.batch_id is null and recur.transaction_id is not null
					then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')'
				when tx.transaction_type = 'CA' and isnull(tx.alt_description,'')='' and batch.batch_id is not null and tx.mppr_flag = 0 then 
					tx.description + ' #' + ltrim(rtrim(str(batch.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number)))
				when tx.transaction_type ='CA' and isnull(tx.alt_description,'')='' and batch.batch_id is null and recur.transaction_id is not null
					then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')' 
				when tx.transaction_type = 'CO' and tx.parent_tx_type <> 'R' then tx.description +  ' Coinsurance'
				when tx.transaction_type = 'XR' and tx.parent_tx_type ='A' then tx.description +  ' Reimb. Reduction' 
				when tx.transaction_type = 'CX' and tx.parent_tx_type ='R' then 'Room Excess' 
				when (tx.transaction_type in('R','XR','CO', 'D', 'CR') or (tx.transaction_type = 'CL' and isnull(tx.alt_description,'')='')) and tx.parent_tx_type = 'R' then
				(Case 
					when isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> ''  
						then rtype.long_description + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(arpayer.show_care_level,'N') = 'Y' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
						and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' +
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + ' (' +isnull(tx.care_level,'') + ')'
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then  
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'XR'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) +	' (' +isnull(tx.care_level,'') + ')'
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'CO'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else
							' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + ' (' +isnull(tx.care_level,'') + ')' + ' Coinsurance'
					else 
						(case when tx.transaction_type = 'XR' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
							(case when abs(tx.days_amount) > 1 then
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else  ' ' +	convert(varchar(4),YEAR(tx.effective_date))
							end)
						else 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') +
							(case when abs(tx.days_amount) > 1 then 
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else ' ' + convert(varchar(4),YEAR(tx.effective_date))
							end) +
							(case when tx.transaction_type = 'D' then ' Deductible' 
								when tx.transaction_type = 'CO' then ' Coinsurance' else '' end)  
						end)
					end
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				) + (case when tx.transaction_type = 'CL' then ' Coverage Deductible' else '' end) 
				 + (case when tx.transaction_type = 'CR' then ' Cont.Adj.' else '' end) 
				else tx.description end as detail_description
			, tx.care_level
			, Case when tx.transaction_type = 'R' and libpayer.pps_flag='Y' then ltrim(rtrim(str(tx.medicare_day))) + '-' 
				+ltrim(rtrim(str((
					case when tx.days_amount < 0 and (tx.days_amount*-1) > 1 then tx.days_amount*-1 + tx.medicare_day -1
					when tx.days_amount > 0 and (tx.days_amount*-1) = 1 then tx.days_amount*-1  + tx.medicare_day
					when tx.days_amount > 1 then tx.days_amount + tx.medicare_day -1
					else tx.days_amount + tx.medicare_day end))))
				else Null
					end as benefit_days
			, tx.parent_tx_type
			, tx.transaction_type
			, tx.daily_rate as unit_amount
			, case when tx.transaction_type = 'XR' then Null else tx.days_amount end as number_of_units
			, tx.amount
			, acct.account_number as gl_account
			, daysacct.account_number as days_account
			, case when tx.is_billed = 1 and isnull(tx.invoice_id,0) > 0 then 'Y'
				when tx.is_billed = 1 and isnull(tx.invoice_id,0) < 0 then 'N/A' else 'N' end as billed
			, tx.comment
			, tx.cheque_number
			, Case when tx.invoice_id = -999 then isnull(tx.mark_as_billed_by,'System') else null end as mark_as_billed_by
			, Case when tx.invoice_id = -999 then tx.mark_as_billed_date else null end as mark_as_billed_date
			, Case when tx.invoice_id = -999 then tx.mark_as_billed_comment else null end as mark_as_billed_comment
			, case when libcc.adjustment_type is not null and tx.transaction_type = 'X' then libcc.transaction_type + '_' + libcc.adjustment_type 
				when recur.transaction_id is not null then 'Recur'
				when tx.mppr_flag = 1 or convert(bit, case when bump.bumpup_transaction_id is null then 0 else 1 end) = 'true' then 'MPPR'
				else tx.transaction_type end as adjusted_tx_type
			, case when recur.transaction_id is null then 0 else 1 end as recurring_tx
			, case when tx.reversing_tx_id is null then 0 else 1 end as reversed
			, tx.transaction_type_group	
			, 0 as ancillary_year
			, 0 as ancillary_month		
			, tx.ar_applied_payment_history_id
		FROM #local_transactions tx with (nolock)
		inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
		inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
		left join dbo.ar_transactions_location_room roomLocation with (nolock) on roomLocation.transaction_id = tx.transaction_id
		left join dbo.ar_transaction_recurring_tx_refs recur with (nolock) on tx.transaction_id = recur.transaction_id
		left join dbo.ar_batch batch with (nolock) on tx.batch_id = batch.batch_id
		left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
		left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
		left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
		left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
		left join dbo.ar_mppr_bumpup bump with (nolock) on tx.distribution_tx_id = bump.bumpup_transaction_id  
		WHERE 
			tx.transaction_type <> 'A' 

		if @vPrintReportBy = 'billing_date'
			begin

				INSERT INTO #transactions	
				SELECT 
					  tx.fac_id
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, '' as auto_generated
					, tx.billing_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, '' as charge_code
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, case when tx.is_billed = 0 then 'Ancillary Charges' else 
						'Ancillary Charges ' + convert(varchar(3), tx.billing_date,100) +' ' + convert(varchar(4),datepart(yyyy,tx.billing_date),100) end as detail_description
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, '' as transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, '' as mark_as_billed_by
					, Null as mark_as_billed_date
					, '' as mark_as_billed_comment
					, 'A' as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.billing_date) as ancillary_year
					, datepart(mm,tx.billing_date) as ancillary_month	
					, tx.ar_applied_payment_history_id
				FROM #local_transactions tx with (nolock)
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					tx.transaction_type = 'A'
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, tx.transaction_type, tx.is_billed, tx.transaction_type_group, tx.billing_date, tx.ar_applied_payment_history_id
			end

		else if @vPrintReportBy = 'service_date'
			begin

				INSERT INTO #transactions	
				SELECT 
					  tx.fac_id
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, '' as auto_generated
					, tx.billing_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, '' as charge_code
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, 'Ancillary Charges ' + convert(varchar(3), tx.effective_date,100) +' ' + convert(varchar(4),datepart(yyyy,tx.effective_date),100) as detail_description 
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, '' as transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, '' as mark_as_billed_by
					, Null as mark_as_billed_date
					, '' as mark_as_billed_comment
					, 'A' as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.effective_date) as ancillary_year
					, datepart(mm,tx.effective_date) as ancillary_month	
					, tx.ar_applied_payment_history_id
				FROM #local_transactions tx with (nolock)
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					tx.transaction_type = 'A'
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, tx.transaction_type, tx.transaction_type_group, tx.is_billed,
					datepart(yyyy,tx.effective_date),	datepart(mm,tx.effective_date), convert(varchar(3), tx.effective_date,100), tx.billing_date, tx.ar_applied_payment_history_id
			end	
			
		else if @vPrintReportBy = 'posting_date'
			begin

				INSERT INTO #transactions	
				SELECT 
					  tx.fac_id
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, Null as batch_id
					, Null entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, '' as auto_generated
					, tx.billing_date
					, min(tx.transaction_date) as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, '' as charge_code
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, 'Ancillary Charges ' + convert(varchar(3), tx.transaction_date,100) +' ' + convert(varchar(4),datepart(yyyy,tx.transaction_date),100) as detail_description  
					, '' as care_level
					, Null as benefit_days
					, '' as parent_tx_type
					, '' as transaction_type
					, Null as unit_amount
					, Null as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, '' as mark_as_billed_by
					, Null as mark_as_billed_date
					, '' as mark_as_billed_comment
					, 'A' as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, datepart(yyyy,tx.transaction_date) as ancillary_year
					, datepart(mm,tx.transaction_date) as ancillary_month	
					, tx.ar_applied_payment_history_id
				FROM #local_transactions tx with (nolock)
				inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
				inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
				left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
				left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
				left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
				left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
				WHERE 
					tx.transaction_type = 'A'
				group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, tx.transaction_type, tx.transaction_type_group, tx.is_billed, eomonth(tx.transaction_date),
					datepart(yyyy,tx.transaction_date),	datepart(mm,tx.transaction_date), convert(varchar(3), tx.transaction_date,100), tx.billing_date, tx.ar_applied_payment_history_id
					
			end		
	end

if @vShowResults = 'C'

	begin

		INSERT INTO #transactions	
		SELECT 
			  tx.fac_id
			, tx.client_id
			, tx.payer_id
			, libpayer.description AS payer
			, tx.batch_id
			, tx.entry_number
			, tx.distribution_tx_id
			, tx.transaction_id
			, isnull(tx.auto_generated, 'N') as auto_generated
			, tx.billing_date
			, tx.transaction_date as posting_date
			, tx.effective_date
			, Null as effective_from_date
			, Null as effective_thru_date
			, libcc.charge_code
			, tx.revenue_code
			, tx.hcpcs_code
			, tx.mppr_flag
			, Case when tx.transaction_type = 'R' and isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> '' 
					then rtype.long_description + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then 
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' + convert(varchar(4),YEAR(tx.effective_date))
					end) +
					' (' +isnull(tx.care_level,'') + ')'
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) +
					' (' +isnull(tx.care_level,'') + ')'
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
				and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') = ''  
				and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) + 	' (' +isnull(tx.care_level,'') + ')'
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'CL' and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X','CA') and isnull(tx.alt_description,'')<>''  and batch.batch_id is null then tx.alt_description 
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')<>'' and batch.batch_id is not null then 
					tx.alt_description + ' #' + ltrim(rtrim(str(batch.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number)))
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' and batch.batch_id is not null then 
					tx.description + ' #' + ltrim(rtrim(str(batch.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number)))
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' and batch.batch_id is null and recur.transaction_id is not null
					then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')'
				when tx.transaction_type = 'CA' and isnull(tx.alt_description,'')='' and batch.batch_id is not null and tx.mppr_flag = 0 then 
					tx.description + ' #' + ltrim(rtrim(str(batch.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number)))
				when tx.transaction_type ='CA' and isnull(tx.alt_description,'')='' and batch.batch_id is null and recur.transaction_id is not null
					then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')' 
				when tx.transaction_type = 'CO' and tx.parent_tx_type <> 'R' then tx.description +  ' Coinsurance'
				when tx.transaction_type = 'XR' and tx.parent_tx_type ='A' then tx.description +  ' Reimb. Reduction' 
				when tx.transaction_type = 'CX' and tx.parent_tx_type ='R' then 'Room Excess' 
				when (tx.transaction_type in('R','XR','CO', 'D', 'CR') or (tx.transaction_type = 'CL' and isnull(tx.alt_description,'')='')) and tx.parent_tx_type = 'R' then
				(Case 
					when isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> ''  
						then rtype.long_description + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(arpayer.show_care_level,'N') = 'Y' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
						and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' +
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + ' (' +isnull(tx.care_level,'') + ')'
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then  
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'XR'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) +	' (' +isnull(tx.care_level,'') + ')'
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'CO'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else
							' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + ' (' +isnull(tx.care_level,'') + ')' + ' Coinsurance'
					else 
						(case when tx.transaction_type = 'XR' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
							(case when abs(tx.days_amount) > 1 then
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else  ' ' +	convert(varchar(4),YEAR(tx.effective_date))
							end)
						else 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') +
							(case when abs(tx.days_amount) > 1 then 
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else ' ' + convert(varchar(4),YEAR(tx.effective_date))
							end) +
							(case when tx.transaction_type = 'D' then ' Deductible' 
								when tx.transaction_type = 'CO' then ' Coinsurance' else '' end)  
						end)
					end
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				) + (case when tx.transaction_type = 'CL' then ' Coverage Deductible' else '' end) 
				 + (case when tx.transaction_type = 'CR' then ' Cont.Adj.' else '' end) 
				else tx.description end as detail_description
			, tx.care_level
			, Case when tx.transaction_type = 'R' and libpayer.pps_flag='Y' then ltrim(rtrim(str(tx.medicare_day))) + '-' 
				+ltrim(rtrim(str((
					case when tx.days_amount < 0 and (tx.days_amount*-1) > 1 then tx.days_amount*-1 + tx.medicare_day -1
					when tx.days_amount > 0 and (tx.days_amount*-1) = 1 then tx.days_amount*-1  + tx.medicare_day
					when tx.days_amount > 1 then tx.days_amount + tx.medicare_day -1
					else tx.days_amount + tx.medicare_day end))))
				else Null
					end as benefit_days
			, tx.parent_tx_type
			, tx.transaction_type
			, tx.daily_rate as unit_amount
			, case when tx.transaction_type = 'XR' then Null else tx.days_amount end as number_of_units
			, tx.amount
			, acct.account_number as gl_account
			, daysacct.account_number as days_account
			, case when tx.is_billed = 1 and isnull(tx.invoice_id,0) > 0 then 'Y'
				when tx.is_billed = 1 and isnull(tx.invoice_id,0) < 0 then 'N/A' else 'N' end as billed
			, tx.comment
			, tx.cheque_number
			, Case when tx.invoice_id = -999 then isnull(tx.mark_as_billed_by,'System') else null end as mark_as_billed_by
			, Case when tx.invoice_id = -999 then tx.mark_as_billed_date else null end as mark_as_billed_date
			, Case when tx.invoice_id = -999 then tx.mark_as_billed_comment else null end as mark_as_billed_comment
			, case when libcc.adjustment_type is not null and tx.transaction_type = 'X' then libcc.transaction_type + '_' + libcc.adjustment_type 
				when recur.transaction_id is not null then 'Recur'
				when tx.mppr_flag = 1 or convert(bit, case when bump.bumpup_transaction_id is null then 0 else 1 end) = 'true' then 'MPPR'
				else tx.transaction_type end as adjusted_tx_type
			, case when recur.transaction_id is null then 0 else 1 end as recurring_tx
			, case when tx.reversing_tx_id is null then 0 else 1 end as reversed
			, tx.transaction_type_group	
			, 0 as ancillary_year
			, 0 as ancillary_month	
			, tx.ar_applied_payment_history_id			
		FROM #local_transactions tx with (nolock)
		inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
		inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
		left join dbo.ar_transactions_location_room roomLocation with (nolock) on roomLocation.transaction_id = tx.transaction_id
		left join dbo.ar_transaction_recurring_tx_refs recur with (nolock) on tx.transaction_id = recur.transaction_id
		left join dbo.ar_batch batch with (nolock) on tx.batch_id = batch.batch_id
		left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
		left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
		left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
		left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
		left join dbo.ar_mppr_bumpup bump with (nolock) on tx.distribution_tx_id = bump.bumpup_transaction_id  
		WHERE 
			libcc.charge_code_id is null

		if @vPrintReportBy = 'billing_date'
			begin

				INSERT INTO #transactions	
				SELECT 
					  tx.fac_id
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, '' as auto_generated
					, tx.billing_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, libcc.charge_code
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')<>'' then 
						(Case when min(tx.effective_date) <> max(tx.effective_date) then 
							'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + tx.alt_description
						else
							tx.alt_description 
						end)
						else 
						(Case when min(tx.effective_date) <> max(tx.effective_date) then 
							'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + libcc.description
						else
							libcc.description
						end)
						end as detail_description	
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, '' as mark_as_billed_by
					, Null as mark_as_billed_date
					, '' as mark_as_billed_comment
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month	
					, tx.ar_applied_payment_history_id
					FROM #local_transactions tx with (nolock)
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					left join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, tx.parent_tx_type, tx.transaction_type, tx.care_level, libcc.charge_code 
					,tx.alt_description, libcc.description, tx.is_billed, tx.transaction_type_group, tx.billing_date, tx.ar_applied_payment_history_id

			end

		else if @vPrintReportBy = 'service_date'
			begin

				INSERT INTO #transactions	
				SELECT 
					  tx.fac_id
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, '' as auto_generated
					, tx.billing_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, libcc.charge_code
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')<>'' then 
						(Case when min(tx.effective_date) <> max(tx.effective_date) then 
							'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + tx.alt_description
						else
							tx.alt_description 
						end)
						else 
						(Case when min(tx.effective_date) <> max(tx.effective_date) then 
							'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + libcc.description
						else
							libcc.description
						end)
						end as detail_description	
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, '' as mark_as_billed_by
					, Null as mark_as_billed_date
					, '' as mark_as_billed_comment
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month	
					, tx.ar_applied_payment_history_id
					FROM #local_transactions tx with (nolock)
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					left join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, tx.parent_tx_type, tx.transaction_type, tx.care_level, libcc.charge_code 
					,tx.alt_description, libcc.description, tx.is_billed, tx.transaction_type_group,
					datepart(yyyy,tx.effective_date), datepart(mm,tx.effective_date), convert(varchar(3), tx.effective_date,100), tx.billing_date, tx.ar_applied_payment_history_id

			end	
			
		else if @vPrintReportBy = 'posting_date'
			begin

				INSERT INTO #transactions	
				SELECT 
					  tx.fac_id
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, '' as auto_generated
					, tx.billing_date
					, min(tx.transaction_date) as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, libcc.charge_code
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')<>'' then 
						(Case when min(tx.effective_date) <> max(tx.effective_date) then 
							'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + tx.alt_description 
						else
							tx.alt_description 
						end)
						else 
						(Case when min(tx.effective_date) <> max(tx.effective_date) then 
							'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + libcc.description
						else
							libcc.description
						end)					
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, '' as mark_as_billed_by
					, Null as mark_as_billed_date
					, '' as mark_as_billed_comment
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month	
					, tx.ar_applied_payment_history_id
					FROM #local_transactions tx with (nolock)
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					left join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, tx.parent_tx_type, tx.transaction_type, tx.care_level, libcc.charge_code 
					,tx.alt_description, libcc.description, tx.is_billed, tx.transaction_type_group, eomonth(tx.transaction_date),
					datepart(yyyy,tx.transaction_date),	datepart(mm,tx.transaction_date), convert(varchar(3), tx.transaction_date,100), tx.billing_date, tx.ar_applied_payment_history_id

			end		
	end

if @vShowResults = 'CC'

	begin

		INSERT INTO #transactions	
		SELECT 
			  tx.fac_id
			, tx.client_id
			, tx.payer_id
			, libpayer.description AS payer
			, tx.batch_id
			, tx.entry_number
			, tx.distribution_tx_id
			, tx.transaction_id
			, isnull(tx.auto_generated, 'N') as auto_generated
			, tx.billing_date
			, tx.transaction_date as posting_date
			, tx.effective_date
			, Null as effective_from_date
			, Null as effective_thru_date
			, libcc.charge_code
			, tx.revenue_code
			, tx.hcpcs_code
			, tx.mppr_flag
			, Case when tx.transaction_type = 'R' and isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> '' 
					then rtype.long_description + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then 
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' + convert(varchar(4),YEAR(tx.effective_date))
					end) +
					' (' +isnull(tx.care_level,'') + ')'
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) +
					' (' +isnull(tx.care_level,'') + ')'
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
				and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') = ''  
				and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) + 	' (' +isnull(tx.care_level,'') + ')'
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'CL' and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X','CA') and isnull(tx.alt_description,'')<>''  and batch.batch_id is null then tx.alt_description 
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')<>'' and batch.batch_id is not null then 
					tx.alt_description + ' #' + ltrim(rtrim(str(batch.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number)))
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' and batch.batch_id is not null then 
					tx.description + ' #' + ltrim(rtrim(str(batch.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number)))
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' and batch.batch_id is null and recur.transaction_id is not null
					then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')'
				when tx.transaction_type = 'CA' and isnull(tx.alt_description,'')='' and batch.batch_id is not null and tx.mppr_flag = 0 then 
					tx.description + ' #' + ltrim(rtrim(str(batch.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number)))
				when tx.transaction_type ='CA' and isnull(tx.alt_description,'')='' and batch.batch_id is null and recur.transaction_id is not null
					then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')' 
				when tx.transaction_type = 'CO' and tx.parent_tx_type <> 'R' then tx.description +  ' Coinsurance'
				when tx.transaction_type = 'XR' and tx.parent_tx_type ='A' then tx.description +  ' Reimb. Reduction' 
				when tx.transaction_type = 'CX' and tx.parent_tx_type ='R' then 'Room Excess' 
				when (tx.transaction_type in('R','XR','CO', 'D', 'CR') or (tx.transaction_type = 'CL' and isnull(tx.alt_description,'')='')) and tx.parent_tx_type = 'R' then
				(Case 
					when isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> ''  
						then rtype.long_description + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(arpayer.show_care_level,'N') = 'Y' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
						and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' +
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + ' (' +isnull(tx.care_level,'') + ')'
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then  
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'XR'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) +	' (' +isnull(tx.care_level,'') + ')'
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'CO'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else
							' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + ' (' +isnull(tx.care_level,'') + ')' + ' Coinsurance'
					else 
						(case when tx.transaction_type = 'XR' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
							(case when abs(tx.days_amount) > 1 then
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else  ' ' +	convert(varchar(4),YEAR(tx.effective_date))
							end)
						else 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') +
							(case when abs(tx.days_amount) > 1 then 
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else ' ' + convert(varchar(4),YEAR(tx.effective_date))
							end) +
							(case when tx.transaction_type = 'D' then ' Deductible' 
								when tx.transaction_type = 'CO' then ' Coinsurance' else '' end)  
						end)
					end
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				) + (case when tx.transaction_type = 'CL' then ' Coverage Deductible' else '' end) 
				 + (case when tx.transaction_type = 'CR' then ' Cont.Adj.' else '' end) 
				else tx.description end as detail_description
			, tx.care_level
			, Case when tx.transaction_type = 'R' and libpayer.pps_flag='Y' then ltrim(rtrim(str(tx.medicare_day))) + '-' 
				+ltrim(rtrim(str((
					case when tx.days_amount < 0 and (tx.days_amount*-1) > 1 then tx.days_amount*-1 + tx.medicare_day -1
					when tx.days_amount > 0 and (tx.days_amount*-1) = 1 then tx.days_amount*-1  + tx.medicare_day
					when tx.days_amount > 1 then tx.days_amount + tx.medicare_day -1
					else tx.days_amount + tx.medicare_day end))))
				else Null
					end as benefit_days
			, tx.parent_tx_type
			, tx.transaction_type
			, tx.daily_rate as unit_amount
			, case when tx.transaction_type = 'XR' then Null else tx.days_amount end as number_of_units
			, tx.amount
			, acct.account_number as gl_account
			, daysacct.account_number as days_account
			, case when tx.is_billed = 1 and isnull(tx.invoice_id,0) > 0 then 'Y'
				when tx.is_billed = 1 and isnull(tx.invoice_id,0) < 0 then 'N/A' else 'N' end as billed
			, tx.comment
			, tx.cheque_number
			, Case when tx.invoice_id = -999 then isnull(tx.mark_as_billed_by,'System') else null end as mark_as_billed_by
			, Case when tx.invoice_id = -999 then tx.mark_as_billed_date else null end as mark_as_billed_date
			, Case when tx.invoice_id = -999 then tx.mark_as_billed_comment else null end as mark_as_billed_comment
			, case when libcc.adjustment_type is not null and tx.transaction_type = 'X' then libcc.transaction_type + '_' + libcc.adjustment_type 
				when recur.transaction_id is not null then 'Recur'
				when tx.mppr_flag = 1 or convert(bit, case when bump.bumpup_transaction_id is null then 0 else 1 end) = 'true' then 'MPPR'
				else tx.transaction_type end as adjusted_tx_type
			, case when recur.transaction_id is null then 0 else 1 end as recurring_tx
			, case when tx.reversing_tx_id is null then 0 else 1 end as reversed
			, tx.transaction_type_group	
			, 0 as ancillary_year
			, 0 as ancillary_month	
			, tx.ar_applied_payment_history_id			
		FROM #local_transactions tx with (nolock)
		inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
		inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
		left join dbo.ar_transactions_location_room roomLocation with (nolock) on roomLocation.transaction_id = tx.transaction_id
		left join dbo.ar_transaction_recurring_tx_refs recur with (nolock) on tx.transaction_id = recur.transaction_id
		left join dbo.ar_batch batch with (nolock) on tx.batch_id = batch.batch_id
		left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
		left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
		left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
		left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
		left join dbo.ar_mppr_bumpup bump with (nolock) on tx.distribution_tx_id = bump.bumpup_transaction_id  
		WHERE 
			libcc.charge_code_id is null

		if @vPrintReportBy = 'billing_date'
			begin

				INSERT INTO #transactions	
				SELECT 
					  tx.fac_id
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, '' as auto_generated
					, tx.billing_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, '' as charge_code
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then 
							'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + cat.cat_description
						else
							cat.cat_description
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, '' as mark_as_billed_by
					, Null as mark_as_billed_date
					, '' as mark_as_billed_comment
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month	
					, tx.ar_applied_payment_history_id
					FROM #local_transactions tx with (nolock)
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					inner join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, tx.parent_tx_type,
					tx.transaction_type, tx.care_level, cat.item_cat_id, cat.cat_description,tx.is_billed, tx.transaction_type_group, tx.billing_date, tx.ar_applied_payment_history_id

				INSERT INTO #transactions	
				SELECT 
					  tx.fac_id
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, '' as auto_generated
					, tx.billing_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, '' as charge_code
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then 
							'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + libcc.description
						else
							libcc.description
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, '' as mark_as_billed_by
					, Null as mark_as_billed_date
					, '' as mark_as_billed_comment
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month	
					, tx.ar_applied_payment_history_id
					FROM #local_transactions tx with (nolock)
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					left join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					where cat.item_cat_id is null
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, tx.parent_tx_type,
					tx.transaction_type, tx.care_level, libcc.charge_code, libcc.description, tx.is_billed, tx.transaction_type_group, tx.billing_date, tx.ar_applied_payment_history_id

			end

		else if @vPrintReportBy = 'service_date'
			begin

				INSERT INTO #transactions	
				SELECT 
					  tx.fac_id
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, '' as auto_generated
					, tx.billing_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, '' as charge_code
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then 
							'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + cat.cat_description
						else
							cat.cat_description
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, '' as mark_as_billed_by
					, Null as mark_as_billed_date
					, '' as mark_as_billed_comment
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month	
					, tx.ar_applied_payment_history_id
					FROM #local_transactions tx with (nolock)
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					inner join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, tx.parent_tx_type,
					tx.transaction_type, tx.care_level, cat.item_cat_id, cat.cat_description,tx.is_billed, tx.transaction_type_group,
					datepart(yyyy,tx.effective_date),	datepart(mm,tx.effective_date), convert(varchar(3), tx.effective_date,100), tx.billing_date, tx.ar_applied_payment_history_id

				INSERT INTO #transactions	
				SELECT 
					  tx.fac_id
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, '' as auto_generated
					, tx.billing_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, '' as charge_code
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then 
							'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + libcc.description
						else
							libcc.description
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, '' as mark_as_billed_by
					, Null as mark_as_billed_date
					, '' as mark_as_billed_comment
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month	
					, tx.ar_applied_payment_history_id
					FROM #local_transactions tx with (nolock)
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					left join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					where cat.item_cat_id is null
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, tx.parent_tx_type,
					tx.transaction_type, tx.care_level, libcc.charge_code, libcc.description, tx.is_billed, tx.transaction_type_group,
					datepart(yyyy,tx.effective_date),	datepart(mm,tx.effective_date), convert(varchar(3), tx.effective_date,100), tx.billing_date, tx.ar_applied_payment_history_id
			end	
			
		else if @vPrintReportBy = 'posting_date'
			begin

				INSERT INTO #transactions	
				SELECT 
					  tx.fac_id
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, '' as auto_generated
					, tx.billing_date
					, min(tx.transaction_date) as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, '' as charge_code
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then 
							'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + cat.cat_description
						else
							cat.cat_description
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, '' as mark_as_billed_by
					, Null as mark_as_billed_date
					, '' as mark_as_billed_comment
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month	
					, tx.ar_applied_payment_history_id
					FROM #local_transactions tx with (nolock)
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					inner join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, tx.parent_tx_type,
					tx.transaction_type, tx.care_level, cat.item_cat_id, cat.cat_description,tx.is_billed, tx.transaction_type_group,
					datepart(yyyy,tx.transaction_date),	datepart(mm,tx.transaction_date), convert(varchar(3), tx.transaction_date,100), tx.billing_date, tx.ar_applied_payment_history_id

				INSERT INTO #transactions	
				SELECT 
					  tx.fac_id
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, '' as auto_generated
					, tx.billing_date
					, min(tx.transaction_date) as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, '' as charge_code
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then 
							'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' + libcc.description
						else
							libcc.description
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, '' as mark_as_billed_by
					, Null as mark_as_billed_date
					, '' as mark_as_billed_comment
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group
					, 0 as ancillary_year
					, 0 as ancillary_month	
					, tx.ar_applied_payment_history_id
					FROM #local_transactions tx with (nolock)
					inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
					inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N' 
					inner join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N') 
					left join dbo.ar_item_category cat with (nolock) on libcc.category_id = cat.item_cat_id 
					left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
					left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
					left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
					where cat.item_cat_id is null
					group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, tx.parent_tx_type,
					tx.transaction_type, tx.care_level, libcc.charge_code, libcc.description, tx.is_billed, tx.transaction_type_group,
					datepart(yyyy,tx.transaction_date),	datepart(mm,tx.transaction_date), convert(varchar(3), tx.transaction_date,100), tx.billing_date, tx.ar_applied_payment_history_id

			end	
	end

if @vShowResults = 'R'

	begin

		INSERT INTO #transactions	
		SELECT 
			  tx.fac_id
			, tx.client_id
			, tx.payer_id
			, libpayer.description AS payer
			, tx.batch_id
			, tx.entry_number
			, tx.distribution_tx_id
			, tx.transaction_id
			, isnull(tx.auto_generated, 'N') as auto_generated
			, tx.billing_date
			, tx.transaction_date as posting_date
			, tx.effective_date
			, Null as effective_from_date
			, Null as effective_thru_date
			, libcc.charge_code
			, tx.revenue_code
			, tx.hcpcs_code
			, tx.mppr_flag
			, Case when tx.transaction_type = 'R' and isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> '' 
					then rtype.long_description + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then 
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' + convert(varchar(4),YEAR(tx.effective_date))
					end) +
					' (' +isnull(tx.care_level,'') + ')'
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) +
					' (' +isnull(tx.care_level,'') + ')'
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') <> ''  
				and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end)
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'R' and isnull(arpayer.room_charge_bill_desc,'') = ''  
				and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
					FORMAT(tx.effective_date,'MMM dd') + 
					(case when abs(tx.days_amount) > 1 then
						'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
						convert(varchar(4),YEAR(tx.effective_date))
					else ' ' +	convert(varchar(4),YEAR(tx.effective_date))
					end) + 	' (' +isnull(tx.care_level,'') + ')'
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				when tx.transaction_type = 'CL' and isnull(tx.alt_description,'')<>'' then tx.alt_description 
				when tx.transaction_type in('A','X','CA') and isnull(tx.alt_description,'')<>''  and batch.batch_id is null then tx.alt_description 
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')<>'' and batch.batch_id is not null then 
					tx.alt_description + ' #' + ltrim(rtrim(str(batch.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number)))
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' and batch.batch_id is not null then 
					tx.description + ' #' + ltrim(rtrim(str(batch.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number)))
				when tx.transaction_type in('A','X') and isnull(tx.alt_description,'')='' and batch.batch_id is null and recur.transaction_id is not null
					then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')'
				when tx.transaction_type = 'CA' and isnull(tx.alt_description,'')='' and batch.batch_id is not null and tx.mppr_flag = 0 then 
					tx.description + ' #' + ltrim(rtrim(str(batch.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number)))
				when tx.transaction_type ='CA' and isnull(tx.alt_description,'')='' and batch.batch_id is null and recur.transaction_id is not null
					then tx.description + ' ('+FORMAT(tx.effective_date,'MMM')+')' 
				when tx.transaction_type = 'CO' and tx.parent_tx_type <> 'R' then tx.description +  ' Coinsurance'
				when tx.transaction_type = 'XR' and tx.parent_tx_type ='A' then tx.description +  ' Reimb. Reduction' 
				when tx.transaction_type = 'CX' and tx.parent_tx_type ='R' then 'Room Excess' 
				when (tx.transaction_type in('R','XR','CO', 'D', 'CR') or (tx.transaction_type = 'CL' and isnull(tx.alt_description,'')='')) and tx.parent_tx_type = 'R' then
				(Case 
					when isnull(arpayer.use_rate_desc,'N') = 'Y' and isnull(rtype.long_description,'') <> ''  
						then rtype.long_description + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + (case when isnull(arpayer.show_care_level,'N') = 'Y' then ' (' +isnull(tx.care_level,'') + ')' else '' end)
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
						and isnull(arpayer.show_care_level,'N') = 'Y' then arpayer.room_charge_bill_desc + ' ' +
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date)) 
						else ' ' + convert(varchar(4),YEAR(tx.effective_date)) 
						end) + ' (' +isnull(tx.care_level,'') + ')'
					when isnull(arpayer.room_charge_bill_desc,'') <> ''  
					and isnull(arpayer.show_care_level,'N') = 'N' then arpayer.room_charge_bill_desc + ' ' + 
						FORMAT(tx.effective_date,'MMM dd') +
						(case when abs(tx.days_amount) > 1 then  
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end)
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'XR'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then 
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else ' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) +	' (' +isnull(tx.care_level,'') + ')'
					when isnull(arpayer.room_charge_bill_desc,'') = ''  and tx.transaction_type = 'CO'
					and isnull(arpayer.show_care_level,'N') = 'Y' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
						(case when abs(tx.days_amount) > 1 then
							'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
							convert(varchar(4),YEAR(tx.effective_date))
						else
							' ' + convert(varchar(4),YEAR(tx.effective_date))
						end) + ' (' +isnull(tx.care_level,'') + ')' + ' Coinsurance'
					else 
						(case when tx.transaction_type = 'XR' then 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') + 
							(case when abs(tx.days_amount) > 1 then
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else  ' ' +	convert(varchar(4),YEAR(tx.effective_date))
							end)
						else 'Room ' + 
						FORMAT(tx.effective_date,'MMM dd') +
							(case when abs(tx.days_amount) > 1 then 
								'-' +  CAST((DATEPART(dd,tx.effective_date) + ABS(tx.days_amount) -1) AS VARCHAR) + ' ' +
								convert(varchar(4),YEAR(tx.effective_date))
							else ' ' + convert(varchar(4),YEAR(tx.effective_date))
							end) +
							(case when tx.transaction_type = 'D' then ' Deductible' 
								when tx.transaction_type = 'CO' then ' Coinsurance' else '' end)  
						end)
					end
					+ (case when isnull(arpayer.show_location, 'N') = 'Y' then ' ' + isnull(roomLocation.room_desc, '') else '' end)
				) + (case when tx.transaction_type = 'CL' then ' Coverage Deductible' else '' end) 
				 + (case when tx.transaction_type = 'CR' then ' Cont.Adj.' else '' end) 
				else tx.description end as detail_description
			, tx.care_level
			, Case when tx.transaction_type = 'R' and libpayer.pps_flag='Y' then ltrim(rtrim(str(tx.medicare_day))) + '-' 
				+ltrim(rtrim(str((
					case when tx.days_amount < 0 and (tx.days_amount*-1) > 1 then tx.days_amount*-1 + tx.medicare_day -1
					when tx.days_amount > 0 and (tx.days_amount*-1) = 1 then tx.days_amount*-1  + tx.medicare_day
					when tx.days_amount > 1 then tx.days_amount + tx.medicare_day -1
					else tx.days_amount + tx.medicare_day end))))
				else Null
					end as benefit_days
			, tx.parent_tx_type
			, tx.transaction_type
			, tx.daily_rate as unit_amount
			, case when tx.transaction_type = 'XR' then Null else tx.days_amount end as number_of_units
			, tx.amount
			, acct.account_number as gl_account
			, daysacct.account_number as days_account
			, case when tx.is_billed = 1 and isnull(tx.invoice_id,0) > 0 then 'Y'
				when tx.is_billed = 1 and isnull(tx.invoice_id,0) < 0 then 'N/A' else 'N' end as billed
			, tx.comment
			, tx.cheque_number
			, Case when tx.invoice_id = -999 then isnull(tx.mark_as_billed_by,'System') else null end as mark_as_billed_by
			, Case when tx.invoice_id = -999 then tx.mark_as_billed_date else null end as mark_as_billed_date
			, Case when tx.invoice_id = -999 then tx.mark_as_billed_comment else null end as mark_as_billed_comment
			, case when libcc.adjustment_type is not null and tx.transaction_type = 'X' then libcc.transaction_type + '_' + libcc.adjustment_type 
				when recur.transaction_id is not null then 'Recur'
				when tx.mppr_flag = 1 or convert(bit, case when bump.bumpup_transaction_id is null then 0 else 1 end) = 'true' then 'MPPR'
				else tx.transaction_type end as adjusted_tx_type
			, case when recur.transaction_id is null then 0 else 1 end as recurring_tx
			, case when tx.reversing_tx_id is null then 0 else 1 end as reversed
			, tx.transaction_type_group	
			, 0 as ancillary_year
			, 0 as ancillary_month		
			, tx.ar_applied_payment_history_id
		FROM #local_transactions tx with (nolock)
		inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
		inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
		left join dbo.ar_transactions_location_room roomLocation with (nolock) on roomLocation.transaction_id = tx.transaction_id
		left join dbo.ar_transaction_recurring_tx_refs recur with (nolock) on tx.transaction_id = recur.transaction_id
		left join dbo.ar_batch batch with (nolock) on tx.batch_id = batch.batch_id
		left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
		left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
		left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id 
		left join dbo.ar_lib_charge_codes libcc with (nolock) on tx.item_type_id = libcc.charge_code_id and (libcc.deleted = 'N')
		left join dbo.ar_mppr_bumpup bump with (nolock) on tx.distribution_tx_id = bump.bumpup_transaction_id  
		left join #revenue_codes revcd on tx.revenue_code = revcd.revenue_code
		WHERE revcd.revenue_code is null

		if @vPrintReportBy = 'billing_date'
			begin

				INSERT INTO #transactions
				SELECT	
					  tx.fac_id
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, '' as auto_generated
					, tx.billing_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, '' as charge_code
					, isnull(tx.revenue_code,'') as revenue_code
					, '' as hcpcs_code
					, '' mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then 
							 'to '+ format(max(tx.effective_date),'MMM dd, yyyy') +' ' + revcd.description
						else
							revcd.description 
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, '' as mark_as_billed_by
					, Null as mark_as_billed_date
					, '' as mark_as_billed_comment
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, 0 as ancillary_year
					, 0 as ancillary_month	
					, tx.ar_applied_payment_history_id
				FROM #local_transactions tx with (nolock)
						inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
						inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
						left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
						left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
						left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id
						inner join #revenue_codes revcd on tx.revenue_code = revcd.revenue_code
						group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, tx.parent_tx_type, 
							tx.transaction_type, tx.care_level, tx.revenue_code, revcd.description,
							tx.is_billed, tx.transaction_type_group, tx.billing_date, tx.ar_applied_payment_history_id
			end

		else if @vPrintReportBy = 'service_date'
			begin

				INSERT INTO #transactions	
				SELECT 
					  tx.fac_id
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, '' as auto_generated
					, tx.billing_date
					, Null as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, '' as charge_code
					, isnull(tx.revenue_code,'') as revenue_code
					, '' as hcpcs_code
					, '' mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then 
							'to '+ format(max(tx.effective_date),'MMM dd, yyyy') +' ' + revcd.description
						else
							revcd.description 
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, '' as mark_as_billed_by
					, Null as mark_as_billed_date
					, '' as mark_as_billed_comment
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, 0 as ancillary_year
					, 0 as ancillary_month	
					, tx.ar_applied_payment_history_id
				FROM #local_transactions tx with (nolock)
						inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
						inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
						left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
						left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
						left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id
						inner join #revenue_codes revcd on tx.revenue_code = revcd.revenue_code
						group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, tx.parent_tx_type, 
							tx.transaction_type, tx.care_level, tx.revenue_code, revcd.description,
							tx.is_billed, tx.transaction_type_group,
							datepart(yyyy,tx.effective_date),	datepart(mm,tx.effective_date), convert(varchar(3), tx.effective_date,100), tx.billing_date, tx.ar_applied_payment_history_id

			end	
			
		else if @vPrintReportBy = 'posting_date'
			begin

				INSERT INTO #transactions	
				SELECT 
					  tx.fac_id
					, tx.client_id
					, tx.payer_id
					, libpayer.description AS payer
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, '' as auto_generated
					, tx.billing_date
					, min(tx.transaction_date) as posting_date
					, min(tx.effective_date) as effective_date
					, min(tx.effective_date) as effective_from_date
					, max(tx.effective_date) as effective_thru_date
					, '' as charge_code
					, isnull(tx.revenue_code,'') as revenue_code
					, '' as hcpcs_code
					, '' mppr_flag
					, Case when min(tx.effective_date) <> max(tx.effective_date) then 
							'to '+ format(max(tx.effective_date),'MMM dd, yyyy') + ' ' +revcd.description 
						else
							revcd.description 
						end as detail_description
					, tx.care_level
					, Null as benefit_days
					, tx.parent_tx_type
					, tx.transaction_type
					, sum(tx.daily_rate) as unit_amount
					, sum(tx.days_amount)  as number_of_units
					, sum(tx.amount) as amount
					, '' as gl_account
					, '' as days_account
					, case when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) > 0 then 'Y'
						when tx.is_billed = 1 and min(isnull(tx.invoice_id,0)) < 0 then 'N/A' else 'N' end as billed
					, '' as comment
					, '' as cheque_number
					, '' as mark_as_billed_by
					, Null as mark_as_billed_date
					, '' as mark_as_billed_comment
					, tx.transaction_type as adjusted_tx_type
					, 0 as recurring_tx
					, 0 as reversed	
					, tx.transaction_type_group	
					, 0 as ancillary_year
					, 0 as ancillary_month	
					, tx.ar_applied_payment_history_id
				FROM #local_transactions tx with (nolock)
						inner join dbo.ar_payers arpayer with (nolock) on tx.payer_id = arpayer.payer_id and arpayer.fac_id = tx.fac_id
						inner join dbo.ar_lib_payers libpayer with (nolock) on tx.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'   
						left join dbo.ar_lib_rate_type rtype with (nolock) on tx.rate_type_id = rtype.rate_type_id and rtype.deleted='N'
						left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
						left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id
						inner join #revenue_codes revcd on tx.revenue_code = revcd.revenue_code
						group by tx.fac_id, tx.client_id, tx.payer_id, libpayer.description, tx.parent_tx_type, 
							tx.transaction_type, tx.care_level, tx.revenue_code, revcd.description,
							tx.is_billed, tx.transaction_type_group,
							datepart(yyyy,tx.transaction_date),	datepart(mm,tx.transaction_date), convert(varchar(3), tx.transaction_date,100), tx.billing_date, tx.ar_applied_payment_history_id
			end		
	end

if @vIncludeMiscCash = 1
	begin

		insert into #transactions
		select
			  tx.fac_id
			, tx.client_id
			, tx.payer_id
			, tx.description AS payer
			, tx.batch_id
			, tx.entry_number
			, tx.distribution_tx_id
			, tx.transaction_id
			, tx.auto_generated
			, tx.billing_date
			, tx.transaction_date
			, tx.effective_date
			, Null as effective_from_date
			, Null as effective_thru_date
			, '' as charge_code
			, tx.revenue_code
			, tx.hcpcs_code
			, tx.mppr_flag
			, case when batch.batch_id is not null then 'Cash Receipt #' + ltrim(rtrim(str(batch.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number))) else 'Cash Receipt' end as tx_description
			, tx.care_level
			, Null as benefit_days
			, tx.parent_tx_type
			, tx.transaction_type
			, Null as unit_amount
			, Null as units
			, tx.amount
			, acct.account_number as gl_account
			, daysacct.account_number as days_account
			, case when tx.is_billed = 1 then 'Y' else 'N' end as billed
			, tx.comment
			, tx.cheque_number
			, tx.mark_as_billed_by
			, tx.mark_as_billed_date
			, tx.mark_as_billed_comment
			, 'C' as adjusted_tx_type
			, Null as recurring_tx
			, case when tx.reversing_tx_id is null then 0 else 1 end as reversed
			, 0
			, 0 as ancillary_year
			, 0 as ancillary_month
			, tx.ar_applied_payment_history_id
		from #local_transactions tx with (nolock)
		left join dbo.ar_lib_accounts daysacct with (nolock) on tx.days_account_id = daysacct.account_id 
		left join dbo.ar_lib_accounts acct with (nolock) on tx.dollars_account_id = acct.account_id
		left join dbo.ar_batch batch with (nolock) on tx.batch_id = batch.batch_id 
		WHERE 
			tx.client_id is null
	end

If @vCalcBF = 1
	begin
		--insert previous balance rows with data
		INSERT INTO #transactions	
				SELECT 
					  bf.fac_id
					, bf.client_id
					, bf.payer_id
					, libpayer.description AS payer
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, '' as auto_generated
					, Null as billing_date
					, Null as posting_date
					, Null as effective_date
					, Null as effective_from_date
					, Null as effective_thru_date
					, '' as charge_code
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, 'Previous Balance:' as [description]
					, '' as care_level
					, '' as benefit_days
					, '' as parent_tx_type
					, '' as transaction_type
					, Null as unit_amount
					, Null as units
					, bf.amount
					, '' as gl_account
					, '' as days_account
					, '' as billed
					, '' as comment
					, '' as cheque_number
					, Null as mark_as_billed_by
					, Null as mark_as_billed_date
					, Null as mark_as_billed_comment
					, '' as adjusted_tx_type
					, '' as recurring_tx
					, Null as reversed
					, 0
					, 0 as ancillary_year
					, 0 as ancillary_month
					, 0 as ar_applied_payment_history_id
		from #balance_forward_amount bf
		inner join dbo.ar_lib_payers libpayer with (nolock) on bf.payer_id = libpayer.payer_id AND libpayer.deleted = 'N'
		--inner join (select distinct(client_id) from #transactions) cl on bf.client_id = cl.client_id
		--where bf.amount <> 0

		--insert missing previous balance rows with data
		INSERT INTO #transactions	
				SELECT 
					  cl.fac_id
					, cl.client_id
					, cl.payer_id
					, libpayer.description AS payer
					, Null as batch_id
					, Null as entry_number
					, 0 as distribution_tx_id
					, 0 as transaction_id
					, '' as auto_generated
					, Null as billing_date
					, Null as posting_date
					, Null as effective_date
					, Null as effective_from_date
					, Null as effective_thru_date
					, '' as charge_code
					, '' as revenue_code
					, '' as hcpcs_code
					, '' as mppr_flag
					, 'Previous Balance:' as [description]
					, '' as care_level
					, '' as benefit_days
					, '' as parent_tx_type
					, '' as transaction_type
					, Null as unit_amount
					, Null as units
					, 0.00 as amount
					, '' as gl_account
					, '' as days_account
					, '' as billed
					, '' as comment
					, '' as cheque_number
					, Null as mark_as_billed_by
					, Null as mark_as_billed_date
					, Null as mark_as_billed_comment
					, '' as adjusted_tx_type
					, '' as recurring_tx
					, Null as reversed
					, 0
					, 0 as ancillary_year
					, 0 as ancillary_month
					, 0 as ar_applied_payment_history_id
		from dbo.ar_lib_payers libpayer with (nolock) 
		inner join (select fac_id,client_id, payer_id from #transactions group by fac_id,client_id,payer_id) cl on libpayer.payer_id = cl.payer_id AND libpayer.deleted = 'N'
		left join #balance_forward_amount bf on cl.payer_id = bf.payer_id and cl.client_id = bf.client_id
		where bf.client_id is null and bf.payer_id is null
end

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'

Select @vStep = 100;
set @vgsStepStartTime = GETDATE()
if @debug_me='Y' Print 'STEP '+convert(varchar(20), @vStep)  + ' Final Select ' + convert(varchar(26),getdate(),109);

If @vReportFormat = 'csv'

	SELECT distinct 		 
			  tx.fac_id
			, tx.client_id	
			, Case when tx.client_id is null then 'Misc. Cash' else mpi.last_name end as last_name
			, mpi.first_name
			, cl.client_id_number
			, tx.payer_id
			, tx.payer
			, case when @vShowResults = 'A' and tx.ancillary_month <> 0 then Null else tx.billing_date end as billing_date
			, case when @vShowResults = 'A' and tx.ancillary_month <> 0 then Null else tx.posting_date end as posting_date
			, case when @vShowResults = 'A' and tx.ancillary_month <> 0 then Null else tx.effective_date end as effective_date
			, tx.effective_from_date
			, tx.effective_thru_date
			, tx.charge_code
			, tx.revenue_code
			, tx.hcpcs_code
			, Case when tx.mppr_flag = 1 then 'Y' else 'N' end as mppr_flag
			, Case when tx.reversed = 1 then '** ' + tx.tx_description + ' **' + CASE WHEN tx_ai.cmi_component_name IS NULL THEN '' ELSE '-' + tx_ai.cmi_component_name END
				else tx.tx_description + CASE WHEN tx_ai.cmi_component_name IS NULL THEN '' ELSE '-' + tx_ai.cmi_component_name END end as tx_description
			, Case when @vShowDetails = 1 and tx.transaction_type <> 'C' and isnull(tx.mark_as_billed_by,'') <> '' THEN 'Marked as Billed By: ' + tx.mark_as_billed_by + 
				(case when tx.mark_as_billed_date is not null then ' On: ' + convert(varchar(20),tx.mark_as_billed_date, 120) else '' end) else '' end as mark_as_billed_details
			, Case when  @vShowDetails = 1 and tx.transaction_type <> 'C' and isnull(tx.mark_as_billed_comment, '') <> '' then 'Comments: ' + tx.mark_as_billed_comment else '' end as mark_as_billed_comment
			, tx.care_level
			, tx.benefit_days
			, case when tx.recurring_tx = 1 then tx.transaction_type+'(r)' else tx.transaction_type end as transaction_type
			, Case when round((tx.units * tx.unit_amount),2) <> round(tx.amount, 2) then Null else round(tx.unit_amount, 2) end as unit_amount
			, tx.units	
			, round(tx.amount, 2) as amount
			, Case when @vCombineChildren = 1 and tx.payer_id <> 0 then '' else tx.gl_account end as gl_account
			, Case when @vCombineChildren = 1 and tx.payer_id <> 0 then '' else tx.days_account end as days_account
			--, Case when isnull(tx.mark_as_billed_by,'') <> '' and transaction_id <> 0 and tx.transaction_type <> 'C'  then 'N/A' else tx.billed end as billed
			, Case when tx.transaction_id = -1 then '' else tx.billed end as billed 
			, Case when @vShowComments = 1 then isnull(tx.comment,'') else Null end as comment
			, tx.cheque_number
			, b.batch_number
			, tx.entry_number
			, tx.transaction_type_group
			, case when tx.ancillary_month <> 0 then 'True' else 'False' end as ancillary_flag		
			, Dense_rank() over ( ORDER BY case when tx.client_id is null then 1 else 0 end, mpi.last_name + ', ' + mpi.first_name + ' (' + cl.client_id_number + ')',tx.client_id,tx.payer,tx.payer_id,
				case when  tx.transaction_type_group = 0 then 0 else 1 end,
				case when @vPrintReportBy = 'billing_date' then datepart(yyyy,(isnull(tx.billing_date,dateadd(yy,100,getdate())))) else '1900'  end,
				case when @vPrintReportBy = 'billing_date' then datepart(mm,(isnull(tx.billing_date,dateadd(yy,100,getdate())))) else '1'  end,
				case when @vPrintReportBy = 'posting_date' then datepart(yyyy,tx.posting_date) else '1900' end,
				case when @vPrintReportBy = 'posting_date' then datepart(mm,tx.posting_date) else '1' end,
				case when @vPrintReportBy = 'service_date' then datepart(yyyy,tx.effective_date) else '1900' end,
				case when @vPrintReportBy = 'service_date' then datepart(mm,tx.effective_date) else '1' end,
				case when tx.transaction_type = 'R' or tx.parent_tx_type = 'R' then 1 
					when tx.transaction_type = 'A' or tx.parent_tx_type = 'A' then 2 
					when tx.transaction_type = 'CA' or tx.parent_tx_type = 'CA' then 3 
					when tx.transaction_type = 'X' or tx.parent_tx_type = 'X' then 5 
					when tx.transaction_type = 'C' then 6 else 4 end,
				case when @vPrintReportBy = 'billing_date' then isnull(tx.billing_date,dateadd(yy,100,getdate())) else '1/1/1900'  end,
				case when @vPrintReportBy = 'posting_date' then tx.posting_date else '1/1/1900' end,
				case when @vPrintReportBy = 'service_date' then tx.effective_date else '1/1/1900' end,
				datepart(yy,isnull(tx.effective_date,dateadd(yy,100,getdate()))),datepart(mm,isnull(tx.effective_date,dateadd(yy,100,getdate()))),
				isnull(tx.distribution_tx_id,tx.transaction_id) ,tx.transaction_id,
				tx.effective_date) as row_num
			, @status_code as status_code
			, @status_text as status_text
	FROM #transactions tx
	left join dbo.ar_batch b with (nolock) on tx.batch_id = b.batch_id
	left join dbo.clients cl with (nolock) on tx.client_id = cl.client_id
	left join dbo.mpi  mpi with (nolock) on cl.mpi_id = mpi.mpi_id and (mpi.deleted = 'N')
	left join @transaction_type_list txtype on tx.adjusted_tx_type = txtype.transaction_type 
	left join dbo.ar_transaction_assessment_info tx_ai on tx.transaction_id = tx_ai.transaction_id and tx.transaction_type = 'CR'
         and tx_ai.pdpm_account_distribution_flag = 1 and tx_ai.pdpm_flag = 1 and tx_ai.cmi_component_name is not null
	WHERE (@vSuppress0value = 0 or (@vSuppress0value = 1 and  (tx.amount <> 0.00 or tx.transaction_type_group = 0)) or tx.payer_id = 0)
		and (isnull(@vTransactionTypes, '-1') = '-1' or txtype.transaction_type is not null or tx.transaction_type_group = 0 or (@vIncludeMiscCash = 1 and tx.client_id is null))
	ORDER BY 
	row_num  
	
else
	SELECT distinct 		 
			  tx.fac_id
			, tx.client_id	
			, Case when tx.client_id is null then 'Misc. Cash' else mpi.last_name + ', ' + mpi.first_name + ' (' + cl.client_id_number + ')' end as name
			, tx.payer_id
			, tx.payer
			, tx.billing_date
			, tx.posting_date
			, tx.effective_date
			, tx.effective_from_date
			, tx.effective_thru_date
			, tx.charge_code
			, tx.revenue_code
			, tx.hcpcs_code
			, Case when tx.mppr_flag = 1 then 'Y' else 'N' end as mppr_flag
			, Case when tx.transaction_type ='C' and tx.client_id is not null and tx.reversed = 1 and b.batch_id is not null and isnull(tx.cheque_number,'') = ''  
					then '** ' + tx.tx_description + ' #' + ltrim(rtrim(str(b.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number))) + ' **' 
				when tx.transaction_type ='C' and tx.client_id is not null and tx.reversed = 1 and b.batch_id is not null and isnull(tx.cheque_number,'') <> ''  
					then '** ' + tx.tx_description + ' #' + ltrim(rtrim(str(b.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number))) + ', ch#' + tx.cheque_number +' **' 
				when tx.transaction_type ='C' and tx.client_id is not null and tx.reversed = 0 and  b.batch_id is not null and isnull(tx.cheque_number,'') = '' 
					then tx.tx_description + ' #' + ltrim(rtrim(str(b.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number)))
				when tx.transaction_type ='C' and tx.client_id is not null and tx.reversed = 0 and  b.batch_id is not null and isnull(tx.cheque_number,'') <> ''  
					then tx.tx_description + ' #' + ltrim(rtrim(str(b.batch_number))) + '-' + ltrim(rtrim(str(tx.entry_number))) + ', ch#' + tx.cheque_number
				when  tx.transaction_type = 'C' and tx.client_id is not null and tx.reversed = 0 and b.batch_id is null  and isnull(tx.cheque_number,'') = '' then tx.tx_description
				when  tx.transaction_type = 'C' and tx.client_id is not null and tx.reversed = 0 and b.batch_id is null  and isnull(tx.cheque_number,'') <> '' then tx.tx_description + ', ch#' + tx.cheque_number
				when tx.transaction_type <> 'C' and tx.client_id is not null and tx.reversed = 1 and isnull(tx.cheque_number,'') = '' then '** ' + tx.tx_description + ' **' + CASE WHEN tx_ai.cmi_component_name IS NULL THEN '' ELSE '-' + tx_ai.cmi_component_name END
				when tx.transaction_type <> 'C' and tx.client_id is not null and tx.reversed = 1 and isnull(tx.cheque_number,'') <> '' then '** ' + tx.tx_description + ', ch#' + tx.cheque_number + ' **' + CASE WHEN tx_ai.cmi_component_name IS NULL THEN '' ELSE '-' + tx_ai.cmi_component_name END
				else tx.tx_description + CASE WHEN tx_ai.cmi_component_name IS NULL THEN '' ELSE '-' + tx_ai.cmi_component_name END end as tx_description
			, Case when @vShowDetails = 1 and tx.transaction_type <> 'C' and isnull(tx.mark_as_billed_by,'') <> '' THEN @vBeginBoldTag + 'Marked as Billed By: ' 
					+ @vEndBoldTag + tx.mark_as_billed_by + 
					(case when tx.mark_as_billed_date is not null then @vBeginBoldTag + ' On: ' + @vEndBoldTag + convert(varchar(20),tx.mark_as_billed_date, 120) else '' end) else '' end as mark_as_billed_details
			, Case when  @vShowDetails = 1 and tx.transaction_type <> 'C' and isnull(tx.mark_as_billed_comment, '') <> '' then  @vBeginBoldTag + 'Comments: ' + @vEndBoldTag + tx.mark_as_billed_comment else '' end as mark_as_billed_comment
			, tx.care_level
			, tx.benefit_days
			, case when tx.recurring_tx = 1 then tx.transaction_type+'(r)' else tx.transaction_type end as transaction_type
			, Case when round((tx.units * tx.unit_amount),2) <> round(tx.amount, 2) then Null else round(tx.unit_amount, 2) end as unit_amount
			, tx.units	
			, round(tx.amount, 2) as amount
			, Case when @vCombineChildren = 1 and tx.payer_id <> 0 then '' else tx.gl_account end as gl_account
			, Case when @vCombineChildren = 1 and tx.payer_id <> 0 then '' else tx.days_account end as days_account
			--, Case when isnull(tx.mark_as_billed_by,'') <> '' and transaction_id <> 0 and tx.transaction_type <> 'C'  then 'N/A' else tx.billed end as billed
			, Case when tx.transaction_id = -1 then '' else tx.billed end as billed
			, Case when @vShowComments = 1 then isnull(tx.comment,'') else Null end as comment
			, tx.cheque_number
			, tx.transaction_type_group	
			, case when tx.ancillary_month <> 0 then 'True' else 'False' end as ancillary_flag	
			, Dense_rank() over ( ORDER BY case when tx.client_id is null then 1 else 0 end, mpi.last_name + ', ' + mpi.first_name + ' (' + cl.client_id_number + ')',tx.client_id,tx.payer,tx.payer_id,
				case when  tx.transaction_type_group = 0 then 0 else 1 end,
				case when @vPrintReportBy = 'billing_date' then datepart(yyyy,(isnull(tx.billing_date,dateadd(yy,100,getdate())))) else '1900'  end,
				case when @vPrintReportBy = 'billing_date' then datepart(mm,(isnull(tx.billing_date,dateadd(yy,100,getdate())))) else '1'  end,
				case when @vPrintReportBy = 'posting_date' then datepart(yyyy,tx.posting_date) else '1900' end,
				case when @vPrintReportBy = 'posting_date' then datepart(mm,tx.posting_date) else '1' end,
				case when @vPrintReportBy = 'service_date' then datepart(yyyy,tx.effective_date) else '1900' end,
				case when @vPrintReportBy = 'service_date' then datepart(mm,tx.effective_date) else '1' end,
				case when tx.transaction_type = 'R' or tx.parent_tx_type = 'R' then 1 
					when tx.transaction_type = 'A' or tx.parent_tx_type = 'A' then 2 
					when tx.transaction_type = 'CA' or tx.parent_tx_type = 'CA' then 3 
					when tx.transaction_type = 'X' or tx.parent_tx_type = 'X' then 5 
					when tx.transaction_type = 'C' then 6 else 4 end,
				case when @vPrintReportBy = 'billing_date' then isnull(tx.billing_date,dateadd(yy,100,getdate())) else '1/1/1900'  end,
				case when @vPrintReportBy = 'posting_date' then tx.posting_date else '1/1/1900' end,
				case when @vPrintReportBy = 'service_date' then tx.effective_date else '1/1/1900' end,
				datepart(yy,isnull(tx.effective_date,dateadd(yy,100,getdate()))),datepart(mm,isnull(tx.effective_date,dateadd(yy,100,getdate()))),
				isnull(tx.distribution_tx_id,tx.transaction_id) ,tx.transaction_id,
				tx.effective_date) as row_num
			, @status_code as status_code
			, @status_text as status_text
			, CASE WHEN @vPrintReportBy = 'service_date' THEN tx.ar_applied_payment_history_id  ELSE 0 end
	FROM #transactions tx
	left join dbo.ar_batch b with (nolock) on tx.batch_id = b.batch_id
	left join dbo.clients cl with (nolock) on tx.client_id = cl.client_id
	left join dbo.mpi  mpi with (nolock) on cl.mpi_id = mpi.mpi_id and (mpi.deleted = 'N')
	left join @transaction_type_list txtype on tx.adjusted_tx_type = txtype.transaction_type 
	left join dbo.ar_transaction_assessment_info tx_ai on tx.transaction_id = tx_ai.transaction_id and tx.transaction_type = 'CR'
         and tx_ai.pdpm_account_distribution_flag = 1 and tx_ai.pdpm_flag = 1 and tx_ai.cmi_component_name is not null
	WHERE (@vSuppress0value = 0 or (@vSuppress0value = 1 and  (tx.amount <> 0.00 or tx.transaction_type_group = 0)) or tx.payer_id = 0)
		and (isnull(@vTransactionTypes, '-1') = '-1' or txtype.transaction_type is not null or tx.transaction_type_group = 0 or (@vIncludeMiscCash = 1 and tx.client_id is null))
	ORDER BY 
	row_num  

set @vgsStepEndTime=GETDATE()
if @debug_me='Y' Print 'STEP ' +  convert(varchar(20), @vStep)  + ' complete: '+ltrim(rtrim(str(DATEDIFF(ms,@vgsStepStartTime,@vgsStepEndTime))))+ ' ms'
if @debug_me='Y' Print 'Successful execution of stored procedure ' + Object_name(@@ProcID) + convert(varchar(26),getdate(),109);

END TRY 

BEGIN CATCH 
	if @status_code = 0 Set @Status_Code = 1 else set @status_code = 2  --- convert 3 to 2
	if @status_code = 1
	BEGIN
		select @Status_Text = Rtrim(Left('Stored Procedure Failed with error Code : ' +   Cast(@@error as Varchar(10)) +  ' Line Number : ' +  Cast(ERROR_LINE() as Varchar(5)) + ' ' +  ERROR_MESSAGE(),3000))

		if @debug_me='Y' Print 'Stored procedure failure in step:'+ convert(varchar(3),@vstep) + '	' + convert(varchar(26),getdate())
		if @debug_me='Y' Print 'Error code: '+convert(varchar(3),@vStep) + '; Error description:	' + @Status_Text
	END 

If @vReportFormat = 'csv'
	Select 
		  NULL as fac_id
		, NULL as client_id	
		, NULL as last_name
		, NULL as first_name
		, NULL as client_id_number
		, NULL as payer_id
		, NULL as payer
		, NULL as billing_date
		, NULL as posting_date
		, NULL as effective_date
		, NULL as effective_from_date
		, NULL as effective_thru_date
		, NULL as charge_code
		, NULL as revenue_code
		, NULL as hcpcs_code
		, NULL as mppr_flag
		, NULL as tx_description
		, NULL as mark_as_billed_details
		, NULL as mark_as_billed_comment
		, NULL as care_level
		, NULL as benefit_days
		, NULL as transaction_type
		, NULL as unit_amount
		, NULL as units	
		, NULL as amount
		, NULL as gl_account
		, NULL as days_account
		, NULL as billed
		, NULL as comment
		, NULL as cheque_number
		, NULL as batch_number
		, NULL as entry_number
		, NULL as distribution_tx_id
		, NULL as transaction_type_group
		, NULL as ancillary_flag	
		, NULL as row_num	
		, @status_code as status_code
		, @status_text as status_text
else
	Select 
		  NULL as fac_id
		, NULL as client_id	
		, NULL as client_name
		, NULL as payer_id
		, NULL as payer
		, NULL as billing_date
		, NULL as posting_date
		, NULL as effective_date
		, NULL as effective_from_date
		, NULL as effective_thru_date
		, NULL as charge_code
		, NULL as revenue_code
		, NULL as hcpcs_code
		, NULL as mppr_flag
		, NULL as tx_description
		, NULL as mark_as_billed_details
		, NULL as mark_as_billed_comment
		, NULL as care_level
		, NULL as benefit_days
		, NULL as transaction_type
		, NULL as unit_amount
		, NULL as units	
		, NULL as amount
		, NULL as gl_account
		, NULL as days_account
		, NULL as billed
		, NULL as comment
		, NULL as cheque_number
		, NULL as distribution_tx_id
		, NULL as transaction_type_group
		, NULL as ancillary_flag		
		, NULL as row_num	
		, @status_code as status_code
		, @status_text as status_text
		
END CATCH 

RETURN 

END
GO
GRANT EXECUTE ON  dbo.sproc_prp_rl_transaction_report to PUBLIC
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_prp_rl_transaction_report.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_prp_rl_transaction_report.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_set_cash_application_transition_date.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- ===========================================================================================
-- Jira #:              CORE-68520 - Cash Application: Set Cash Application Transition Date
--
-- Written By:         Jorge Santos
-- Reviewed By:
-- Script Type:         DML
-- Target DB Type:      Client
-- Target ENVIRONMENT:  BOTH (US/CA)
-- Re-Runnable:         YES
--
-- Description of Script Function: Set Cash Application Transition Date and cash_application_version
--
-- ============================================================================================
-- Sample execution:
-- DECLARE @debug char(1), @status_code int, @status_text varchar(3000)
-- EXEC sproc_set_cash_application_transition_date 3.1,'2020-05-15', @debug, @status_code, @status_text
--
--
-- Params:
--              @cashApplicationVersionNumber decimal (3,1) - the cash application version number (format is major.minor  ie. 3.1)
--				@cashApplicationTransitionDate DATE - Cash application transition date
--
-- =============================================================================================

SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO

IF EXISTS (
    SELECT 1
    FROM dbo.sysobjects
    WHERE id = object_id(N'dbo.sproc_set_cash_application_transition_date')
        AND objectproperty(id, N'IsProcedure') = 1
    )
BEGIN
    DROP PROCEDURE dbo.sproc_set_cash_application_transition_date
END
GO

CREATE PROCEDURE sproc_set_cash_application_transition_date
(
  @cashApplicationVersionNumber decimal(3,1) = null,
  @cashApplicationTransitionDate DATE = '1900-01-01',
  @debug char(1) = 'N',
  @status_code int out,
  @status_text varchar(3000) out
)
AS

SET NOCOUNT ON

DECLARE @error_msg varchar(255)
       ,@error_code int
       ,@step int

BEGIN TRY

	SET @status_code = 0;
	
	IF isnull(@cashApplicationVersionNumber,0) < 3.1
	THROW 51000, 'Invalid cash application version number', 1;
	
	IF @cashApplicationTransitionDate <= '1900-01-01'
	THROW 51000, 'Invalid cash transition date', 1;
	
	BEGIN TRAN
		select @step = 1
		if @debug='Y'
		BEGIN
			select @cashApplicationTransitionDate as 'cash_transition_date'
			Print 'STEP ' +  convert(varchar(3), @step) + ': Set previous date.';
		END

		DECLARE @currentCashApplicationTransitionDate DATE =
			(SELECT CONVERT(DATE, value, 23)
				FROM configuration_parameter
				WHERE fac_id = -1 AND name = 'cash_application_transition_date')

		IF (@currentCashApplicationTransitionDate <> @cashApplicationTransitionDate
			or (@currentCashApplicationTransitionDate is not null and @cashApplicationTransitionDate is null)

			/*
				Need to differentiate between the configuration_parameter existing with a value of NULL
				and the configuration_parameter not existing at all. 
				Don't want to show the warning message if we are inserting the transition date for the first time
			*/
			or (EXISTS (select 1 from configuration_parameter  WHERE fac_id = -1 AND name = 'cash_application_transition_date') 
				and @currentCashApplicationTransitionDate is null 
				and @cashApplicationTransitionDate is not null)
		)
		BEGIN
			PRINT 'WARNING: cash_application_transition_date already exists with a value of '
				+ isnull(convert(varchar(30), @currentCashApplicationTransitionDate, 23), 'null')
				+ '. The new value will be '
				+ isnull(convert(varchar(30), @cashApplicationTransitionDate, 23), 'null')
				+ '.';
		END

		select @step = 2
		DECLARE @cashApplicationTransitionDateText VARCHAR(30) = CONVERT(VARCHAR(30), @cashApplicationTransitionDate, 23)

		if @debug='Y' Print 'STEP ' +  convert(varchar(3), @step) + ': Set cash_application_transition_date configuration parameter. With @cashApplicationTransitionDate: '
			+  isnull(@cashApplicationTransitionDateText,'NULL') + '.';

		IF NOT EXISTS (SELECT 1
						FROM configuration_parameter
						WHERE fac_id = -1 and name = 'cash_application_transition_date')
		BEGIN
			INSERT INTO configuration_parameter (fac_id, name, value)
			VALUES (-1, 'cash_application_transition_date', @cashApplicationTransitionDateText)
		END
		ELSE
		BEGIN
			UPDATE configuration_parameter
			SET value = @cashApplicationTransitionDateText
			WHERE fac_id = -1 AND name = 'cash_application_transition_date'
		END
		
		select @step = 3
		if @debug='Y'
		BEGIN
			Print 'STEP ' +  convert(varchar(3), @step) + ': Get current cash_application_version';
		END

		DECLARE @currentCashApplicationVersionNumber decimal(3,1) =
			(SELECT CONVERT(decimal(3,1), value)
				FROM configuration_parameter
				WHERE fac_id = -1 AND name = 'cash_application_version')

		IF (@currentCashApplicationVersionNumber > @cashApplicationVersionNumber)
		BEGIN
			PRINT 'WARNING: cash_application_version already exists with a value of '
				+ convert(varchar(10), @currentCashApplicationVersionNumber)
				+ '. This is greater than the new value of '
				+ convert(varchar(10), @cashApplicationVersionNumber)
				+ '.';
		END

		select @step = 4
		if @debug='Y'
		BEGIN
			select @cashApplicationVersionNumber as 'cash_application_version_number'
			Print 'STEP ' +  convert(varchar(3), @step) + ': Set cash_application_version configuration parameter with a value of ' + convert(varchar(10),@cashApplicationVersionNumber);
		END

		
		IF NOT EXISTS (SELECT 1
						FROM configuration_parameter
						WHERE fac_id = -1 and name = 'cash_application_version')
		BEGIN
			INSERT INTO configuration_parameter (fac_id, name, value)
			VALUES (-1, 'cash_application_version', @cashApplicationVersionNumber)
		END
		ELSE
		BEGIN
			UPDATE configuration_parameter
			SET value = @cashApplicationVersionNumber
			WHERE fac_id = -1 AND name = 'cash_application_version'
		END
		
	COMMIT TRAN
	
	IF @debug='Y'
		PRINT 'Successful execution of stored procedure'
END TRY
BEGIN CATCH
	
	IF @@trancount > 0
	BEGIN
		ROLLBACK TRAN
	End
	
	SET @status_text = ERROR_MESSAGE();
	SET @status_code = ERROR_NUMBER();
	SET @error_code = @@error;
	
	IF @debug='Y'
	BEGIN
		PRINT 'Stored procedure failure in step: '+ convert(varchar(3),@step) + '. With transition date: ' + convert(varchar(30), getdate(), 23);
		PRINT 'Error code: ' + convert(varchar(3),@step) + '; Error description: ' + @status_text;
	END;

	THROW;
END CATCH

GO

GRANT EXECUTE ON dbo.sproc_set_cash_application_transition_date TO PUBLIC
GO

SET ANSI_NULLS OFF
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_set_cash_application_transition_date.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_set_cash_application_transition_date.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_sprt_order_list.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- =========================================================================================================================
--
--  Script Type: user defined store procedure
--  Target DB Type:  Client
--  Target Database:  Both
--
--  Re-Runable:  Yes
--
--  Description :  Return a list of Physician Orders and other dependent data such as schedules.
--
--	Params:			
--			@facUUIdCSV
--			@clientId
--			@facilityDateTime
--			@orderCategoryIdsCSV
--			@orderStatusCSV
--			@clientStatus
--			@changesetTypesCSV
--			@changesetStatusesCSV
--			@changesetSourceId
--			@physOrderId
--			@pageSize
--			@pageNumber
--			@sortByColumn
--			@sortByOrder
--			@includeOrders
--			@includeSchedules
--			@includeChangesets
--			@debug          - Debug param, 'Y' or 'N'
--			@status_code    - SP execution flag, 0 for success.
--			@status_text    - SP error text if error occurs.
--
-- Change History:
--   Date			Jira				Team		Author				Comment
-- -----------------------------------------------------------------------------------------------------------------------------------
--   09/28/2021     SPRT-740			Coda	    Elias Ghanem  		Created.
-- =========================================================================================================================

IF EXISTS (SELECT *
               FROM
                   dbo.sysobjects
               WHERE
                   id = object_id(N'[dbo].[sproc_sprt_order_list]')
                   AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
    DROP PROCEDURE [dbo].[sproc_sprt_order_list]

SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[sproc_sprt_order_list]			@facUUIdCSV               varchar(MAX),-- Required: CSV list of fac uuids to filter on
														@clientId				INT,-- Optional: client Id to filter on
                                                        @facilityDateTime       DATETIME,-- Required: facility date time
                                                        @orderCategoryIdsCSV	VARCHAR(100),-- Required CSV list of categegory ids to filter n
                                                        @orderStatusCSV         VARCHAR(100),-- Required: CSV list of order status ids to filter on
                                                        @clientStatus 			INT,-- Required: flag to filter on client status: -1: ALL, 0: Discharged, 1:Current(not discharged)
														@changesetTypesCSV		VARCHAR(100),-- Optional: changeset types to filter on and return
														@changesetStatusesCSV	VARCHAR(100),-- Optional: changeset statuses to filter on and return
														@changesetSourceId		INT,-- Optional: changeset sourece to filter on
                                                        @physOrderId 			INT,-- Optional: physOrderId to filter on
                                                        @pageSize 				INT,-- Required: number of phys orders per page
                                                        @pageNumber 			INT,-- Required: page number	
                                                        @sortByColumn 			VARCHAR(100),-- Required: column to sort on.
                                                        @sortByOrder  			VARCHAR(10),-- Required sort order
														@includeOrders 			INT,-- Required: flag to indicate whether orders data is returned or not: 1: orders summary, 2:orders details, 0:orders data not to be returned
														@includeSchedules 		INT,-- Required: flag to indicate whether schedules data is returned or not: 1: schedules summary, 2:schedules details, 0:schedules data not to be returned
														@includeChangesets 		INT,-- Required: flag to indicate whether changeset data is returned or not: 1: changeset summary, 2:changeset details, 0:changeset data not to be returned
														@debug              	CHAR(1)  = 'N',-- Required: flag to indicate whether to print debug data or not
														@status_code        	INT  = 0 OUT,
                                                        @status_text        	VARCHAR(3000) OUT



/***********************************************************************************************

Purpose:
This procedure provides data shown on Resident' Order Chart
This procedure does not use VIEW_PHO_PHYS_ORDER

*************************************************************************************************/

AS
BEGIN TRY
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

DECLARE @step                       			int,
		@step_label								varchar(100),
        @error_code                 			int

SET @step = 0
SET @step_label = 'Starting...'
SET @error_code = 0

/*
DECLARE @facIds TABLE
(
	fac_id int  not null
)
*/

DECLARE @orderCategoryIds TABLE
(
	order_category_id INT  NOT NULL
)

DECLARE @orderStatus TABLE
(
	status INT NOT NULL
)

DECLARE @changesetTypes TABLE
(
	changeset_type_id INT NOT NULL
)

DECLARE @changesetStatuses TABLE
(
	status_id INT NOT NULL
)

DECLARE @facInfo TABLE
(
	fac_id INT,
	fac_uuid UNIQUEIDENTIFIER,
	facility_time datetime,
	IsDischargeEnabled  BIT
)

CREATE TABLE #orders_data
  ( 
	phys_order_id             	INT, 
	fac_id                    	INT, 
	client_id                 	INT, 
	order_verified            	VARCHAR(1),
	order_status				INT,
	active_flag               	CHAR(1), 
	draft                     	BIT, 
	hold_date                 	DATETIME, 
	hold_date_end             	DATETIME, 
	end_date                  	DATETIME, 
	discontinued_date         	DATETIME, 
	order_category_id         	INT, 
	controlled_substance_code 	INT,
	
	physician_id INT,
	pharmacy_id INT,
	route_of_admin INT,
	created_by VARCHAR(60),
	created_date DATETIME,
	revision_by VARCHAR(60),
	revision_date DATETIME,
	start_date DATETIME,
	strength VARCHAR(30),
	form VARCHAR(50),
	description VARCHAR(500),
	directions VARCHAR(1000),
	related_generic VARCHAR(250),
	communication_method INT,
	prescription VARCHAR(50),
	order_date DATETIME,
	completed_date DATETIME,
	origin_id INT,
	drug_strength VARCHAR(100),
	drug_strength_uom VARCHAR(10),
	drug_name VARCHAR(500),
	order_class_id INT,
	resident_last_name varchar(50),
	resident_first_name varchar(50)	 
  ) ;

CREATE TABLE #tempresult 
  ( 
	phys_order_id             INT, 
	fac_id                    INT, 
	client_id                 INT, 
	order_verified            VARCHAR(1), 
	active_flag               CHAR(1), 
	draft                     BIT, 
	hold_date                 DATETIME, 
	hold_date_end             DATETIME, 
	end_date                  DATETIME, 
	discontinued_date         DATETIME, 
	order_category_id         INT, 
	controlled_substance_code INT,
	facility_time datetime,
	IsDischargeEnabled  BIT,
	
	physician_id INT,
	pharmacy_id INT,
	route_of_admin INT,
	created_by VARCHAR(60),
	created_date DATETIME,
	revision_by VARCHAR(60),
	revision_date DATETIME,
	start_date DATETIME,
	strength VARCHAR(30),
	form VARCHAR(50),
	description VARCHAR(500),
	directions VARCHAR(1000),
	related_generic VARCHAR(250),
	communication_method INT,
	prescription VARCHAR(50),
	order_date DATETIME,
	completed_date DATETIME,
	origin_id INT,
	drug_strength VARCHAR(100),
	drug_strength_uom VARCHAR(10),
	drug_name VARCHAR(500),
	order_class_id INT,
	resident_last_name varchar(50),
	resident_first_name varchar(50)
  ) ;
CREATE CLUSTERED INDEX _tempresult_order_id ON #tempresult( phys_order_id );  

CREATE TABLE #vpos
	(
	phys_order_id int NOT NULL,
	fac_id int NOT NULL,
	order_status int NOT NULL,
	order_relationship int NULL,
	status_reason int NULL
	)

SET @step = @step + 1	
SET @step_label = 'Parse CSV parameters into table vairables'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
	
--INSERT INTO @facIds (fac_id)
--SELECT f.fac_id FROM facility f INNER JOIN dbo.Split(@facUUIdCSV, ',') uuids ON uuids.items = f.fac_uuid
INSERT INTO @facInfo
	(fac_id,
	fac_uuid,
	facility_time,
	IsDischargeEnabled
	)
	SELECT f.fac_id,
	f.fac_uuid,
	dbo.fn_facility_getCurrentTime(f.fac_id),
	CASE WHEN cp.value = 'Y' THEN 1 ELSE 0 END
	FROM facility f
	INNER JOIN dbo.Split(@facUUIdCSV, ',') uuids ON uuids.items = f.fac_uuid
	LEFT JOIN configuration_parameter cp ON cp.fac_id = f.fac_id AND cp.name='discharge_order_enable'


INSERT INTO @orderCategoryIds (order_category_id)
SELECT * FROM dbo.Split(@orderCategoryIdsCSV, ',')	
DELETE FROM @orderCategoryIds where order_category_id=1 or order_category_id=3030

INSERT INTO @orderStatus (status)
SELECT * FROM dbo.Split(@orderStatusCSV, ',');

INSERT INTO @changesetTypes (changeset_type_id)
SELECT * FROM dbo.Split(@changesetTypesCSV, ',');

INSERT INTO @changesetStatuses (status_id)
SELECT * FROM dbo.Split(@changesetStatusesCSV, ',');

	
SET @step = @step + 1	
SET @step_label = 'Check for required parameters...'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
IF NOT EXISTS(SELECT 1 FROM @facInfo)
BEGIN
	raiserror ('facUUIdCSV is required. At least one facUUId must be provided.', 16, 1)
END
IF NOT EXISTS(SELECT 1 FROM @orderCategoryIds)
BEGIN
	raiserror ('orderCategoryIdsCSV is required. At least one orderCategoryId must be provided.', 16, 1)
END
IF NOT EXISTS(SELECT 1 FROM @orderStatus)
BEGIN
	raiserror ('orderStatusCSV is required. At least one orderStatus must be provided.', 16, 1)
END	
IF @facilityDateTime IS NULL
BEGIN
	raiserror ('facilityDateTime is required.', 16, 1)
END
IF @clientStatus IS NULL OR @clientStatus NOT IN (-1, 0, 1)
BEGIN
	raiserror ('clientStatus is required. Allowed values are: -1, 0, 1.', 16, 1)
END	
IF @pageSize IS NULL OR @pageSize <= 0
BEGIN
	raiserror ('pageSize is required and should be a positive number.', 16, 1)
END	
IF @pageNumber IS NULL or @pageNumber <= 0
BEGIN
	raiserror ('pageNumber is required and should be a positive number.', 16, 1)
END	
IF @sortByColumn IS NULL
BEGIN
	raiserror ('sortByColumn is required.', 16, 1)
END	
IF @sortByOrder IS NULL
BEGIN
	raiserror ('sortByOrder is required.', 16, 1)
END
IF (( EXISTS(SELECT 1 FROM @changesetTypes) OR EXISTS(SELECT 1 FROM @changesetStatuses)) AND
	(NOT EXISTS(SELECT 1 FROM @changesetTypes) OR NOT EXISTS(SELECT 1 FROM @changesetStatuses)))
BEGIN
	raiserror ('changesetTypesCSV and changesetStatusesCSV should be both set or both empty', 16, 1)
END
IF @changesetSourceId IS NOT NULL AND (NOT EXISTS(SELECT 1 FROM @changesetTypes) OR NOT EXISTS(SELECT 1 FROM @changesetStatuses))
BEGIN
	raiserror ('If changesetSourceId is set, both changesetTypesCSV and changesetStatusesCSV should be set', 16, 1)
END
IF @includeOrders IS NULL OR @includeOrders NOT IN (0, 1, 2)
BEGIN
	raiserror ('includeOrders is required. Allowed values are: 0, 1, 2', 16, 1)
END	
IF @includeSchedules IS NULL OR @includeSchedules NOT IN (0, 1, 2)
BEGIN
	raiserror ('includeSchedules is required. Allowed values are: 0, 1, 2', 16, 1)
END
IF @includeChangesets IS NULL OR @includeSchedules NOT IN (0, 1, 2)
BEGIN
	raiserror ('includeChangesets is required. Allowed values are: 0, 1, 2', 16, 1)
END
IF @includeChangesets IN (1, 2) AND (NOT EXISTS(SELECT 1 FROM @changesetTypes) OR NOT EXISTS(SELECT 1 FROM @changesetStatuses))
BEGIN
	raiserror ('If includeChangesets value is 1 or 2, both changesetTypesCSV and changesetStatusesCSV should be set', 16, 1)
END
		
/*
SET @step = @step + 1
SET @step_label = 'Prepare facility info'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
INSERT INTO @facInfo	
	(fac_id,
	facility_time,
	IsDischargeEnabled
	)
	SELECT f.fac_id, 
	dbo.fn_facility_getCurrentTime(f.fac_id),
	CASE WHEN cp.value = 'Y' THEN 1 ELSE 0 END
	FROM @facIds f	
	LEFT JOIN configuration_parameter cp ON cp.fac_id = f.fac_id AND cp.name='discharge_order_enable'
*/	
	
SET @step = @step + 1
SET @step_label = 'Insert into #tempresult'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text

INSERT INTO #tempresult
	( 
	phys_order_id, 
	fac_id, 
	client_id, 
	order_verified, 
	active_flag, 
	draft, 
	hold_date, 
	hold_date_end, 
	end_date, 
	discontinued_date, 
	order_category_id, 
	controlled_substance_code,
	facility_time,
	IsDischargeEnabled,
	
	physician_id,
	pharmacy_id,
	route_of_admin,
	created_by,
	created_date,
	revision_by,
	revision_date,
	start_date,
	strength,
	form,
	description,
	directions,
	related_generic,
	communication_method,
	prescription,
	order_date,
	completed_date,
	origin_id,
	drug_strength,
	drug_strength_uom,
	drug_name,
	order_class_id,
	resident_last_name,
	resident_first_name
	)
	SELECT
		o.phys_order_id, 
		o.fac_id, 
		o.client_id, 
		o.order_verified, 
		o.active_flag, 
		o.draft, 
		o.hold_date, 
		o.hold_date_end, 
		o.end_date, 
		o.discontinued_date, 
		o.order_category_id, 
		o.controlled_substance_code,
		fi.facility_time,
		fi.IsDischargeEnabled,
		o.physician_id,
		o.pharmacy_id,
		o.route_of_admin,
		o.created_by,
		o.created_date,
		o.revision_by,
		o.revision_date,
		o.start_date,
		o.strength,
		o.form,
		o.description,
		o.directions,
		o.related_generic,
		o.communication_method,
		o.prescription,
		o.order_date,
		o.completed_date,
		o.origin_id,
		o.drug_strength,
		o.drug_strength_uom,
		o.drug_name,
		o.order_class_id,
		m.last_name,
		m.first_name
	FROM pho_phys_order o
	--INNER JOIN @facIds f ON f.fac_id = o.fac_id
	INNER JOIN @facInfo fi ON fi.fac_id = o.fac_id
	INNER JOIN @orderCategoryIds cat ON cat.order_category_id = o.order_category_id
	INNER JOIN clients c ON c.client_id = o.client_id
	INNER JOIN mpi m ON m.mpi_id = c.mpi_id
	WHERE (@physOrderId IS NULL OR o.phys_order_id = @physOrderId) AND ISNULL(o.active_flag, 'Y') = 'Y'
	AND (@clientId IS NULL OR o.client_id = @clientId)
	AND (@clientStatus = -1 OR (@clientStatus = 1 AND (c.discharge_date IS NULL OR c.discharge_date > @facilityDateTime)) OR (@clientStatus = 0 AND c.discharge_date <= @facilityDateTime))

SET @step = @step + 1	
SET @step_label = 'Applying changeset filtering if needed'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text

IF EXISTS(SELECT 1 FROM @changesetTypes) OR EXISTS (SELECT 1 FROM @changesetStatuses) OR @changesetSourceId IS NOT NULL
	BEGIN
	MERGE #tempresult AS TARGET
	USING (select o.phys_order_id
	FROM #tempresult o	
	INNER JOIN pho_phys_order_changeset cs ON cs.phys_order_id = o.phys_order_id
	INNER JOIN @changesetTypes cst ON cst.changeset_type_id = cs.changeset_type_id
	INNER JOIN changeset_status csstat ON csstat.changeset_status_id = cs.current_status_id
	INNER JOIN @changesetStatuses csstats ON csstats.status_id = csstat.status_id
	WHERE @changesetSourceId IS NULL OR cs.changeset_source_id = @changesetSourceId
	) AS SOURCE
	ON (TARGET.phys_order_id = SOURCE.phys_order_id) 
	WHEN NOT MATCHED BY SOURCE 
	THEN DELETE; 
END

SET @step = @step + 1	
SET @step_label = 'Calculating orders statuses'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
insert into #vpos
exec sproc_sprt_pho_getOrderStatus  @debug,@status_code out,@status_text out


SET @step = @step + 1	
SET @step_label = 'Insert into #orders_data'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
INSERT INTO #orders_data
	( 
	phys_order_id, 
	fac_id, 
	client_id, 
	order_verified,
	order_status,
	active_flag, 
	draft, 
	hold_date, 
	hold_date_end, 
	end_date, 
	discontinued_date, 
	order_category_id, 
	controlled_substance_code,
	physician_id,
	pharmacy_id,
	route_of_admin,
	created_by,
	created_date,
	revision_by,
	revision_date,
	start_date,
	strength,
	form,
	description,
	directions,
	related_generic,
	communication_method,
	prescription,
	order_date,
	completed_date,
	origin_id,
	drug_strength,
	drug_strength_uom,
	drug_name,
	order_class_id,
	resident_last_name,
	resident_first_name
	)
	SELECT
		temp.phys_order_id, 
		temp.fac_id, 
		temp.client_id, 
		temp.order_verified,
		vpos.order_status,
		temp.active_flag, 
		temp.draft, 
		temp.hold_date, 
		temp.hold_date_end, 
		temp.end_date, 
		temp.discontinued_date, 
		temp.order_category_id, 
		temp.controlled_substance_code,
		temp.physician_id,
		temp.pharmacy_id,
		temp.route_of_admin,
		temp.created_by,
		temp.created_date,
		temp.revision_by,
		temp.revision_date,
		temp.start_date,
		temp.strength,
		temp.form,
		temp.description,
		temp.directions,
		temp.related_generic,
		temp.communication_method,
		temp.prescription,
		temp.order_date,
		temp.completed_date,
		temp.origin_id,
		temp.drug_strength,
		temp.drug_strength_uom,
		temp.drug_name,
		temp.order_class_id,
		temp.resident_last_name,
		temp.resident_first_name
	FROM @orderStatus stat
	INNER JOIN #vpos vpos ON vpos.order_status = stat.status
	INNER JOIN #tempresult temp ON temp.phys_order_id = vpos.phys_order_id	


SET @step = @step + 1
SET @step_label = 'Apply pagination'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
IF @sortByOrder='desc'
BEGIN
	;WITH TMP AS
	(
		SELECT ROW_NUMBER() OVER(ORDER BY
									 CASE
										WHEN @sortByColumn = 'fac_id' THEN CONVERT(VARCHAR(50), o.fac_id)
										WHEN @sortByColumn = 'description' THEN o.description
										WHEN @sortByColumn = 'client_id' THEN CONVERT(VARCHAR(50), o.resident_first_name)
										ELSE CONVERT(VARCHAR(50), o.phys_order_id)
									END
									DESC,
									CASE
										WHEN @sortByColumn = 'client_id' THEN CONVERT(VARCHAR(50), o.resident_last_name)
										ELSE CONVERT(VARCHAR(50), o.phys_order_id)
									END
									DESC,
									o.phys_order_id DESC) AS rn FROM #orders_data o
	)
	DELETE FROM TMP WHERE @pageSize > 0 AND (rn <= (@pageSize * (@pageNumber-1)) OR rn > (@pageSize * @pageNumber))
END
ELSE
BEGIN
	;WITH TMP AS
	(
		SELECT ROW_NUMBER() OVER(ORDER BY
										CASE
										WHEN @sortByColumn = 'fac_id' THEN CONVERT(varchar(50), o.fac_id)
										WHEN @sortByColumn = 'description' THEN o.description										
										WHEN @sortByColumn = 'client_id' THEN CONVERT(VARCHAR(50), o.resident_first_name)
										ELSE CONVERT(VARCHAR(50), o.phys_order_id)
									END
									ASC,
									CASE
										WHEN @sortByColumn = 'client_id' THEN CONVERT(VARCHAR(50), o.resident_last_name)
										ELSE CONVERT(VARCHAR(50), o.phys_order_id)
									END
									ASC,
									o.phys_order_id DESC) AS rn FROM #orders_data o
	)
	DELETE FROM TMP WHERE @pageSize > 0 AND (rn <= (@pageSize * (@pageNumber-1)) OR rn > (@pageSize * @pageNumber))

END


    /****************************************
    return final result
    ****************************************/
SET @step = @step + 1	
SET @step_label = 'Return final results...'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text

SET @step = @step + 1	
SET @step_label = 'Return orders'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
IF @includeOrders = 1
BEGIN
	SELECT
	o.phys_order_id,
	o.fac_id,
	f.fac_uuid,
	o.client_id,
	o.order_status,
	o.description,
	lib.pho_ext_lib_id,
	lib.pho_ext_lib_med_id,
	lib.pho_ext_lib_med_ddid,
	o.resident_first_name,
	o.resident_last_name	
	FROM #orders_data o
	INNER JOIN @facInfo f ON f.fac_id = o.fac_id
	LEFT JOIN pho_order_ext_lib_med_ref lib ON lib.phys_order_id = o.phys_order_id
	ORDER BY o.fac_id, o.phys_order_id ASC
END
ELSE
BEGIN
	IF @includeOrders = 2
	BEGIN
		SELECT
		o.phys_order_id,
		o.fac_id,
		f.fac_uuid,
		o.client_id,
		o.physician_id,
		c.first_name AS physician_first_name,
		c.last_name AS physician_last_name,
		c.title AS physician_title,
		o.order_category_id,
		o.communication_method,
		o.route_of_admin,
		roa.pcc_route_of_admin AS route_of_admin_desc,
		o.order_status,
		o.description,
		lib.pho_ext_lib_id,
		lib.pho_ext_lib_med_id,
		lib.pho_ext_lib_med_ddid,
		lib.pho_ext_lib_generic_id,
		lib.pho_ext_lib_generic_desc,
		lib.ext_lib_rxnorm_id,
		o.resident_first_name,
		o.resident_last_name,
		o.created_by,
		o.created_date,
		o.revision_by,
		o.revision_date
		FROM #orders_data o
		INNER JOIN @facInfo f ON f.fac_id = o.fac_id
		INNER JOIN wesreference.dbo.pho_std_route_of_admin roa ON roa.route_of_admin_id = o.route_of_admin
		LEFT JOIN contact c ON c.contact_id = o.physician_id		
		LEFT JOIN pho_order_ext_lib_med_ref lib ON lib.phys_order_id = o.phys_order_id
		ORDER BY o.fac_id, o.phys_order_id ASC
	END
	ELSE
		SELECT 'ORDER DATA NOT REQUESTED'
END

SET @step = @step + 1	
SET @step_label = 'Return schedules'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
IF @includeSchedules = 1
BEGIN
	SELECT
	o.phys_order_id,
	s.order_schedule_id,
	s.schedule_directions
	FROM #orders_data o
	INNER JOIN PHO_ORDER_SCHEDULE s ON s.phys_order_id = o.phys_order_id
	WHERE s.deleted = 'N'
	ORDER BY o.fac_id, o.phys_order_id, s.order_schedule_id
END
ELSE
BEGIN
	IF @includeSchedules = 2	
	BEGIN	
		SELECT
		os.phys_order_id,
		os.order_schedule_id,
		os.schedule_template,
		os.dose_value,
		os.dose_uom_id,
		os.alternate_dose_value,
		os.dose_low,
		os.quantity_per_dose,
		os.quantity_uom_id,
		os.need_location_of_admin,
		os.sliding_scale_id,
		os.apply_to,
		os.apply_remove_flag,
		os.std_freq_id,
		os.schedule_type,
		sched_type.description AS schedule_type_desc,
		os.repeat_week,
		os.mon,
		os.tues,
		os.wed,
		os.thurs,
		os.fri,
		os.sat,
		os.sun,
		os.xxdays,
		os.xxmonths,
		os.xxhours,
		os.date_of_month,
		os.date_start,
		os.date_stop,
		os.days_on,
		os.days_off,
		os.pho_std_time_id,
		os.related_diagnosis,
		os.indications_for_use,
		os.additional_directions,
		os.administered_by_id,
		admined_by.description AS administered_by_desc,
		os.schedule_start_date,
		os.schedule_end_date,
		os.schedule_end_date_type_id,
		sched_end_date_type.name AS schedule_end_date_type_name,
		os.schedule_duration,
		os.schedule_duration_type_id,
		sched_duration_type.name AS schedule_duration_type_name,
		os.schedule_dose_duration,
		os.prn_admin,
		os.prn_admin_value,
		os.prn_admin_units,
		os.schedule_directions,
		os.created_by,
		os.created_date,
		os.revision_by,
		os.revision_date,		
		--os.std_freq_time_label,
		--os.until_finished,
		--os.order_type_id,
		--os.extended_end_date,
		--os.extended_count,
		--os.prescriber_schedule_start_date,		
		ps.order_schedule_id,
		ps.schedule_id,
		ps.start_time,
		ps.end_time,
		ps.std_shift_id,
		ps.remove_time,
		ps.remove_duration,
		ps.nurse_action_notes
		FROM #orders_data o
		INNER JOIN PHO_ORDER_SCHEDULE os ON os.phys_order_id = o.phys_order_id
		INNER JOIN PHO_SCHEDULE ps ON ps.order_schedule_id = os.order_schedule_id
		INNER JOIN pho_schedule_type sched_type ON sched_type.schedule_type_id = os.schedule_type
		INNER JOIN pho_std_administered_by admined_by ON admined_by.administered_by_id = os.administered_by_id
		INNER JOIN pho_schedule_end_date_type sched_end_date_type ON sched_end_date_type.schedule_end_date_type_id = os.schedule_end_date_type_id
		LEFT JOIN pho_schedule_duration_type sched_duration_type ON sched_duration_type.schedule_duration_type_id = os.schedule_duration_type_id
		WHERE os.deleted = 'N' and ps.deleted = 'N'
		ORDER BY o.fac_id, o.phys_order_id, os.order_schedule_id		
	END
	ELSE
		SELECT 'SCHEDULES DATA NOT REQUESTED'
END

SET @step = @step + 1	
SET @step_label = 'Return changeset'
SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' ' + @step_label
IF @debug='Y' PRINT @status_text
IF @includeChangesets = 1
BEGIN
	SELECT
	o.phys_order_id,
	cs.changeset_id,
	cs.changeset_type_id,
	cs.current_status_id,
	cs.changeset_source_id
	FROM #orders_data o
	INNER JOIN pho_phys_order_changeset cs ON cs.phys_order_id = o.phys_order_id
	INNER JOIN @changesetTypes cst ON cst.changeset_type_id = cs.changeset_type_id
	INNER JOIN changeset_status csstat ON csstat.changeset_status_id = cs.current_status_id
	INNER JOIN @changesetStatuses csstats ON csstats.status_id = csstat.status_id
	WHERE @changesetSourceId IS NULL OR cs.changeset_source_id = @changesetSourceId	
END
ELSE
BEGIN
	IF @includeChangesets = 2
	BEGIN
		SELECT
		o.phys_order_id,
		cs.changeset_id,
		cs.changeset_type_id,
		cs.current_status_id,
		cs.changeset_source_id,
		cs.changeset_data,
		cs.resulting_phys_order_id,
		cs.aggregate_changeset_id,
		csstat.status_source,
		csstat.status_by,
		csstat.status_date
		FROM #orders_data o
		INNER JOIN pho_phys_order_changeset cs ON cs.phys_order_id = o.phys_order_id
		INNER JOIN @changesetTypes cst ON cst.changeset_type_id = cs.changeset_type_id
		INNER JOIN changeset_status csstat ON csstat.changeset_status_id = cs.current_status_id
		INNER JOIN @changesetStatuses csstats ON csstats.status_id = csstat.status_id
		WHERE @changesetSourceId IS NULL OR cs.changeset_source_id = @changesetSourceId	
	END
	ELSE
		SELECT 'CHANGESET DATA NOT REQUESTED'
END

    SET @status_text = convert(VARCHAR(26), getdate(), 13) + ' Done'
    IF @debug='Y'
        PRINT @status_text
    SET @status_code = 0
    GOTO PgmSuccess
END TRY
--error trapping
BEGIN CATCH
    --SELECT @error_code = @@error, @status_text = 'Error at step:'+convert(varchar(3),@step)+', '+ERROR_MESSAGE()
	SELECT @error_code = @@error, @status_text = 'Error at step:' + convert(varchar(3),@step) + ' <' + @step_label + '>, '+ERROR_MESSAGE()

    SET @status_code = 1

    GOTO PgmAbend

END CATCH

--program success return
PgmSuccess:

IF @status_code = 0
BEGIN
    IF @debug='Y' PRINT 'Successfull execution of stored procedure'
    RETURN @status_code
END

--program failure return
PgmAbend:

--IF @debug='Y' PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + '   ' + convert(varchar(26),getdate())
IF @debug='Y' PRINT 'Stored procedure failure in step:'+ convert(varchar(3),@step) + ' <' + @step_label + '>   ' + convert(varchar(26),getdate())
    IF @debug='Y' PRINT 'Error code: '+convert(varchar(3),@error_code) + '; Error description:    ' +@status_text
    RETURN @status_code

GO
GRANT EXECUTE ON sproc_sprt_order_list TO public
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_sprt_order_list.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_sprt_order_list.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_synch_msc_controlledSubstanceCode.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


/*****************************************************************************************************
**  Created By: Patrick Campbell
**
**	Purpose:  To synchronize the controlled substance code in the client db with the last pho_controlled_substance_code_rescreening info
** 				- For order templates it updates the code to the latest value
**              - For Queued and Pending orders it updates the code to the latest value
**              - For existing orders it will populate the pho_phys_order_new_ctrlsubstancecode with the latest value
**
**	Params:
**
**	@debug       - Debug param, 'Y' or 'N'
**	@status_code - SP execution flag, 0 for success.
**	@status_text - SP error text if error occurs.
**
**  Return:
**  -- status code
*****************************************************************************************************/
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'[dbo].[sproc_synch_msc_controlledSubstanceCode]')
		AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
    DROP PROCEDURE [dbo].[sproc_synch_msc_controlledSubstanceCode]

GO
CREATE PROCEDURE [dbo].[sproc_synch_msc_controlledSubstanceCode]
	@debug char(1) = 'N',
	@status_code int = 0 out,
	@status_text varchar(3000) out
AS
BEGIN TRY
    SET NOCOUNT ON;

	DECLARE @runId int, @step int, @mmdbVersion varchar(10);

	SET @step = 0;
	SET @status_code = 0;

    SET @mmdbVersion = FORMAT (getdate(), 'yyyyMMdd')
BEGIN
CREATE TABLE #lastMedInfo (
    pnid int not null,
    ddid int not null,
    ctrlsubstancecode varchar(2) not null,
    primary key (pnid, ddid, ctrlsubstancecode)
);

DECLARE @orderCandidates table (
    phys_order_id int not null,
    new_ctrlsubstancecode varchar(2) not null,
    queued_order bit not null,
    verified bit not null,
    pendingClinicalOrderId int,
    pendingSignatureOrderId int,
    primary key (phys_order_id)
    );
BEGIN TRANSACTION synchMedInfo
    SET @step=1;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Inserting into #lastMedInfo table';
    IF (select count(*) from facility where fac_id < 9000) > 0
BEGIN
    insert into #lastMedInfo SELECT pnid, ddid, new_controlled_substance_code
    from pho_controlled_substance_code_rescreening
    where new_controlled_substance_code is not null
    and new_controlled_substance_code <> isnull(old_controlled_substance_code, -1);
END

    SET @step=2;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Update Order templates';
    -- Update the templates
    UPDATE so SET so.controlled_substance_code=ms.ctrlsubstancecode from
    #lastMedInfo ms INNER JOIN pho_std_order so on so.ext_lib_med_id = ms.pnid and isnull(so.ext_lib_med_ddid,-1) = ms.DDID
    and so.controlled_substance_code <> ms.ctrlsubstancecode;

    SET @step=3;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Find list of candidate orders';
    INSERT INTO @orderCandidates
    SELECT po.phys_order_id, ms.ctrlsubstancecode ,(case when qo.phys_order_id IS NOT NULL THEN 1 ELSE 0 END) queued, (case when po.order_verified='N' THEN 0 ELSE 1 END) verified,
           cr.phys_order_id, esig.phys_order_id
    from
        pho_phys_order po INNER JOIN pho_order_ext_lib_med_ref mr on mr.phys_order_id=po.phys_order_id and mr.deleted='N' and mr.pho_ext_lib_med_id is not null
                          inner join #lastMedInfo ms on mr.pho_ext_lib_med_id = ms.PNID and (case when isnull(mr.pho_ext_lib_med_ddid,-1) <=0 then -1 else mr.pho_ext_lib_med_ddid end)  = ms.DDID
                          left join pho_order_queue qo on po.phys_order_id=qo.phys_order_id and qo.deleted='N' and qo.promoted_date is null
                          left join pho_order_clinical_review cr on cr.phys_order_id = po.phys_order_id and cr.reviewed_date is NULL
                          left join pho_phys_order_esignature esig on esig.phys_order_id = po.phys_order_id and esig.sign_user_id IS NULL
    where (case when po.controlled_substance_code ='' then 0 else isnull(po.controlled_substance_code ,0) end) <> ms.ctrlsubstancecode;

    SET @step=4;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Update queued and pending orders substance code';
    -- For queued and pending orders directly update the code
    UPDATE po SET po.controlled_substance_code=cd.new_ctrlsubstancecode from @orderCandidates cd INNER JOIN pho_phys_order po on po.phys_order_id = cd.phys_order_id and (cd.queued_order =1 OR cd.verified=0 OR cd.pendingClinicalOrderId IS NOT NULL or cd.pendingSignatureOrderId IS NOT NULL);

    SET @step=5;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Clear and insert new order controlled substance codes';
    -- -1 is for orders with custom med
    DELETE FROM pho_phys_order_new_ctrlsubstancecode WHERE mmdb_synch_run_history_id <> -1;

    INSERT INTO pho_mmdb_synch_run_history(run_date, synched_mmdb_version) VALUES (getdate(), @mmdbVersion);

    SET @runId = @@identity;

    INSERT INTO pho_phys_order_new_ctrlsubstancecode(phys_order_id,new_controlled_substance_code,mmdb_synch_run_history_id)
    SELECT cd.phys_order_id, cd.new_ctrlsubstancecode, @runId from @orderCandidates cd WHERE cd.queued_order = 0 AND cd.verified = 1 AND cd.pendingClinicalOrderId IS NULL AND cd.pendingSignatureOrderId IS NULL;

COMMIT TRANSACTION synchMedInfo
END
BEGIN
	SET @step=2;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' It is already synched';
END
	SET @step=6;IF @debug='Y' print 'Step '+cast(@step as char(3))+' '+convert(VARCHAR(26), getdate(), 21) + ' Done';
    SET @status_code = 0
    GOTO PgmSuccess
END TRY


--error trapping
BEGIN CATCH
SELECT @status_code = @@error, @status_text = 'Error at step '+convert(varchar(3),@step)+', '+ERROR_MESSAGE()
    ROLLBACK TRANSACTION synchMedInfo
    GOTO PgmAbend

END CATCH

--program success return
PgmSuccess:

IF @status_code = 0
BEGIN
    IF @debug='Y' PRINT 'Successful execution of stored procedure'
    RETURN @status_code
END

--program failure return
PgmAbend:

IF @debug='Y' PRINT 'Stored procedure failure in step '+ convert(varchar(3),@step) + '   ' + convert(varchar(26),getdate())
    IF @debug='Y' PRINT 'Error code: '+convert(varchar(3),@status_code) + '; Error description:    ' +@status_text
    RETURN @status_code
GO
GRANT EXECUTE ON sproc_synch_msc_controlledSubstanceCode TO public
GO


GO

print 'C_Branch/04_StoredProcedures/sproc_synch_msc_controlledSubstanceCode.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/sproc_synch_msc_controlledSubstanceCode.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/US_Only/sproc_ar_getUBRuleByPayerIdAndEffectiveDate.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


--================================================================================================
-- PCC-22284             sproc_ar_getUBRuleByPayerIdAndEffectiveDate
--
-- Written By:           Jimmy Zhang
-- Reviewed By:    
--
-- Script Type:          DML
-- Target DB Type:       Client
-- Target Environment:   US ONLY
--
--
-- Re-Runable:           YES
--
-- Description:
-- Retrieve ub rule from ar_lib_ub_rule based on the payerId and effectiveDate
--
--
-- Special Instruction:
--   None
--===============================================================================================

set ANSI_NULLS on
go

set QUOTED_IDENTIFIER ON
go
  
if exists (select 1 from sysobjects where id = object_id(N'sproc_ar_getUBRuleByPayerIdAndEffectiveDate') )
  drop procedure sproc_ar_getUBRuleByPayerIdAndEffectiveDate  
go 

create procedure sproc_ar_getUBRuleByPayerIdAndEffectiveDate (@payerId int, 
  @effectiveDate datetime
)
as
/*
 * This stored procedure will retrieve the ub rule record from ar_lib_ub_rule table
 *
 * Arguments:
 * - @payerId: The payer id
 * - @effectiveDate: The effective date
 *
 * Sample Execution:
 * exec sproc_ar_getUBRuleByPayerIdAndEffectiveDate @payerId= 1, 
 *   @effectiveDate='2011-05-01'
 */ 
begin

  if (@payerId is null or @payerId <= 0)
    raiserror('Invalid payer id',11,1)
    
  if (@effectiveDate is null)
    raiserror('Invalid effective date',11,1)
    
  select ubRule.eff_date_range_id,
         ubRule.include_assessment_info_flag as assessment_included,
         ubRule.show_ard_as_occ50_flag as ard_in_occurrence_code50,
         ubRule.show_ard_on_room_txn_flag as ard_in_revenue_code0022_service_line,
         ubRule.therapy_unit,
         ubRule.room_charge_description_code,
         dateRange.payer_id,
         ubRule.show_occurrence_code55_with_date_of_death_flag,
         ubRule.hcpcs_rate_hipps_code,
         ubRule.include_tpl,
         ubRule.show_hipps_on_0022_flag as show_hipps_on0022_flag
  from ar_lib_ub_rule ubRule
  join ar_lib_date_range dateRange
    on ubRule.eff_date_range_id = dateRange.eff_date_range_id
  where dateRange.payer_id = @payerId
    and dateRange.deleted = 'N'
    and dateadd(dd, 0, datediff(dd, 0, dateRange.eff_date_from)) <= @effectiveDate
    and (dateRange.eff_date_to is null or dateadd(dd, 1, datediff(dd, 0, dateRange.eff_date_to)) > @effectiveDate)
end
go

grant execute on sproc_ar_getUBRuleByPayerIdAndEffectiveDate to public
go

GO

print 'C_Branch/04_StoredProcedures/US_Only/sproc_ar_getUBRuleByPayerIdAndEffectiveDate.sql -- ****SCRIPT DONE****'

GO

insert into upload_tracking(script,timestamp,upload) values ('C_Branch/04_StoredProcedures/US_Only/sproc_ar_getUBRuleByPayerIdAndEffectiveDate.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking (script, timestamp, upload) values ('..\Update db version.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO
SET ANSI_NULLS ON
GO
SET ARITHABORT ON
GO
SET ANSI_WARNINGS ON
GO
SET ANSI_PADDING ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_NULL_DFLT_ON ON
GO

SET QUOTED_IDENTIFIER ON
GO


insert into pcc_db_version (db_version_code, db_upload_by)
values ('4.4.8_C', 'upload_history')


GO

print '..\Update db version.sql --****SCRIPT DONE****'

GO

insert into upload_tracking (script, timestamp, upload) values ('..\Update db version.sql',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')

GO

insert into upload_tracking (script,timestamp,upload) values ('UPLOAD END',getdate(),'4.4.8_06_CLIENT_C_Branch_US.sql')